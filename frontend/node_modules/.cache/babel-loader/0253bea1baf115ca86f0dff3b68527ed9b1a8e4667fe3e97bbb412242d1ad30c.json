{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { parser } from '@lezer/python';\nimport { syntaxTree, LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\nvar cache = /*@__PURE__*/new NodeWeakMap();\nvar ScopeNodes = /*@__PURE__*/new Set([\"Script\", \"Body\", \"FunctionDefinition\", \"ClassDefinition\", \"LambdaExpression\", \"ForStatement\", \"MatchClause\"]);\nfunction defID(type) {\n  return function (node, def, outer) {\n    if (outer) return false;\n    var id = node.node.getChild(\"VariableName\");\n    if (id) def(id, type);\n    return true;\n  };\n}\nvar gatherCompletions = {\n  FunctionDefinition: /*@__PURE__*/defID(\"function\"),\n  ClassDefinition: /*@__PURE__*/defID(\"class\"),\n  ForStatement: function ForStatement(node, def, outer) {\n    if (outer) for (var child = node.node.firstChild; child; child = child.nextSibling) {\n      if (child.name == \"VariableName\") def(child, \"variable\");else if (child.name == \"in\") break;\n    }\n  },\n  ImportStatement: function ImportStatement(_node, def) {\n    var _a, _b;\n    var node = _node.node;\n    var isFrom = ((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"from\";\n    for (var ch = node.getChild(\"import\"); ch; ch = ch.nextSibling) {\n      if (ch.name == \"VariableName\" && ((_b = ch.nextSibling) === null || _b === void 0 ? void 0 : _b.name) != \"as\") def(ch, isFrom ? \"variable\" : \"namespace\");\n    }\n  },\n  AssignStatement: function AssignStatement(node, def) {\n    for (var child = node.node.firstChild; child; child = child.nextSibling) {\n      if (child.name == \"VariableName\") def(child, \"variable\");else if (child.name == \":\" || child.name == \"AssignOp\") break;\n    }\n  },\n  ParamList: function ParamList(node, def) {\n    for (var prev = null, child = node.node.firstChild; child; child = child.nextSibling) {\n      if (child.name == \"VariableName\" && (!prev || !/\\*|AssignOp/.test(prev.name))) def(child, \"variable\");\n      prev = child;\n    }\n  },\n  CapturePattern: /*@__PURE__*/defID(\"variable\"),\n  AsPattern: /*@__PURE__*/defID(\"variable\"),\n  __proto__: null\n};\nfunction getScope(doc, node) {\n  var cached = cache.get(node);\n  if (cached) return cached;\n  var completions = [],\n    top = true;\n  function def(node, type) {\n    var name = doc.sliceString(node.from, node.to);\n    completions.push({\n      label: name,\n      type: type\n    });\n  }\n  node.cursor(IterMode.IncludeAnonymous).iterate(function (node) {\n    if (node.name) {\n      var gather = gatherCompletions[node.name];\n      if (gather && gather(node, def, top) || !top && ScopeNodes.has(node.name)) return false;\n      top = false;\n    } else if (node.to - node.from > 8192) {\n      // Allow caching for bigger internal nodes\n      var _iterator = _createForOfIteratorHelper(getScope(doc, node.node)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var c = _step.value;\n          completions.push(c);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return false;\n    }\n  });\n  cache.set(node, completions);\n  return completions;\n}\nvar Identifier = /^[\\w\\xa1-\\uffff][\\w\\d\\xa1-\\uffff]*$/;\nvar dontComplete = [\"String\", \"FormatString\", \"Comment\", \"PropertyName\"];\n/**\nCompletion source that looks up locally defined names in\nPython code.\n*/\nfunction localCompletionSource(context) {\n  var inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n  if (dontComplete.indexOf(inner.name) > -1) return null;\n  var isWord = inner.name == \"VariableName\" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n  if (!isWord && !context.explicit) return null;\n  var options = [];\n  for (var pos = inner; pos; pos = pos.parent) {\n    if (ScopeNodes.has(pos.name)) options = options.concat(getScope(context.state.doc, pos));\n  }\n  return {\n    options: options,\n    from: isWord ? inner.from : context.pos,\n    validFor: Identifier\n  };\n}\nvar globals = /*@__PURE__*/[\"__annotations__\", \"__builtins__\", \"__debug__\", \"__doc__\", \"__import__\", \"__name__\", \"__loader__\", \"__package__\", \"__spec__\", \"False\", \"None\", \"True\"].map(function (n) {\n  return {\n    label: n,\n    type: \"constant\"\n  };\n}).concat( /*@__PURE__*/[\"ArithmeticError\", \"AssertionError\", \"AttributeError\", \"BaseException\", \"BlockingIOError\", \"BrokenPipeError\", \"BufferError\", \"BytesWarning\", \"ChildProcessError\", \"ConnectionAbortedError\", \"ConnectionError\", \"ConnectionRefusedError\", \"ConnectionResetError\", \"DeprecationWarning\", \"EOFError\", \"Ellipsis\", \"EncodingWarning\", \"EnvironmentError\", \"Exception\", \"FileExistsError\", \"FileNotFoundError\", \"FloatingPointError\", \"FutureWarning\", \"GeneratorExit\", \"IOError\", \"ImportError\", \"ImportWarning\", \"IndentationError\", \"IndexError\", \"InterruptedError\", \"IsADirectoryError\", \"KeyError\", \"KeyboardInterrupt\", \"LookupError\", \"MemoryError\", \"ModuleNotFoundError\", \"NameError\", \"NotADirectoryError\", \"NotImplemented\", \"NotImplementedError\", \"OSError\", \"OverflowError\", \"PendingDeprecationWarning\", \"PermissionError\", \"ProcessLookupError\", \"RecursionError\", \"ReferenceError\", \"ResourceWarning\", \"RuntimeError\", \"RuntimeWarning\", \"StopAsyncIteration\", \"StopIteration\", \"SyntaxError\", \"SyntaxWarning\", \"SystemError\", \"SystemExit\", \"TabError\", \"TimeoutError\", \"TypeError\", \"UnboundLocalError\", \"UnicodeDecodeError\", \"UnicodeEncodeError\", \"UnicodeError\", \"UnicodeTranslateError\", \"UnicodeWarning\", \"UserWarning\", \"ValueError\", \"Warning\", \"ZeroDivisionError\"].map(function (n) {\n  return {\n    label: n,\n    type: \"type\"\n  };\n})).concat( /*@__PURE__*/[\"bool\", \"bytearray\", \"bytes\", \"classmethod\", \"complex\", \"float\", \"frozenset\", \"int\", \"list\", \"map\", \"memoryview\", \"object\", \"range\", \"set\", \"staticmethod\", \"str\", \"super\", \"tuple\", \"type\"].map(function (n) {\n  return {\n    label: n,\n    type: \"class\"\n  };\n})).concat( /*@__PURE__*/[\"abs\", \"aiter\", \"all\", \"anext\", \"any\", \"ascii\", \"bin\", \"breakpoint\", \"callable\", \"chr\", \"compile\", \"delattr\", \"dict\", \"dir\", \"divmod\", \"enumerate\", \"eval\", \"exec\", \"exit\", \"filter\", \"format\", \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\", \"input\", \"isinstance\", \"issubclass\", \"iter\", \"len\", \"license\", \"locals\", \"max\", \"min\", \"next\", \"oct\", \"open\", \"ord\", \"pow\", \"print\", \"property\", \"quit\", \"repr\", \"reversed\", \"round\", \"setattr\", \"slice\", \"sorted\", \"sum\", \"vars\", \"zip\"].map(function (n) {\n  return {\n    label: n,\n    type: \"function\"\n  };\n}));\nvar snippets = [/*@__PURE__*/snippetCompletion(\"def ${name}(${params}):\\n\\t${}\", {\n  label: \"def\",\n  detail: \"function\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"for ${name} in ${collection}:\\n\\t${}\", {\n  label: \"for\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"while ${}:\\n\\t${}\", {\n  label: \"while\",\n  detail: \"loop\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"try:\\n\\t${}\\nexcept ${error}:\\n\\t${}\", {\n  label: \"try\",\n  detail: \"/ except block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"if ${}:\\n\\t\\n\", {\n  label: \"if\",\n  detail: \"block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"if ${}:\\n\\t${}\\nelse:\\n\\t${}\", {\n  label: \"if\",\n  detail: \"/ else block\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"class ${name}:\\n\\tdef __init__(self, ${params}):\\n\\t\\t\\t${}\", {\n  label: \"class\",\n  detail: \"definition\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"import ${module}\", {\n  label: \"import\",\n  detail: \"statement\",\n  type: \"keyword\"\n}), /*@__PURE__*/snippetCompletion(\"from ${module} import ${names}\", {\n  label: \"from\",\n  detail: \"import\",\n  type: \"keyword\"\n})];\n/**\nAutocompletion for built-in Python globals and keywords.\n*/\nvar globalCompletion = /*@__PURE__*/ifNotIn(dontComplete, /*@__PURE__*/completeFromList( /*@__PURE__*/globals.concat(snippets)));\nfunction indentBody(context, node) {\n  var base = context.baseIndentFor(node);\n  var line = context.lineAt(context.pos, -1),\n    to = line.from + line.text.length;\n  // Don't consider blank, deindented lines at the end of the\n  // block part of the block\n  if (/^\\s*($|#)/.test(line.text) && context.node.to < to + 100 && !/\\S/.test(context.state.sliceDoc(to, context.node.to)) && context.lineIndent(context.pos, -1) <= base) return null;\n  // A normally deindenting keyword that appears at a higher\n  // indentation than the block should probably be handled by the next\n  // level\n  if (/^\\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base) return null;\n  return base + context.unit;\n}\n/**\nA language provider based on the [Lezer Python\nparser](https://github.com/lezer-parser/python), extended with\nhighlighting and indentation information.\n*/\nvar pythonLanguage = /*@__PURE__*/LRLanguage.define({\n  name: \"python\",\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      Body: function Body(context) {\n        var _a;\n        return (_a = indentBody(context, context.node)) !== null && _a !== void 0 ? _a : context.continue();\n      },\n      IfStatement: function IfStatement(cx) {\n        return /^\\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue();\n      },\n      TryStatement: function TryStatement(cx) {\n        return /^\\s*(except |finally:|else:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue();\n      },\n      \"TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \")\"\n      }),\n      \"DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \"}\"\n      }),\n      \"ArrayExpression ArrayComprehensionExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \"]\"\n      }),\n      \"String FormatString\": function StringFormatString() {\n        return null;\n      },\n      Script: function Script(context) {\n        if (context.pos + /\\s*/.exec(context.textAfter)[0].length >= context.node.to) {\n          var endBody = null;\n          for (var cur = context.node, to = cur.to;;) {\n            cur = cur.lastChild;\n            if (!cur || cur.to != to) break;\n            if (cur.type.name == \"Body\") endBody = cur;\n          }\n          if (endBody) {\n            var bodyIndent = indentBody(context, endBody);\n            if (bodyIndent != null) return bodyIndent;\n          }\n        }\n        return context.continue();\n      }\n    }), /*@__PURE__*/foldNodeProp.add({\n      \"ArrayExpression DictionaryExpression SetExpression TupleExpression\": foldInside,\n      Body: function Body(node, state) {\n        return {\n          from: node.from + 1,\n          to: node.to - (node.to == state.doc.length ? 0 : 1)\n        };\n      }\n    })]\n  }),\n  languageData: {\n    closeBrackets: {\n      brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"'''\", '\"\"\"'],\n      stringPrefixes: [\"f\", \"fr\", \"rf\", \"r\", \"u\", \"b\", \"br\", \"rb\", \"F\", \"FR\", \"RF\", \"R\", \"U\", \"B\", \"BR\", \"RB\"]\n    },\n    commentTokens: {\n      line: \"#\"\n    },\n    indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/\n  }\n});\n/**\nPython language support.\n*/\nfunction python() {\n  return new LanguageSupport(pythonLanguage, [pythonLanguage.data.of({\n    autocomplete: localCompletionSource\n  }), pythonLanguage.data.of({\n    autocomplete: globalCompletion\n  })]);\n}\nexport { globalCompletion, localCompletionSource, python, pythonLanguage };","map":{"version":3,"names":["parser","syntaxTree","LRLanguage","indentNodeProp","delimitedIndent","foldNodeProp","foldInside","LanguageSupport","NodeWeakMap","IterMode","snippetCompletion","ifNotIn","completeFromList","cache","ScopeNodes","Set","defID","type","node","def","outer","id","getChild","gatherCompletions","FunctionDefinition","ClassDefinition","ForStatement","child","firstChild","nextSibling","name","ImportStatement","_node","_a","_b","isFrom","ch","AssignStatement","ParamList","prev","test","CapturePattern","AsPattern","__proto__","getScope","doc","cached","get","completions","top","sliceString","from","to","push","label","cursor","IncludeAnonymous","iterate","gather","has","_iterator","_createForOfIteratorHelper","_step","s","n","done","c","value","err","e","f","set","Identifier","dontComplete","localCompletionSource","context","inner","state","resolveInner","pos","indexOf","isWord","sliceDoc","explicit","options","parent","concat","validFor","globals","map","snippets","detail","globalCompletion","indentBody","base","baseIndentFor","line","lineAt","text","length","lineIndent","textAfter","unit","pythonLanguage","define","configure","props","add","Body","continue","IfStatement","cx","baseIndent","TryStatement","closing","StringFormatString","Script","exec","endBody","cur","lastChild","bodyIndent","languageData","closeBrackets","brackets","stringPrefixes","commentTokens","indentOnInput","python","data","of","autocomplete"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@codemirror/lang-python/dist/index.js"],"sourcesContent":["import { parser } from '@lezer/python';\nimport { syntaxTree, LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { NodeWeakMap, IterMode } from '@lezer/common';\nimport { snippetCompletion, ifNotIn, completeFromList } from '@codemirror/autocomplete';\n\nconst cache = /*@__PURE__*/new NodeWeakMap();\nconst ScopeNodes = /*@__PURE__*/new Set([\n    \"Script\", \"Body\",\n    \"FunctionDefinition\", \"ClassDefinition\", \"LambdaExpression\",\n    \"ForStatement\", \"MatchClause\"\n]);\nfunction defID(type) {\n    return (node, def, outer) => {\n        if (outer)\n            return false;\n        let id = node.node.getChild(\"VariableName\");\n        if (id)\n            def(id, type);\n        return true;\n    };\n}\nconst gatherCompletions = {\n    FunctionDefinition: /*@__PURE__*/defID(\"function\"),\n    ClassDefinition: /*@__PURE__*/defID(\"class\"),\n    ForStatement(node, def, outer) {\n        if (outer)\n            for (let child = node.node.firstChild; child; child = child.nextSibling) {\n                if (child.name == \"VariableName\")\n                    def(child, \"variable\");\n                else if (child.name == \"in\")\n                    break;\n            }\n    },\n    ImportStatement(_node, def) {\n        var _a, _b;\n        let { node } = _node;\n        let isFrom = ((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.name) == \"from\";\n        for (let ch = node.getChild(\"import\"); ch; ch = ch.nextSibling) {\n            if (ch.name == \"VariableName\" && ((_b = ch.nextSibling) === null || _b === void 0 ? void 0 : _b.name) != \"as\")\n                def(ch, isFrom ? \"variable\" : \"namespace\");\n        }\n    },\n    AssignStatement(node, def) {\n        for (let child = node.node.firstChild; child; child = child.nextSibling) {\n            if (child.name == \"VariableName\")\n                def(child, \"variable\");\n            else if (child.name == \":\" || child.name == \"AssignOp\")\n                break;\n        }\n    },\n    ParamList(node, def) {\n        for (let prev = null, child = node.node.firstChild; child; child = child.nextSibling) {\n            if (child.name == \"VariableName\" && (!prev || !/\\*|AssignOp/.test(prev.name)))\n                def(child, \"variable\");\n            prev = child;\n        }\n    },\n    CapturePattern: /*@__PURE__*/defID(\"variable\"),\n    AsPattern: /*@__PURE__*/defID(\"variable\"),\n    __proto__: null\n};\nfunction getScope(doc, node) {\n    let cached = cache.get(node);\n    if (cached)\n        return cached;\n    let completions = [], top = true;\n    function def(node, type) {\n        let name = doc.sliceString(node.from, node.to);\n        completions.push({ label: name, type });\n    }\n    node.cursor(IterMode.IncludeAnonymous).iterate(node => {\n        if (node.name) {\n            let gather = gatherCompletions[node.name];\n            if (gather && gather(node, def, top) || !top && ScopeNodes.has(node.name))\n                return false;\n            top = false;\n        }\n        else if (node.to - node.from > 8192) {\n            // Allow caching for bigger internal nodes\n            for (let c of getScope(doc, node.node))\n                completions.push(c);\n            return false;\n        }\n    });\n    cache.set(node, completions);\n    return completions;\n}\nconst Identifier = /^[\\w\\xa1-\\uffff][\\w\\d\\xa1-\\uffff]*$/;\nconst dontComplete = [\"String\", \"FormatString\", \"Comment\", \"PropertyName\"];\n/**\nCompletion source that looks up locally defined names in\nPython code.\n*/\nfunction localCompletionSource(context) {\n    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);\n    if (dontComplete.indexOf(inner.name) > -1)\n        return null;\n    let isWord = inner.name == \"VariableName\" ||\n        inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));\n    if (!isWord && !context.explicit)\n        return null;\n    let options = [];\n    for (let pos = inner; pos; pos = pos.parent) {\n        if (ScopeNodes.has(pos.name))\n            options = options.concat(getScope(context.state.doc, pos));\n    }\n    return {\n        options,\n        from: isWord ? inner.from : context.pos,\n        validFor: Identifier\n    };\n}\nconst globals = /*@__PURE__*/[\n    \"__annotations__\", \"__builtins__\", \"__debug__\", \"__doc__\", \"__import__\", \"__name__\",\n    \"__loader__\", \"__package__\", \"__spec__\",\n    \"False\", \"None\", \"True\"\n].map(n => ({ label: n, type: \"constant\" })).concat(/*@__PURE__*/[\n    \"ArithmeticError\", \"AssertionError\", \"AttributeError\", \"BaseException\", \"BlockingIOError\",\n    \"BrokenPipeError\", \"BufferError\", \"BytesWarning\", \"ChildProcessError\", \"ConnectionAbortedError\",\n    \"ConnectionError\", \"ConnectionRefusedError\", \"ConnectionResetError\", \"DeprecationWarning\",\n    \"EOFError\", \"Ellipsis\", \"EncodingWarning\", \"EnvironmentError\", \"Exception\", \"FileExistsError\",\n    \"FileNotFoundError\", \"FloatingPointError\", \"FutureWarning\", \"GeneratorExit\", \"IOError\",\n    \"ImportError\", \"ImportWarning\", \"IndentationError\", \"IndexError\", \"InterruptedError\",\n    \"IsADirectoryError\", \"KeyError\", \"KeyboardInterrupt\", \"LookupError\", \"MemoryError\",\n    \"ModuleNotFoundError\", \"NameError\", \"NotADirectoryError\", \"NotImplemented\", \"NotImplementedError\",\n    \"OSError\", \"OverflowError\", \"PendingDeprecationWarning\", \"PermissionError\", \"ProcessLookupError\",\n    \"RecursionError\", \"ReferenceError\", \"ResourceWarning\", \"RuntimeError\", \"RuntimeWarning\",\n    \"StopAsyncIteration\", \"StopIteration\", \"SyntaxError\", \"SyntaxWarning\", \"SystemError\",\n    \"SystemExit\", \"TabError\", \"TimeoutError\", \"TypeError\", \"UnboundLocalError\", \"UnicodeDecodeError\",\n    \"UnicodeEncodeError\", \"UnicodeError\", \"UnicodeTranslateError\", \"UnicodeWarning\", \"UserWarning\",\n    \"ValueError\", \"Warning\", \"ZeroDivisionError\"\n].map(n => ({ label: n, type: \"type\" }))).concat(/*@__PURE__*/[\n    \"bool\", \"bytearray\", \"bytes\", \"classmethod\", \"complex\", \"float\", \"frozenset\", \"int\", \"list\",\n    \"map\", \"memoryview\", \"object\", \"range\", \"set\", \"staticmethod\", \"str\", \"super\", \"tuple\", \"type\"\n].map(n => ({ label: n, type: \"class\" }))).concat(/*@__PURE__*/[\n    \"abs\", \"aiter\", \"all\", \"anext\", \"any\", \"ascii\", \"bin\", \"breakpoint\", \"callable\", \"chr\",\n    \"compile\", \"delattr\", \"dict\", \"dir\", \"divmod\", \"enumerate\", \"eval\", \"exec\", \"exit\", \"filter\",\n    \"format\", \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\", \"input\", \"isinstance\",\n    \"issubclass\", \"iter\", \"len\", \"license\", \"locals\", \"max\", \"min\", \"next\", \"oct\", \"open\",\n    \"ord\", \"pow\", \"print\", \"property\", \"quit\", \"repr\", \"reversed\", \"round\", \"setattr\", \"slice\",\n    \"sorted\", \"sum\", \"vars\", \"zip\"\n].map(n => ({ label: n, type: \"function\" })));\nconst snippets = [\n    /*@__PURE__*/snippetCompletion(\"def ${name}(${params}):\\n\\t${}\", {\n        label: \"def\",\n        detail: \"function\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"for ${name} in ${collection}:\\n\\t${}\", {\n        label: \"for\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"while ${}:\\n\\t${}\", {\n        label: \"while\",\n        detail: \"loop\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"try:\\n\\t${}\\nexcept ${error}:\\n\\t${}\", {\n        label: \"try\",\n        detail: \"/ except block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if ${}:\\n\\t\\n\", {\n        label: \"if\",\n        detail: \"block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"if ${}:\\n\\t${}\\nelse:\\n\\t${}\", {\n        label: \"if\",\n        detail: \"/ else block\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"class ${name}:\\n\\tdef __init__(self, ${params}):\\n\\t\\t\\t${}\", {\n        label: \"class\",\n        detail: \"definition\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"import ${module}\", {\n        label: \"import\",\n        detail: \"statement\",\n        type: \"keyword\"\n    }),\n    /*@__PURE__*/snippetCompletion(\"from ${module} import ${names}\", {\n        label: \"from\",\n        detail: \"import\",\n        type: \"keyword\"\n    })\n];\n/**\nAutocompletion for built-in Python globals and keywords.\n*/\nconst globalCompletion = /*@__PURE__*/ifNotIn(dontComplete, /*@__PURE__*/completeFromList(/*@__PURE__*/globals.concat(snippets)));\n\nfunction indentBody(context, node) {\n    let base = context.baseIndentFor(node);\n    let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;\n    // Don't consider blank, deindented lines at the end of the\n    // block part of the block\n    if (/^\\s*($|#)/.test(line.text) &&\n        context.node.to < to + 100 &&\n        !/\\S/.test(context.state.sliceDoc(to, context.node.to)) &&\n        context.lineIndent(context.pos, -1) <= base)\n        return null;\n    // A normally deindenting keyword that appears at a higher\n    // indentation than the block should probably be handled by the next\n    // level\n    if (/^\\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base)\n        return null;\n    return base + context.unit;\n}\n/**\nA language provider based on the [Lezer Python\nparser](https://github.com/lezer-parser/python), extended with\nhighlighting and indentation information.\n*/\nconst pythonLanguage = /*@__PURE__*/LRLanguage.define({\n    name: \"python\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                Body: context => { var _a; return (_a = indentBody(context, context.node)) !== null && _a !== void 0 ? _a : context.continue(); },\n                IfStatement: cx => /^\\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                TryStatement: cx => /^\\s*(except |finally:|else:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),\n                \"TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression\": /*@__PURE__*/delimitedIndent({ closing: \")\" }),\n                \"DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression\": /*@__PURE__*/delimitedIndent({ closing: \"}\" }),\n                \"ArrayExpression ArrayComprehensionExpression\": /*@__PURE__*/delimitedIndent({ closing: \"]\" }),\n                \"String FormatString\": () => null,\n                Script: context => {\n                    if (context.pos + /\\s*/.exec(context.textAfter)[0].length >= context.node.to) {\n                        let endBody = null;\n                        for (let cur = context.node, to = cur.to;;) {\n                            cur = cur.lastChild;\n                            if (!cur || cur.to != to)\n                                break;\n                            if (cur.type.name == \"Body\")\n                                endBody = cur;\n                        }\n                        if (endBody) {\n                            let bodyIndent = indentBody(context, endBody);\n                            if (bodyIndent != null)\n                                return bodyIndent;\n                        }\n                    }\n                    return context.continue();\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                \"ArrayExpression DictionaryExpression SetExpression TupleExpression\": foldInside,\n                Body: (node, state) => ({ from: node.from + 1, to: node.to - (node.to == state.doc.length ? 0 : 1) })\n            })\n        ],\n    }),\n    languageData: {\n        closeBrackets: {\n            brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"'''\", '\"\"\"'],\n            stringPrefixes: [\"f\", \"fr\", \"rf\", \"r\", \"u\", \"b\", \"br\", \"rb\",\n                \"F\", \"FR\", \"RF\", \"R\", \"U\", \"B\", \"BR\", \"RB\"]\n        },\n        commentTokens: { line: \"#\" },\n        indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/\n    }\n});\n/**\nPython language support.\n*/\nfunction python() {\n    return new LanguageSupport(pythonLanguage, [\n        pythonLanguage.data.of({ autocomplete: localCompletionSource }),\n        pythonLanguage.data.of({ autocomplete: globalCompletion }),\n    ]);\n}\n\nexport { globalCompletion, localCompletionSource, python, pythonLanguage };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}