{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport deepCopy from 'deep-copy';\nimport { Editor, Operation } from '@seafile/slate';\nimport { getNode } from '../extension/core';\nimport * as OPERATION from '../node-id/constants';\nimport { setCursor } from '../cursor/helper';\nexport var getNodePathById = function getNodePathById(rootNode, nodeId) {\n  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  if (rootNode.id === nodeId) return path;\n  var _rootNode$children = rootNode.children,\n    children = _rootNode$children === void 0 ? [] : _rootNode$children;\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    path.push(i);\n    var nodePath = getNodePathById(child, nodeId, path);\n    if (nodePath) return nodePath;\n    path.pop();\n  }\n  return null;\n};\nexport var validateOperation = function validateOperation(editor, operation) {\n  var isValid = false;\n  var newOperation = deepCopy(operation);\n  var type = newOperation.type;\n  switch (type) {\n    case OPERATION.INSERT_TEXT:\n    case OPERATION.REMOVE_TEXT:\n      {\n        var node_id = newOperation.node_id,\n          path = newOperation.path;\n        var node = getNode(editor, path);\n        // node is exist and node path is not changed\n        if (node && node.id === node_id) {\n          isValid = true;\n          break;\n        }\n\n        // node is exist but node path is changed\n        var nodePath = getNodePathById(editor, node_id);\n        if (nodePath) {\n          isValid = true;\n          newOperation.path = nodePath;\n          break;\n        }\n        // node is not exist\n        isValid = false;\n        break;\n      }\n    case OPERATION.INSERT_NODE:\n      {\n        var parent_node_id = newOperation.parent_node_id,\n          _path = newOperation.path;\n        var parentNodePath = getNodePathById(editor, parent_node_id);\n        if (!parentNodePath) {\n          isValid = false;\n          break;\n        }\n        var parentPath = _path.slice(0, _path.length - 1);\n        if (parentPath.join() === parentNodePath.join()) {\n          isValid = true;\n          break;\n        }\n\n        // reset insert node path\n        var parentNode = getNode(editor, _path);\n        if (parentNode) {\n          var childLength = parentNode.children.length;\n          var index = Math.min(_path[_path.length - 1], childLength);\n          newOperation.path = parentNodePath.concat([index]);\n          isValid = true;\n        }\n        break;\n      }\n    case OPERATION.REMOVE_NODE:\n      {\n        var _node_id = newOperation.node_id,\n          _path2 = newOperation.path;\n        var _node = getNode(editor, _path2);\n        // node is exist and node path is not changed\n        if (_node && _node.id === _node_id) {\n          isValid = true;\n          break;\n        }\n\n        // node is exist but node path is changed\n        var _nodePath = getNodePathById(editor, _node_id);\n        if (_nodePath) {\n          isValid = true;\n          newOperation.path = _nodePath;\n          break;\n        }\n\n        // node is not exist\n        isValid = false;\n        break;\n      }\n    case OPERATION.MERGE_NODE:\n      {\n        // merge next node into prev node\n        var _node_id2 = newOperation.node_id,\n          _path3 = newOperation.path;\n        var _node2 = getNode(editor, _path3);\n        // node is exist and node path is not changed\n        if (_node2 && _node2.id === _node_id2) {\n          isValid = true;\n          break;\n        }\n\n        // node is exist but node path is changed\n        var _nodePath2 = getNodePathById(editor, _node_id2);\n        if (_nodePath2) {\n          isValid = true;\n          newOperation.path = _nodePath2;\n          break;\n        }\n\n        // node is not exist\n        isValid = false;\n        break;\n      }\n    case OPERATION.SPLIT_NODE:\n      {\n        var _node_id3 = newOperation.node_id,\n          _path4 = newOperation.path;\n        var _node3 = getNode(editor, _path4);\n        // node is exist and node path is not changed\n        if (_node3 && _node3.id === _node_id3) {\n          isValid = true;\n          break;\n        }\n\n        // node is exist but node path is changed\n        var _nodePath3 = getNodePathById(editor, _node_id3);\n        if (_nodePath3) {\n          isValid = true;\n          newOperation.path = _nodePath3;\n          break;\n        }\n\n        // node is not exist\n        isValid = false;\n        break;\n      }\n    case OPERATION.SET_NODE:\n      {\n        var _node_id4 = newOperation.node_id,\n          _path5 = newOperation.path,\n          properties = newOperation.properties;\n        var _node4 = getNode(editor, _path5);\n        // node is exist and node path is not changed\n        if (_node4 && _node4.id === _node_id4) {\n          isValid = true;\n          newOperation.properties = _objectSpread(_objectSpread({}, properties), {}, {\n            type: _node4.type\n          });\n          break;\n        }\n\n        // node is exist but node path is changed\n        var _nodePath4 = getNodePathById(editor, _node_id4);\n        if (_nodePath4) {\n          isValid = true;\n          var _node5 = getNode(editor, _nodePath4);\n          newOperation.properties = _objectSpread(_objectSpread({}, properties), {}, {\n            type: _node5.type\n          });\n          newOperation.path = _nodePath4;\n          break;\n        }\n\n        // node is not exist\n        isValid = false;\n        break;\n      }\n    case OPERATION.MOVE_NODE:\n      {\n        var _node_id5 = newOperation.node_id,\n          _path6 = newOperation.path;\n        var _node6 = getNode(editor, _path6);\n        // node is exist and node path is not changed\n        if (_node6 && _node6.id === _node_id5) {\n          isValid = true;\n          break;\n        }\n\n        // TODO: newPath can not calculate by nodePath\n        // node is exist but node path is changed\n        // const nodePath = getNodePathById(editor, node_id);\n        // if (nodePath) {}\n\n        // node is not exist\n        isValid = false;\n        break;\n      }\n    default:\n      {\n        // set_selection\n        break;\n      }\n  }\n  if (isValid) return newOperation;\n  return isValid;\n};\nexport var getRevertOperationList = function getRevertOperationList(operationList) {\n  if (operationList.length === 0) return [];\n\n  // Generate a duplicate operationList, The original value cannot be modified here\n  var revertOperationList = deepCopy(operationList);\n  revertOperationList = revertOperationList.reverse();\n  return revertOperationList.map(function (operations) {\n    var ops = operations.reverse();\n    return ops.map(function (item) {\n      return Operation.inverse(item);\n    });\n  });\n};\nexport var revertOperationList = function revertOperationList(editor, operationList) {\n  if (operationList.length === 0) return [];\n  var revertOperationList = getRevertOperationList(operationList);\n\n  // Cancel locale execute operations\n  var _loop = function _loop() {\n    var operations = revertOperationList[i];\n    Editor.withoutNormalizing(editor, function () {\n      for (var j = 0; j < operations.length; j++) {\n        var op = operations[j];\n        editor.apply(op);\n      }\n    });\n  };\n  for (var i = 0; i < revertOperationList.length; i++) {\n    _loop();\n  }\n};\nexport var reExecRevertOperationList = function reExecRevertOperationList(editor, revertOperationList) {\n  if (revertOperationList.length === 0) return;\n\n  // Re-execute revert operations\n  var _loop2 = function _loop2() {\n    var operations = revertOperationList[i];\n    Editor.withoutNormalizing(editor, function () {\n      for (var j = 0; j < operations.length; j++) {\n        var op = validateOperation(editor, operations[j]);\n        if (op) {\n          editor.apply(op);\n        }\n      }\n    });\n  };\n  for (var i = 0; i < revertOperationList.length; i++) {\n    _loop2();\n  }\n};\nexport var syncRemoteOperations = function syncRemoteOperations(editor, remoteOperations) {\n  if (remoteOperations.length === 0) return;\n  Editor.withoutNormalizing(editor, function () {\n    for (var i = 0; i < remoteOperations.length; i++) {\n      var op = remoteOperations[i];\n      if (op.type === 'set_selection') {\n        continue;\n      }\n      editor.apply(op);\n    }\n  });\n};\nexport var syncRemoteCursorLocation = function syncRemoteCursorLocation(editor, user, location, cursorData) {\n  var currentUser = editor.user;\n  if (user && user.username !== currentUser.username) {\n    setCursor(editor, user, location, cursorData);\n\n    // sync cursor position\n    editor.onCursor && editor.onCursor(editor.cursors);\n  }\n};","map":{"version":3,"names":["_objectSpread","deepCopy","Editor","Operation","getNode","OPERATION","setCursor","getNodePathById","rootNode","nodeId","path","arguments","length","undefined","id","_rootNode$children","children","i","child","push","nodePath","pop","validateOperation","editor","operation","isValid","newOperation","type","INSERT_TEXT","REMOVE_TEXT","node_id","node","INSERT_NODE","parent_node_id","parentNodePath","parentPath","slice","join","parentNode","childLength","index","Math","min","concat","REMOVE_NODE","MERGE_NODE","SPLIT_NODE","SET_NODE","properties","MOVE_NODE","getRevertOperationList","operationList","revertOperationList","reverse","map","operations","ops","item","inverse","_loop","withoutNormalizing","j","op","apply","reExecRevertOperationList","_loop2","syncRemoteOperations","remoteOperations","syncRemoteCursorLocation","user","location","cursorData","currentUser","username","onCursor","cursors"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/socket/helpers.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport deepCopy from 'deep-copy';\nimport { Editor, Operation } from '@seafile/slate';\nimport { getNode } from '../extension/core';\nimport * as OPERATION from '../node-id/constants';\nimport { setCursor } from '../cursor/helper';\nexport const getNodePathById = function (rootNode, nodeId) {\n  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  if (rootNode.id === nodeId) return path;\n  const {\n    children = []\n  } = rootNode;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    path.push(i);\n    const nodePath = getNodePathById(child, nodeId, path);\n    if (nodePath) return nodePath;\n    path.pop();\n  }\n  return null;\n};\nexport const validateOperation = (editor, operation) => {\n  let isValid = false;\n  let newOperation = deepCopy(operation);\n  const {\n    type\n  } = newOperation;\n  switch (type) {\n    case OPERATION.INSERT_TEXT:\n    case OPERATION.REMOVE_TEXT:\n      {\n        const {\n          node_id,\n          path\n        } = newOperation;\n        const node = getNode(editor, path);\n        // node is exist and node path is not changed\n        if (node && node.id === node_id) {\n          isValid = true;\n          break;\n        }\n\n        // node is exist but node path is changed\n        const nodePath = getNodePathById(editor, node_id);\n        if (nodePath) {\n          isValid = true;\n          newOperation.path = nodePath;\n          break;\n        }\n        // node is not exist\n        isValid = false;\n        break;\n      }\n    case OPERATION.INSERT_NODE:\n      {\n        let {\n          parent_node_id,\n          path\n        } = newOperation;\n        const parentNodePath = getNodePathById(editor, parent_node_id);\n        if (!parentNodePath) {\n          isValid = false;\n          break;\n        }\n        const parentPath = path.slice(0, path.length - 1);\n        if (parentPath.join() === parentNodePath.join()) {\n          isValid = true;\n          break;\n        }\n\n        // reset insert node path\n        const parentNode = getNode(editor, path);\n        if (parentNode) {\n          const childLength = parentNode.children.length;\n          const index = Math.min(path[path.length - 1], childLength);\n          newOperation.path = parentNodePath.concat([index]);\n          isValid = true;\n        }\n        break;\n      }\n    case OPERATION.REMOVE_NODE:\n      {\n        const {\n          node_id,\n          path\n        } = newOperation;\n        const node = getNode(editor, path);\n        // node is exist and node path is not changed\n        if (node && node.id === node_id) {\n          isValid = true;\n          break;\n        }\n\n        // node is exist but node path is changed\n        const nodePath = getNodePathById(editor, node_id);\n        if (nodePath) {\n          isValid = true;\n          newOperation.path = nodePath;\n          break;\n        }\n\n        // node is not exist\n        isValid = false;\n        break;\n      }\n    case OPERATION.MERGE_NODE:\n      {\n        // merge next node into prev node\n        const {\n          node_id,\n          path\n        } = newOperation;\n        const node = getNode(editor, path);\n        // node is exist and node path is not changed\n        if (node && node.id === node_id) {\n          isValid = true;\n          break;\n        }\n\n        // node is exist but node path is changed\n        const nodePath = getNodePathById(editor, node_id);\n        if (nodePath) {\n          isValid = true;\n          newOperation.path = nodePath;\n          break;\n        }\n\n        // node is not exist\n        isValid = false;\n        break;\n      }\n    case OPERATION.SPLIT_NODE:\n      {\n        const {\n          node_id,\n          path\n        } = newOperation;\n        const node = getNode(editor, path);\n        // node is exist and node path is not changed\n        if (node && node.id === node_id) {\n          isValid = true;\n          break;\n        }\n\n        // node is exist but node path is changed\n        const nodePath = getNodePathById(editor, node_id);\n        if (nodePath) {\n          isValid = true;\n          newOperation.path = nodePath;\n          break;\n        }\n\n        // node is not exist\n        isValid = false;\n        break;\n      }\n    case OPERATION.SET_NODE:\n      {\n        const {\n          node_id,\n          path,\n          properties\n        } = newOperation;\n        const node = getNode(editor, path);\n        // node is exist and node path is not changed\n        if (node && node.id === node_id) {\n          isValid = true;\n          newOperation.properties = _objectSpread(_objectSpread({}, properties), {}, {\n            type: node.type\n          });\n          break;\n        }\n\n        // node is exist but node path is changed\n        const nodePath = getNodePathById(editor, node_id);\n        if (nodePath) {\n          isValid = true;\n          const node = getNode(editor, nodePath);\n          newOperation.properties = _objectSpread(_objectSpread({}, properties), {}, {\n            type: node.type\n          });\n          newOperation.path = nodePath;\n          break;\n        }\n\n        // node is not exist\n        isValid = false;\n        break;\n      }\n    case OPERATION.MOVE_NODE:\n      {\n        const {\n          node_id,\n          path\n        } = newOperation;\n        const node = getNode(editor, path);\n        // node is exist and node path is not changed\n        if (node && node.id === node_id) {\n          isValid = true;\n          break;\n        }\n\n        // TODO: newPath can not calculate by nodePath\n        // node is exist but node path is changed\n        // const nodePath = getNodePathById(editor, node_id);\n        // if (nodePath) {}\n\n        // node is not exist\n        isValid = false;\n        break;\n      }\n    default:\n      {\n        // set_selection\n        break;\n      }\n  }\n  if (isValid) return newOperation;\n  return isValid;\n};\nexport const getRevertOperationList = operationList => {\n  if (operationList.length === 0) return [];\n\n  // Generate a duplicate operationList, The original value cannot be modified here\n  let revertOperationList = deepCopy(operationList);\n  revertOperationList = revertOperationList.reverse();\n  return revertOperationList.map(operations => {\n    const ops = operations.reverse();\n    return ops.map(item => Operation.inverse(item));\n  });\n};\nexport const revertOperationList = (editor, operationList) => {\n  if (operationList.length === 0) return [];\n  const revertOperationList = getRevertOperationList(operationList);\n\n  // Cancel locale execute operations\n  for (let i = 0; i < revertOperationList.length; i++) {\n    const operations = revertOperationList[i];\n    Editor.withoutNormalizing(editor, () => {\n      for (let j = 0; j < operations.length; j++) {\n        const op = operations[j];\n        editor.apply(op);\n      }\n    });\n  }\n};\nexport const reExecRevertOperationList = (editor, revertOperationList) => {\n  if (revertOperationList.length === 0) return;\n\n  // Re-execute revert operations\n  for (let i = 0; i < revertOperationList.length; i++) {\n    const operations = revertOperationList[i];\n    Editor.withoutNormalizing(editor, () => {\n      for (let j = 0; j < operations.length; j++) {\n        const op = validateOperation(editor, operations[j]);\n        if (op) {\n          editor.apply(op);\n        }\n      }\n    });\n  }\n};\nexport const syncRemoteOperations = (editor, remoteOperations) => {\n  if (remoteOperations.length === 0) return;\n  Editor.withoutNormalizing(editor, () => {\n    for (let i = 0; i < remoteOperations.length; i++) {\n      const op = remoteOperations[i];\n      if (op.type === 'set_selection') {\n        continue;\n      }\n      editor.apply(op);\n    }\n  });\n};\nexport const syncRemoteCursorLocation = (editor, user, location, cursorData) => {\n  const currentUser = editor.user;\n  if (user && user.username !== currentUser.username) {\n    setCursor(editor, user, location, cursorData);\n\n    // sync cursor position\n    editor.onCursor && editor.onCursor(editor.cursors);\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}