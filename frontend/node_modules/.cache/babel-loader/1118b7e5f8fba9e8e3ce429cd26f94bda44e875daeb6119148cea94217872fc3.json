{"ast":null,"code":"import _objectSpread from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n/**\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n */\n\n/**\n * @callback Collapse\n *   Collapse a string.\n * @param {string} value\n *   Value to collapse.\n * @returns {string}\n *   Collapsed value.\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [newlines=false]\n *   Collapse whitespace containing newlines to `'\\n'` instead of `' '`\n *   (default: `false`); the default is to collapse to a single space.\n *\n * @typedef Result\n *   Result.\n * @property {boolean} remove\n *   Whether to remove.\n * @property {boolean} ignore\n *   Whether to ignore.\n * @property {boolean} stripAtStart\n *   Whether to strip at the start.\n *\n * @typedef State\n *   Info passed around.\n * @property {Collapse} collapse\n *   Collapse.\n * @property {Whitespace} whitespace\n *   Current whitespace.\n * @property {boolean | undefined} [before]\n *   Whether there is a break before (default: `false`).\n * @property {boolean | undefined} [after]\n *   Whether there is a break after (default: `false`).\n *\n * @typedef {'normal' | 'nowrap' | 'pre' | 'pre-wrap'} Whitespace\n *   Whitespace setting.\n */\n\nimport { embedded } from 'hast-util-embedded';\nimport { isElement } from 'hast-util-is-element';\nimport { whitespace } from 'hast-util-whitespace';\nimport { convert } from 'unist-util-is';\nimport { blocks } from './block.js';\nimport { content as contents } from './content.js';\nimport { skippable as skippables } from './skippable.js';\n\n/** @type {Options} */\nvar emptyOptions = {};\nvar ignorableNode = convert(['doctype', 'comment']);\n\n/**\n * Minify whitespace.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeMinifyWhitespace(options) {\n  var settings = options || emptyOptions;\n  var collapse = collapseFactory(settings.newlines ? replaceNewlines : replaceWhitespace);\n\n  /**\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    minify(tree, {\n      collapse: collapse,\n      whitespace: 'normal'\n    });\n  };\n}\n\n/**\n * @param {Nodes} node\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {Result}\n *   Result.\n */\nfunction minify(node, state) {\n  if ('children' in node) {\n    var settings = _objectSpread({}, state);\n    if (node.type === 'root' || blocklike(node)) {\n      settings.before = true;\n      settings.after = true;\n    }\n    settings.whitespace = inferWhiteSpace(node, state);\n    return all(node, settings);\n  }\n  if (node.type === 'text') {\n    if (state.whitespace === 'normal') {\n      return minifyText(node, state);\n    }\n\n    // Naïve collapse, but no trimming:\n    if (state.whitespace === 'nowrap') {\n      node.value = state.collapse(node.value);\n    }\n\n    // The `pre-wrap` or `pre` whitespace settings are neither collapsed nor\n    // trimmed.\n  }\n\n  return {\n    ignore: ignorableNode(node),\n    stripAtStart: false,\n    remove: false\n  };\n}\n\n/**\n * @param {Text} node\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {Result}\n *   Result.\n */\nfunction minifyText(node, state) {\n  var value = state.collapse(node.value);\n  var result = {\n    ignore: false,\n    stripAtStart: false,\n    remove: false\n  };\n  var start = 0;\n  var end = value.length;\n  if (state.before && removable(value.charAt(0))) {\n    start++;\n  }\n  if (start !== end && removable(value.charAt(end - 1))) {\n    if (state.after) {\n      end--;\n    } else {\n      result.stripAtStart = true;\n    }\n  }\n  if (start === end) {\n    result.remove = true;\n  } else {\n    node.value = value.slice(start, end);\n  }\n  return result;\n}\n\n/**\n * @param {Parents} parent\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {Result}\n *   Result.\n */\nfunction all(parent, state) {\n  var before = state.before;\n  var after = state.after;\n  var children = parent.children;\n  var length = children.length;\n  var index = -1;\n  while (++index < length) {\n    var result = minify(children[index], _objectSpread(_objectSpread({}, state), {}, {\n      after: collapsableAfter(children, index, after),\n      before: before\n    }));\n    if (result.remove) {\n      children.splice(index, 1);\n      index--;\n      length--;\n    } else if (!result.ignore) {\n      before = result.stripAtStart;\n    }\n\n    // If this element, such as a `<select>` or `<img>`, contributes content\n    // somehow, allow whitespace again.\n    if (content(children[index])) {\n      before = false;\n    }\n  }\n  return {\n    ignore: false,\n    stripAtStart: Boolean(before || after),\n    remove: false\n  };\n}\n\n/**\n * @param {Array<Nodes>} nodes\n *   Nodes.\n * @param {number} index\n *   Index.\n * @param {boolean | undefined} [after]\n *   Whether there is a break after `nodes` (default: `false`).\n * @returns {boolean | undefined}\n *   Whether there is a break after the node at `index`.\n */\nfunction collapsableAfter(nodes, index, after) {\n  while (++index < nodes.length) {\n    var node = nodes[index];\n    var result = inferBoundary(node);\n    if (result === undefined && 'children' in node && !skippable(node)) {\n      result = collapsableAfter(node.children, -1);\n    }\n    if (typeof result === 'boolean') {\n      return result;\n    }\n  }\n  return after;\n}\n\n/**\n * Infer two types of boundaries:\n *\n * 1. `true` — boundary for which whitespace around it does not contribute\n *    anything\n * 2. `false` — boundary for which whitespace around it *does* contribute\n *\n * No result (`undefined`) is returned if it is unknown.\n *\n * @param {Nodes} node\n *   Node.\n * @returns {boolean | undefined}\n *   Boundary.\n */\nfunction inferBoundary(node) {\n  if (node.type === 'element') {\n    if (content(node)) {\n      return false;\n    }\n    if (blocklike(node)) {\n      return true;\n    }\n\n    // Unknown: either depends on siblings if embedded or metadata, or on\n    // children.\n  } else if (node.type === 'text') {\n    if (!whitespace(node)) {\n      return false;\n    }\n  } else if (!ignorableNode(node)) {\n    return false;\n  }\n}\n\n/**\n * Infer whether a node is skippable.\n *\n * @param {Nodes} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` is skippable.\n */\nfunction content(node) {\n  return embedded(node) || isElement(node, contents);\n}\n\n/**\n * See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\n *\n * @param {Nodes} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` is block-like.\n */\nfunction blocklike(node) {\n  return isElement(node, blocks);\n}\n\n/**\n * @param {Parents} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` is skippable.\n */\nfunction skippable(node) {\n  return Boolean(node.type === 'element' && node.properties.hidden) || ignorableNode(node) || isElement(node, skippables);\n}\n\n/**\n * @param {string} character\n *   Character.\n * @returns {boolean}\n *   Whether `character` is removable.\n */\nfunction removable(character) {\n  return character === ' ' || character === '\\n';\n}\n\n/**\n * @type {Collapse}\n */\nfunction replaceNewlines(value) {\n  var match = /\\r?\\n|\\r/.exec(value);\n  return match ? match[0] : ' ';\n}\n\n/**\n * @type {Collapse}\n */\nfunction replaceWhitespace() {\n  return ' ';\n}\n\n/**\n * @param {Collapse} replace\n * @returns {Collapse}\n *   Collapse.\n */\nfunction collapseFactory(replace) {\n  return collapse;\n\n  /**\n   * @type {Collapse}\n   */\n  function collapse(value) {\n    return String(value).replace(/[\\t\\n\\v\\f\\r ]+/g, replace);\n  }\n}\n\n/**\n * We don’t need to support void elements here (so `nobr wbr` -> `normal` is\n * ignored).\n *\n * @param {Parents} node\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {Whitespace}\n *   Whitespace.\n */\nfunction inferWhiteSpace(node, state) {\n  if ('tagName' in node && node.properties) {\n    switch (node.tagName) {\n      // Whitespace in script/style, while not displayed by CSS as significant,\n      // could have some meaning in JS/CSS, so we can’t touch them.\n      case 'listing':\n      case 'plaintext':\n      case 'script':\n      case 'style':\n      case 'xmp':\n        {\n          return 'pre';\n        }\n      case 'nobr':\n        {\n          return 'nowrap';\n        }\n      case 'pre':\n        {\n          return node.properties.wrap ? 'pre-wrap' : 'pre';\n        }\n      case 'td':\n      case 'th':\n        {\n          return node.properties.noWrap ? 'nowrap' : state.whitespace;\n        }\n      case 'textarea':\n        {\n          return 'pre-wrap';\n        }\n      default:\n    }\n  }\n  return state.whitespace;\n}","map":{"version":3,"names":["embedded","isElement","whitespace","convert","blocks","content","contents","skippable","skippables","emptyOptions","ignorableNode","rehypeMinifyWhitespace","options","settings","collapse","collapseFactory","newlines","replaceNewlines","replaceWhitespace","tree","minify","node","state","_objectSpread","type","blocklike","before","after","inferWhiteSpace","all","minifyText","value","ignore","stripAtStart","remove","result","start","end","length","removable","charAt","slice","parent","children","index","collapsableAfter","splice","Boolean","nodes","inferBoundary","undefined","properties","hidden","character","match","exec","replace","String","tagName","wrap","noWrap"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/rehype-minify-whitespace/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Text} Text\n */\n\n/**\n * @callback Collapse\n *   Collapse a string.\n * @param {string} value\n *   Value to collapse.\n * @returns {string}\n *   Collapsed value.\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [newlines=false]\n *   Collapse whitespace containing newlines to `'\\n'` instead of `' '`\n *   (default: `false`); the default is to collapse to a single space.\n *\n * @typedef Result\n *   Result.\n * @property {boolean} remove\n *   Whether to remove.\n * @property {boolean} ignore\n *   Whether to ignore.\n * @property {boolean} stripAtStart\n *   Whether to strip at the start.\n *\n * @typedef State\n *   Info passed around.\n * @property {Collapse} collapse\n *   Collapse.\n * @property {Whitespace} whitespace\n *   Current whitespace.\n * @property {boolean | undefined} [before]\n *   Whether there is a break before (default: `false`).\n * @property {boolean | undefined} [after]\n *   Whether there is a break after (default: `false`).\n *\n * @typedef {'normal' | 'nowrap' | 'pre' | 'pre-wrap'} Whitespace\n *   Whitespace setting.\n */\n\nimport {embedded} from 'hast-util-embedded'\nimport {isElement} from 'hast-util-is-element'\nimport {whitespace} from 'hast-util-whitespace'\nimport {convert} from 'unist-util-is'\nimport {blocks} from './block.js'\nimport {content as contents} from './content.js'\nimport {skippable as skippables} from './skippable.js'\n\n/** @type {Options} */\nconst emptyOptions = {}\nconst ignorableNode = convert(['doctype', 'comment'])\n\n/**\n * Minify whitespace.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeMinifyWhitespace(options) {\n  const settings = options || emptyOptions\n  const collapse = collapseFactory(\n    settings.newlines ? replaceNewlines : replaceWhitespace\n  )\n\n  /**\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    minify(tree, {collapse, whitespace: 'normal'})\n  }\n}\n\n/**\n * @param {Nodes} node\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {Result}\n *   Result.\n */\nfunction minify(node, state) {\n  if ('children' in node) {\n    const settings = {...state}\n\n    if (node.type === 'root' || blocklike(node)) {\n      settings.before = true\n      settings.after = true\n    }\n\n    settings.whitespace = inferWhiteSpace(node, state)\n\n    return all(node, settings)\n  }\n\n  if (node.type === 'text') {\n    if (state.whitespace === 'normal') {\n      return minifyText(node, state)\n    }\n\n    // Naïve collapse, but no trimming:\n    if (state.whitespace === 'nowrap') {\n      node.value = state.collapse(node.value)\n    }\n\n    // The `pre-wrap` or `pre` whitespace settings are neither collapsed nor\n    // trimmed.\n  }\n\n  return {ignore: ignorableNode(node), stripAtStart: false, remove: false}\n}\n\n/**\n * @param {Text} node\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {Result}\n *   Result.\n */\nfunction minifyText(node, state) {\n  const value = state.collapse(node.value)\n  const result = {ignore: false, stripAtStart: false, remove: false}\n  let start = 0\n  let end = value.length\n\n  if (state.before && removable(value.charAt(0))) {\n    start++\n  }\n\n  if (start !== end && removable(value.charAt(end - 1))) {\n    if (state.after) {\n      end--\n    } else {\n      result.stripAtStart = true\n    }\n  }\n\n  if (start === end) {\n    result.remove = true\n  } else {\n    node.value = value.slice(start, end)\n  }\n\n  return result\n}\n\n/**\n * @param {Parents} parent\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {Result}\n *   Result.\n */\nfunction all(parent, state) {\n  let before = state.before\n  const after = state.after\n  const children = parent.children\n  let length = children.length\n  let index = -1\n\n  while (++index < length) {\n    const result = minify(children[index], {\n      ...state,\n      after: collapsableAfter(children, index, after),\n      before\n    })\n\n    if (result.remove) {\n      children.splice(index, 1)\n      index--\n      length--\n    } else if (!result.ignore) {\n      before = result.stripAtStart\n    }\n\n    // If this element, such as a `<select>` or `<img>`, contributes content\n    // somehow, allow whitespace again.\n    if (content(children[index])) {\n      before = false\n    }\n  }\n\n  return {ignore: false, stripAtStart: Boolean(before || after), remove: false}\n}\n\n/**\n * @param {Array<Nodes>} nodes\n *   Nodes.\n * @param {number} index\n *   Index.\n * @param {boolean | undefined} [after]\n *   Whether there is a break after `nodes` (default: `false`).\n * @returns {boolean | undefined}\n *   Whether there is a break after the node at `index`.\n */\nfunction collapsableAfter(nodes, index, after) {\n  while (++index < nodes.length) {\n    const node = nodes[index]\n    let result = inferBoundary(node)\n\n    if (result === undefined && 'children' in node && !skippable(node)) {\n      result = collapsableAfter(node.children, -1)\n    }\n\n    if (typeof result === 'boolean') {\n      return result\n    }\n  }\n\n  return after\n}\n\n/**\n * Infer two types of boundaries:\n *\n * 1. `true` — boundary for which whitespace around it does not contribute\n *    anything\n * 2. `false` — boundary for which whitespace around it *does* contribute\n *\n * No result (`undefined`) is returned if it is unknown.\n *\n * @param {Nodes} node\n *   Node.\n * @returns {boolean | undefined}\n *   Boundary.\n */\nfunction inferBoundary(node) {\n  if (node.type === 'element') {\n    if (content(node)) {\n      return false\n    }\n\n    if (blocklike(node)) {\n      return true\n    }\n\n    // Unknown: either depends on siblings if embedded or metadata, or on\n    // children.\n  } else if (node.type === 'text') {\n    if (!whitespace(node)) {\n      return false\n    }\n  } else if (!ignorableNode(node)) {\n    return false\n  }\n}\n\n/**\n * Infer whether a node is skippable.\n *\n * @param {Nodes} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` is skippable.\n */\nfunction content(node) {\n  return embedded(node) || isElement(node, contents)\n}\n\n/**\n * See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\n *\n * @param {Nodes} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` is block-like.\n */\nfunction blocklike(node) {\n  return isElement(node, blocks)\n}\n\n/**\n * @param {Parents} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` is skippable.\n */\nfunction skippable(node) {\n  return (\n    Boolean(node.type === 'element' && node.properties.hidden) ||\n    ignorableNode(node) ||\n    isElement(node, skippables)\n  )\n}\n\n/**\n * @param {string} character\n *   Character.\n * @returns {boolean}\n *   Whether `character` is removable.\n */\nfunction removable(character) {\n  return character === ' ' || character === '\\n'\n}\n\n/**\n * @type {Collapse}\n */\nfunction replaceNewlines(value) {\n  const match = /\\r?\\n|\\r/.exec(value)\n  return match ? match[0] : ' '\n}\n\n/**\n * @type {Collapse}\n */\nfunction replaceWhitespace() {\n  return ' '\n}\n\n/**\n * @param {Collapse} replace\n * @returns {Collapse}\n *   Collapse.\n */\nfunction collapseFactory(replace) {\n  return collapse\n\n  /**\n   * @type {Collapse}\n   */\n  function collapse(value) {\n    return String(value).replace(/[\\t\\n\\v\\f\\r ]+/g, replace)\n  }\n}\n\n/**\n * We don’t need to support void elements here (so `nobr wbr` -> `normal` is\n * ignored).\n *\n * @param {Parents} node\n *   Node.\n * @param {State} state\n *   Info passed around.\n * @returns {Whitespace}\n *   Whitespace.\n */\nfunction inferWhiteSpace(node, state) {\n  if ('tagName' in node && node.properties) {\n    switch (node.tagName) {\n      // Whitespace in script/style, while not displayed by CSS as significant,\n      // could have some meaning in JS/CSS, so we can’t touch them.\n      case 'listing':\n      case 'plaintext':\n      case 'script':\n      case 'style':\n      case 'xmp': {\n        return 'pre'\n      }\n\n      case 'nobr': {\n        return 'nowrap'\n      }\n\n      case 'pre': {\n        return node.properties.wrap ? 'pre-wrap' : 'pre'\n      }\n\n      case 'td':\n      case 'th': {\n        return node.properties.noWrap ? 'nowrap' : state.whitespace\n      }\n\n      case 'textarea': {\n        return 'pre-wrap'\n      }\n\n      default:\n    }\n  }\n\n  return state.whitespace\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}