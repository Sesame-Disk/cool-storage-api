{"ast":null,"code":"function words(str) {\n  var obj = {},\n    words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\nvar keywords = words(\"if elsif else stop require\");\nvar atoms = words(\"true false not\");\nfunction tokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == \"/\" && stream.eat(\"*\")) {\n    state.tokenize = tokenCComment;\n    return tokenCComment(stream, state);\n  }\n  if (ch === '#') {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n  if (ch == \"\\\"\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  }\n  if (ch == \"(\") {\n    state._indent.push(\"(\");\n    // add virtual angel wings so that editor behaves...\n    // ...more sane incase of broken brackets\n    state._indent.push(\"{\");\n    return null;\n  }\n  if (ch === \"{\") {\n    state._indent.push(\"{\");\n    return null;\n  }\n  if (ch == \")\") {\n    state._indent.pop();\n    state._indent.pop();\n  }\n  if (ch === \"}\") {\n    state._indent.pop();\n    return null;\n  }\n  if (ch == \",\") return null;\n  if (ch == \";\") return null;\n  if (/[{}\\(\\),;]/.test(ch)) return null;\n\n  // 1*DIGIT \"K\" / \"M\" / \"G\"\n  if (/\\d/.test(ch)) {\n    stream.eatWhile(/[\\d]/);\n    stream.eat(/[KkMmGg]/);\n    return \"number\";\n  }\n\n  // \":\" (ALPHA / \"_\") *(ALPHA / DIGIT / \"_\")\n  if (ch == \":\") {\n    stream.eatWhile(/[a-zA-Z_]/);\n    stream.eatWhile(/[a-zA-Z0-9_]/);\n    return \"operator\";\n  }\n  stream.eatWhile(/\\w/);\n  var cur = stream.current();\n\n  // \"text:\" *(SP / HTAB) (hash-comment / CRLF)\n  // *(multiline-literal / multiline-dotstart)\n  // \".\" CRLF\n  if (cur == \"text\" && stream.eat(\":\")) {\n    state.tokenize = tokenMultiLineString;\n    return \"string\";\n  }\n  if (keywords.propertyIsEnumerable(cur)) return \"keyword\";\n  if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n  return null;\n}\nfunction tokenMultiLineString(stream, state) {\n  state._multiLineString = true;\n  // the first line is special it may contain a comment\n  if (!stream.sol()) {\n    stream.eatSpace();\n    if (stream.peek() == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n    stream.skipToEnd();\n    return \"string\";\n  }\n  if (stream.next() == \".\" && stream.eol()) {\n    state._multiLineString = false;\n    state.tokenize = tokenBase;\n  }\n  return \"string\";\n}\nfunction tokenCComment(stream, state) {\n  var maybeEnd = false,\n    ch;\n  while ((ch = stream.next()) != null) {\n    if (maybeEnd && ch == \"/\") {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = ch == \"*\";\n  }\n  return \"comment\";\n}\nfunction tokenString(quote) {\n  return function (stream, state) {\n    var escaped = false,\n      ch;\n    while ((ch = stream.next()) != null) {\n      if (ch == quote && !escaped) break;\n      escaped = !escaped && ch == \"\\\\\";\n    }\n    if (!escaped) state.tokenize = tokenBase;\n    return \"string\";\n  };\n}\nexport var sieve = {\n  name: \"sieve\",\n  startState: function startState(base) {\n    return {\n      tokenize: tokenBase,\n      baseIndent: base || 0,\n      _indent: []\n    };\n  },\n  token: function token(stream, state) {\n    if (stream.eatSpace()) return null;\n    return (state.tokenize || tokenBase)(stream, state);\n  },\n  indent: function indent(state, _textAfter, cx) {\n    var length = state._indent.length;\n    if (_textAfter && _textAfter[0] == \"}\") length--;\n    if (length < 0) length = 0;\n    return length * cx.unit;\n  },\n  languageData: {\n    indentOnInput: /^\\s*\\}$/\n  }\n};","map":{"version":3,"names":["words","str","obj","split","i","length","keywords","atoms","tokenBase","stream","state","ch","next","eat","tokenize","tokenCComment","skipToEnd","tokenString","_indent","push","pop","test","eatWhile","cur","current","tokenMultiLineString","propertyIsEnumerable","_multiLineString","sol","eatSpace","peek","eol","maybeEnd","quote","escaped","sieve","name","startState","base","baseIndent","token","indent","_textAfter","cx","unit","languageData","indentOnInput"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@codemirror/legacy-modes/mode/sieve.js"],"sourcesContent":["function words(str) {\n  var obj = {}, words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\n\nvar keywords = words(\"if elsif else stop require\");\nvar atoms = words(\"true false not\");\n\nfunction tokenBase(stream, state) {\n\n  var ch = stream.next();\n  if (ch == \"/\" && stream.eat(\"*\")) {\n    state.tokenize = tokenCComment;\n    return tokenCComment(stream, state);\n  }\n\n  if (ch === '#') {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  if (ch == \"\\\"\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  }\n\n  if (ch == \"(\") {\n    state._indent.push(\"(\");\n    // add virtual angel wings so that editor behaves...\n    // ...more sane incase of broken brackets\n    state._indent.push(\"{\");\n    return null;\n  }\n\n  if (ch === \"{\") {\n    state._indent.push(\"{\");\n    return null;\n  }\n\n  if (ch == \")\")  {\n    state._indent.pop();\n    state._indent.pop();\n  }\n\n  if (ch === \"}\") {\n    state._indent.pop();\n    return null;\n  }\n\n  if (ch == \",\")\n    return null;\n\n  if (ch == \";\")\n    return null;\n\n\n  if (/[{}\\(\\),;]/.test(ch))\n    return null;\n\n  // 1*DIGIT \"K\" / \"M\" / \"G\"\n  if (/\\d/.test(ch)) {\n    stream.eatWhile(/[\\d]/);\n    stream.eat(/[KkMmGg]/);\n    return \"number\";\n  }\n\n  // \":\" (ALPHA / \"_\") *(ALPHA / DIGIT / \"_\")\n  if (ch == \":\") {\n    stream.eatWhile(/[a-zA-Z_]/);\n    stream.eatWhile(/[a-zA-Z0-9_]/);\n\n    return \"operator\";\n  }\n\n  stream.eatWhile(/\\w/);\n  var cur = stream.current();\n\n  // \"text:\" *(SP / HTAB) (hash-comment / CRLF)\n  // *(multiline-literal / multiline-dotstart)\n  // \".\" CRLF\n  if ((cur == \"text\") && stream.eat(\":\"))\n  {\n    state.tokenize = tokenMultiLineString;\n    return \"string\";\n  }\n\n  if (keywords.propertyIsEnumerable(cur))\n    return \"keyword\";\n\n  if (atoms.propertyIsEnumerable(cur))\n    return \"atom\";\n\n  return null;\n}\n\nfunction tokenMultiLineString(stream, state)\n{\n  state._multiLineString = true;\n  // the first line is special it may contain a comment\n  if (!stream.sol()) {\n    stream.eatSpace();\n\n    if (stream.peek() == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n\n    stream.skipToEnd();\n    return \"string\";\n  }\n\n  if ((stream.next() == \".\")  && (stream.eol()))\n  {\n    state._multiLineString = false;\n    state.tokenize = tokenBase;\n  }\n\n  return \"string\";\n}\n\nfunction tokenCComment(stream, state) {\n  var maybeEnd = false, ch;\n  while ((ch = stream.next()) != null) {\n    if (maybeEnd && ch == \"/\") {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return \"comment\";\n}\n\nfunction tokenString(quote) {\n  return function(stream, state) {\n    var escaped = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (ch == quote && !escaped)\n        break;\n      escaped = !escaped && ch == \"\\\\\";\n    }\n    if (!escaped) state.tokenize = tokenBase;\n    return \"string\";\n  };\n}\n\nexport const sieve = {\n  name: \"sieve\",\n  startState: function(base) {\n    return {tokenize: tokenBase,\n            baseIndent: base || 0,\n            _indent: []};\n  },\n\n  token: function(stream, state) {\n    if (stream.eatSpace())\n      return null;\n\n    return (state.tokenize || tokenBase)(stream, state);\n  },\n\n  indent: function(state, _textAfter, cx) {\n    var length = state._indent.length;\n    if (_textAfter && (_textAfter[0] == \"}\"))\n      length--;\n\n    if (length <0)\n      length = 0;\n\n    return length * cx.unit;\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*\\}$/\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}