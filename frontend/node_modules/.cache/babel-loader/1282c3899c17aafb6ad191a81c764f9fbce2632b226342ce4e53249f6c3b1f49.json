{"ast":null,"code":"import _toConsumableArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { Editor, Path, Transforms } from '@seafile/slate';\nimport { getNode } from '../queries';\nexport var moveChildren = function moveChildren(editor, _ref) {\n  var at = _ref.at,\n    to = _ref.to,\n    match = _ref.match,\n    _ref$fromStartIndex = _ref.fromStartIndex,\n    fromStartIndex = _ref$fromStartIndex === void 0 ? 0 : _ref$fromStartIndex;\n  var moved = 0;\n  var parentPath = Path.isPath(at) ? at : at[1];\n  var parentNode = Path.isPath(at) ? getNode(editor, parentPath) : at[0];\n  if (!parentNode) return moved;\n  // There have none children in a not block element\n  if (!Editor.isBlock(editor, parentNode)) return moved;\n  for (var i = parentNode.children.length - 1; i >= fromStartIndex; i--) {\n    var childPath = [].concat(_toConsumableArray(parentPath), [i]);\n    var childNode = getNode(editor, childPath);\n    if (!match || childNode && match([childNode, childPath])) {\n      Transforms.moveNodes(editor, {\n        at: childPath,\n        to: to\n      });\n      moved++;\n    }\n  }\n  return moved;\n};","map":{"version":3,"names":["Editor","Path","Transforms","getNode","moveChildren","editor","_ref","at","to","match","_ref$fromStartIndex","fromStartIndex","moved","parentPath","isPath","parentNode","isBlock","i","children","length","childPath","concat","_toConsumableArray","childNode","moveNodes"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/core/transforms/move-children.js"],"sourcesContent":["import { Editor, Path, Transforms } from '@seafile/slate';\nimport { getNode } from '../queries';\nexport const moveChildren = (editor, _ref) => {\n  let {\n    at,\n    to,\n    match,\n    fromStartIndex = 0\n  } = _ref;\n  let moved = 0;\n  const parentPath = Path.isPath(at) ? at : at[1];\n  const parentNode = Path.isPath(at) ? getNode(editor, parentPath) : at[0];\n  if (!parentNode) return moved;\n  // There have none children in a not block element\n  if (!Editor.isBlock(editor, parentNode)) return moved;\n  for (let i = parentNode.children.length - 1; i >= fromStartIndex; i--) {\n    const childPath = [...parentPath, i];\n    const childNode = getNode(editor, childPath);\n    if (!match || childNode && match([childNode, childPath])) {\n      Transforms.moveNodes(editor, {\n        at: childPath,\n        to\n      });\n      moved++;\n    }\n  }\n  return moved;\n};"],"mappings":";AAAA,SAASA,MAAM,EAAEC,IAAI,EAAEC,UAAU,QAAQ,gBAAgB;AACzD,SAASC,OAAO,QAAQ,YAAY;AACpC,OAAO,IAAMC,YAAY,GAAG,SAAfA,YAAYA,CAAIC,MAAM,EAAEC,IAAI,EAAK;EAC5C,IACEC,EAAE,GAIAD,IAAI,CAJNC,EAAE;IACFC,EAAE,GAGAF,IAAI,CAHNE,EAAE;IACFC,KAAK,GAEHH,IAAI,CAFNG,KAAK;IAAAC,mBAAA,GAEHJ,IAAI,CADNK,cAAc;IAAdA,cAAc,GAAAD,mBAAA,cAAG,CAAC,GAAAA,mBAAA;EAEpB,IAAIE,KAAK,GAAG,CAAC;EACb,IAAMC,UAAU,GAAGZ,IAAI,CAACa,MAAM,CAACP,EAAE,CAAC,GAAGA,EAAE,GAAGA,EAAE,CAAC,CAAC,CAAC;EAC/C,IAAMQ,UAAU,GAAGd,IAAI,CAACa,MAAM,CAACP,EAAE,CAAC,GAAGJ,OAAO,CAACE,MAAM,EAAEQ,UAAU,CAAC,GAAGN,EAAE,CAAC,CAAC,CAAC;EACxE,IAAI,CAACQ,UAAU,EAAE,OAAOH,KAAK;EAC7B;EACA,IAAI,CAACZ,MAAM,CAACgB,OAAO,CAACX,MAAM,EAAEU,UAAU,CAAC,EAAE,OAAOH,KAAK;EACrD,KAAK,IAAIK,CAAC,GAAGF,UAAU,CAACG,QAAQ,CAACC,MAAM,GAAG,CAAC,EAAEF,CAAC,IAAIN,cAAc,EAAEM,CAAC,EAAE,EAAE;IACrE,IAAMG,SAAS,MAAAC,MAAA,CAAAC,kBAAA,CAAOT,UAAU,IAAEI,CAAC,EAAC;IACpC,IAAMM,SAAS,GAAGpB,OAAO,CAACE,MAAM,EAAEe,SAAS,CAAC;IAC5C,IAAI,CAACX,KAAK,IAAIc,SAAS,IAAId,KAAK,CAAC,CAACc,SAAS,EAAEH,SAAS,CAAC,CAAC,EAAE;MACxDlB,UAAU,CAACsB,SAAS,CAACnB,MAAM,EAAE;QAC3BE,EAAE,EAAEa,SAAS;QACbZ,EAAE,EAAFA;MACF,CAAC,CAAC;MACFI,KAAK,EAAE;IACT;EACF;EACA,OAAOA,KAAK;AACd,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}