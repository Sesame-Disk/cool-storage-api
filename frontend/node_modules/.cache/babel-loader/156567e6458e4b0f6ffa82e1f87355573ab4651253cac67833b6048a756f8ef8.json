{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _slate = require(\"slate\");\nvar _core = require(\"../../core\");\nvar _elementTypes = require(\"../../constants/element-types\");\nvar _constants = require(\"../../constants\");\nvar isSelectionAtLineEnd = function isSelectionAtLineEnd(editor, path) {\n  var selection = editor.selection;\n  if (!selection) return false;\n  var isAtLineEnd = _slate.Editor.isEnd(editor, selection.anchor, path) || _slate.Editor.isEnd(editor, selection.focus, path);\n  return isAtLineEnd;\n};\nvar isSelectionAtLineStart = function isSelectionAtLineStart(editor, path) {\n  var selection = editor.selection;\n  if (!selection) return false;\n  var isAtLineEnd = _slate.Editor.isStart(editor, selection.anchor, path) || _slate.Editor.isStart(editor, selection.focus, path);\n  return isAtLineEnd;\n};\nvar withParagraph = function withParagraph(editor) {\n  var deleteBackward = editor.deleteBackward,\n    insertBreak = editor.insertBreak,\n    insertFragment = editor.insertFragment;\n  var newEditor = editor;\n  newEditor.insertBreak = function () {\n    if (!newEditor.selection) {\n      insertBreak();\n      return;\n    }\n    var _slate$Editor$nodes = _slate.Editor.nodes(newEditor, {\n        mode: 'lowest'\n      }),\n      _slate$Editor$nodes2 = _slicedToArray(_slate$Editor$nodes, 1),\n      node = _slate$Editor$nodes2[0];\n    if (node && node[0].code) {\n      var aboveNode = (0, _core.getAboveBlockNode)(newEditor, {\n        match: function match(n) {\n          return _slate.Element.isElement(n);\n        },\n        mode: 'highest'\n      });\n      if (isSelectionAtLineStart(editor, node[1]) && _slate.Node.string(node[0]).length !== 0) {\n        _slate.Transforms.insertNodes(newEditor, (0, _core.generateDefaultParagraph)(), {\n          at: aboveNode[1],\n          select: true\n        });\n        var startPosition = _slate.Editor.start(editor, _slate.Path.next(aboveNode[1]));\n        var range = {\n          anchor: startPosition,\n          focus: startPosition\n        };\n        (0, _core.focusEditor)(newEditor, range);\n        return;\n      }\n      if (isSelectionAtLineEnd(editor, node[1])) {\n        var nextPath = _slate.Path.next(aboveNode[1]);\n        _slate.Transforms.insertNodes(newEditor, (0, _core.generateDefaultParagraph)(), {\n          at: nextPath,\n          select: true\n        });\n        return;\n      }\n    }\n    insertBreak();\n  };\n  newEditor.deleteBackward = function (unit) {\n    var selection = newEditor.selection;\n    if (!selection) {\n      deleteBackward(unit);\n      return;\n    }\n    var selectedParagraphNodeEntry = (0, _core.getSelectedNodeEntryByType)(newEditor, _elementTypes.PARAGRAPH);\n    if (selectedParagraphNodeEntry) {\n      if (_slate.Node.string(selectedParagraphNodeEntry[0]) === '') {\n        var previousNodeEntry = (0, _core.getPrevNode)(newEditor);\n        if (previousNodeEntry && previousNodeEntry[0].type === _elementTypes.TABLE_CELL) {\n          _slate.Transforms.removeNodes(newEditor, {\n            at: selectedParagraphNodeEntry[1]\n          });\n          return;\n        }\n      }\n    }\n    return deleteBackward(unit);\n  };\n  newEditor.insertFragment = function (fragment) {\n    var match = {\n      type: [_elementTypes.PARAGRAPH]\n    };\n    var _ref = (0, _core.getNodeEntries)(newEditor, {\n        match: match\n      }),\n      _ref2 = _slicedToArray(_ref, 1),\n      paragraphEntry = _ref2[0];\n    if (!paragraphEntry) return insertFragment(fragment);\n    var firstChild = fragment[0];\n    if (fragment.length === 1 && _constants.LIST_TYPE_ARRAY.includes(firstChild.type)) {\n      // insert text\n      if (firstChild.children.length === 1) {\n        var text = _slate.Node.string(fragment[0]);\n        (0, _slate.insertText)(text);\n        return;\n      }\n\n      // insert list at current path\n      if ((0, _core.isSelectionAtBlockStart)(editor)) {\n        _slate.Transforms.insertNodes(newEditor, fragment);\n        return;\n      }\n\n      // insert list at next path\n      var nextPath = _slate.Path.next(paragraphEntry[1]);\n      _slate.Transforms.insertNodes(newEditor, fragment, {\n        at: nextPath\n      });\n      return;\n    }\n    if (fragment.length === 1 && firstChild.type === _elementTypes.TABLE) {\n      var hasVoidNode = paragraphEntry[0].children.some(function (item) {\n        return _slate.Editor.isVoid(newEditor, item);\n      });\n      if (_slate.Node.string(paragraphEntry[0]).length === 0 && !hasVoidNode) {\n        _slate.Transforms.insertNodes(newEditor, fragment, {\n          at: paragraphEntry[1]\n        });\n        return;\n      }\n      var _nextPath = _slate.Path.next(paragraphEntry[1]);\n      _slate.Transforms.insertNodes(newEditor, fragment, {\n        at: _nextPath\n      });\n      return;\n    }\n    return insertFragment(fragment);\n  };\n  return newEditor;\n};\nvar _default = exports.default = withParagraph;","map":{"version":3,"names":["_slicedToArray","require","default","Object","defineProperty","exports","value","_slate","_core","_elementTypes","_constants","isSelectionAtLineEnd","editor","path","selection","isAtLineEnd","Editor","isEnd","anchor","focus","isSelectionAtLineStart","isStart","withParagraph","deleteBackward","insertBreak","insertFragment","newEditor","_slate$Editor$nodes","nodes","mode","_slate$Editor$nodes2","node","code","aboveNode","getAboveBlockNode","match","n","Element","isElement","Node","string","length","Transforms","insertNodes","generateDefaultParagraph","at","select","startPosition","start","Path","next","range","focusEditor","nextPath","unit","selectedParagraphNodeEntry","getSelectedNodeEntryByType","PARAGRAPH","previousNodeEntry","getPrevNode","type","TABLE_CELL","removeNodes","fragment","_ref","getNodeEntries","_ref2","paragraphEntry","firstChild","LIST_TYPE_ARRAY","includes","children","text","insertText","isSelectionAtBlockStart","TABLE","hasVoidNode","some","item","isVoid","_default"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/seafile-editor/dist/extension/plugins/paragraph/plugin.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _slate = require(\"slate\");\nvar _core = require(\"../../core\");\nvar _elementTypes = require(\"../../constants/element-types\");\nvar _constants = require(\"../../constants\");\nconst isSelectionAtLineEnd = (editor, path) => {\n  const {\n    selection\n  } = editor;\n  if (!selection) return false;\n  const isAtLineEnd = _slate.Editor.isEnd(editor, selection.anchor, path) || _slate.Editor.isEnd(editor, selection.focus, path);\n  return isAtLineEnd;\n};\nconst isSelectionAtLineStart = (editor, path) => {\n  const {\n    selection\n  } = editor;\n  if (!selection) return false;\n  const isAtLineEnd = _slate.Editor.isStart(editor, selection.anchor, path) || _slate.Editor.isStart(editor, selection.focus, path);\n  return isAtLineEnd;\n};\nconst withParagraph = editor => {\n  const {\n    deleteBackward,\n    insertBreak,\n    insertFragment\n  } = editor;\n  const newEditor = editor;\n  newEditor.insertBreak = () => {\n    if (!newEditor.selection) {\n      insertBreak();\n      return;\n    }\n    const [node] = _slate.Editor.nodes(newEditor, {\n      mode: 'lowest'\n    });\n    if (node && node[0].code) {\n      const aboveNode = (0, _core.getAboveBlockNode)(newEditor, {\n        match: n => _slate.Element.isElement(n),\n        mode: 'highest'\n      });\n      if (isSelectionAtLineStart(editor, node[1]) && _slate.Node.string(node[0]).length !== 0) {\n        _slate.Transforms.insertNodes(newEditor, (0, _core.generateDefaultParagraph)(), {\n          at: aboveNode[1],\n          select: true\n        });\n        const startPosition = _slate.Editor.start(editor, _slate.Path.next(aboveNode[1]));\n        const range = {\n          anchor: startPosition,\n          focus: startPosition\n        };\n        (0, _core.focusEditor)(newEditor, range);\n        return;\n      }\n      if (isSelectionAtLineEnd(editor, node[1])) {\n        const nextPath = _slate.Path.next(aboveNode[1]);\n        _slate.Transforms.insertNodes(newEditor, (0, _core.generateDefaultParagraph)(), {\n          at: nextPath,\n          select: true\n        });\n        return;\n      }\n    }\n    insertBreak();\n  };\n  newEditor.deleteBackward = unit => {\n    const {\n      selection\n    } = newEditor;\n    if (!selection) {\n      deleteBackward(unit);\n      return;\n    }\n    const selectedParagraphNodeEntry = (0, _core.getSelectedNodeEntryByType)(newEditor, _elementTypes.PARAGRAPH);\n    if (selectedParagraphNodeEntry) {\n      if (_slate.Node.string(selectedParagraphNodeEntry[0]) === '') {\n        const previousNodeEntry = (0, _core.getPrevNode)(newEditor);\n        if (previousNodeEntry && previousNodeEntry[0].type === _elementTypes.TABLE_CELL) {\n          _slate.Transforms.removeNodes(newEditor, {\n            at: selectedParagraphNodeEntry[1]\n          });\n          return;\n        }\n      }\n    }\n    return deleteBackward(unit);\n  };\n  newEditor.insertFragment = fragment => {\n    const match = {\n      type: [_elementTypes.PARAGRAPH]\n    };\n    const [paragraphEntry] = (0, _core.getNodeEntries)(newEditor, {\n      match\n    });\n    if (!paragraphEntry) return insertFragment(fragment);\n    const firstChild = fragment[0];\n    if (fragment.length === 1 && _constants.LIST_TYPE_ARRAY.includes(firstChild.type)) {\n      // insert text\n      if (firstChild.children.length === 1) {\n        const text = _slate.Node.string(fragment[0]);\n        (0, _slate.insertText)(text);\n        return;\n      }\n\n      // insert list at current path\n      if ((0, _core.isSelectionAtBlockStart)(editor)) {\n        _slate.Transforms.insertNodes(newEditor, fragment);\n        return;\n      }\n\n      // insert list at next path\n      const nextPath = _slate.Path.next(paragraphEntry[1]);\n      _slate.Transforms.insertNodes(newEditor, fragment, {\n        at: nextPath\n      });\n      return;\n    }\n    if (fragment.length === 1 && firstChild.type === _elementTypes.TABLE) {\n      const hasVoidNode = paragraphEntry[0].children.some(item => _slate.Editor.isVoid(newEditor, item));\n      if (_slate.Node.string(paragraphEntry[0]).length === 0 && !hasVoidNode) {\n        _slate.Transforms.insertNodes(newEditor, fragment, {\n          at: paragraphEntry[1]\n        });\n        return;\n      }\n      const nextPath = _slate.Path.next(paragraphEntry[1]);\n      _slate.Transforms.insertNodes(newEditor, fragment, {\n        at: nextPath\n      });\n      return;\n    }\n    return insertFragment(fragment);\n  };\n  return newEditor;\n};\nvar _default = exports.default = withParagraph;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}