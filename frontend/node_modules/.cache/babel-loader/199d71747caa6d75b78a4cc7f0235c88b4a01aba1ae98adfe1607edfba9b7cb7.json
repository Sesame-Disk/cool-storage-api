{"ast":null,"code":"import slugid from 'slugid';\nimport typeOf from 'type-of';\nimport { INLINE_LEVEL_TYPES, LIST_ITEM, PARAGRAPH, TOP_LEVEL_TYPES, UNORDERED_LIST } from '../../constants';\nimport rules from './rules';\nvar cruftNewline = function cruftNewline(element) {\n  return !(element.nodeName === '#text' && element.nodeValue === '\\n');\n};\nvar deserializeElement = function deserializeElement(element) {\n  var node;\n  var next = function next(elements) {\n    if (Object.prototype.toString.call(elements) === '[object NodeList]') {\n      elements = Array.from(elements);\n    }\n    switch (typeOf(elements)) {\n      case 'array':\n        return deserializeElements(elements);\n      case 'object':\n        return deserializeElement(elements);\n      case 'null':\n      case 'undefined':\n        return;\n      default:\n        throw new Error(\"The `next` argument was called with invalid children: \\\"\".concat(elements, \"\\\".\"));\n    }\n  };\n  for (var i = 0; i < rules.length; i++) {\n    var rule = rules[i];\n    if (!rule) continue;\n    var ret = rule(element, next);\n    var type = typeOf(ret);\n    if (type !== 'array' && type !== 'object' && type !== 'null' && type !== 'undefined') {\n      throw new Error(\"A rule returned an invalid deserialized representation: \\\"\".concat(node, \"\\\".\"));\n    }\n\n    // Not eligible for current component processing\n    if (ret === undefined) {\n      continue;\n    }\n\n    // Empty tags will be discarded and not converted accordingly\n    if (ret === null) {\n      return null;\n    }\n\n    // Assign the final processing result to node\n    node = ret;\n    break;\n  }\n\n  // If node is undefined, it means that the label is not processed, and continue to process the child nodes of the element\n  return node || next(element.childNodes);\n};\nvar deserializeElements = function deserializeElements() {\n  var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var isTopLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var nodes = [];\n  elements.filter(cruftNewline).forEach(function (element) {\n    var node = deserializeElement(element);\n    switch (typeOf(node)) {\n      case 'array':\n        var formatNode = isTopLevel ? formatElementNodes(node) : node;\n        nodes = nodes.concat(formatNode);\n        break;\n      case 'object':\n        nodes.push(node);\n        break;\n      default:\n      // nothing todo\n    }\n  });\n\n  return nodes;\n};\nvar formatElementNodes = function formatElementNodes(nodes) {\n  if (nodes.length === 0) return nodes;\n  nodes = nodes.reduce(function (memo, node) {\n    if (TOP_LEVEL_TYPES.includes(node.type)) {\n      memo.push(node);\n    }\n    if (node.type === LIST_ITEM) {\n      var newNode = {\n        id: slugid.nice(),\n        type: UNORDERED_LIST,\n        children: [node]\n      };\n      memo.push(newNode);\n      return memo;\n    }\n\n    // The following types will not appear individually during the pasting process\n    // code_line\n    // table_row | table_cell\n\n    // text | image | link\n    if (!node.type || INLINE_LEVEL_TYPES.includes(node.type)) {\n      var prevNode = memo[memo.length - 1];\n      if (prevNode && prevNode.type === PARAGRAPH) {\n        prevNode.children.push(node);\n        return memo;\n      }\n      var _newNode = {\n        id: slugid.nice(),\n        type: PARAGRAPH,\n        children: [node]\n      };\n      memo.push(_newNode);\n      return memo;\n    }\n    return memo;\n  }, []);\n  return nodes;\n};\nvar parseHtml = function parseHtml(html) {\n  var parsed = new DOMParser().parseFromString(html, 'text/html');\n  var body = parsed.body;\n  return body;\n};\nexport var deserializeHtml = function deserializeHtml(html) {\n  var fragment = parseHtml(html);\n  var children = Array.from(fragment.childNodes);\n  var nodes = [];\n  nodes = deserializeElements(children, true);\n  nodes = formatElementNodes(nodes);\n  if (nodes.length === 0) {\n    nodes = [{\n      id: slugid.nice(),\n      type: PARAGRAPH,\n      children: [{\n        text: '',\n        id: slugid.nice()\n      }]\n    }];\n  }\n  return nodes;\n};","map":{"version":3,"names":["slugid","typeOf","INLINE_LEVEL_TYPES","LIST_ITEM","PARAGRAPH","TOP_LEVEL_TYPES","UNORDERED_LIST","rules","cruftNewline","element","nodeName","nodeValue","deserializeElement","node","next","elements","Object","prototype","toString","call","Array","from","deserializeElements","Error","concat","i","length","rule","ret","type","undefined","childNodes","arguments","isTopLevel","nodes","filter","forEach","formatNode","formatElementNodes","push","reduce","memo","includes","newNode","id","nice","children","prevNode","parseHtml","html","parsed","DOMParser","parseFromString","body","deserializeHtml","fragment","text"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/plugins/html/helper.js"],"sourcesContent":["import slugid from 'slugid';\nimport typeOf from 'type-of';\nimport { INLINE_LEVEL_TYPES, LIST_ITEM, PARAGRAPH, TOP_LEVEL_TYPES, UNORDERED_LIST } from '../../constants';\nimport rules from './rules';\nconst cruftNewline = element => {\n  return !(element.nodeName === '#text' && element.nodeValue === '\\n');\n};\nconst deserializeElement = element => {\n  let node;\n  const next = elements => {\n    if (Object.prototype.toString.call(elements) === '[object NodeList]') {\n      elements = Array.from(elements);\n    }\n    switch (typeOf(elements)) {\n      case 'array':\n        return deserializeElements(elements);\n      case 'object':\n        return deserializeElement(elements);\n      case 'null':\n      case 'undefined':\n        return;\n      default:\n        throw new Error(\"The `next` argument was called with invalid children: \\\"\".concat(elements, \"\\\".\"));\n    }\n  };\n  for (let i = 0; i < rules.length; i++) {\n    const rule = rules[i];\n    if (!rule) continue;\n    const ret = rule(element, next);\n    const type = typeOf(ret);\n    if (type !== 'array' && type !== 'object' && type !== 'null' && type !== 'undefined') {\n      throw new Error(\"A rule returned an invalid deserialized representation: \\\"\".concat(node, \"\\\".\"));\n    }\n\n    // Not eligible for current component processing\n    if (ret === undefined) {\n      continue;\n    }\n\n    // Empty tags will be discarded and not converted accordingly\n    if (ret === null) {\n      return null;\n    }\n\n    // Assign the final processing result to node\n    node = ret;\n    break;\n  }\n\n  // If node is undefined, it means that the label is not processed, and continue to process the child nodes of the element\n  return node || next(element.childNodes);\n};\nconst deserializeElements = function () {\n  let elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let isTopLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let nodes = [];\n  elements.filter(cruftNewline).forEach(element => {\n    const node = deserializeElement(element);\n    switch (typeOf(node)) {\n      case 'array':\n        const formatNode = isTopLevel ? formatElementNodes(node) : node;\n        nodes = nodes.concat(formatNode);\n        break;\n      case 'object':\n        nodes.push(node);\n        break;\n      default:\n      // nothing todo\n    }\n  });\n\n  return nodes;\n};\nconst formatElementNodes = nodes => {\n  if (nodes.length === 0) return nodes;\n  nodes = nodes.reduce((memo, node) => {\n    if (TOP_LEVEL_TYPES.includes(node.type)) {\n      memo.push(node);\n    }\n    if (node.type === LIST_ITEM) {\n      const newNode = {\n        id: slugid.nice(),\n        type: UNORDERED_LIST,\n        children: [node]\n      };\n      memo.push(newNode);\n      return memo;\n    }\n\n    // The following types will not appear individually during the pasting process\n    // code_line\n    // table_row | table_cell\n\n    // text | image | link\n    if (!node.type || INLINE_LEVEL_TYPES.includes(node.type)) {\n      let prevNode = memo[memo.length - 1];\n      if (prevNode && prevNode.type === PARAGRAPH) {\n        prevNode.children.push(node);\n        return memo;\n      }\n      const newNode = {\n        id: slugid.nice(),\n        type: PARAGRAPH,\n        children: [node]\n      };\n      memo.push(newNode);\n      return memo;\n    }\n    return memo;\n  }, []);\n  return nodes;\n};\nconst parseHtml = html => {\n  const parsed = new DOMParser().parseFromString(html, 'text/html');\n  const {\n    body\n  } = parsed;\n  return body;\n};\nexport const deserializeHtml = html => {\n  const fragment = parseHtml(html);\n  const children = Array.from(fragment.childNodes);\n  let nodes = [];\n  nodes = deserializeElements(children, true);\n  nodes = formatElementNodes(nodes);\n  if (nodes.length === 0) {\n    nodes = [{\n      id: slugid.nice(),\n      type: PARAGRAPH,\n      children: [{\n        text: '',\n        id: slugid.nice()\n      }]\n    }];\n  }\n  return nodes;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}