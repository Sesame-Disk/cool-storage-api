{"ast":null,"code":"/**\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {Array<string> | null | undefined} [blanks=[]]\n *   List of tag names to join with a blank line (default: `[]`); these tags,\n *   when next to each other, are joined by a blank line (`\\n\\n`); for example,\n *   when `['head', 'body']` is given, a blank line is added between these two.\n * @property {number | string | null | undefined} [indent=2]\n *   Indentation per level (default: `2`); when number, uses that amount of\n *   spaces; when `string`, uses that per indentation level.\n * @property {boolean | null | undefined} [indentInitial=true]\n *   Whether to indent the first level (default: `true`); this is usually the\n *   `<html>`, thus not indenting `head` and `body`.\n */\n\nimport { embedded } from 'hast-util-embedded';\nimport { isElement } from 'hast-util-is-element';\nimport { phrasing } from 'hast-util-phrasing';\nimport { whitespace } from 'hast-util-whitespace';\nimport { whitespaceSensitiveTagNames } from 'html-whitespace-sensitive-tag-names';\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace';\nimport { SKIP, visitParents } from 'unist-util-visit-parents';\n\n/** @type {Options} */\nvar emptyOptions = {};\nvar transformWhitespace = rehypeMinifyWhitespace({\n  newlines: true\n});\n\n/**\n * Format whitespace in HTML.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeFormat(options) {\n  var settings = options || emptyOptions;\n  var indent = settings.indent || 2;\n  var indentInitial = settings.indentInitial;\n  if (typeof indent === 'number') {\n    indent = ' '.repeat(indent);\n  }\n\n  // Default to indenting the initial level.\n  if (indentInitial === null || indentInitial === undefined) {\n    indentInitial = true;\n  }\n\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    /** @type {boolean | undefined} */\n    var head;\n    transformWhitespace(tree);\n\n    // eslint-disable-next-line complexity\n    visitParents(tree, function (node, parents) {\n      var index = -1;\n      if (!('children' in node)) {\n        return;\n      }\n      if (isElement(node, 'head')) {\n        head = true;\n      }\n      if (head && isElement(node, 'body')) {\n        head = undefined;\n      }\n      if (isElement(node, whitespaceSensitiveTagNames)) {\n        return SKIP;\n      }\n      var children = node.children;\n      var level = parents.length;\n\n      // Don’t indent content of whitespace-sensitive nodes / inlines.\n      if (children.length === 0 || !padding(node, head)) {\n        return;\n      }\n      if (!indentInitial) {\n        level--;\n      }\n\n      /** @type {boolean | undefined} */\n      var eol;\n\n      // Indent newlines in `text`.\n      while (++index < children.length) {\n        var child = children[index];\n        if (child.type === 'text' || child.type === 'comment') {\n          if (child.value.includes('\\n')) {\n            eol = true;\n          }\n          child.value = child.value.replace(/ *\\n/g, '$&' + String(indent).repeat(level));\n        }\n      }\n\n      /** @type {Array<RootContent>} */\n      var result = [];\n      /** @type {RootContent | undefined} */\n      var previous;\n      index = -1;\n      while (++index < children.length) {\n        var _child = children[index];\n        if (padding(_child, head) || eol && !index) {\n          addBreak(result, level, _child);\n          eol = true;\n        }\n        previous = _child;\n        result.push(_child);\n      }\n      if (previous && (eol || padding(previous, head))) {\n        // Ignore trailing whitespace (if that already existed), as we’ll add\n        // properly indented whitespace.\n        if (whitespace(previous)) {\n          result.pop();\n          previous = result[result.length - 1];\n        }\n        addBreak(result, level - 1);\n      }\n      node.children = result;\n    });\n  };\n\n  /**\n   * @param {Array<RootContent>} list\n   *   Nodes.\n   * @param {number} level\n   *   Indentation level.\n   * @param {RootContent | undefined} [next]\n   *   Next node.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function addBreak(list, level, next) {\n    var tail = list[list.length - 1];\n    var previous = tail && whitespace(tail) ? list[list.length - 2] : tail;\n    var replace = (blank(previous) && blank(next) ? '\\n\\n' : '\\n') + String(indent).repeat(Math.max(level, 0));\n    if (tail && tail.type === 'text') {\n      tail.value = whitespace(tail) ? replace : tail.value + replace;\n    } else {\n      list.push({\n        type: 'text',\n        value: replace\n      });\n    }\n  }\n\n  /**\n   * @param {Nodes | undefined} node\n   *   Node.\n   * @returns {boolean}\n   *   Whether `node` is a blank.\n   */\n  function blank(node) {\n    return Boolean(node && node.type === 'element' && settings.blanks && settings.blanks.length > 0 && settings.blanks.includes(node.tagName));\n  }\n}\n\n/**\n * @param {Nodes} node\n *   Node.\n * @param {boolean | undefined} head\n *   Whether the node is in `head`.\n * @returns {boolean}\n *   Whether `node` should be padded.\n */\nfunction padding(node, head) {\n  return node.type === 'root' || (node.type === 'element' ? head || isElement(node, 'script') || embedded(node) || !phrasing(node) : false);\n}","map":{"version":3,"names":["embedded","isElement","phrasing","whitespace","whitespaceSensitiveTagNames","rehypeMinifyWhitespace","SKIP","visitParents","emptyOptions","transformWhitespace","newlines","rehypeFormat","options","settings","indent","indentInitial","repeat","undefined","tree","head","node","parents","index","children","level","length","padding","eol","child","type","value","includes","replace","String","result","previous","addBreak","push","pop","list","next","tail","blank","Math","max","Boolean","blanks","tagName"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/rehype-format/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {Array<string> | null | undefined} [blanks=[]]\n *   List of tag names to join with a blank line (default: `[]`); these tags,\n *   when next to each other, are joined by a blank line (`\\n\\n`); for example,\n *   when `['head', 'body']` is given, a blank line is added between these two.\n * @property {number | string | null | undefined} [indent=2]\n *   Indentation per level (default: `2`); when number, uses that amount of\n *   spaces; when `string`, uses that per indentation level.\n * @property {boolean | null | undefined} [indentInitial=true]\n *   Whether to indent the first level (default: `true`); this is usually the\n *   `<html>`, thus not indenting `head` and `body`.\n */\n\nimport {embedded} from 'hast-util-embedded'\nimport {isElement} from 'hast-util-is-element'\nimport {phrasing} from 'hast-util-phrasing'\nimport {whitespace} from 'hast-util-whitespace'\nimport {whitespaceSensitiveTagNames} from 'html-whitespace-sensitive-tag-names'\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace'\nimport {SKIP, visitParents} from 'unist-util-visit-parents'\n\n/** @type {Options} */\nconst emptyOptions = {}\nconst transformWhitespace = rehypeMinifyWhitespace({newlines: true})\n\n/**\n * Format whitespace in HTML.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeFormat(options) {\n  const settings = options || emptyOptions\n  let indent = settings.indent || 2\n  let indentInitial = settings.indentInitial\n\n  if (typeof indent === 'number') {\n    indent = ' '.repeat(indent)\n  }\n\n  // Default to indenting the initial level.\n  if (indentInitial === null || indentInitial === undefined) {\n    indentInitial = true\n  }\n\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    /** @type {boolean | undefined} */\n    let head\n\n    transformWhitespace(tree)\n\n    // eslint-disable-next-line complexity\n    visitParents(tree, function (node, parents) {\n      let index = -1\n\n      if (!('children' in node)) {\n        return\n      }\n\n      if (isElement(node, 'head')) {\n        head = true\n      }\n\n      if (head && isElement(node, 'body')) {\n        head = undefined\n      }\n\n      if (isElement(node, whitespaceSensitiveTagNames)) {\n        return SKIP\n      }\n\n      const children = node.children\n      let level = parents.length\n\n      // Don’t indent content of whitespace-sensitive nodes / inlines.\n      if (children.length === 0 || !padding(node, head)) {\n        return\n      }\n\n      if (!indentInitial) {\n        level--\n      }\n\n      /** @type {boolean | undefined} */\n      let eol\n\n      // Indent newlines in `text`.\n      while (++index < children.length) {\n        const child = children[index]\n\n        if (child.type === 'text' || child.type === 'comment') {\n          if (child.value.includes('\\n')) {\n            eol = true\n          }\n\n          child.value = child.value.replace(\n            / *\\n/g,\n            '$&' + String(indent).repeat(level)\n          )\n        }\n      }\n\n      /** @type {Array<RootContent>} */\n      const result = []\n      /** @type {RootContent | undefined} */\n      let previous\n\n      index = -1\n\n      while (++index < children.length) {\n        const child = children[index]\n\n        if (padding(child, head) || (eol && !index)) {\n          addBreak(result, level, child)\n          eol = true\n        }\n\n        previous = child\n        result.push(child)\n      }\n\n      if (previous && (eol || padding(previous, head))) {\n        // Ignore trailing whitespace (if that already existed), as we’ll add\n        // properly indented whitespace.\n        if (whitespace(previous)) {\n          result.pop()\n          previous = result[result.length - 1]\n        }\n\n        addBreak(result, level - 1)\n      }\n\n      node.children = result\n    })\n  }\n\n  /**\n   * @param {Array<RootContent>} list\n   *   Nodes.\n   * @param {number} level\n   *   Indentation level.\n   * @param {RootContent | undefined} [next]\n   *   Next node.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function addBreak(list, level, next) {\n    const tail = list[list.length - 1]\n    const previous = tail && whitespace(tail) ? list[list.length - 2] : tail\n    const replace =\n      (blank(previous) && blank(next) ? '\\n\\n' : '\\n') +\n      String(indent).repeat(Math.max(level, 0))\n\n    if (tail && tail.type === 'text') {\n      tail.value = whitespace(tail) ? replace : tail.value + replace\n    } else {\n      list.push({type: 'text', value: replace})\n    }\n  }\n\n  /**\n   * @param {Nodes | undefined} node\n   *   Node.\n   * @returns {boolean}\n   *   Whether `node` is a blank.\n   */\n  function blank(node) {\n    return Boolean(\n      node &&\n        node.type === 'element' &&\n        settings.blanks &&\n        settings.blanks.length > 0 &&\n        settings.blanks.includes(node.tagName)\n    )\n  }\n}\n\n/**\n * @param {Nodes} node\n *   Node.\n * @param {boolean | undefined} head\n *   Whether the node is in `head`.\n * @returns {boolean}\n *   Whether `node` should be padded.\n */\nfunction padding(node, head) {\n  return (\n    node.type === 'root' ||\n    (node.type === 'element'\n      ? head || isElement(node, 'script') || embedded(node) || !phrasing(node)\n      : false)\n  )\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,QAAQ,QAAO,oBAAoB;AAC3C,SAAQC,SAAS,QAAO,sBAAsB;AAC9C,SAAQC,QAAQ,QAAO,oBAAoB;AAC3C,SAAQC,UAAU,QAAO,sBAAsB;AAC/C,SAAQC,2BAA2B,QAAO,qCAAqC;AAC/E,OAAOC,sBAAsB,MAAM,0BAA0B;AAC7D,SAAQC,IAAI,EAAEC,YAAY,QAAO,0BAA0B;;AAE3D;AACA,IAAMC,YAAY,GAAG,CAAC,CAAC;AACvB,IAAMC,mBAAmB,GAAGJ,sBAAsB,CAAC;EAACK,QAAQ,EAAE;AAAI,CAAC,CAAC;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,YAAYA,CAACC,OAAO,EAAE;EAC5C,IAAMC,QAAQ,GAAGD,OAAO,IAAIJ,YAAY;EACxC,IAAIM,MAAM,GAAGD,QAAQ,CAACC,MAAM,IAAI,CAAC;EACjC,IAAIC,aAAa,GAAGF,QAAQ,CAACE,aAAa;EAE1C,IAAI,OAAOD,MAAM,KAAK,QAAQ,EAAE;IAC9BA,MAAM,GAAG,GAAG,CAACE,MAAM,CAACF,MAAM,CAAC;EAC7B;;EAEA;EACA,IAAIC,aAAa,KAAK,IAAI,IAAIA,aAAa,KAAKE,SAAS,EAAE;IACzDF,aAAa,GAAG,IAAI;EACtB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAO,UAAUG,IAAI,EAAE;IACrB;IACA,IAAIC,IAAI;IAERV,mBAAmB,CAACS,IAAI,CAAC;;IAEzB;IACAX,YAAY,CAACW,IAAI,EAAE,UAAUE,IAAI,EAAEC,OAAO,EAAE;MAC1C,IAAIC,KAAK,GAAG,CAAC,CAAC;MAEd,IAAI,EAAE,UAAU,IAAIF,IAAI,CAAC,EAAE;QACzB;MACF;MAEA,IAAInB,SAAS,CAACmB,IAAI,EAAE,MAAM,CAAC,EAAE;QAC3BD,IAAI,GAAG,IAAI;MACb;MAEA,IAAIA,IAAI,IAAIlB,SAAS,CAACmB,IAAI,EAAE,MAAM,CAAC,EAAE;QACnCD,IAAI,GAAGF,SAAS;MAClB;MAEA,IAAIhB,SAAS,CAACmB,IAAI,EAAEhB,2BAA2B,CAAC,EAAE;QAChD,OAAOE,IAAI;MACb;MAEA,IAAMiB,QAAQ,GAAGH,IAAI,CAACG,QAAQ;MAC9B,IAAIC,KAAK,GAAGH,OAAO,CAACI,MAAM;;MAE1B;MACA,IAAIF,QAAQ,CAACE,MAAM,KAAK,CAAC,IAAI,CAACC,OAAO,CAACN,IAAI,EAAED,IAAI,CAAC,EAAE;QACjD;MACF;MAEA,IAAI,CAACJ,aAAa,EAAE;QAClBS,KAAK,EAAE;MACT;;MAEA;MACA,IAAIG,GAAG;;MAEP;MACA,OAAO,EAAEL,KAAK,GAAGC,QAAQ,CAACE,MAAM,EAAE;QAChC,IAAMG,KAAK,GAAGL,QAAQ,CAACD,KAAK,CAAC;QAE7B,IAAIM,KAAK,CAACC,IAAI,KAAK,MAAM,IAAID,KAAK,CAACC,IAAI,KAAK,SAAS,EAAE;UACrD,IAAID,KAAK,CAACE,KAAK,CAACC,QAAQ,CAAC,IAAI,CAAC,EAAE;YAC9BJ,GAAG,GAAG,IAAI;UACZ;UAEAC,KAAK,CAACE,KAAK,GAAGF,KAAK,CAACE,KAAK,CAACE,OAAO,CAC/B,OAAO,EACP,IAAI,GAAGC,MAAM,CAACnB,MAAM,CAAC,CAACE,MAAM,CAACQ,KAAK,CACpC,CAAC;QACH;MACF;;MAEA;MACA,IAAMU,MAAM,GAAG,EAAE;MACjB;MACA,IAAIC,QAAQ;MAEZb,KAAK,GAAG,CAAC,CAAC;MAEV,OAAO,EAAEA,KAAK,GAAGC,QAAQ,CAACE,MAAM,EAAE;QAChC,IAAMG,MAAK,GAAGL,QAAQ,CAACD,KAAK,CAAC;QAE7B,IAAII,OAAO,CAACE,MAAK,EAAET,IAAI,CAAC,IAAKQ,GAAG,IAAI,CAACL,KAAM,EAAE;UAC3Cc,QAAQ,CAACF,MAAM,EAAEV,KAAK,EAAEI,MAAK,CAAC;UAC9BD,GAAG,GAAG,IAAI;QACZ;QAEAQ,QAAQ,GAAGP,MAAK;QAChBM,MAAM,CAACG,IAAI,CAACT,MAAK,CAAC;MACpB;MAEA,IAAIO,QAAQ,KAAKR,GAAG,IAAID,OAAO,CAACS,QAAQ,EAAEhB,IAAI,CAAC,CAAC,EAAE;QAChD;QACA;QACA,IAAIhB,UAAU,CAACgC,QAAQ,CAAC,EAAE;UACxBD,MAAM,CAACI,GAAG,CAAC,CAAC;UACZH,QAAQ,GAAGD,MAAM,CAACA,MAAM,CAACT,MAAM,GAAG,CAAC,CAAC;QACtC;QAEAW,QAAQ,CAACF,MAAM,EAAEV,KAAK,GAAG,CAAC,CAAC;MAC7B;MAEAJ,IAAI,CAACG,QAAQ,GAAGW,MAAM;IACxB,CAAC,CAAC;EACJ,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASE,QAAQA,CAACG,IAAI,EAAEf,KAAK,EAAEgB,IAAI,EAAE;IACnC,IAAMC,IAAI,GAAGF,IAAI,CAACA,IAAI,CAACd,MAAM,GAAG,CAAC,CAAC;IAClC,IAAMU,QAAQ,GAAGM,IAAI,IAAItC,UAAU,CAACsC,IAAI,CAAC,GAAGF,IAAI,CAACA,IAAI,CAACd,MAAM,GAAG,CAAC,CAAC,GAAGgB,IAAI;IACxE,IAAMT,OAAO,GACX,CAACU,KAAK,CAACP,QAAQ,CAAC,IAAIO,KAAK,CAACF,IAAI,CAAC,GAAG,MAAM,GAAG,IAAI,IAC/CP,MAAM,CAACnB,MAAM,CAAC,CAACE,MAAM,CAAC2B,IAAI,CAACC,GAAG,CAACpB,KAAK,EAAE,CAAC,CAAC,CAAC;IAE3C,IAAIiB,IAAI,IAAIA,IAAI,CAACZ,IAAI,KAAK,MAAM,EAAE;MAChCY,IAAI,CAACX,KAAK,GAAG3B,UAAU,CAACsC,IAAI,CAAC,GAAGT,OAAO,GAAGS,IAAI,CAACX,KAAK,GAAGE,OAAO;IAChE,CAAC,MAAM;MACLO,IAAI,CAACF,IAAI,CAAC;QAACR,IAAI,EAAE,MAAM;QAAEC,KAAK,EAAEE;MAAO,CAAC,CAAC;IAC3C;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,SAASU,KAAKA,CAACtB,IAAI,EAAE;IACnB,OAAOyB,OAAO,CACZzB,IAAI,IACFA,IAAI,CAACS,IAAI,KAAK,SAAS,IACvBhB,QAAQ,CAACiC,MAAM,IACfjC,QAAQ,CAACiC,MAAM,CAACrB,MAAM,GAAG,CAAC,IAC1BZ,QAAQ,CAACiC,MAAM,CAACf,QAAQ,CAACX,IAAI,CAAC2B,OAAO,CACzC,CAAC;EACH;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASrB,OAAOA,CAACN,IAAI,EAAED,IAAI,EAAE;EAC3B,OACEC,IAAI,CAACS,IAAI,KAAK,MAAM,KACnBT,IAAI,CAACS,IAAI,KAAK,SAAS,GACpBV,IAAI,IAAIlB,SAAS,CAACmB,IAAI,EAAE,QAAQ,CAAC,IAAIpB,QAAQ,CAACoB,IAAI,CAAC,IAAI,CAAClB,QAAQ,CAACkB,IAAI,CAAC,GACtE,KAAK,CAAC;AAEd"},"metadata":{},"sourceType":"module","externalDependencies":[]}