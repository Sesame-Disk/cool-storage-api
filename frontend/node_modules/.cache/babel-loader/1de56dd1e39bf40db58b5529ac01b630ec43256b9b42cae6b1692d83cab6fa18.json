{"ast":null,"code":"import _objectSpread from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n/**\n * @typedef {import('katex').KatexOptions} KatexOptions\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n/**\n * @typedef {Omit<KatexOptions, 'displayMode'>} Options\n *   Configuration for HTML output.\n *\n *   > ðŸ‘‰ **Note**: passed to `katex.renderToString`.\n *   > `displayMode` is overwritten by this plugin, to `false` for math in\n *   > text (inline), and `true` for math in flow (block).\n */\n\nimport katex from 'katex';\n\n/** @type {import('katex')['default']['renderToString']} */\n// @ts-expect-error: types are incorrect.\nvar renderToString = katex.renderToString;\n\n/**\n * Create an extension for `micromark` to support math when serializing to\n * HTML.\n *\n * > ðŸ‘‰ **Note**: this uses KaTeX to render math.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {HtmlExtension}\n *   Extension for `micromark` that can be passed in `htmlExtensions`, to\n *   support math when serializing to HTML.\n */\nexport function mathHtml(options) {\n  return {\n    enter: {\n      mathFlow: function mathFlow() {\n        this.lineEndingIfNeeded();\n        this.tag('<div class=\"math math-display\">');\n      },\n      mathFlowFenceMeta: function mathFlowFenceMeta() {\n        this.buffer();\n      },\n      mathText: function mathText() {\n        // Double?\n        this.tag('<span class=\"math math-inline\">');\n        this.buffer();\n      }\n    },\n    exit: {\n      mathFlow: function mathFlow() {\n        var value = this.resume();\n        this.tag(math(value.replace(/(?:\\r?\\n|\\r)$/, ''), true));\n        this.tag('</div>');\n        this.setData('mathFlowOpen');\n        this.setData('slurpOneLineEnding');\n      },\n      mathFlowFence: function mathFlowFence() {\n        // After the first fence.\n        if (!this.getData('mathFlowOpen')) {\n          this.setData('mathFlowOpen', true);\n          this.setData('slurpOneLineEnding', true);\n          this.buffer();\n        }\n      },\n      mathFlowFenceMeta: function mathFlowFenceMeta() {\n        this.resume();\n      },\n      mathFlowValue: function mathFlowValue(token) {\n        this.raw(this.sliceSerialize(token));\n      },\n      mathText: function mathText() {\n        var value = this.resume();\n        this.tag(math(value, false));\n        this.tag('</span>');\n      },\n      mathTextData: function mathTextData(token) {\n        this.raw(this.sliceSerialize(token));\n      }\n    }\n  };\n\n  /**\n   * @param {string} value\n   *   Math text.\n   * @param {boolean} displayMode\n   *   Whether the math is in display mode.\n   * @returns {string}\n   *   HTML.\n   */\n  function math(value, displayMode) {\n    return renderToString(value, _objectSpread(_objectSpread({}, options), {}, {\n      displayMode: displayMode\n    }));\n  }\n}","map":{"version":3,"names":["katex","renderToString","mathHtml","options","enter","mathFlow","lineEndingIfNeeded","tag","mathFlowFenceMeta","buffer","mathText","exit","value","resume","math","replace","setData","mathFlowFence","getData","mathFlowValue","token","raw","sliceSerialize","mathTextData","displayMode","_objectSpread"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/micromark-extension-math/lib/html.js"],"sourcesContent":["/**\n * @typedef {import('katex').KatexOptions} KatexOptions\n * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension\n */\n\n/**\n * @typedef {Omit<KatexOptions, 'displayMode'>} Options\n *   Configuration for HTML output.\n *\n *   > ðŸ‘‰ **Note**: passed to `katex.renderToString`.\n *   > `displayMode` is overwritten by this plugin, to `false` for math in\n *   > text (inline), and `true` for math in flow (block).\n */\n\nimport katex from 'katex'\n\n/** @type {import('katex')['default']['renderToString']} */\n// @ts-expect-error: types are incorrect.\nconst renderToString = katex.renderToString\n\n/**\n * Create an extension for `micromark` to support math when serializing to\n * HTML.\n *\n * > ðŸ‘‰ **Note**: this uses KaTeX to render math.\n *\n * @param {Options | null | undefined} [options={}]\n *   Configuration (default: `{}`).\n * @returns {HtmlExtension}\n *   Extension for `micromark` that can be passed in `htmlExtensions`, to\n *   support math when serializing to HTML.\n */\nexport function mathHtml(options) {\n  return {\n    enter: {\n      mathFlow() {\n        this.lineEndingIfNeeded()\n        this.tag('<div class=\"math math-display\">')\n      },\n      mathFlowFenceMeta() {\n        this.buffer()\n      },\n      mathText() {\n        // Double?\n        this.tag('<span class=\"math math-inline\">')\n        this.buffer()\n      }\n    },\n    exit: {\n      mathFlow() {\n        const value = this.resume()\n        this.tag(math(value.replace(/(?:\\r?\\n|\\r)$/, ''), true))\n        this.tag('</div>')\n        this.setData('mathFlowOpen')\n        this.setData('slurpOneLineEnding')\n      },\n      mathFlowFence() {\n        // After the first fence.\n        if (!this.getData('mathFlowOpen')) {\n          this.setData('mathFlowOpen', true)\n          this.setData('slurpOneLineEnding', true)\n          this.buffer()\n        }\n      },\n      mathFlowFenceMeta() {\n        this.resume()\n      },\n      mathFlowValue(token) {\n        this.raw(this.sliceSerialize(token))\n      },\n      mathText() {\n        const value = this.resume()\n        this.tag(math(value, false))\n        this.tag('</span>')\n      },\n      mathTextData(token) {\n        this.raw(this.sliceSerialize(token))\n      }\n    }\n  }\n\n  /**\n   * @param {string} value\n   *   Math text.\n   * @param {boolean} displayMode\n   *   Whether the math is in display mode.\n   * @returns {string}\n   *   HTML.\n   */\n  function math(value, displayMode) {\n    return renderToString(value, {\n      ...options,\n      displayMode\n    })\n  }\n}\n"],"mappings":";AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,KAAK,MAAM,OAAO;;AAEzB;AACA;AACA,IAAMC,cAAc,GAAGD,KAAK,CAACC,cAAc;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,QAAQA,CAACC,OAAO,EAAE;EAChC,OAAO;IACLC,KAAK,EAAE;MACLC,QAAQ,WAAAA,SAAA,EAAG;QACT,IAAI,CAACC,kBAAkB,CAAC,CAAC;QACzB,IAAI,CAACC,GAAG,CAAC,iCAAiC,CAAC;MAC7C,CAAC;MACDC,iBAAiB,WAAAA,kBAAA,EAAG;QAClB,IAAI,CAACC,MAAM,CAAC,CAAC;MACf,CAAC;MACDC,QAAQ,WAAAA,SAAA,EAAG;QACT;QACA,IAAI,CAACH,GAAG,CAAC,iCAAiC,CAAC;QAC3C,IAAI,CAACE,MAAM,CAAC,CAAC;MACf;IACF,CAAC;IACDE,IAAI,EAAE;MACJN,QAAQ,WAAAA,SAAA,EAAG;QACT,IAAMO,KAAK,GAAG,IAAI,CAACC,MAAM,CAAC,CAAC;QAC3B,IAAI,CAACN,GAAG,CAACO,IAAI,CAACF,KAAK,CAACG,OAAO,CAAC,eAAe,EAAE,EAAE,CAAC,EAAE,IAAI,CAAC,CAAC;QACxD,IAAI,CAACR,GAAG,CAAC,QAAQ,CAAC;QAClB,IAAI,CAACS,OAAO,CAAC,cAAc,CAAC;QAC5B,IAAI,CAACA,OAAO,CAAC,oBAAoB,CAAC;MACpC,CAAC;MACDC,aAAa,WAAAA,cAAA,EAAG;QACd;QACA,IAAI,CAAC,IAAI,CAACC,OAAO,CAAC,cAAc,CAAC,EAAE;UACjC,IAAI,CAACF,OAAO,CAAC,cAAc,EAAE,IAAI,CAAC;UAClC,IAAI,CAACA,OAAO,CAAC,oBAAoB,EAAE,IAAI,CAAC;UACxC,IAAI,CAACP,MAAM,CAAC,CAAC;QACf;MACF,CAAC;MACDD,iBAAiB,WAAAA,kBAAA,EAAG;QAClB,IAAI,CAACK,MAAM,CAAC,CAAC;MACf,CAAC;MACDM,aAAa,WAAAA,cAACC,KAAK,EAAE;QACnB,IAAI,CAACC,GAAG,CAAC,IAAI,CAACC,cAAc,CAACF,KAAK,CAAC,CAAC;MACtC,CAAC;MACDV,QAAQ,WAAAA,SAAA,EAAG;QACT,IAAME,KAAK,GAAG,IAAI,CAACC,MAAM,CAAC,CAAC;QAC3B,IAAI,CAACN,GAAG,CAACO,IAAI,CAACF,KAAK,EAAE,KAAK,CAAC,CAAC;QAC5B,IAAI,CAACL,GAAG,CAAC,SAAS,CAAC;MACrB,CAAC;MACDgB,YAAY,WAAAA,aAACH,KAAK,EAAE;QAClB,IAAI,CAACC,GAAG,CAAC,IAAI,CAACC,cAAc,CAACF,KAAK,CAAC,CAAC;MACtC;IACF;EACF,CAAC;;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASN,IAAIA,CAACF,KAAK,EAAEY,WAAW,EAAE;IAChC,OAAOvB,cAAc,CAACW,KAAK,EAAAa,aAAA,CAAAA,aAAA,KACtBtB,OAAO;MACVqB,WAAW,EAAXA;IAAW,EACZ,CAAC;EACJ;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}