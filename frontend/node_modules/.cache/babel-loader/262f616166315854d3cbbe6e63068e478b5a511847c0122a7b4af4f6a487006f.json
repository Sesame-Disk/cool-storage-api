{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _defineProperty from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport slugid from 'slugid';\nimport { Editor, Range, Transforms, Point, Node } from '@seafile/slate';\nimport { ReactEditor } from '@seafile/slate-react';\nimport deepCopy from 'deep-copy';\nimport { getNodeType, getParentNode, getSelectedNodeByType, isTextNode, getSelectedElems, focusEditor, getNode, findPath, replaceNodeChildren, replaceNode, getSelectedNodeEntryByType, getAboveBlockNode } from '../../core';\nimport { ELEMENT_TYPE, KEYBOARD, CLIPBOARD_FORMAT_KEY, INSERT_POSITION } from '../../constants';\nimport { TABLE_MAX_ROWS, TABLE_MAX_COLUMNS, EMPTY_SELECTED_RANGE, TABLE_ROW_MIN_HEIGHT, TABLE_CELL_MIN_WIDTH, TABLE_ELEMENT, TABLE_ELEMENT_POSITION, TABLE_ROW_STYLE, INHERIT_CELL_STYLE_WHEN_SELECT_MULTIPLE, INHERIT_CELL_STYLE_WHEN_SELECT_SINGLE, TABLE_ALTERNATE_HIGHLIGHT_CLASS_MAP, CELL_SELECTED, DRAG_HANDLER_COLUMN, DRAG_HANDLER_ROW } from './constants';\nimport EventBus from '../../../utils/event-bus';\nimport { INTERNAL_EVENT, PAGE_EDIT_AREA_WIDTH } from '../../../constants';\nimport ObjectUtils from '../../../utils/object-utils';\nimport { replacePastedDataId } from '../../../node-id/helpers';\nexport var isTableMenuDisabled = function isTableMenuDisabled(editor, readonly) {\n  if (readonly) return true;\n  var selection = editor.selection;\n  if (selection === null) return true;\n  if (!Range.isCollapsed(selection)) return true;\n  var _Editor$nodes = Editor.nodes(editor, {\n      match: function match(n) {\n        var type = getNodeType(n);\n        if (!type && isTextNode(n) && n.id) {\n          var parentNode = getParentNode(editor.children, n.id);\n          type = getNodeType(parentNode);\n        }\n        if (type.startsWith('header')) return true;\n        if (type === ELEMENT_TYPE.CODE_BLOCK) return true;\n        if (type === ELEMENT_TYPE.ORDERED_LIST) return true;\n        if (type === ELEMENT_TYPE.UNORDERED_LIST) return true;\n        if (type === ELEMENT_TYPE.BLOCKQUOTE) return true;\n        if (type === ELEMENT_TYPE.LIST_ITEM) return true;\n        if (type === ELEMENT_TYPE.TABLE) return true;\n        if (type === ELEMENT_TYPE.TABLE_CELL) return true;\n        if (type === ELEMENT_TYPE.TABLE_ROW) return true;\n        if (type === ELEMENT_TYPE.CALL_OUT) return true;\n        if (Editor.isVoid(editor, n)) return true;\n        return false;\n      },\n      universal: true\n    }),\n    _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n    match = _Editor$nodes2[0];\n  if (match) return true;\n  return false;\n};\nexport var isCombineCellsDisabled = function isCombineCellsDisabled(editor, readonly) {\n  if (readonly) return true;\n  var selection = editor.selection,\n    tableSelectedRange = editor.tableSelectedRange;\n  if (!selection) return true;\n  if (!ObjectUtils.isSameObject(tableSelectedRange, EMPTY_SELECTED_RANGE)) {\n    return false;\n  }\n  return true;\n};\nexport var generateTableCell = function generateTableCell(editor, rowIndex, cellIndex) {\n  var style = {};\n  var tableNodeEntry = getSelectedNodeEntryByType(editor, ELEMENT_TYPE.TABLE);\n  if (tableNodeEntry && rowIndex !== undefined && cellIndex !== undefined) {\n    var _tableNodeEntry = _slicedToArray(tableNodeEntry, 2),\n      tablePath = _tableNodeEntry[1];\n    style = getCellInheritStyles(editor, tablePath, rowIndex, cellIndex);\n  }\n  return {\n    id: slugid.nice(),\n    type: ELEMENT_TYPE.TABLE_CELL,\n    children: [{\n      text: '',\n      id: slugid.nice()\n    }],\n    style: style,\n    inherit_style: style\n  };\n};\nexport var generateTableRow = function generateTableRow(editor, colsCount, rowIndex) {\n  var children = [];\n  for (var i = 0; i < colsCount; i++) {\n    var tableCell = generateTableCell(editor, rowIndex, i);\n    children.push(tableCell);\n  }\n  return {\n    id: slugid.nice(),\n    type: ELEMENT_TYPE.TABLE_ROW,\n    children: children,\n    style: _defineProperty({}, TABLE_ROW_STYLE.MIN_HEIGHT, TABLE_ROW_MIN_HEIGHT)\n  };\n};\n\n/**\n * @param {Editor} editor\n * @param {Object} tableProps\n * @param {[number,number]} tableProps.size - table size, [row,column]\n * @param {Boolean} tableProps.alternate_highlight - is alternate highlight\n * @param {string} tableProps.alternate_highlight_color - table alternate highlight color\n */\nexport var generateEmptyTable = function generateEmptyTable(editor, tableProps) {\n  var _tableProps$size = tableProps.size,\n    size = _tableProps$size === void 0 ? [0, 0] : _tableProps$size,\n    _tableProps$alternate = tableProps.alternate_highlight,\n    alternate_highlight = _tableProps$alternate === void 0 ? false : _tableProps$alternate,\n    alternate_highlight_color = tableProps.alternate_highlight_color;\n  var rowsCount = size[0];\n  var colsCount = size[1];\n  var children = [];\n  for (var i = 0; i < rowsCount; i++) {\n    var tableRow = generateTableRow(editor, colsCount, i);\n    children.push(tableRow);\n  }\n  var columnWidth = Math.max(TABLE_CELL_MIN_WIDTH, parseInt(editor.width / colsCount));\n  var columns = [];\n  for (var _i = 0; _i < colsCount; _i++) {\n    columns.push({\n      width: columnWidth\n    });\n  }\n  return {\n    id: slugid.nice(),\n    type: ELEMENT_TYPE.TABLE,\n    children: children,\n    columns: columns,\n    ui: {\n      alternate_highlight: alternate_highlight,\n      alternate_highlight_color: alternate_highlight_color\n    },\n    style: {\n      gridTemplateColumns: \"repeat(\".concat(colsCount, \", \").concat(columnWidth, \"px)\"),\n      gridAutoRows: \"minmax(\".concat(TABLE_ROW_MIN_HEIGHT, \"px, auto)\")\n    }\n  };\n};\nexport var insertTable = function insertTable(editor, size, selection) {\n  var position = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : INSERT_POSITION.CURRENT;\n  if (!size) return;\n  if (position !== INSERT_POSITION.AFTER) {\n    if (isTableMenuDisabled(editor)) return;\n  }\n  var tableNode = generateEmptyTable(editor, {\n    size: size\n  });\n  var validSelection = selection || editor.selection;\n  var path = Editor.path(editor, validSelection);\n  handleInsertTable(editor, position, path, tableNode);\n};\n\n// tableSize [tableHeight, tableWidth]\nexport var getSelectedInfo = function getSelectedInfo(editor) {\n  var currentTable = getSelectedNodeByType(editor, ELEMENT_TYPE.TABLE);\n  var currentRow = getSelectedNodeByType(editor, ELEMENT_TYPE.TABLE_ROW);\n  var currentCell = getSelectedNodeByType(editor, ELEMENT_TYPE.TABLE_CELL);\n  var currentCellPath = findPath(editor, currentCell);\n  return {\n    table: currentTable,\n    tablePath: findPath(editor, currentTable),\n    tableSize: [currentTable.children.length, currentRow.children.length],\n    row: currentRow,\n    rowPath: findPath(editor, currentRow),\n    rowIndex: currentCellPath[currentCellPath.length - 2],\n    cell: currentCell,\n    cellPath: findPath(editor, currentCell),\n    cellIndex: currentCellPath[currentCellPath.length - 1]\n  };\n};\nexport var isInTable = function isInTable(editor) {\n  var selectedNodes = getSelectedElems(editor);\n  if (!selectedNodes.some(function (node) {\n    return node.type === ELEMENT_TYPE.TABLE;\n  })) return false;\n  var firstSelectedNode = selectedNodes[0];\n  return firstSelectedNode.type === ELEMENT_TYPE.TABLE;\n};\nexport var isAllInTable = function isAllInTable(editor) {\n  var selectedNodes = getSelectedElems(editor);\n  if (!selectedNodes.some(function (node) {\n    return node.type === ELEMENT_TYPE.TABLE;\n  })) return false;\n  var firstSelectedNode = selectedNodes[0];\n  if (firstSelectedNode.type !== ELEMENT_TYPE.TABLE) return false;\n  return selectedNodes.slice(1).every(function (node) {\n    return [ELEMENT_TYPE.TABLE_ROW, ELEMENT_TYPE.TABLE_CELL].includes(node.type);\n  }); // same table element\n};\n\nexport var setCellStyle = function setCellStyle(editor, style) {\n  // Select single cell\n  if (ObjectUtils.isSameObject(editor.tableSelectedRange, EMPTY_SELECTED_RANGE)) {\n    var selectedNodes = getSelectedElems(editor);\n    var firstTableCellNodePath;\n    selectedNodes.forEach(function (node) {\n      if (node.type === ELEMENT_TYPE.TABLE_CELL) {\n        var path = findPath(editor, node);\n        if (path) {\n          firstTableCellNodePath = firstTableCellNodePath ? firstTableCellNodePath : path;\n          Transforms.setNodes(editor, {\n            style: _objectSpread(_objectSpread({}, node.style), style),\n            inherit_style: generateInheritStyle(INHERIT_CELL_STYLE_WHEN_SELECT_SINGLE, style, node)\n          }, {\n            at: path\n          });\n        }\n      }\n    });\n    if (firstTableCellNodePath) {\n      var start = Editor.start(editor, firstTableCellNodePath);\n      var end = Editor.end(editor, firstTableCellNodePath);\n      var newSelection = {\n        anchor: start,\n        focus: end\n      };\n      Transforms.select(editor, newSelection);\n    }\n    return;\n  }\n  // Select multiple cells\n  var _editor$tableSelected = editor.tableSelectedRange,\n    minColIndex = _editor$tableSelected.minColIndex,\n    maxColIndex = _editor$tableSelected.maxColIndex,\n    minRowIndex = _editor$tableSelected.minRowIndex,\n    maxRowIndex = _editor$tableSelected.maxRowIndex;\n  var _getSelectedInfo = getSelectedInfo(editor),\n    tablePath = _getSelectedInfo.tablePath;\n  for (var i = minRowIndex; i <= maxRowIndex; i++) {\n    for (var j = minColIndex; j <= maxColIndex; j++) {\n      var path = [].concat(_toConsumableArray(tablePath), [i, j]);\n      var node = getNode(editor, path);\n      Transforms.setNodes(editor, {\n        style: _objectSpread(_objectSpread({}, node.style), style),\n        inherit_style: generateInheritStyle(INHERIT_CELL_STYLE_WHEN_SELECT_MULTIPLE, style, node)\n      }, {\n        at: path\n      });\n    }\n  }\n};\nexport var insertTableRow = function insertTableRow(editor, table, rowIndex) {\n  var position = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TABLE_ELEMENT_POSITION.AFTER;\n  var tableRowCount = table.children.length;\n  if (tableRowCount >= TABLE_MAX_ROWS) return;\n  var tableColumnCount = table.children[0].children.length;\n  var row = generateTableRow(editor, tableColumnCount, rowIndex);\n  var tablePath = findPath(editor, table);\n  var targetPath = position === TABLE_ELEMENT_POSITION.AFTER ? [].concat(_toConsumableArray(tablePath), [rowIndex + 1]) : [].concat(_toConsumableArray(tablePath), [rowIndex]);\n  Transforms.insertNodes(editor, row, {\n    at: targetPath\n  });\n  var focusPath = [].concat(_toConsumableArray(targetPath), [0]);\n  focusEditor(editor, focusPath);\n\n  // handle cells with the rowspan > 1\n  if (position === TABLE_ELEMENT_POSITION.AFTER) {\n    handleCombinedCellsAfterInsertTableRow(editor, tablePath, table, rowIndex);\n  }\n};\nexport var handleCombinedCellsAfterInsertTableRow = function handleCombinedCellsAfterInsertTableRow(editor, tablePath, table, rowIndex) {\n  // important background info: the new row is inserted after rowIndex\n  var cells = table.children[rowIndex].children;\n  for (var i = 0, len = cells.length; i < len; i++) {\n    var _cells$i = cells[i],\n      is_combined = _cells$i.is_combined,\n      rowspan = _cells$i.rowspan,\n      colspan = _cells$i.colspan;\n    if (is_combined) {\n      for (var ri = rowIndex - 1; ri >= 0; ri--) {\n        var _table$children$ri$ch = table.children[ri].children[i],\n          ri_is_combined = _table$children$ri$ch.is_combined,\n          ri_rowspan = _table$children$ri$ch.rowspan,\n          ri_colspan = _table$children$ri$ch.colspan;\n        if (!ri_is_combined && ri + ri_rowspan - 1 > rowIndex) {\n          Transforms.setNodes(editor, {\n            rowspan: ri_rowspan + 1\n          }, {\n            at: [].concat(_toConsumableArray(tablePath), [ri, i])\n          });\n          for (var j = 0; j < ri_colspan; j++) {\n            Transforms.setNodes(editor, {\n              'is_combined': true\n            }, {\n              at: [].concat(_toConsumableArray(tablePath), [rowIndex + 1, i + j])\n            });\n          }\n          break;\n        }\n      }\n    } else {\n      if (rowspan > 1) {\n        Transforms.setNodes(editor, {\n          rowspan: rowspan + 1\n        }, {\n          at: [].concat(_toConsumableArray(tablePath), [rowIndex, i])\n        });\n        for (var _j = 0; _j < colspan; _j++) {\n          Transforms.setNodes(editor, {\n            'is_combined': true\n          }, {\n            at: [].concat(_toConsumableArray(tablePath), [rowIndex + 1, i + _j])\n          });\n        }\n      }\n    }\n  }\n};\nexport var insertTableColumn = function insertTableColumn(editor, table, columnIndex) {\n  var position = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TABLE_ELEMENT_POSITION.AFTER;\n  var tableColumnCount = table.children[0].children.length;\n  if (tableColumnCount >= TABLE_MAX_COLUMNS) return;\n  var newCellIndex = position === TABLE_ELEMENT_POSITION.AFTER ? columnIndex + 1 : columnIndex;\n  var newColumns = getTableColumnsAfterInsertColumn(editor, table, newCellIndex, 1);\n  updateColumnWidth(editor, table, newColumns);\n  var tablePath = findPath(editor, table);\n  var tableRowCount = table.children.length;\n  for (var i = 0; i < tableRowCount; i++) {\n    var newCellPath = [].concat(_toConsumableArray(tablePath), [i, newCellIndex]);\n    var newCell = generateTableCell(editor, i, columnIndex);\n    Transforms.insertNodes(editor, newCell, {\n      at: newCellPath\n    });\n  }\n  var focusPath = [].concat(_toConsumableArray(tablePath), [0, newCellIndex, 0]);\n  focusEditor(editor, focusPath);\n\n  // handle cells with the colspan > 1\n  if (position === TABLE_ELEMENT_POSITION.AFTER) {\n    handleCombinedCellsAfterInsertTableColumn(editor, tablePath, table, columnIndex);\n  }\n};\nexport var handleCombinedCellsAfterInsertTableColumn = function handleCombinedCellsAfterInsertTableColumn(editor, tablePath, table, columnIndex) {\n  // important background info: the new column is inserted after columnIndex\n  for (var i = 0, len = table.children.length; i < len; i++) {\n    var _table$children$i$chi = table.children[i].children[columnIndex],\n      is_combined = _table$children$i$chi.is_combined,\n      rowspan = _table$children$i$chi.rowspan,\n      colspan = _table$children$i$chi.colspan;\n    if (is_combined) {\n      for (var ci = columnIndex - 1; ci >= 0; ci--) {\n        var _table$children$i$chi2 = table.children[i].children[ci],\n          ci_is_combined = _table$children$i$chi2.is_combined,\n          ci_rowspan = _table$children$i$chi2.rowspan,\n          ci_colspan = _table$children$i$chi2.colspan;\n        if (!ci_is_combined && ci + ci_colspan - 1 > columnIndex) {\n          Transforms.setNodes(editor, {\n            colspan: ci_colspan + 1\n          }, {\n            at: [].concat(_toConsumableArray(tablePath), [i, ci])\n          });\n          for (var j = 0; j < ci_rowspan; j++) {\n            Transforms.setNodes(editor, {\n              'is_combined': true\n            }, {\n              at: [].concat(_toConsumableArray(tablePath), [i + j, columnIndex + 1])\n            });\n          }\n          break;\n        }\n      }\n    } else {\n      if (colspan > 1) {\n        Transforms.setNodes(editor, {\n          colspan: colspan + 1\n        }, {\n          at: [].concat(_toConsumableArray(tablePath), [i, columnIndex])\n        });\n        for (var _j2 = 0; _j2 < rowspan; _j2++) {\n          Transforms.setNodes(editor, {\n            'is_combined': true\n          }, {\n            at: [].concat(_toConsumableArray(tablePath), [i + _j2, columnIndex + 1])\n          });\n        }\n      }\n    }\n  }\n};\nexport var insertTableElement = function insertTableElement(editor, type) {\n  var position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TABLE_ELEMENT_POSITION.AFTER;\n  var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var _getSelectedInfo2 = getSelectedInfo(editor),\n    table = _getSelectedInfo2.table,\n    tablePath = _getSelectedInfo2.tablePath,\n    tableSize = _getSelectedInfo2.tableSize,\n    rowIndex = _getSelectedInfo2.rowIndex,\n    cellIndex = _getSelectedInfo2.cellIndex;\n  var eventBus = EventBus.getInstance();\n  eventBus.dispatch(INTERNAL_EVENT.CANCEL_TABLE_SELECT_RANGE);\n  if (type === TABLE_ELEMENT.ROW) {\n    if (tableSize[0] >= TABLE_MAX_ROWS) return;\n    var targetPath = position === TABLE_ELEMENT_POSITION.AFTER ? [].concat(_toConsumableArray(tablePath), [rowIndex + 1]) : [].concat(_toConsumableArray(tablePath), [rowIndex]);\n    var validCount = Math.min(TABLE_MAX_ROWS - tableSize[0], count);\n    for (var i = 0; i < validCount; i++) {\n      var row = generateTableRow(editor, tableSize[1], rowIndex);\n      Transforms.insertNodes(editor, row, {\n        at: targetPath\n      });\n      // handle combined cells\n      if (!(rowIndex === 0 && position === TABLE_ELEMENT_POSITION.BEFORE)) {\n        var targetRowIndex = position === TABLE_ELEMENT_POSITION.AFTER ? rowIndex : rowIndex - 1;\n        var currentTable = getSelectedNodeByType(editor, ELEMENT_TYPE.TABLE);\n        handleCombinedCellsAfterInsertTableRow(editor, tablePath, currentTable, targetRowIndex);\n      }\n    }\n    var focusPath = [].concat(_toConsumableArray(targetPath), [cellIndex]);\n    focusEditor(editor, focusPath);\n    return;\n  }\n  if (type === TABLE_ELEMENT.COLUMN) {\n    if (tableSize[1] >= TABLE_MAX_COLUMNS) return;\n    var newCellIndex = position === TABLE_ELEMENT_POSITION.AFTER ? cellIndex + 1 : cellIndex;\n    var _validCount = Math.min(TABLE_MAX_COLUMNS - tableSize[1], count);\n    var newColumns = getTableColumnsAfterInsertColumn(editor, table, newCellIndex, _validCount);\n    updateColumnWidth(editor, table, newColumns);\n    for (var j = 0; j < _validCount; j++) {\n      for (var _i2 = 0; _i2 < tableSize[0]; _i2++) {\n        var newCellPath = [].concat(_toConsumableArray(tablePath), [_i2, newCellIndex]);\n        var newCell = generateTableCell(editor, _i2, cellIndex);\n        Transforms.insertNodes(editor, newCell, {\n          at: newCellPath\n        });\n      }\n      // handle combined cells\n      if (!(cellIndex === 0 && position === TABLE_ELEMENT_POSITION.BEFORE)) {\n        var targetColumnIndex = position === TABLE_ELEMENT_POSITION.AFTER ? cellIndex : cellIndex - 1;\n        var _currentTable = getSelectedNodeByType(editor, ELEMENT_TYPE.TABLE);\n        handleCombinedCellsAfterInsertTableColumn(editor, tablePath, _currentTable, targetColumnIndex);\n      }\n    }\n    var _focusPath = [].concat(_toConsumableArray(tablePath), [rowIndex, cellIndex + 1, 0]);\n    focusEditor(editor, _focusPath);\n    return;\n  }\n};\nexport var combineCells = function combineCells(editor) {\n  var _getSelectedInfo3 = getSelectedInfo(editor),\n    tablePath = _getSelectedInfo3.tablePath;\n  var _editor$tableSelected2 = editor.tableSelectedRange,\n    minColIndex = _editor$tableSelected2.minColIndex,\n    maxColIndex = _editor$tableSelected2.maxColIndex,\n    minRowIndex = _editor$tableSelected2.minRowIndex,\n    maxRowIndex = _editor$tableSelected2.maxRowIndex;\n  var newCellContent = [];\n  for (var i = minRowIndex; i < maxRowIndex + 1; i++) {\n    for (var j = minColIndex; j < maxColIndex + 1; j++) {\n      var nodePath = [].concat(_toConsumableArray(tablePath), [i, j]);\n      var node = Editor.node(editor, nodePath);\n      if (node[0].is_combined) {\n        continue;\n      }\n      Transforms.setNodes(editor, {\n        'is_combined': true\n      }, {\n        at: nodePath\n      });\n      newCellContent = newCellContent.concat(node[0].children);\n    }\n  }\n  var targetCellPath = [].concat(_toConsumableArray(tablePath), [minRowIndex, minColIndex]);\n  var newCell = generateTableCell(editor);\n  newCell.children = newCellContent;\n  newCell.rowspan = maxRowIndex - minRowIndex + 1;\n  newCell.colspan = maxColIndex - minColIndex + 1;\n  // keep row.children.length not changed\n  Transforms.removeNodes(editor, {\n    at: targetCellPath\n  });\n  Transforms.insertNodes(editor, newCell, {\n    at: targetCellPath\n  });\n  focusEditor(editor, targetCellPath);\n\n  // for clicking the 'combine cell' icon in the toolbar\n  var eventBus = EventBus.getInstance();\n  eventBus.dispatch(INTERNAL_EVENT.CANCEL_TABLE_SELECT_RANGE);\n};\nexport var splitCell = function splitCell(editor, rowNumber, columnNumber) {\n  if (rowNumber === 1 && columnNumber === 1) {\n    return;\n  }\n  var _getSelectedInfo4 = getSelectedInfo(editor),\n    cell = _getSelectedInfo4.cell,\n    rowIndex = _getSelectedInfo4.rowIndex,\n    cellIndex = _getSelectedInfo4.cellIndex,\n    cellPath = _getSelectedInfo4.cellPath,\n    tablePath = _getSelectedInfo4.tablePath;\n  var rowspan = cell.rowspan,\n    colspan = cell.colspan;\n  var rowspanBase = Math.floor(rowspan / rowNumber);\n  var rowspanLeft = rowspan % rowNumber;\n  var colspanBase = Math.floor(colspan / columnNumber);\n  var colspanLeft = colspan % columnNumber;\n  var cellNumber = rowNumber * columnNumber;\n  var dataBlockNumber = Math.ceil(cell.children.length / cellNumber);\n  var firstNewCell;\n  var rowspanSum = 0;\n  for (var i = 0; i < rowNumber; i++) {\n    var newRowSpan = rowspanBase + (i + 1 <= rowspanLeft ? 1 : 0);\n    var colspanSum = 0;\n    for (var j = 0; j < columnNumber; j++) {\n      var newCell = generateTableCell(editor);\n      var startIndex = (i * columnNumber + j) * dataBlockNumber;\n      if (startIndex < cell.children.length) {\n        var endIndex = Math.min(startIndex + dataBlockNumber, cell.children.length);\n        newCell.children = cell.children.slice(startIndex, endIndex);\n      }\n      newCell.rowspan = newRowSpan;\n      newCell.colspan = colspanBase + (j + 1 <= colspanLeft ? 1 : 0);\n      var newRowIndex = rowIndex + rowspanSum;\n      var newCellIndex = cellIndex + colspanSum;\n      var targetCellPath = [].concat(_toConsumableArray(tablePath), [newRowIndex, newCellIndex]);\n      if (i === 0 && j === 0) {\n        firstNewCell = newCell;\n      } else {\n        Transforms.removeNodes(editor, {\n          at: targetCellPath\n        });\n        Transforms.insertNodes(editor, newCell, {\n          at: targetCellPath\n        });\n      }\n      colspanSum += newCell.colspan;\n    }\n    rowspanSum += newRowSpan;\n  }\n  Transforms.removeNodes(editor, {\n    at: cellPath\n  });\n  Transforms.insertNodes(editor, firstNewCell, {\n    at: cellPath\n  });\n};\nexport var removeTable = function removeTable(editor, path) {\n  var validPath = path;\n  if (!validPath) {\n    var _getSelectedInfo5 = getSelectedInfo(editor),\n      tablePath = _getSelectedInfo5.tablePath;\n    validPath = tablePath;\n  }\n  editor.reSetTableSelectedRange();\n  Transforms.removeNodes(editor, {\n    at: validPath\n  });\n};\nexport var removeTableElement = function removeTableElement(editor, type) {\n  var _getSelectedInfo6 = getSelectedInfo(editor),\n    table = _getSelectedInfo6.table,\n    tablePath = _getSelectedInfo6.tablePath,\n    tableSize = _getSelectedInfo6.tableSize,\n    rowPath = _getSelectedInfo6.rowPath,\n    rowIndex = _getSelectedInfo6.rowIndex,\n    cellIndex = _getSelectedInfo6.cellIndex;\n  var eventBus = EventBus.getInstance();\n  eventBus.dispatch(INTERNAL_EVENT.CANCEL_TABLE_SELECT_RANGE);\n  if (type === TABLE_ELEMENT.TABLE) {\n    removeTable(editor, tablePath);\n    return;\n  }\n  if (type === TABLE_ELEMENT.ROW) {\n    if (tableSize[0] === 1) {\n      removeTable(editor, tablePath);\n      return;\n    }\n    if (!ObjectUtils.isSameObject(editor.tableSelectedRange, EMPTY_SELECTED_RANGE)) {\n      var _editor$tableSelected3 = editor.tableSelectedRange,\n        minRowIndex = _editor$tableSelected3.minRowIndex,\n        maxRowIndex = _editor$tableSelected3.maxRowIndex;\n      if (minRowIndex === 0 && maxRowIndex === tableSize[0] - 1) {\n        removeTable(editor, tablePath);\n        return;\n      }\n      for (var i = minRowIndex; i <= maxRowIndex; i++) {\n        Transforms.removeNodes(editor, {\n          at: [].concat(_toConsumableArray(tablePath), [minRowIndex])\n        });\n      }\n      var _focusPath2 = [].concat(_toConsumableArray(tablePath), [minRowIndex === 0 ? 0 : minRowIndex - 1, cellIndex]);\n      focusEditor(editor, _focusPath2);\n      return;\n    }\n    handleCombinedCellsBeforeDeleteTableRow(editor, tablePath, table, rowIndex);\n    Transforms.removeNodes(editor, {\n      at: rowPath\n    });\n    var focusRowIndex = rowIndex === tableSize[0] - 1 ? rowIndex - 1 : rowIndex;\n    var focusPath = [].concat(_toConsumableArray(tablePath), [focusRowIndex, cellIndex]);\n    focusEditor(editor, focusPath);\n    return;\n  }\n  if (type === TABLE_ELEMENT.COLUMN) {\n    if (tableSize[1] === 1) {\n      removeTable(editor, tablePath);\n      return;\n    }\n    if (!ObjectUtils.isSameObject(editor.tableSelectedRange, EMPTY_SELECTED_RANGE)) {\n      var _editor$tableSelected4 = editor.tableSelectedRange,\n        minColIndex = _editor$tableSelected4.minColIndex,\n        maxColIndex = _editor$tableSelected4.maxColIndex;\n      if (minColIndex === 0 && maxColIndex === tableSize[1] - 1) {\n        removeTable(editor, tablePath);\n        return;\n      }\n      var _columns = getTableColumns(editor, table);\n      var _newColumns = [].concat(_toConsumableArray(_columns.slice(0, minColIndex)), _toConsumableArray(_columns.slice(maxColIndex + 1)));\n      updateColumnWidth(editor, table, _newColumns);\n      for (var _i3 = 0; _i3 < tableSize[0]; _i3++) {\n        for (var j = minColIndex; j <= maxColIndex; j++) {\n          // count\n          var cellPath = [].concat(_toConsumableArray(tablePath), [_i3, minColIndex]);\n          Transforms.removeNodes(editor, {\n            at: cellPath\n          });\n        }\n      }\n      var _focusPath3 = [].concat(_toConsumableArray(tablePath), [rowIndex, minColIndex === 0 ? 0 : minColIndex - 1]);\n      focusEditor(editor, _focusPath3);\n      return;\n    }\n    var columns = getTableColumns(editor, table);\n    var newColumns = columns.slice(0);\n    newColumns.splice(cellIndex, 1);\n    updateColumnWidth(editor, table, newColumns);\n    handleCombinedCellsBeforeDeleteTableColumn(editor, tablePath, table, cellIndex);\n    for (var _i4 = 0; _i4 < tableSize[0]; _i4++) {\n      var _cellPath = [].concat(_toConsumableArray(tablePath), [_i4, cellIndex]);\n      Transforms.removeNodes(editor, {\n        at: _cellPath\n      });\n    }\n    var focusCellIndex = cellIndex === tableSize[1] - 1 ? cellIndex - 1 : cellIndex;\n    var _focusPath4 = [].concat(_toConsumableArray(tablePath), [rowIndex, focusCellIndex]);\n    focusEditor(editor, _focusPath4);\n    return;\n  }\n};\n\n// handle combined cells before deleting a row\nexport var handleCombinedCellsBeforeDeleteTableRow = function handleCombinedCellsBeforeDeleteTableRow(editor, tablePath, table, rowIndex) {\n  var cells = table.children[rowIndex].children;\n  for (var i = 0, len = cells.length; i < len; i++) {\n    var _cells$i2 = cells[i],\n      is_combined = _cells$i2.is_combined,\n      rowspan = _cells$i2.rowspan,\n      colspan = _cells$i2.colspan;\n    if (is_combined) {\n      for (var ri = rowIndex - 1; ri >= 0; ri--) {\n        var _table$children$ri$ch2 = table.children[ri].children[i],\n          ri_is_combined = _table$children$ri$ch2.is_combined,\n          ri_rowspan = _table$children$ri$ch2.rowspan;\n        if (!ri_is_combined && ri + ri_rowspan - 1 >= rowIndex) {\n          Transforms.setNodes(editor, {\n            rowspan: ri_rowspan - 1\n          }, {\n            at: [].concat(_toConsumableArray(tablePath), [ri, i])\n          });\n          break;\n        }\n      }\n    } else {\n      if (rowspan > 1) {\n        var targetCellPath = [].concat(_toConsumableArray(tablePath), [rowIndex + 1, i]);\n        var newCell = generateTableCell(editor);\n        newCell.rowspan = rowspan - 1;\n        newCell.colspan = colspan;\n        Transforms.removeNodes(editor, {\n          at: targetCellPath\n        });\n        Transforms.insertNodes(editor, newCell, {\n          at: targetCellPath\n        });\n      }\n    }\n  }\n};\n\n// handle combined cells before deleting a column\nexport var handleCombinedCellsBeforeDeleteTableColumn = function handleCombinedCellsBeforeDeleteTableColumn(editor, tablePath, table, columnIndex) {\n  for (var i = 0, len = table.children.length; i < len; i++) {\n    var _table$children$i$chi3 = table.children[i].children[columnIndex],\n      is_combined = _table$children$i$chi3.is_combined,\n      rowspan = _table$children$i$chi3.rowspan,\n      colspan = _table$children$i$chi3.colspan;\n    if (is_combined) {\n      for (var ci = columnIndex - 1; ci >= 0; ci--) {\n        var _table$children$i$chi4 = table.children[i].children[ci],\n          ci_is_combined = _table$children$i$chi4.is_combined,\n          ci_colspan = _table$children$i$chi4.colspan;\n        if (!ci_is_combined && ci + ci_colspan - 1 >= columnIndex) {\n          Transforms.setNodes(editor, {\n            colspan: ci_colspan - 1\n          }, {\n            at: [].concat(_toConsumableArray(tablePath), [i, ci])\n          });\n          break;\n        }\n      }\n    } else {\n      if (colspan > 1) {\n        var targetCellPath = [].concat(_toConsumableArray(tablePath), [i, columnIndex + 1]);\n        var newCell = generateTableCell(editor);\n        newCell.rowspan = rowspan;\n        newCell.colspan = colspan - 1;\n        Transforms.removeNodes(editor, {\n          at: targetCellPath\n        });\n        Transforms.insertNodes(editor, newCell, {\n          at: targetCellPath\n        });\n      }\n    }\n  }\n};\nexport var setTableSelectedRange = function setTableSelectedRange(editor, range) {\n  if (range) {\n    editor.tableSelectedRange = range;\n    return;\n  }\n  editor.tableSelectedRange = EMPTY_SELECTED_RANGE;\n};\nexport var updateTableRowHeight = function updateTableRowHeight(editor, element, rowHeight) {\n  var path = findPath(editor, element);\n  var targetNode = getNode(editor, path);\n  var _targetNode$style = targetNode.style,\n    style = _targetNode$style === void 0 ? {} : _targetNode$style;\n  if (style[TABLE_ROW_STYLE.MIN_HEIGHT] === rowHeight) return;\n  Transforms.setNodes(editor, {\n    style: _objectSpread(_objectSpread({}, style), {}, _defineProperty({}, TABLE_ROW_STYLE.MIN_HEIGHT, rowHeight))\n  }, {\n    at: path\n  });\n};\nexport var updateColumnWidth = function updateColumnWidth(editor, element, columns) {\n  var path = findPath(editor, element);\n  Transforms.setNodes(editor, {\n    columns: columns\n  }, {\n    at: path\n  });\n};\nexport var getTableColumnsWidth = function getTableColumnsWidth() {\n  var columns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  if (!Array.isArray(columns) || columns.length === 0) return 0;\n  return columns.reduce(function (pre, cur) {\n    return pre + cur.width;\n  }, 0);\n};\nexport var getTableColumnsAfterInsertColumn = function getTableColumnsAfterInsertColumn(editor, element, targetColumnIndex, insertColumnCount) {\n  var columns = getTableColumns(editor, element);\n  var newColumns = columns.slice(0);\n  var totalColumnsWidth = getTableColumnsWidth(columns);\n  var targetColumn = columns[targetColumnIndex] || columns[targetColumnIndex - 1];\n  var targetInsertColumnsWidth = targetColumn.width * insertColumnCount;\n\n  // Currently in scrolling state, insert directly\n  if (totalColumnsWidth > editor.width) {\n    for (var i = 0; i < insertColumnCount; i++) {\n      newColumns.splice(targetColumnIndex, 0, targetColumn);\n    }\n    return newColumns;\n  }\n\n  // Not currently scrolling\n  // It is not a scroll state after inserting a new column\n  if (totalColumnsWidth + targetInsertColumnsWidth < editor.width) {\n    for (var _i5 = 0; _i5 < insertColumnCount; _i5++) {\n      newColumns.push(targetColumn);\n    }\n    return newColumns;\n  }\n\n  // After inserting a new column is a scrolling state\n  for (var _i6 = 0; _i6 < insertColumnCount; _i6++) {\n    totalColumnsWidth += targetColumn.width;\n    newColumns.splice(targetColumnIndex, 0, targetColumn);\n  }\n  var proportion = totalColumnsWidth / (editor.width - 1);\n  return newColumns.map(function (column) {\n    return _objectSpread(_objectSpread({}, column), {}, {\n      width: Math.max(parseInt(column.width / proportion), TABLE_CELL_MIN_WIDTH)\n    });\n  });\n};\nexport var getTableColumns = function getTableColumns(editor, element) {\n  if (!element) return [];\n  var tableElement = element;\n  if (element.type === ELEMENT_TYPE.TABLE_CELL) {\n    var cellPath = findPath(editor, element);\n    var tablePath = cellPath.slice(0, -2);\n    tableElement = getNode(editor, tablePath);\n  }\n  var _tableElement = tableElement,\n    columns = _tableElement.columns,\n    children = _tableElement.children;\n  if (columns) return columns;\n  var columnsCount = children[0].children.length;\n  var initColumns = [];\n  var pageEditAreaWidth = editor.width || PAGE_EDIT_AREA_WIDTH;\n  for (var i = 0; i < columnsCount; i++) {\n    var column = {\n      width: Math.max(TABLE_CELL_MIN_WIDTH, parseInt(pageEditAreaWidth / columnsCount))\n    };\n    initColumns.push(column);\n  }\n  return initColumns;\n};\nexport var getCellColumn = function getCellColumn(editor, cellElement) {\n  var column = {\n    width: TABLE_CELL_MIN_WIDTH\n  };\n  if (!editor || !cellElement) return column;\n  var cellPath = findPath(editor, cellElement);\n  if (!cellPath) return column;\n  var pathLength = cellPath.length;\n  var cellIndex = cellPath[pathLength - 1];\n  var tablePath = cellPath.slice(0, -2);\n  var tableElement = getNode(editor, tablePath);\n  var columns = tableElement.columns;\n  var columnsCount = tableElement.children[0].children.length;\n  var pageEditAreaWidth = editor.width || PAGE_EDIT_AREA_WIDTH;\n  if (columns) {\n    column = columns[cellIndex];\n  }\n  return column || {\n    width: Math.max(TABLE_CELL_MIN_WIDTH, parseInt(pageEditAreaWidth / columnsCount))\n  };\n};\nexport var getFirstTableCell = function getFirstTableCell(element) {\n  var tableCellElement = element;\n  while (tableCellElement && !(tableCellElement.hasAttribute('row-index') && tableCellElement.hasAttribute('cell-index'))) {\n    tableCellElement = tableCellElement.parentNode;\n  }\n  return tableCellElement;\n};\nexport var elementHasImage = function elementHasImage(element) {\n  if (!element) return false;\n  if (!Array.isArray(element.children) || element.children.length === 0) return false;\n  return element.children.some(function (child) {\n    if (child.type === ELEMENT_TYPE.IMAGE) return true;\n    if (ObjectUtils.hasProperty(child, 'children')) {\n      return elementHasImage(child);\n    }\n    return false;\n  });\n};\nexport var isSelectedAllCell = function isSelectedAllCell(editor) {\n  var _getSelectedInfo7 = getSelectedInfo(editor),\n    tableSize = _getSelectedInfo7.tableSize;\n  return ObjectUtils.isSameObject(editor.tableSelectedRange, {\n    minColIndex: 0,\n    maxColIndex: tableSize[1] - 1,\n    minRowIndex: 0,\n    maxRowIndex: tableSize[0] - 1\n  });\n};\nexport var insertMultipleRowsAndColumns = function insertMultipleRowsAndColumns(editor, rows, columns) {\n  var _getSelectedInfo8 = getSelectedInfo(editor),\n    table = _getSelectedInfo8.table,\n    tablePath = _getSelectedInfo8.tablePath,\n    tableSize = _getSelectedInfo8.tableSize,\n    rowIndex = _getSelectedInfo8.rowIndex,\n    cellIndex = _getSelectedInfo8.cellIndex;\n  var newTable = deepCopy(table);\n  var eventBus = EventBus.getInstance();\n  eventBus.dispatch(INTERNAL_EVENT.CANCEL_TABLE_SELECT_RANGE);\n  var insertRows = rows.slice(tableSize[0] - rowIndex);\n  var insertColumns = columns.slice(tableSize[1] - cellIndex);\n  var validInsertRows = insertRows.slice(0, Math.min(TABLE_MAX_ROWS - tableSize[0], insertRows.length));\n  var validInsertColumns = insertColumns.slice(0, Math.min(TABLE_MAX_COLUMNS - tableSize[1], columns.length));\n  for (var i = 0; i < validInsertRows.length; i++) {\n    var insertRow = validInsertRows[i];\n    var row = generateTableRow(editor, tableSize[1], rowIndex);\n    row.style = insertRow.style;\n    newTable.children.push(row);\n  }\n  if (validInsertColumns.length > 0) {\n    newTable.columns = [].concat(_toConsumableArray(table.columns), _toConsumableArray(validInsertColumns));\n  }\n  for (var j = 0; j < validInsertColumns.length; j++) {\n    for (var _i7 = 0; _i7 < tableSize[0] + validInsertRows.length; _i7++) {\n      var newCell = generateTableCell(editor);\n      newTable.children[_i7].children.push(newCell);\n    }\n  }\n  for (var _i8 = rowIndex; _i8 < Math.min(TABLE_MAX_ROWS, rowIndex + rows.length); _i8++) {\n    var _row = rows[_i8 - rowIndex];\n    var cells = _row.children;\n    for (var _j3 = cellIndex; _j3 < Math.min(TABLE_MAX_COLUMNS, cellIndex + columns.length); _j3++) {\n      var replaceCellIndex = _j3 - cellIndex;\n      var replaceCell = cells[replaceCellIndex];\n      newTable.children[_i8].children[_j3].children = replacePastedDataId(replaceCell.children);\n    }\n  }\n  replaceNode(editor, {\n    at: tablePath,\n    nodes: newTable\n  });\n  focusEditor(editor, [].concat(_toConsumableArray(tablePath), [rowIndex, cellIndex, 0]));\n  var newFocus = editor.selection.focus;\n  Transforms.select(editor, {\n    focus: newFocus,\n    anchor: newFocus\n  });\n  return;\n};\nexport var setTableFragmentData = function setTableFragmentData(editor, dataTransfer) {\n  var selectedNode = getSelectedNodeByType(editor, ELEMENT_TYPE.TABLE);\n  var fragment = editor.getFragment();\n  var string = JSON.stringify(fragment);\n  var encoded = window.btoa(encodeURIComponent(string));\n  dataTransfer.setData(\"application/\".concat(CLIPBOARD_FORMAT_KEY), encoded);\n  var tableDom = document.createElement('table');\n  var _editor$tableSelected5 = editor.tableSelectedRange,\n    minColIndex = _editor$tableSelected5.minColIndex,\n    maxColIndex = _editor$tableSelected5.maxColIndex,\n    minRowIndex = _editor$tableSelected5.minRowIndex,\n    maxRowIndex = _editor$tableSelected5.maxRowIndex;\n  var tablePath = findPath(editor, selectedNode);\n  for (var i = minRowIndex; i <= maxRowIndex; i++) {\n    var tr = document.createElement('tr');\n    for (var j = minColIndex; j <= maxColIndex; j++) {\n      var path = [].concat(_toConsumableArray(tablePath), [i, j]);\n      var node = getNode(editor, path);\n      var td = document.createElement('td');\n      var _div = document.createElement('div');\n      _div.innerHTML = ReactEditor.toDOMNode(editor, node).innerHTML;\n      td.appendChild(_div);\n      tr.appendChild(td);\n    }\n    tableDom.appendChild(tr);\n  }\n  tableDom.setAttribute('data-slate-fragment', encoded);\n  var div = document.createElement('div');\n  div.appendChild(tableDom);\n  dataTransfer.setData('text/html', div.innerHTML);\n  dataTransfer.setData('text/plain', div.innerText);\n  return dataTransfer;\n};\nexport var deleteTableRangeData = function deleteTableRangeData(editor) {\n  var tableSelectedRange = editor.tableSelectedRange;\n  var minRowIndex = tableSelectedRange.minRowIndex,\n    maxRowIndex = tableSelectedRange.maxRowIndex,\n    minColIndex = tableSelectedRange.minColIndex,\n    maxColIndex = tableSelectedRange.maxColIndex;\n  var _getSelectedInfo9 = getSelectedInfo(editor),\n    tablePath = _getSelectedInfo9.tablePath;\n  var forceCellPath;\n  for (var i = minRowIndex; i <= maxRowIndex; i++) {\n    for (var j = minColIndex; j <= maxColIndex; j++) {\n      var path = [].concat(_toConsumableArray(tablePath), [i, j]);\n      var node = getNode(editor, path);\n      if (!forceCellPath && (Node.string(node) || elementHasImage(node))) {\n        forceCellPath = path;\n      }\n      var firstNode = node.children[0];\n      replaceNodeChildren(editor, {\n        at: path,\n        nodes: _objectSpread(_objectSpread({}, firstNode), {}, {\n          text: ''\n        })\n      });\n    }\n  }\n  if (forceCellPath) {\n    editor.tableSelectedRange = EMPTY_SELECTED_RANGE;\n    var eventBus = EventBus.getInstance();\n    eventBus.dispatch(INTERNAL_EVENT.CANCEL_TABLE_SELECT_RANGE);\n    focusEditor(editor, forceCellPath);\n    var newFocus = editor.selection.focus;\n    Transforms.select(editor, {\n      focus: newFocus,\n      anchor: newFocus\n    });\n  }\n};\nexport var deleteHandler = function deleteHandler(editor) {\n  var selection = editor.selection,\n    tableSelectedRange = editor.tableSelectedRange;\n  if (selection == null) return '';\n  if (!ObjectUtils.isSameObject(tableSelectedRange, EMPTY_SELECTED_RANGE)) {\n    if (isSelectedAllCell(editor)) return 'table';\n    return 'range';\n  }\n  var _Editor$nodes3 = Editor.nodes(editor, {\n      match: function match(n) {\n        var type = getNodeType(n);\n        if (!type && isTextNode(n) && n.id) {\n          var parentNode = getParentNode(editor.children, n.id);\n          type = getNodeType(parentNode);\n        }\n        return type === ELEMENT_TYPE.TABLE_CELL;\n      }\n    }),\n    _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1),\n    cellNodeEntry = _Editor$nodes4[0];\n  if (cellNodeEntry) {\n    var _cellNodeEntry = _slicedToArray(cellNodeEntry, 2),\n      cellPath = _cellNodeEntry[1];\n    var start = Editor.start(editor, cellPath);\n    if (Point.equals(selection.anchor, start)) {\n      return 'default';\n    }\n  }\n  return '';\n};\nexport var isTableLocation = function isTableLocation(editor, location) {\n  var tables = Editor.nodes(editor, {\n    at: location,\n    match: function match(n) {\n      var type = getNodeType(n);\n      if (!type && isTextNode(n) && n.id) {\n        var parentNode = getParentNode(editor.children, n.id);\n        type = getNodeType(parentNode);\n      }\n      return type === ELEMENT_TYPE.TABLE_CELL;\n    }\n  });\n  var hasTable = false;\n  // eslint-disable-next-line no-unused-vars\n  var _iterator = _createForOfIteratorHelper(tables),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var table = _step.value;\n      hasTable = true;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return hasTable;\n};\nexport var isCursorAtCellEnd = function isCursorAtCellEnd(cell) {\n  var cursor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (!cell) return false;\n  var childrenCount = cell.children.length;\n  var lastChildren = cell.children[childrenCount - 1];\n  var textCount = lastChildren.text.length;\n  return cursor === textCount;\n};\nexport var isCursorAtCellStart = function isCursorAtCellStart() {\n  var cursor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return cursor === 0;\n};\nexport var focusCell = function focusCell(editor, event) {\n  var keyboardName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  var _getSelectedInfo10 = getSelectedInfo(editor),\n    tableSize = _getSelectedInfo10.tableSize,\n    tablePath = _getSelectedInfo10.tablePath,\n    rowIndex = _getSelectedInfo10.rowIndex,\n    cellIndex = _getSelectedInfo10.cellIndex,\n    cell = _getSelectedInfo10.cell;\n  var tableParentPath = tablePath.slice(0, -1);\n  var tableIndex = tablePath[tablePath.length - 1];\n  var selection = editor.selection;\n  var focus = selection.focus;\n  if (keyboardName === KEYBOARD.UP) {\n    if (!isCursorAtCellStart(focus.offset)) {\n      setTimeout(function () {\n        if (getSelectedNodeByType(editor, ELEMENT_TYPE.TABLE)) {\n          var _getSelectedInfo11 = getSelectedInfo(editor),\n            newCellIndex = _getSelectedInfo11.cellIndex;\n          if (Math.abs(newCellIndex - cellIndex) !== 0) {\n            if (rowIndex === 0) {\n              if (tableIndex !== 0) {\n                focusEditor(editor, [].concat(_toConsumableArray(tableParentPath), [tableIndex - 1]));\n              }\n              return;\n            }\n            focusEditor(editor, [].concat(_toConsumableArray(tableParentPath), [tableIndex, rowIndex - 1, cellIndex]));\n            var _newFocus = editor.selection.focus;\n            Transforms.select(editor, {\n              focus: _newFocus,\n              anchor: _newFocus\n            });\n          }\n        }\n      }, 10);\n      return;\n    }\n    event.preventDefault();\n    if (rowIndex === 0) {\n      if (tableIndex !== 0) {\n        focusEditor(editor, [].concat(_toConsumableArray(tableParentPath), [tableIndex - 1]));\n      }\n      return;\n    }\n    focusEditor(editor, [].concat(_toConsumableArray(tableParentPath), [tableIndex, rowIndex - 1, cellIndex]));\n    var newFocus = editor.selection.focus;\n    Transforms.select(editor, {\n      focus: newFocus,\n      anchor: newFocus\n    });\n  }\n  if (keyboardName === KEYBOARD.RIGHT) {\n    if (!isCursorAtCellEnd(cell, focus.offset)) return;\n    event.preventDefault();\n    if (rowIndex === tableSize[0] - 1 && cellIndex === tableSize[1] - 1) {\n      focusEditor(editor, [].concat(_toConsumableArray(tableParentPath), [tableIndex + 1]));\n      return;\n    }\n    if (cellIndex === tableSize[1] - 1) {\n      focusEditor(editor, [].concat(_toConsumableArray(tableParentPath), [tableIndex, rowIndex + 1, 0]));\n    } else {\n      focusEditor(editor, [].concat(_toConsumableArray(tableParentPath), [tableIndex, rowIndex, cellIndex + 1]));\n    }\n    var newAnchor = editor.selection.anchor;\n    Transforms.select(editor, {\n      focus: newAnchor,\n      anchor: newAnchor\n    });\n  }\n  if (keyboardName === KEYBOARD.DOWN) {\n    if (!isCursorAtCellEnd(cell, focus.offset)) {\n      setTimeout(function () {\n        if (getSelectedNodeByType(editor, ELEMENT_TYPE.TABLE)) {\n          var _getSelectedInfo12 = getSelectedInfo(editor),\n            newCellIndex = _getSelectedInfo12.cellIndex;\n          if (Math.abs(newCellIndex - cellIndex) !== 0) {\n            if (rowIndex === tableSize[0] - 1) {\n              var nextNode = getNode(editor, [].concat(_toConsumableArray(tableParentPath), [tableIndex + 1]));\n              if (!nextNode) return;\n              focusEditor(editor, [].concat(_toConsumableArray(tableParentPath), [tableIndex + 1]));\n              return;\n            }\n            focusEditor(editor, [].concat(_toConsumableArray(tableParentPath), [tableIndex, rowIndex + 1, cellIndex]));\n            var _newAnchor = editor.selection.anchor;\n            Transforms.select(editor, {\n              focus: _newAnchor,\n              anchor: _newAnchor\n            });\n          }\n        }\n      }, 10);\n      return;\n    }\n    event.preventDefault();\n    if (rowIndex === tableSize[0] - 1) {\n      var nextNode = getNode([].concat(_toConsumableArray(tableParentPath), [tableIndex + 1]));\n      if (!nextNode) return;\n      focusEditor(editor, [].concat(_toConsumableArray(tableParentPath), [tableIndex + 1]));\n      return;\n    }\n    focusEditor(editor, [].concat(_toConsumableArray(tableParentPath), [tableIndex, rowIndex + 1, cellIndex]));\n    var _newAnchor2 = editor.selection.anchor;\n    Transforms.select(editor, {\n      focus: _newAnchor2,\n      anchor: _newAnchor2\n    });\n  }\n  if (keyboardName === KEYBOARD.LEFT) {\n    if (!isCursorAtCellStart(focus.offset)) return;\n    event.preventDefault();\n    if (rowIndex === 0 && cellIndex === 0) {\n      if (tableIndex !== 0) {\n        focusEditor(editor, [].concat(_toConsumableArray(tableParentPath), [tableIndex - 1]));\n      }\n      return;\n    }\n    if (cellIndex === 0) {\n      focusEditor(editor, [].concat(_toConsumableArray(tableParentPath), [tableIndex, rowIndex - 1, tableSize[1] - 1]));\n    } else {\n      focusEditor(editor, [].concat(_toConsumableArray(tableParentPath), [tableIndex, rowIndex, cellIndex - 1]));\n    }\n    var _newFocus2 = editor.selection.focus;\n    Transforms.select(editor, {\n      focus: _newFocus2,\n      anchor: _newFocus2\n    });\n  }\n};\nexport var isLastTableCell = function isLastTableCell(editor, cellNode) {\n  if (cellNode[0].type !== ELEMENT_TYPE.TABLE_CELL) return false;\n  var _getSelectedInfo13 = getSelectedInfo(editor),\n    tableSize = _getSelectedInfo13.tableSize;\n  var lastRowIndex = tableSize[0] - 1;\n  var lastColumnIndex = tableSize[1] - 1;\n  var cellNodePath = cellNode[1];\n  var cellNodePathDeep = cellNodePath.length;\n  return cellNodePath[cellNodePathDeep - 1] === lastColumnIndex && cellNodePath[cellNodePathDeep - 2] === lastRowIndex;\n};\nvar getValidColor = function getValidColor(color) {\n  if (!color) return '';\n  var validColor = color.length === 4 ? '#' + color.slice(1, 4).repeat(2) : color;\n  return validColor.toUpperCase();\n};\nexport var colorBlend = function colorBlend(c1, c2, ratio) {\n  var color1 = getValidColor(c1);\n  var color2 = getValidColor(c2);\n  if (!color1 && !color2) return 'unset';\n  if (color1 && !color2) return color1;\n  if (!color1 && color2) return color2;\n  if (color1 === '#FFFFFF') return color2;\n  if (color2 === '#FFFFFF') return color1;\n  var validRatio = Math.max(Math.min(Number(ratio), 1), 0);\n  var r1 = parseInt(color1.substring(1, 3), 16);\n  var g1 = parseInt(color1.substring(3, 5), 16);\n  var b1 = parseInt(color1.substring(5, 7), 16);\n  var r2 = parseInt(color2.substring(1, 3), 16);\n  var g2 = parseInt(color2.substring(3, 5), 16);\n  var b2 = parseInt(color2.substring(5, 7), 16);\n  var r = Math.round(r1 * (1 - validRatio) + r2 * validRatio);\n  var g = Math.round(g1 * (1 - validRatio) + g2 * validRatio);\n  var b = Math.round(b1 * (1 - validRatio) + b2 * validRatio);\n  r = ('0' + (r || 0).toString(16)).slice(-2);\n  g = ('0' + (g || 0).toString(16)).slice(-2);\n  b = ('0' + (b || 0).toString(16)).slice(-2);\n  return '#' + r + g + b;\n};\nexport var getRowHeight = function getRowHeight(element, rowIndex) {\n  var _element$style = element.style,\n    style = _element$style === void 0 ? {} : _element$style;\n  var rowHeight = style[TABLE_ROW_STYLE.MIN_HEIGHT] || TABLE_ROW_MIN_HEIGHT;\n  return rowIndex === 0 ? rowHeight + 1 : rowHeight;\n};\nexport var getRowDomHeight = function getRowDomHeight(editor, row) {\n  var height = 0;\n  var _iterator2 = _createForOfIteratorHelper(row.children),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var cell = _step2.value;\n      var is_combined = cell.is_combined,\n        _cell$rowspan = cell.rowspan,\n        rowspan = _cell$rowspan === void 0 ? 1 : _cell$rowspan;\n      if (is_combined || rowspan > 1) continue;\n      var cellDom = null;\n      try {\n        cellDom = ReactEditor.toDOMNode(editor, cell);\n      } catch (error) {\n        if (!cellDom) break;\n      }\n      height = cellDom.getBoundingClientRect().height;\n      break;\n    }\n    // if the row is empty, get the height from style\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  if (!height) {\n    height = row.style[TABLE_ROW_STYLE.MIN_HEIGHT] || TABLE_ROW_MIN_HEIGHT;\n  }\n  return height;\n};\nvar normalizeTableCell = function normalizeTableCell(editor, cell) {\n  if (!cell) return generateTableCell(editor);\n  var newCell = _objectSpread({\n    children: [{\n      text: '',\n      id: slugid.nice()\n    }]\n  }, cell);\n\n  // normalize cell children\n  var newCellChildren = [];\n  newCell.children.forEach(function (cellChild) {\n    var cellChildType = cellChild.type;\n    if (cellChildType === ELEMENT_TYPE.PARAGRAPH) {\n      newCellChildren.push.apply(newCellChildren, _toConsumableArray(cellChild.children));\n    } else {\n      newCellChildren.push(cellChild);\n    }\n  });\n  newCell.children = newCellChildren.map(function (item) {\n    if (item.BOLD) {\n      item.bold = item.BOLD;\n      delete item['BOLD'];\n    }\n    if (item.ITALIC) {\n      item.italic = item.ITALIC;\n      delete item['ITALIC'];\n    }\n    return item;\n  });\n\n  // normalize cell style\n  if (newCell.data) {\n    var cellStyle = _objectSpread({}, newCell.data);\n    delete newCell['data'];\n    Object.keys(cellStyle).forEach(function (cellStyleKey) {\n      if (cellStyleKey === 'align') {\n        cellStyle['text_align'] = cellStyle['align'];\n        delete cellStyle['align'];\n      }\n    });\n    newCell.style = cellStyle;\n  }\n  return newCell;\n};\nexport var normalizeTableELement = function normalizeTableELement(editor, element) {\n  if (element.type !== ELEMENT_TYPE.TABLE) {\n    var size = [element.children.length, element.children[0].children.length];\n    return generateEmptyTable(editor, {\n      size: size\n    });\n  }\n  var newElement = _objectSpread({}, element);\n  for (var i = 0; i < element.children.length; i++) {\n    var row = newElement.children[i];\n    for (var j = 0; j < row.children.length; j++) {\n      row.children[j] = normalizeTableCell(editor, row.children[j]);\n    }\n    newElement.children[i] = row;\n  }\n  return newElement;\n};\nexport var insertTableByTemplate = function insertTableByTemplate(editor, alternateColor) {\n  var size = [4, 4];\n  var tableNode = generateEmptyTable(editor, {\n    size: size,\n    alternate_highlight_color: alternateColor,\n    alternate_highlight: true\n  });\n  var path = Editor.path(editor, editor.selection);\n  var insertPosition = getInsertPosition(editor);\n  handleInsertTable(editor, insertPosition, path, tableNode);\n};\n\n/**\n * @param {Editor} editor\n * @param {InsertPosition} insertPosition\n * @param {Path} path\n * @param {Node} tableNode\n * Insert table by insertPosition\n */\nexport var handleInsertTable = function handleInsertTable(editor, insertPosition, path, tableNode) {\n  var selection = editor.selection;\n  if (insertPosition === INSERT_POSITION.BEFORE) {\n    var insertPath = [path[0]];\n    Transforms.insertNodes(editor, tableNode, {\n      at: insertPath\n    });\n  } else if (insertPosition === INSERT_POSITION.AFTER) {\n    var _insertPath = [path[0] + 1];\n    Transforms.insertNodes(editor, tableNode, {\n      at: _insertPath\n    });\n  } else if (insertPosition === INSERT_POSITION.CURRENT) {\n    Transforms.splitNodes(editor, {\n      at: selection,\n      always: true\n    });\n    Transforms.insertNodes(editor, tableNode, {\n      at: selection.anchor\n    });\n  }\n};\nexport var getInsertPosition = function getInsertPosition(editor) {\n  var selection = editor.selection;\n  if (!selection) return INSERT_POSITION.CURRENT;\n  if (!Range.isCollapsed(selection)) return INSERT_POSITION.CURRENT;\n  var aboveNodeEntry = getAboveBlockNode(editor);\n  if (!aboveNodeEntry) return INSERT_POSITION.CURRENT;\n  var isAtStart = Editor.isStart(editor, selection.anchor, aboveNodeEntry[1]);\n  if (isAtStart) return INSERT_POSITION.BEFORE;\n  var isAtEnd = Editor.isEnd(editor, selection.anchor, aboveNodeEntry[1]);\n  if (isAtEnd) return INSERT_POSITION.AFTER;\n  return INSERT_POSITION.CURRENT;\n};\nexport var generateInheritStyle = function generateInheritStyle(allowedInheritStyleList, style, cell) {\n  var inheritStyle = _objectSpread({}, cell['inherit_style']) || {};\n  for (var key in style) {\n    if (Object.hasOwnProperty.call(style, key) && allowedInheritStyleList.includes(key)) {\n      inheritStyle[key] = style[key];\n    }\n  }\n  return inheritStyle;\n};\nexport var getCellInheritStyles = function getCellInheritStyles(editor, tablePath, rowIndex, colIndex) {\n  var _table$children$rowIn, _tableCell$inherit_st;\n  var _Editor$nodes5 = Editor.nodes(editor, {\n      match: function match(n) {\n        return n.type === ELEMENT_TYPE.TABLE;\n      },\n      at: tablePath\n    }),\n    _Editor$nodes6 = _slicedToArray(_Editor$nodes5, 1),\n    tableNodeEntry = _Editor$nodes6[0];\n  if (!tableNodeEntry) return {};\n  var table = tableNodeEntry[0];\n  var tableCell = (_table$children$rowIn = table.children[rowIndex]) === null || _table$children$rowIn === void 0 ? void 0 : _table$children$rowIn.children[colIndex];\n  if (!tableCell) return {};\n  return (_tableCell$inherit_st = tableCell['inherit_style']) !== null && _tableCell$inherit_st !== void 0 ? _tableCell$inherit_st : {};\n};\nexport var getCellHighlightClassName = function getCellHighlightClassName(primaryColorClassName, rowIndex) {\n  var className = '';\n  if (rowIndex === 0) {\n    className = primaryColorClassName;\n  } else if (rowIndex % 2 === 0) {\n    className = TABLE_ALTERNATE_HIGHLIGHT_CLASS_MAP[primaryColorClassName];\n  }\n  return className;\n};\nexport var focusClosestCellWhenJustifyCellSize = function focusClosestCellWhenJustifyCellSize(editor, adjustingCell) {\n  var cellPath = ReactEditor.findPath(editor, adjustingCell);\n  focusEditor(editor, Editor.end(editor, cellPath));\n};\n\n// Search main cell of combined cell\nvar searchCombinedMainCell = function searchCombinedMainCell(table, startRowIndex, startColIndex) {\n  for (var rowIndex = startRowIndex; rowIndex >= 0; rowIndex--) {\n    var row = table.children[rowIndex];\n    for (var cellIndex = startColIndex; cellIndex >= 0; cellIndex--) {\n      var currentCell = row.children[cellIndex];\n      var _currentCell$colspan = currentCell.colspan,\n        colspan = _currentCell$colspan === void 0 ? 0 : _currentCell$colspan,\n        _currentCell$rowspan = currentCell.rowspan,\n        rowspan = _currentCell$rowspan === void 0 ? 0 : _currentCell$rowspan;\n      if (colspan <= 1 && rowspan <= 1) continue;\n      var isInColRange = cellIndex + colspan >= startColIndex;\n      var isInRowRange = rowIndex + rowspan >= startRowIndex;\n      if (isInColRange && isInRowRange) {\n        return {\n          currentCell: currentCell,\n          rowIndex: rowIndex,\n          cellIndex: cellIndex\n        };\n      } else break;\n    }\n  }\n};\nexport var getResizeMaskCellInfo = function getResizeMaskCellInfo(editor, table, rowIndex, cellIndex) {\n  // The cell shown cursor as resize (mouse is on this cell)\n  var focusCellIndex = cellIndex;\n  var focusCell = table.children[rowIndex].children[cellIndex];\n  // The cell dominating resize handlers (the true cell to be resized)\n  var cell = table.children[rowIndex].children[cellIndex];\n  // Resolve combined cell\n  if (cell.is_combined) {\n    var targetCellInfo = searchCombinedMainCell(table, rowIndex, cellIndex);\n    cellIndex = targetCellInfo.cellIndex;\n    rowIndex = targetCellInfo.rowIndex;\n    cell = targetCellInfo.currentCell;\n  }\n  var columns = table.columns;\n  var focussedCell = ReactEditor.toDOMNode(editor, cell);\n  var colspan = focusCell.colspan,\n    rowspan = focusCell.rowspan;\n  var width = columns[cellIndex].width;\n  var height = focussedCell.getBoundingClientRect().height;\n  // Calculate cell width and height\n  if (colspan > 1) {\n    var index = cellIndex + 1;\n    while (index < cellIndex + colspan) {\n      width += columns[index].width;\n      index++;\n    }\n  }\n  if (rowspan > 1) {\n    var _index = rowIndex + 1;\n    while (_index < rowIndex + rowspan) {\n      var currentCell = table.children[_index].children[cellIndex];\n      var currentHeight = ReactEditor.toDOMNode(editor, currentCell).getBoundingClientRect().height;\n      height += currentHeight;\n      _index++;\n    }\n  }\n  return {\n    width: width,\n    height: height,\n    top: focussedCell.offsetTop,\n    left: focussedCell.offsetLeft,\n    rowIndex: rowIndex,\n    cellIndex: cellIndex,\n    cell: cell,\n    focusCellIndex: focusCellIndex\n  };\n};\n\n// Table alternate highlight\nexport var getHighlightClass = function getHighlightClass(editor, cellPath) {\n  var _tableEntry$;\n  var _Editor$nodes7 = Editor.nodes(editor, {\n      at: cellPath,\n      match: function match(n) {\n        return n.type === ELEMENT_TYPE.TABLE;\n      }\n    }),\n    _Editor$nodes8 = _slicedToArray(_Editor$nodes7, 1),\n    tableEntry = _Editor$nodes8[0];\n  var _ref = ((_tableEntry$ = tableEntry[0]) === null || _tableEntry$ === void 0 ? void 0 : _tableEntry$.ui) || {},\n    alternate_highlight = _ref.alternate_highlight,\n    alternate_highlight_color = _ref.alternate_highlight_color;\n  if (!alternate_highlight) return '';\n  var rowIndex = cellPath[cellPath.length - 2];\n  var className = getCellHighlightClassName(alternate_highlight_color, rowIndex);\n  return className;\n};\n\n// Correct the selected range when combined cell are selected\nexport var adjustCombinedCellRange = function adjustCombinedCellRange(table, range) {\n  var minRowIndex = range.minRowIndex,\n    maxRowIndex = range.maxRowIndex,\n    minColIndex = range.minColIndex,\n    maxColIndex = range.maxColIndex;\n  var firstCell = table.children[minRowIndex].children[minColIndex];\n  var _firstCell$colspan = firstCell.colspan,\n    colspan = _firstCell$colspan === void 0 ? 0 : _firstCell$colspan,\n    _firstCell$rowspan = firstCell.rowspan,\n    rowspan = _firstCell$rowspan === void 0 ? 0 : _firstCell$rowspan;\n  if (rowspan > 1 || colspan > 1) {\n    var isRowCombined = minRowIndex + rowspan === maxRowIndex + 1;\n    var isColCombined = minColIndex + colspan === maxColIndex + 1;\n    if (isRowCombined && isColCombined) return EMPTY_SELECTED_RANGE;\n  }\n  return range;\n};\n\n/**\n *  Do not reset table selected range, when drag table column / row\n * @param {MouseEvent} event\n * @returns {Boolean}\n */\nexport var isPreventResetTableSelectedRange = function isPreventResetTableSelectedRange(event) {\n  var target = event.target;\n  var draggable = target.getAttribute('draggable');\n  var isColumnHeader = target.classList.contains('sdoc-table-column-header');\n  var isRowHeader = target.classList.contains('sdoc-table-row-header');\n  var isHeader = isColumnHeader || isRowHeader;\n  var isPreventReset = isHeader || draggable === 'true';\n  return isPreventReset;\n};\n\n/**\n * Check drag type, column or row\n */\nexport var getTableDragType = function getTableDragType(table, selectedRange) {\n  var rowCount = table.children.length;\n  var minRowIndex = selectedRange.minRowIndex,\n    maxRowIndex = selectedRange.maxRowIndex;\n  var isSelectColumn = minRowIndex === 0 && maxRowIndex === rowCount - 1;\n  return isSelectColumn ? DRAG_HANDLER_COLUMN : DRAG_HANDLER_ROW;\n};\nvar updateTableColumns = function updateTableColumns(editor, table, targetColIndex, startColIndex, endColIndex) {\n  var columns = _toConsumableArray(table.columns);\n  var deleteCount = endColIndex - startColIndex + 1;\n  var newColumns = columns.splice(startColIndex, deleteCount);\n  columns.splice.apply(columns, [targetColIndex, 0].concat(_toConsumableArray(newColumns)));\n  updateColumnWidth(editor, table, columns);\n};\nexport var moveColumns = function moveColumns(editor, targetColIndex, startColIndex, endColIndex) {\n  // Get selected table information\n  var _getSelectedInfo14 = getSelectedInfo(editor),\n    table = _getSelectedInfo14.table,\n    tablePath = _getSelectedInfo14.tablePath;\n  // Check if moving columns forward or backward\n  var isMoveToFroward = targetColIndex < startColIndex;\n\n  // Iterate over each row in the table\n  table.children.forEach(function (row, rowIndex) {\n    if (isMoveToFroward) {\n      // Calculate target and source paths for moving columns forward\n      var targetPath = [].concat(_toConsumableArray(tablePath), [rowIndex, targetColIndex]);\n      var sourcePath = [].concat(_toConsumableArray(tablePath), [rowIndex, endColIndex]);\n\n      // Move columns forward by inserting nodes\n      for (var insertIndex = endColIndex; insertIndex >= startColIndex; insertIndex--) {\n        var insertNode = row.children[insertIndex];\n        Transforms.removeNodes(editor, {\n          at: sourcePath\n        });\n        Transforms.insertNodes(editor, insertNode, {\n          at: targetPath\n        });\n      }\n    } else {\n      // Calculate target and source paths for moving columns backward\n      var _targetPath = [].concat(_toConsumableArray(tablePath), [rowIndex, targetColIndex - 1]);\n      var _sourcePath = [].concat(_toConsumableArray(tablePath), [rowIndex, startColIndex]);\n\n      // Move columns backward by inserting nodes\n      for (var _insertIndex = startColIndex; _insertIndex <= endColIndex; _insertIndex++) {\n        var _insertNode = row.children[_insertIndex];\n        Transforms.removeNodes(editor, {\n          at: _sourcePath\n        });\n        Transforms.insertNodes(editor, _insertNode, {\n          at: _targetPath\n        });\n      }\n    }\n  });\n\n  // Update table columns after moving\n  updateTableColumns(editor, table, targetColIndex, startColIndex, endColIndex);\n\n  // Set new selected range after moving columns\n  var newSelectRange = {\n    minRowIndex: 0,\n    maxRowIndex: table.children.length - 1,\n    minColIndex: targetColIndex,\n    maxColIndex: targetColIndex + endColIndex - startColIndex\n  };\n  setTableSelectedRange(editor, newSelectRange);\n};\n\n/**\n * Calculate the new selected range after dragging a column or row in the table.\n * @param {Object} table - The table object containing columns and rows.\n * @param {string} moveType - The type of drag operation (DRAG_HANDLER_COLUMN for column, DRAG_HANDLER_ROW for row).\n * @param {number} targetIndex - The index of the target column or row after dragging.\n * @param {number} startIndex - The index of the starting column or row before dragging.\n * @param {number} endIndex - The index of the ending column or row before dragging.\n * @returns {Object} - The new selected range after the drag operation.\n */\nexport var getTableSelectedRangeAfterDrag = function getTableSelectedRangeAfterDrag(table, moveType, targetIndex, startIndex, endIndex) {\n  // Calculate the total number of columns and rows in the table\n  var colCount = table.columns.length;\n  var rowCount = table.children.length;\n\n  // Initialize the new selected range with full table range\n  var newSelectRange = {\n    minRowIndex: 0,\n    maxRowIndex: rowCount - 1,\n    minColIndex: 0,\n    maxColIndex: colCount - 1\n  };\n\n  // Determine if the drag movement is forward or backward\n  var isMoveToFroward = targetIndex < startIndex;\n\n  // Adjust selected range based on the type of drag operation\n  if (moveType === DRAG_HANDLER_COLUMN) {\n    if (isMoveToFroward) {\n      newSelectRange.minColIndex = targetIndex;\n      newSelectRange.maxColIndex = targetIndex + endIndex - startIndex;\n    } else {\n      var moveCount = endIndex - startIndex + 1;\n      newSelectRange.minColIndex = targetIndex - moveCount;\n      newSelectRange.maxColIndex = targetIndex - 1;\n    }\n  } else {\n    if (isMoveToFroward) {\n      newSelectRange.minRowIndex = targetIndex;\n      newSelectRange.maxRowIndex = targetIndex + endIndex - startIndex;\n    } else {\n      var _moveCount = endIndex - startIndex + 1;\n      newSelectRange.minRowIndex = targetIndex - _moveCount;\n      newSelectRange.maxRowIndex = targetIndex - 1;\n    }\n  }\n  return newSelectRange;\n};\nexport var moveRows = function moveRows(editor, targetRowIndex, startRowIndex, endRowIndex) {\n  var _getSelectedInfo15 = getSelectedInfo(editor),\n    table = _getSelectedInfo15.table,\n    tablePath = _getSelectedInfo15.tablePath;\n  var isMoveToFroward = targetRowIndex < startRowIndex;\n  var targetPath = [].concat(_toConsumableArray(tablePath), [isMoveToFroward ? targetRowIndex : targetRowIndex - 1]);\n  var sourcePath = [].concat(_toConsumableArray(tablePath), [isMoveToFroward ? endRowIndex : startRowIndex]);\n  if (isMoveToFroward) {\n    for (var insertIndex = endRowIndex; insertIndex >= startRowIndex; insertIndex--) {\n      var insertNode = table.children[insertIndex];\n      Transforms.removeNodes(editor, {\n        at: sourcePath\n      });\n      Transforms.insertNodes(editor, insertNode, {\n        at: targetPath\n      });\n    }\n  } else {\n    for (var _insertIndex2 = startRowIndex; _insertIndex2 <= endRowIndex; _insertIndex2++) {\n      var _insertNode2 = table.children[_insertIndex2];\n      Transforms.removeNodes(editor, {\n        at: sourcePath\n      });\n      Transforms.insertNodes(editor, _insertNode2, {\n        at: targetPath\n      });\n    }\n  }\n  var newSelectRange = {\n    minRowIndex: targetRowIndex,\n    maxRowIndex: targetRowIndex + endRowIndex - startRowIndex,\n    minColIndex: 0,\n    maxColIndex: table.children.length - 1\n  };\n  setTableSelectedRange(editor, newSelectRange);\n};\nexport var generateDragMoveElement = function generateDragMoveElement(tipText) {\n  var canvasId = 'sdoc-drag-image';\n  var canvas = document.getElementById(canvasId);\n  if (!canvas) {\n    var dpr = window.devicePixelRatio;\n    canvas = document.createElement('canvas');\n    canvas.width = 115;\n    canvas.height = 30;\n    canvas.id = canvasId;\n    document.body.appendChild(canvas);\n    var _canvas$getBoundingCl = canvas.getBoundingClientRect(),\n      cssWidth = _canvas$getBoundingCl.width,\n      cssHeight = _canvas$getBoundingCl.height;\n    canvas.style.width = canvas.width + 'px';\n    canvas.style.height = canvas.height + 'px';\n    canvas.width = dpr * cssWidth;\n    canvas.height = dpr * cssHeight;\n    canvas.style.position = 'fixed';\n  }\n  canvas.style.display = 'block';\n  var context = canvas.getContext('2d');\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  context.fillStyle = 'rgb(241,243,246)';\n  context.fillRect(0, 0, canvas.width, canvas.height);\n  context.font = '22px Arial';\n  context.textBaseline = 'middle';\n  context.textAlign = 'center';\n  context.fillStyle = 'black';\n  context.fillText(tipText, canvas.width / 2, canvas.height / 2);\n  return canvas;\n};\nexport var isHideDragHandlerLine = function isHideDragHandlerLine(editor, displayType, table, cellPath, isDragOverCellHalf) {\n  var pathLength = cellPath.length;\n  var rowIndex = cellPath[pathLength - 2];\n  var cellIndex = cellPath[pathLength - 1];\n\n  // Check is above cell selected\n  var currentCellDom = ReactEditor.toDOMNode(editor, table.children[rowIndex].children[cellIndex]);\n  var isCurrentCellSelected = currentCellDom.classList.contains(CELL_SELECTED);\n  if (isCurrentCellSelected) return true;\n  if (isDragOverCellHalf) {\n    if (displayType === DRAG_HANDLER_COLUMN) {\n      cellIndex = cellIndex + 1;\n    } else {\n      rowIndex = rowIndex + 1;\n    }\n  }\n  var isEndOfRowOrColumn = displayType === DRAG_HANDLER_COLUMN && cellIndex === table.columns.length || displayType === DRAG_HANDLER_ROW && rowIndex === table.children.length;\n  if (isEndOfRowOrColumn) return false;\n  var preCellDom = null;\n  if (displayType === DRAG_HANDLER_COLUMN && cellIndex > 0) {\n    var prevCell = table.children[rowIndex].children[cellIndex - 1];\n    preCellDom = ReactEditor.toDOMNode(editor, prevCell);\n  } else if (displayType === DRAG_HANDLER_ROW && rowIndex > 0) {\n    var _prevCell = table.children[rowIndex - 1].children[cellIndex];\n    preCellDom = ReactEditor.toDOMNode(editor, _prevCell);\n  }\n\n  // Check is above cell selected\n  currentCellDom = ReactEditor.toDOMNode(editor, table.children[rowIndex].children[cellIndex]);\n  isCurrentCellSelected = currentCellDom.classList.contains(CELL_SELECTED);\n  if (isCurrentCellSelected) return true;\n\n  // Check if the previous cell is selected\n  var isPrevCellSelected = preCellDom && preCellDom.classList.contains(CELL_SELECTED);\n  if (isPrevCellSelected) return true;\n  var isCombined = false;\n  // Check if the combined cell\n  if (displayType === DRAG_HANDLER_COLUMN) {\n    isCombined = table.children.some(function (row) {\n      return row.children[cellIndex - isDragOverCellHalf].is_combined;\n    });\n  } else {\n    isCombined = table.children[rowIndex - isDragOverCellHalf].children.some(function (cell) {\n      return cell.is_combined;\n    });\n  }\n  if (isCombined) return true;\n\n  // Check is the last column\n  if (displayType === DRAG_HANDLER_COLUMN) {\n    var isLastColumn = cellIndex === table.columns.length - 1;\n    if (isLastColumn) return false;\n  }\n};\nexport var getTableRowSelectedRange = function getTableRowSelectedRange(table, rowIndex) {\n  var row = table.children[rowIndex];\n  var columnCount = row.children.length;\n  var minRowIndex = rowIndex;\n  var maxRowIndex = rowIndex;\n  var minColIndex = 0;\n  var maxColIndex = columnCount - 1;\n  var findRowRange = function findRowRange(findRowIndex) {\n    var checkRow = table.children[findRowIndex];\n    var combinedIndexes = checkRow.children.reduce(function (acc, cell, index) {\n      if (cell.is_combined) acc.push(index);\n      if (cell.rowspan > 1) {\n        maxRowIndex = Math.max(maxRowIndex, findRowIndex + cell.rowspan - 1);\n        findRowRange(maxRowIndex);\n      }\n      return acc;\n    }, []);\n    combinedIndexes.some(function (combinedIndex) {\n      var _searchCombinedMainCe = searchCombinedMainCell(table, findRowIndex, combinedIndex),\n        mainCellRowIndex = _searchCombinedMainCe.rowIndex,\n        currentCell = _searchCombinedMainCe.currentCell;\n      if (minRowIndex > mainCellRowIndex) {\n        minRowIndex = mainCellRowIndex;\n        findRowRange(minRowIndex, 0);\n        return false;\n      } else if (maxRowIndex < mainCellRowIndex + currentCell.rowspan - 1) {\n        maxRowIndex = mainCellRowIndex + currentCell.rowspan - 1;\n        findRowRange(maxRowIndex, 0);\n        return false;\n      }\n      return false;\n    });\n  };\n  findRowRange(rowIndex);\n  return {\n    minRowIndex: minRowIndex,\n    maxRowIndex: maxRowIndex,\n    minColIndex: minColIndex,\n    maxColIndex: maxColIndex\n  };\n};\nexport var getTableColumnSelectedRange = function getTableColumnSelectedRange(table, columnIndex) {\n  var minRowIndex = 0;\n  var maxRowIndex = table.children.length - 1;\n  var minColIndex = columnIndex;\n  var maxColIndex = columnIndex;\n  var findColRange = function findColRange(findColIndex) {\n    var combinedIndexes = [];\n    table.children.forEach(function (row, rowIndex) {\n      var cell = row.children[findColIndex];\n      if (cell.is_combined) combinedIndexes.push(rowIndex);\n      if (cell.colspan > 1) {\n        maxColIndex = Math.max(maxColIndex, findColIndex + cell.colspan - 1);\n        findColRange(maxColIndex);\n      }\n    });\n    combinedIndexes.some(function (combinedIndex) {\n      var _searchCombinedMainCe2 = searchCombinedMainCell(table, combinedIndex, findColIndex),\n        mainCellColIndex = _searchCombinedMainCe2.cellIndex,\n        currentCell = _searchCombinedMainCe2.currentCell;\n      if (minColIndex > mainCellColIndex) {\n        minColIndex = mainCellColIndex;\n        findColRange(minColIndex, 0);\n        return false;\n      } else if (maxColIndex < mainCellColIndex + currentCell.colspan - 1) {\n        maxColIndex = mainCellColIndex + currentCell.colspan - 1;\n        findColRange(maxColIndex, 0);\n        return false;\n      }\n      return false;\n    });\n  };\n  findColRange(columnIndex);\n  return {\n    minRowIndex: minRowIndex,\n    maxRowIndex: maxRowIndex,\n    minColIndex: minColIndex,\n    maxColIndex: maxColIndex\n  };\n};\nexport var isTableWidthFitScreen = function isTableWidthFitScreen(editor) {\n  var _getSelectedInfo16 = getSelectedInfo(editor),\n    table = _getSelectedInfo16.table;\n  var tableNode = ReactEditor.toDOMNode(editor, table);\n  if (!tableNode) return;\n  var tableDom = tableNode.querySelector('.sdoc-table-scroll-wrapper');\n  var _tableDom$getBounding = tableDom.getBoundingClientRect(),\n    tableWidth = _tableDom$getBounding.width;\n  var sdocWidth = editor.width;\n  if (tableWidth >= sdocWidth) return true;\n  return false;\n};\nexport var fitTableColumnToScreen = function fitTableColumnToScreen(editor) {\n  var _getSelectedInfo17 = getSelectedInfo(editor),\n    table = _getSelectedInfo17.table,\n    tablePath = _getSelectedInfo17.tablePath;\n  var colCount = table.columns.length;\n  var columnWidth = Math.max(TABLE_CELL_MIN_WIDTH, parseInt(editor.width / colCount));\n  var columns = table.columns.map(function (column) {\n    return _objectSpread(_objectSpread({}, column), {}, {\n      width: columnWidth\n    });\n  });\n  Transforms.setNodes(editor, {\n    columns: columns\n  }, {\n    at: tablePath\n  });\n};","map":{"version":3,"names":["_objectSpread","slugid","Editor","Range","Transforms","Point","Node","ReactEditor","deepCopy","getNodeType","getParentNode","getSelectedNodeByType","isTextNode","getSelectedElems","focusEditor","getNode","findPath","replaceNodeChildren","replaceNode","getSelectedNodeEntryByType","getAboveBlockNode","ELEMENT_TYPE","KEYBOARD","CLIPBOARD_FORMAT_KEY","INSERT_POSITION","TABLE_MAX_ROWS","TABLE_MAX_COLUMNS","EMPTY_SELECTED_RANGE","TABLE_ROW_MIN_HEIGHT","TABLE_CELL_MIN_WIDTH","TABLE_ELEMENT","TABLE_ELEMENT_POSITION","TABLE_ROW_STYLE","INHERIT_CELL_STYLE_WHEN_SELECT_MULTIPLE","INHERIT_CELL_STYLE_WHEN_SELECT_SINGLE","TABLE_ALTERNATE_HIGHLIGHT_CLASS_MAP","CELL_SELECTED","DRAG_HANDLER_COLUMN","DRAG_HANDLER_ROW","EventBus","INTERNAL_EVENT","PAGE_EDIT_AREA_WIDTH","ObjectUtils","replacePastedDataId","isTableMenuDisabled","editor","readonly","selection","isCollapsed","_Editor$nodes","nodes","match","n","type","id","parentNode","children","startsWith","CODE_BLOCK","ORDERED_LIST","UNORDERED_LIST","BLOCKQUOTE","LIST_ITEM","TABLE","TABLE_CELL","TABLE_ROW","CALL_OUT","isVoid","universal","_Editor$nodes2","_slicedToArray","isCombineCellsDisabled","tableSelectedRange","isSameObject","generateTableCell","rowIndex","cellIndex","style","tableNodeEntry","undefined","_tableNodeEntry","tablePath","getCellInheritStyles","nice","text","inherit_style","generateTableRow","colsCount","i","tableCell","push","_defineProperty","MIN_HEIGHT","generateEmptyTable","tableProps","_tableProps$size","size","_tableProps$alternate","alternate_highlight","alternate_highlight_color","rowsCount","tableRow","columnWidth","Math","max","parseInt","width","columns","ui","gridTemplateColumns","concat","gridAutoRows","insertTable","position","arguments","length","CURRENT","AFTER","tableNode","validSelection","path","handleInsertTable","getSelectedInfo","currentTable","currentRow","currentCell","currentCellPath","table","tableSize","row","rowPath","cell","cellPath","isInTable","selectedNodes","some","node","firstSelectedNode","isAllInTable","slice","every","includes","setCellStyle","firstTableCellNodePath","forEach","setNodes","generateInheritStyle","at","start","end","newSelection","anchor","focus","select","_editor$tableSelected","minColIndex","maxColIndex","minRowIndex","maxRowIndex","_getSelectedInfo","j","_toConsumableArray","insertTableRow","tableRowCount","tableColumnCount","targetPath","insertNodes","focusPath","handleCombinedCellsAfterInsertTableRow","cells","len","_cells$i","is_combined","rowspan","colspan","ri","_table$children$ri$ch","ri_is_combined","ri_rowspan","ri_colspan","insertTableColumn","columnIndex","newCellIndex","newColumns","getTableColumnsAfterInsertColumn","updateColumnWidth","newCellPath","newCell","handleCombinedCellsAfterInsertTableColumn","_table$children$i$chi","ci","_table$children$i$chi2","ci_is_combined","ci_rowspan","ci_colspan","insertTableElement","count","_getSelectedInfo2","eventBus","getInstance","dispatch","CANCEL_TABLE_SELECT_RANGE","ROW","validCount","min","BEFORE","targetRowIndex","COLUMN","targetColumnIndex","combineCells","_getSelectedInfo3","_editor$tableSelected2","newCellContent","nodePath","targetCellPath","removeNodes","splitCell","rowNumber","columnNumber","_getSelectedInfo4","rowspanBase","floor","rowspanLeft","colspanBase","colspanLeft","cellNumber","dataBlockNumber","ceil","firstNewCell","rowspanSum","newRowSpan","colspanSum","startIndex","endIndex","newRowIndex","removeTable","validPath","_getSelectedInfo5","reSetTableSelectedRange","removeTableElement","_getSelectedInfo6","_editor$tableSelected3","handleCombinedCellsBeforeDeleteTableRow","focusRowIndex","_editor$tableSelected4","getTableColumns","splice","handleCombinedCellsBeforeDeleteTableColumn","focusCellIndex","_cells$i2","_table$children$ri$ch2","_table$children$i$chi3","_table$children$i$chi4","setTableSelectedRange","range","updateTableRowHeight","element","rowHeight","targetNode","_targetNode$style","getTableColumnsWidth","Array","isArray","reduce","pre","cur","insertColumnCount","totalColumnsWidth","targetColumn","targetInsertColumnsWidth","proportion","map","column","tableElement","_tableElement","columnsCount","initColumns","pageEditAreaWidth","getCellColumn","cellElement","pathLength","getFirstTableCell","tableCellElement","hasAttribute","elementHasImage","child","IMAGE","hasProperty","isSelectedAllCell","_getSelectedInfo7","insertMultipleRowsAndColumns","rows","_getSelectedInfo8","newTable","insertRows","insertColumns","validInsertRows","validInsertColumns","insertRow","replaceCellIndex","replaceCell","newFocus","setTableFragmentData","dataTransfer","selectedNode","fragment","getFragment","string","JSON","stringify","encoded","window","btoa","encodeURIComponent","setData","tableDom","document","createElement","_editor$tableSelected5","tr","td","div","innerHTML","toDOMNode","appendChild","setAttribute","innerText","deleteTableRangeData","_getSelectedInfo9","forceCellPath","firstNode","deleteHandler","_Editor$nodes3","_Editor$nodes4","cellNodeEntry","_cellNodeEntry","equals","isTableLocation","location","tables","hasTable","_iterator","_createForOfIteratorHelper","_step","s","done","value","err","e","f","isCursorAtCellEnd","cursor","childrenCount","lastChildren","textCount","isCursorAtCellStart","focusCell","event","keyboardName","_getSelectedInfo10","tableParentPath","tableIndex","UP","offset","setTimeout","_getSelectedInfo11","abs","preventDefault","RIGHT","newAnchor","DOWN","_getSelectedInfo12","nextNode","LEFT","isLastTableCell","cellNode","_getSelectedInfo13","lastRowIndex","lastColumnIndex","cellNodePath","cellNodePathDeep","getValidColor","color","validColor","repeat","toUpperCase","colorBlend","c1","c2","ratio","color1","color2","validRatio","Number","r1","substring","g1","b1","r2","g2","b2","r","round","g","b","toString","getRowHeight","_element$style","getRowDomHeight","height","_iterator2","_step2","_cell$rowspan","cellDom","error","getBoundingClientRect","normalizeTableCell","newCellChildren","cellChild","cellChildType","PARAGRAPH","apply","item","BOLD","bold","ITALIC","italic","data","cellStyle","Object","keys","cellStyleKey","normalizeTableELement","newElement","insertTableByTemplate","alternateColor","insertPosition","getInsertPosition","insertPath","splitNodes","always","aboveNodeEntry","isAtStart","isStart","isAtEnd","isEnd","allowedInheritStyleList","inheritStyle","key","hasOwnProperty","call","colIndex","_table$children$rowIn","_tableCell$inherit_st","_Editor$nodes5","_Editor$nodes6","getCellHighlightClassName","primaryColorClassName","className","focusClosestCellWhenJustifyCellSize","adjustingCell","searchCombinedMainCell","startRowIndex","startColIndex","_currentCell$colspan","_currentCell$rowspan","isInColRange","isInRowRange","getResizeMaskCellInfo","targetCellInfo","focussedCell","index","currentHeight","top","offsetTop","left","offsetLeft","getHighlightClass","_tableEntry$","_Editor$nodes7","_Editor$nodes8","tableEntry","_ref","adjustCombinedCellRange","firstCell","_firstCell$colspan","_firstCell$rowspan","isRowCombined","isColCombined","isPreventResetTableSelectedRange","target","draggable","getAttribute","isColumnHeader","classList","contains","isRowHeader","isHeader","isPreventReset","getTableDragType","selectedRange","rowCount","isSelectColumn","updateTableColumns","targetColIndex","endColIndex","deleteCount","moveColumns","_getSelectedInfo14","isMoveToFroward","sourcePath","insertIndex","insertNode","newSelectRange","getTableSelectedRangeAfterDrag","moveType","targetIndex","colCount","moveCount","moveRows","endRowIndex","_getSelectedInfo15","generateDragMoveElement","tipText","canvasId","canvas","getElementById","dpr","devicePixelRatio","body","_canvas$getBoundingCl","cssWidth","cssHeight","display","context","getContext","clearRect","fillStyle","fillRect","font","textBaseline","textAlign","fillText","isHideDragHandlerLine","displayType","isDragOverCellHalf","currentCellDom","isCurrentCellSelected","isEndOfRowOrColumn","preCellDom","prevCell","isPrevCellSelected","isCombined","isLastColumn","getTableRowSelectedRange","columnCount","findRowRange","findRowIndex","checkRow","combinedIndexes","acc","combinedIndex","_searchCombinedMainCe","mainCellRowIndex","getTableColumnSelectedRange","findColRange","findColIndex","_searchCombinedMainCe2","mainCellColIndex","isTableWidthFitScreen","_getSelectedInfo16","querySelector","_tableDom$getBounding","tableWidth","sdocWidth","fitTableColumnToScreen","_getSelectedInfo17"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/plugins/table/helpers.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport slugid from 'slugid';\nimport { Editor, Range, Transforms, Point, Node } from '@seafile/slate';\nimport { ReactEditor } from '@seafile/slate-react';\nimport deepCopy from 'deep-copy';\nimport { getNodeType, getParentNode, getSelectedNodeByType, isTextNode, getSelectedElems, focusEditor, getNode, findPath, replaceNodeChildren, replaceNode, getSelectedNodeEntryByType, getAboveBlockNode } from '../../core';\nimport { ELEMENT_TYPE, KEYBOARD, CLIPBOARD_FORMAT_KEY, INSERT_POSITION } from '../../constants';\nimport { TABLE_MAX_ROWS, TABLE_MAX_COLUMNS, EMPTY_SELECTED_RANGE, TABLE_ROW_MIN_HEIGHT, TABLE_CELL_MIN_WIDTH, TABLE_ELEMENT, TABLE_ELEMENT_POSITION, TABLE_ROW_STYLE, INHERIT_CELL_STYLE_WHEN_SELECT_MULTIPLE, INHERIT_CELL_STYLE_WHEN_SELECT_SINGLE, TABLE_ALTERNATE_HIGHLIGHT_CLASS_MAP, CELL_SELECTED, DRAG_HANDLER_COLUMN, DRAG_HANDLER_ROW } from './constants';\nimport EventBus from '../../../utils/event-bus';\nimport { INTERNAL_EVENT, PAGE_EDIT_AREA_WIDTH } from '../../../constants';\nimport ObjectUtils from '../../../utils/object-utils';\nimport { replacePastedDataId } from '../../../node-id/helpers';\nexport const isTableMenuDisabled = (editor, readonly) => {\n  if (readonly) return true;\n  const {\n    selection\n  } = editor;\n  if (selection === null) return true;\n  if (!Range.isCollapsed(selection)) return true;\n  const [match] = Editor.nodes(editor, {\n    match: n => {\n      let type = getNodeType(n);\n      if (!type && isTextNode(n) && n.id) {\n        const parentNode = getParentNode(editor.children, n.id);\n        type = getNodeType(parentNode);\n      }\n      if (type.startsWith('header')) return true;\n      if (type === ELEMENT_TYPE.CODE_BLOCK) return true;\n      if (type === ELEMENT_TYPE.ORDERED_LIST) return true;\n      if (type === ELEMENT_TYPE.UNORDERED_LIST) return true;\n      if (type === ELEMENT_TYPE.BLOCKQUOTE) return true;\n      if (type === ELEMENT_TYPE.LIST_ITEM) return true;\n      if (type === ELEMENT_TYPE.TABLE) return true;\n      if (type === ELEMENT_TYPE.TABLE_CELL) return true;\n      if (type === ELEMENT_TYPE.TABLE_ROW) return true;\n      if (type === ELEMENT_TYPE.CALL_OUT) return true;\n      if (Editor.isVoid(editor, n)) return true;\n      return false;\n    },\n    universal: true\n  });\n  if (match) return true;\n  return false;\n};\nexport const isCombineCellsDisabled = (editor, readonly) => {\n  if (readonly) return true;\n  const {\n    selection,\n    tableSelectedRange\n  } = editor;\n  if (!selection) return true;\n  if (!ObjectUtils.isSameObject(tableSelectedRange, EMPTY_SELECTED_RANGE)) {\n    return false;\n  }\n  return true;\n};\nexport const generateTableCell = (editor, rowIndex, cellIndex) => {\n  let style = {};\n  const tableNodeEntry = getSelectedNodeEntryByType(editor, ELEMENT_TYPE.TABLE);\n  if (tableNodeEntry && rowIndex !== undefined && cellIndex !== undefined) {\n    const [, tablePath] = tableNodeEntry;\n    style = getCellInheritStyles(editor, tablePath, rowIndex, cellIndex);\n  }\n  return {\n    id: slugid.nice(),\n    type: ELEMENT_TYPE.TABLE_CELL,\n    children: [{\n      text: '',\n      id: slugid.nice()\n    }],\n    style,\n    inherit_style: style\n  };\n};\nexport const generateTableRow = (editor, colsCount, rowIndex) => {\n  let children = [];\n  for (let i = 0; i < colsCount; i++) {\n    const tableCell = generateTableCell(editor, rowIndex, i);\n    children.push(tableCell);\n  }\n  return {\n    id: slugid.nice(),\n    type: ELEMENT_TYPE.TABLE_ROW,\n    children: children,\n    style: {\n      [TABLE_ROW_STYLE.MIN_HEIGHT]: TABLE_ROW_MIN_HEIGHT\n    }\n  };\n};\n\n/**\n * @param {Editor} editor\n * @param {Object} tableProps\n * @param {[number,number]} tableProps.size - table size, [row,column]\n * @param {Boolean} tableProps.alternate_highlight - is alternate highlight\n * @param {string} tableProps.alternate_highlight_color - table alternate highlight color\n */\nexport const generateEmptyTable = (editor, tableProps) => {\n  const {\n    size = [0, 0],\n    alternate_highlight = false,\n    alternate_highlight_color\n  } = tableProps;\n  const rowsCount = size[0];\n  const colsCount = size[1];\n  let children = [];\n  for (let i = 0; i < rowsCount; i++) {\n    const tableRow = generateTableRow(editor, colsCount, i);\n    children.push(tableRow);\n  }\n  const columnWidth = Math.max(TABLE_CELL_MIN_WIDTH, parseInt(editor.width / colsCount));\n  let columns = [];\n  for (let i = 0; i < colsCount; i++) {\n    columns.push({\n      width: columnWidth\n    });\n  }\n  return {\n    id: slugid.nice(),\n    type: ELEMENT_TYPE.TABLE,\n    children: children,\n    columns,\n    ui: {\n      alternate_highlight,\n      alternate_highlight_color\n    },\n    style: {\n      gridTemplateColumns: \"repeat(\".concat(colsCount, \", \").concat(columnWidth, \"px)\"),\n      gridAutoRows: \"minmax(\".concat(TABLE_ROW_MIN_HEIGHT, \"px, auto)\")\n    }\n  };\n};\nexport const insertTable = function (editor, size, selection) {\n  let position = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : INSERT_POSITION.CURRENT;\n  if (!size) return;\n  if (position !== INSERT_POSITION.AFTER) {\n    if (isTableMenuDisabled(editor)) return;\n  }\n  const tableNode = generateEmptyTable(editor, {\n    size\n  });\n  const validSelection = selection || editor.selection;\n  const path = Editor.path(editor, validSelection);\n  handleInsertTable(editor, position, path, tableNode);\n};\n\n// tableSize [tableHeight, tableWidth]\nexport const getSelectedInfo = editor => {\n  const currentTable = getSelectedNodeByType(editor, ELEMENT_TYPE.TABLE);\n  const currentRow = getSelectedNodeByType(editor, ELEMENT_TYPE.TABLE_ROW);\n  const currentCell = getSelectedNodeByType(editor, ELEMENT_TYPE.TABLE_CELL);\n  const currentCellPath = findPath(editor, currentCell);\n  return {\n    table: currentTable,\n    tablePath: findPath(editor, currentTable),\n    tableSize: [currentTable.children.length, currentRow.children.length],\n    row: currentRow,\n    rowPath: findPath(editor, currentRow),\n    rowIndex: currentCellPath[currentCellPath.length - 2],\n    cell: currentCell,\n    cellPath: findPath(editor, currentCell),\n    cellIndex: currentCellPath[currentCellPath.length - 1]\n  };\n};\nexport const isInTable = editor => {\n  const selectedNodes = getSelectedElems(editor);\n  if (!selectedNodes.some(node => node.type === ELEMENT_TYPE.TABLE)) return false;\n  const firstSelectedNode = selectedNodes[0];\n  return firstSelectedNode.type === ELEMENT_TYPE.TABLE;\n};\nexport const isAllInTable = editor => {\n  const selectedNodes = getSelectedElems(editor);\n  if (!selectedNodes.some(node => node.type === ELEMENT_TYPE.TABLE)) return false;\n  const firstSelectedNode = selectedNodes[0];\n  if (firstSelectedNode.type !== ELEMENT_TYPE.TABLE) return false;\n  return selectedNodes.slice(1).every(node => [ELEMENT_TYPE.TABLE_ROW, ELEMENT_TYPE.TABLE_CELL].includes(node.type)); // same table element\n};\n\nexport const setCellStyle = (editor, style) => {\n  // Select single cell\n  if (ObjectUtils.isSameObject(editor.tableSelectedRange, EMPTY_SELECTED_RANGE)) {\n    const selectedNodes = getSelectedElems(editor);\n    let firstTableCellNodePath;\n    selectedNodes.forEach(node => {\n      if (node.type === ELEMENT_TYPE.TABLE_CELL) {\n        const path = findPath(editor, node);\n        if (path) {\n          firstTableCellNodePath = firstTableCellNodePath ? firstTableCellNodePath : path;\n          Transforms.setNodes(editor, {\n            style: _objectSpread(_objectSpread({}, node.style), style),\n            inherit_style: generateInheritStyle(INHERIT_CELL_STYLE_WHEN_SELECT_SINGLE, style, node)\n          }, {\n            at: path\n          });\n        }\n      }\n    });\n    if (firstTableCellNodePath) {\n      const start = Editor.start(editor, firstTableCellNodePath);\n      const end = Editor.end(editor, firstTableCellNodePath);\n      const newSelection = {\n        anchor: start,\n        focus: end\n      };\n      Transforms.select(editor, newSelection);\n    }\n    return;\n  }\n  // Select multiple cells\n  const {\n    minColIndex,\n    maxColIndex,\n    minRowIndex,\n    maxRowIndex\n  } = editor.tableSelectedRange;\n  const {\n    tablePath\n  } = getSelectedInfo(editor);\n  for (let i = minRowIndex; i <= maxRowIndex; i++) {\n    for (let j = minColIndex; j <= maxColIndex; j++) {\n      const path = [...tablePath, i, j];\n      const node = getNode(editor, path);\n      Transforms.setNodes(editor, {\n        style: _objectSpread(_objectSpread({}, node.style), style),\n        inherit_style: generateInheritStyle(INHERIT_CELL_STYLE_WHEN_SELECT_MULTIPLE, style, node)\n      }, {\n        at: path\n      });\n    }\n  }\n};\nexport const insertTableRow = function (editor, table, rowIndex) {\n  let position = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TABLE_ELEMENT_POSITION.AFTER;\n  const tableRowCount = table.children.length;\n  if (tableRowCount >= TABLE_MAX_ROWS) return;\n  const tableColumnCount = table.children[0].children.length;\n  const row = generateTableRow(editor, tableColumnCount, rowIndex);\n  const tablePath = findPath(editor, table);\n  const targetPath = position === TABLE_ELEMENT_POSITION.AFTER ? [...tablePath, rowIndex + 1] : [...tablePath, rowIndex];\n  Transforms.insertNodes(editor, row, {\n    at: targetPath\n  });\n  const focusPath = [...targetPath, 0];\n  focusEditor(editor, focusPath);\n\n  // handle cells with the rowspan > 1\n  if (position === TABLE_ELEMENT_POSITION.AFTER) {\n    handleCombinedCellsAfterInsertTableRow(editor, tablePath, table, rowIndex);\n  }\n};\nexport const handleCombinedCellsAfterInsertTableRow = (editor, tablePath, table, rowIndex) => {\n  // important background info: the new row is inserted after rowIndex\n  const cells = table.children[rowIndex].children;\n  for (let i = 0, len = cells.length; i < len; i++) {\n    const {\n      is_combined,\n      rowspan,\n      colspan\n    } = cells[i];\n    if (is_combined) {\n      for (let ri = rowIndex - 1; ri >= 0; ri--) {\n        const {\n          is_combined: ri_is_combined,\n          rowspan: ri_rowspan,\n          colspan: ri_colspan\n        } = table.children[ri].children[i];\n        if (!ri_is_combined && ri + ri_rowspan - 1 > rowIndex) {\n          Transforms.setNodes(editor, {\n            rowspan: ri_rowspan + 1\n          }, {\n            at: [...tablePath, ri, i]\n          });\n          for (let j = 0; j < ri_colspan; j++) {\n            Transforms.setNodes(editor, {\n              'is_combined': true\n            }, {\n              at: [...tablePath, rowIndex + 1, i + j]\n            });\n          }\n          break;\n        }\n      }\n    } else {\n      if (rowspan > 1) {\n        Transforms.setNodes(editor, {\n          rowspan: rowspan + 1\n        }, {\n          at: [...tablePath, rowIndex, i]\n        });\n        for (let j = 0; j < colspan; j++) {\n          Transforms.setNodes(editor, {\n            'is_combined': true\n          }, {\n            at: [...tablePath, rowIndex + 1, i + j]\n          });\n        }\n      }\n    }\n  }\n};\nexport const insertTableColumn = function (editor, table, columnIndex) {\n  let position = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TABLE_ELEMENT_POSITION.AFTER;\n  const tableColumnCount = table.children[0].children.length;\n  if (tableColumnCount >= TABLE_MAX_COLUMNS) return;\n  const newCellIndex = position === TABLE_ELEMENT_POSITION.AFTER ? columnIndex + 1 : columnIndex;\n  const newColumns = getTableColumnsAfterInsertColumn(editor, table, newCellIndex, 1);\n  updateColumnWidth(editor, table, newColumns);\n  const tablePath = findPath(editor, table);\n  const tableRowCount = table.children.length;\n  for (let i = 0; i < tableRowCount; i++) {\n    const newCellPath = [...tablePath, i, newCellIndex];\n    const newCell = generateTableCell(editor, i, columnIndex);\n    Transforms.insertNodes(editor, newCell, {\n      at: newCellPath\n    });\n  }\n  const focusPath = [...tablePath, 0, newCellIndex, 0];\n  focusEditor(editor, focusPath);\n\n  // handle cells with the colspan > 1\n  if (position === TABLE_ELEMENT_POSITION.AFTER) {\n    handleCombinedCellsAfterInsertTableColumn(editor, tablePath, table, columnIndex);\n  }\n};\nexport const handleCombinedCellsAfterInsertTableColumn = (editor, tablePath, table, columnIndex) => {\n  // important background info: the new column is inserted after columnIndex\n  for (let i = 0, len = table.children.length; i < len; i++) {\n    const {\n      is_combined,\n      rowspan,\n      colspan\n    } = table.children[i].children[columnIndex];\n    if (is_combined) {\n      for (let ci = columnIndex - 1; ci >= 0; ci--) {\n        const {\n          is_combined: ci_is_combined,\n          rowspan: ci_rowspan,\n          colspan: ci_colspan\n        } = table.children[i].children[ci];\n        if (!ci_is_combined && ci + ci_colspan - 1 > columnIndex) {\n          Transforms.setNodes(editor, {\n            colspan: ci_colspan + 1\n          }, {\n            at: [...tablePath, i, ci]\n          });\n          for (let j = 0; j < ci_rowspan; j++) {\n            Transforms.setNodes(editor, {\n              'is_combined': true\n            }, {\n              at: [...tablePath, i + j, columnIndex + 1]\n            });\n          }\n          break;\n        }\n      }\n    } else {\n      if (colspan > 1) {\n        Transforms.setNodes(editor, {\n          colspan: colspan + 1\n        }, {\n          at: [...tablePath, i, columnIndex]\n        });\n        for (let j = 0; j < rowspan; j++) {\n          Transforms.setNodes(editor, {\n            'is_combined': true\n          }, {\n            at: [...tablePath, i + j, columnIndex + 1]\n          });\n        }\n      }\n    }\n  }\n};\nexport const insertTableElement = function (editor, type) {\n  let position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TABLE_ELEMENT_POSITION.AFTER;\n  let count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  const {\n    table,\n    tablePath,\n    tableSize,\n    rowIndex,\n    cellIndex\n  } = getSelectedInfo(editor);\n  const eventBus = EventBus.getInstance();\n  eventBus.dispatch(INTERNAL_EVENT.CANCEL_TABLE_SELECT_RANGE);\n  if (type === TABLE_ELEMENT.ROW) {\n    if (tableSize[0] >= TABLE_MAX_ROWS) return;\n    const targetPath = position === TABLE_ELEMENT_POSITION.AFTER ? [...tablePath, rowIndex + 1] : [...tablePath, rowIndex];\n    const validCount = Math.min(TABLE_MAX_ROWS - tableSize[0], count);\n    for (let i = 0; i < validCount; i++) {\n      const row = generateTableRow(editor, tableSize[1], rowIndex);\n      Transforms.insertNodes(editor, row, {\n        at: targetPath\n      });\n      // handle combined cells\n      if (!(rowIndex === 0 && position === TABLE_ELEMENT_POSITION.BEFORE)) {\n        const targetRowIndex = position === TABLE_ELEMENT_POSITION.AFTER ? rowIndex : rowIndex - 1;\n        const currentTable = getSelectedNodeByType(editor, ELEMENT_TYPE.TABLE);\n        handleCombinedCellsAfterInsertTableRow(editor, tablePath, currentTable, targetRowIndex);\n      }\n    }\n    const focusPath = [...targetPath, cellIndex];\n    focusEditor(editor, focusPath);\n    return;\n  }\n  if (type === TABLE_ELEMENT.COLUMN) {\n    if (tableSize[1] >= TABLE_MAX_COLUMNS) return;\n    const newCellIndex = position === TABLE_ELEMENT_POSITION.AFTER ? cellIndex + 1 : cellIndex;\n    const validCount = Math.min(TABLE_MAX_COLUMNS - tableSize[1], count);\n    const newColumns = getTableColumnsAfterInsertColumn(editor, table, newCellIndex, validCount);\n    updateColumnWidth(editor, table, newColumns);\n    for (let j = 0; j < validCount; j++) {\n      for (let i = 0; i < tableSize[0]; i++) {\n        const newCellPath = [...tablePath, i, newCellIndex];\n        const newCell = generateTableCell(editor, i, cellIndex);\n        Transforms.insertNodes(editor, newCell, {\n          at: newCellPath\n        });\n      }\n      // handle combined cells\n      if (!(cellIndex === 0 && position === TABLE_ELEMENT_POSITION.BEFORE)) {\n        const targetColumnIndex = position === TABLE_ELEMENT_POSITION.AFTER ? cellIndex : cellIndex - 1;\n        const currentTable = getSelectedNodeByType(editor, ELEMENT_TYPE.TABLE);\n        handleCombinedCellsAfterInsertTableColumn(editor, tablePath, currentTable, targetColumnIndex);\n      }\n    }\n    const focusPath = [...tablePath, rowIndex, cellIndex + 1, 0];\n    focusEditor(editor, focusPath);\n    return;\n  }\n};\nexport const combineCells = editor => {\n  const {\n    tablePath\n  } = getSelectedInfo(editor);\n  const {\n    minColIndex,\n    maxColIndex,\n    minRowIndex,\n    maxRowIndex\n  } = editor.tableSelectedRange;\n  let newCellContent = [];\n  for (let i = minRowIndex; i < maxRowIndex + 1; i++) {\n    for (let j = minColIndex; j < maxColIndex + 1; j++) {\n      let nodePath = [...tablePath, i, j];\n      let node = Editor.node(editor, nodePath);\n      if (node[0].is_combined) {\n        continue;\n      }\n      Transforms.setNodes(editor, {\n        'is_combined': true\n      }, {\n        at: nodePath\n      });\n      newCellContent = newCellContent.concat(node[0].children);\n    }\n  }\n  const targetCellPath = [...tablePath, minRowIndex, minColIndex];\n  const newCell = generateTableCell(editor);\n  newCell.children = newCellContent;\n  newCell.rowspan = maxRowIndex - minRowIndex + 1;\n  newCell.colspan = maxColIndex - minColIndex + 1;\n  // keep row.children.length not changed\n  Transforms.removeNodes(editor, {\n    at: targetCellPath\n  });\n  Transforms.insertNodes(editor, newCell, {\n    at: targetCellPath\n  });\n  focusEditor(editor, targetCellPath);\n\n  // for clicking the 'combine cell' icon in the toolbar\n  const eventBus = EventBus.getInstance();\n  eventBus.dispatch(INTERNAL_EVENT.CANCEL_TABLE_SELECT_RANGE);\n};\nexport const splitCell = (editor, rowNumber, columnNumber) => {\n  if (rowNumber === 1 && columnNumber === 1) {\n    return;\n  }\n  const {\n    cell,\n    rowIndex,\n    cellIndex,\n    cellPath,\n    tablePath\n  } = getSelectedInfo(editor);\n  const {\n    rowspan,\n    colspan\n  } = cell;\n  const rowspanBase = Math.floor(rowspan / rowNumber);\n  const rowspanLeft = rowspan % rowNumber;\n  const colspanBase = Math.floor(colspan / columnNumber);\n  const colspanLeft = colspan % columnNumber;\n  const cellNumber = rowNumber * columnNumber;\n  const dataBlockNumber = Math.ceil(cell.children.length / cellNumber);\n  let firstNewCell;\n  let rowspanSum = 0;\n  for (let i = 0; i < rowNumber; i++) {\n    let newRowSpan = rowspanBase + (i + 1 <= rowspanLeft ? 1 : 0);\n    let colspanSum = 0;\n    for (let j = 0; j < columnNumber; j++) {\n      const newCell = generateTableCell(editor);\n      let startIndex = (i * columnNumber + j) * dataBlockNumber;\n      if (startIndex < cell.children.length) {\n        let endIndex = Math.min(startIndex + dataBlockNumber, cell.children.length);\n        newCell.children = cell.children.slice(startIndex, endIndex);\n      }\n      newCell.rowspan = newRowSpan;\n      newCell.colspan = colspanBase + (j + 1 <= colspanLeft ? 1 : 0);\n      const newRowIndex = rowIndex + rowspanSum;\n      const newCellIndex = cellIndex + colspanSum;\n      const targetCellPath = [...tablePath, newRowIndex, newCellIndex];\n      if (i === 0 && j === 0) {\n        firstNewCell = newCell;\n      } else {\n        Transforms.removeNodes(editor, {\n          at: targetCellPath\n        });\n        Transforms.insertNodes(editor, newCell, {\n          at: targetCellPath\n        });\n      }\n      colspanSum += newCell.colspan;\n    }\n    rowspanSum += newRowSpan;\n  }\n  Transforms.removeNodes(editor, {\n    at: cellPath\n  });\n  Transforms.insertNodes(editor, firstNewCell, {\n    at: cellPath\n  });\n};\nexport const removeTable = (editor, path) => {\n  let validPath = path;\n  if (!validPath) {\n    const {\n      tablePath\n    } = getSelectedInfo(editor);\n    validPath = tablePath;\n  }\n  editor.reSetTableSelectedRange();\n  Transforms.removeNodes(editor, {\n    at: validPath\n  });\n};\nexport const removeTableElement = (editor, type) => {\n  const {\n    table,\n    tablePath,\n    tableSize,\n    rowPath,\n    rowIndex,\n    cellIndex\n  } = getSelectedInfo(editor);\n  const eventBus = EventBus.getInstance();\n  eventBus.dispatch(INTERNAL_EVENT.CANCEL_TABLE_SELECT_RANGE);\n  if (type === TABLE_ELEMENT.TABLE) {\n    removeTable(editor, tablePath);\n    return;\n  }\n  if (type === TABLE_ELEMENT.ROW) {\n    if (tableSize[0] === 1) {\n      removeTable(editor, tablePath);\n      return;\n    }\n    if (!ObjectUtils.isSameObject(editor.tableSelectedRange, EMPTY_SELECTED_RANGE)) {\n      const {\n        minRowIndex,\n        maxRowIndex\n      } = editor.tableSelectedRange;\n      if (minRowIndex === 0 && maxRowIndex === tableSize[0] - 1) {\n        removeTable(editor, tablePath);\n        return;\n      }\n      for (let i = minRowIndex; i <= maxRowIndex; i++) {\n        Transforms.removeNodes(editor, {\n          at: [...tablePath, minRowIndex]\n        });\n      }\n      const focusPath = [...tablePath, minRowIndex === 0 ? 0 : minRowIndex - 1, cellIndex];\n      focusEditor(editor, focusPath);\n      return;\n    }\n    handleCombinedCellsBeforeDeleteTableRow(editor, tablePath, table, rowIndex);\n    Transforms.removeNodes(editor, {\n      at: rowPath\n    });\n    const focusRowIndex = rowIndex === tableSize[0] - 1 ? rowIndex - 1 : rowIndex;\n    const focusPath = [...tablePath, focusRowIndex, cellIndex];\n    focusEditor(editor, focusPath);\n    return;\n  }\n  if (type === TABLE_ELEMENT.COLUMN) {\n    if (tableSize[1] === 1) {\n      removeTable(editor, tablePath);\n      return;\n    }\n    if (!ObjectUtils.isSameObject(editor.tableSelectedRange, EMPTY_SELECTED_RANGE)) {\n      const {\n        minColIndex,\n        maxColIndex\n      } = editor.tableSelectedRange;\n      if (minColIndex === 0 && maxColIndex === tableSize[1] - 1) {\n        removeTable(editor, tablePath);\n        return;\n      }\n      const columns = getTableColumns(editor, table);\n      const newColumns = [...columns.slice(0, minColIndex), ...columns.slice(maxColIndex + 1)];\n      updateColumnWidth(editor, table, newColumns);\n      for (let i = 0; i < tableSize[0]; i++) {\n        for (let j = minColIndex; j <= maxColIndex; j++) {\n          // count\n          const cellPath = [...tablePath, i, minColIndex];\n          Transforms.removeNodes(editor, {\n            at: cellPath\n          });\n        }\n      }\n      const focusPath = [...tablePath, rowIndex, minColIndex === 0 ? 0 : minColIndex - 1];\n      focusEditor(editor, focusPath);\n      return;\n    }\n    const columns = getTableColumns(editor, table);\n    const newColumns = columns.slice(0);\n    newColumns.splice(cellIndex, 1);\n    updateColumnWidth(editor, table, newColumns);\n    handleCombinedCellsBeforeDeleteTableColumn(editor, tablePath, table, cellIndex);\n    for (let i = 0; i < tableSize[0]; i++) {\n      const cellPath = [...tablePath, i, cellIndex];\n      Transforms.removeNodes(editor, {\n        at: cellPath\n      });\n    }\n    const focusCellIndex = cellIndex === tableSize[1] - 1 ? cellIndex - 1 : cellIndex;\n    const focusPath = [...tablePath, rowIndex, focusCellIndex];\n    focusEditor(editor, focusPath);\n    return;\n  }\n};\n\n// handle combined cells before deleting a row\nexport const handleCombinedCellsBeforeDeleteTableRow = (editor, tablePath, table, rowIndex) => {\n  const cells = table.children[rowIndex].children;\n  for (let i = 0, len = cells.length; i < len; i++) {\n    const {\n      is_combined,\n      rowspan,\n      colspan\n    } = cells[i];\n    if (is_combined) {\n      for (let ri = rowIndex - 1; ri >= 0; ri--) {\n        const {\n          is_combined: ri_is_combined,\n          rowspan: ri_rowspan\n        } = table.children[ri].children[i];\n        if (!ri_is_combined && ri + ri_rowspan - 1 >= rowIndex) {\n          Transforms.setNodes(editor, {\n            rowspan: ri_rowspan - 1\n          }, {\n            at: [...tablePath, ri, i]\n          });\n          break;\n        }\n      }\n    } else {\n      if (rowspan > 1) {\n        const targetCellPath = [...tablePath, rowIndex + 1, i];\n        const newCell = generateTableCell(editor);\n        newCell.rowspan = rowspan - 1;\n        newCell.colspan = colspan;\n        Transforms.removeNodes(editor, {\n          at: targetCellPath\n        });\n        Transforms.insertNodes(editor, newCell, {\n          at: targetCellPath\n        });\n      }\n    }\n  }\n};\n\n// handle combined cells before deleting a column\nexport const handleCombinedCellsBeforeDeleteTableColumn = (editor, tablePath, table, columnIndex) => {\n  for (let i = 0, len = table.children.length; i < len; i++) {\n    const {\n      is_combined,\n      rowspan,\n      colspan\n    } = table.children[i].children[columnIndex];\n    if (is_combined) {\n      for (let ci = columnIndex - 1; ci >= 0; ci--) {\n        const {\n          is_combined: ci_is_combined,\n          colspan: ci_colspan\n        } = table.children[i].children[ci];\n        if (!ci_is_combined && ci + ci_colspan - 1 >= columnIndex) {\n          Transforms.setNodes(editor, {\n            colspan: ci_colspan - 1\n          }, {\n            at: [...tablePath, i, ci]\n          });\n          break;\n        }\n      }\n    } else {\n      if (colspan > 1) {\n        const targetCellPath = [...tablePath, i, columnIndex + 1];\n        const newCell = generateTableCell(editor);\n        newCell.rowspan = rowspan;\n        newCell.colspan = colspan - 1;\n        Transforms.removeNodes(editor, {\n          at: targetCellPath\n        });\n        Transforms.insertNodes(editor, newCell, {\n          at: targetCellPath\n        });\n      }\n    }\n  }\n};\nexport const setTableSelectedRange = (editor, range) => {\n  if (range) {\n    editor.tableSelectedRange = range;\n    return;\n  }\n  editor.tableSelectedRange = EMPTY_SELECTED_RANGE;\n};\nexport const updateTableRowHeight = (editor, element, rowHeight) => {\n  const path = findPath(editor, element);\n  const targetNode = getNode(editor, path);\n  const {\n    style = {}\n  } = targetNode;\n  if (style[TABLE_ROW_STYLE.MIN_HEIGHT] === rowHeight) return;\n  Transforms.setNodes(editor, {\n    style: _objectSpread(_objectSpread({}, style), {}, {\n      [TABLE_ROW_STYLE.MIN_HEIGHT]: rowHeight\n    })\n  }, {\n    at: path\n  });\n};\nexport const updateColumnWidth = (editor, element, columns) => {\n  const path = findPath(editor, element);\n  Transforms.setNodes(editor, {\n    columns: columns\n  }, {\n    at: path\n  });\n};\nexport const getTableColumnsWidth = function () {\n  let columns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  if (!Array.isArray(columns) || columns.length === 0) return 0;\n  return columns.reduce((pre, cur) => pre + cur.width, 0);\n};\nexport const getTableColumnsAfterInsertColumn = (editor, element, targetColumnIndex, insertColumnCount) => {\n  const columns = getTableColumns(editor, element);\n  let newColumns = columns.slice(0);\n  let totalColumnsWidth = getTableColumnsWidth(columns);\n  const targetColumn = columns[targetColumnIndex] || columns[targetColumnIndex - 1];\n  const targetInsertColumnsWidth = targetColumn.width * insertColumnCount;\n\n  // Currently in scrolling state, insert directly\n  if (totalColumnsWidth > editor.width) {\n    for (let i = 0; i < insertColumnCount; i++) {\n      newColumns.splice(targetColumnIndex, 0, targetColumn);\n    }\n    return newColumns;\n  }\n\n  // Not currently scrolling\n  // It is not a scroll state after inserting a new column\n  if (totalColumnsWidth + targetInsertColumnsWidth < editor.width) {\n    for (let i = 0; i < insertColumnCount; i++) {\n      newColumns.push(targetColumn);\n    }\n    return newColumns;\n  }\n\n  // After inserting a new column is a scrolling state\n  for (let i = 0; i < insertColumnCount; i++) {\n    totalColumnsWidth += targetColumn.width;\n    newColumns.splice(targetColumnIndex, 0, targetColumn);\n  }\n  const proportion = totalColumnsWidth / (editor.width - 1);\n  return newColumns.map(column => {\n    return _objectSpread(_objectSpread({}, column), {}, {\n      width: Math.max(parseInt(column.width / proportion), TABLE_CELL_MIN_WIDTH)\n    });\n  });\n};\nexport const getTableColumns = (editor, element) => {\n  if (!element) return [];\n  let tableElement = element;\n  if (element.type === ELEMENT_TYPE.TABLE_CELL) {\n    const cellPath = findPath(editor, element);\n    const tablePath = cellPath.slice(0, -2);\n    tableElement = getNode(editor, tablePath);\n  }\n  const {\n    columns,\n    children\n  } = tableElement;\n  if (columns) return columns;\n  const columnsCount = children[0].children.length;\n  let initColumns = [];\n  const pageEditAreaWidth = editor.width || PAGE_EDIT_AREA_WIDTH;\n  for (let i = 0; i < columnsCount; i++) {\n    const column = {\n      width: Math.max(TABLE_CELL_MIN_WIDTH, parseInt(pageEditAreaWidth / columnsCount))\n    };\n    initColumns.push(column);\n  }\n  return initColumns;\n};\nexport const getCellColumn = (editor, cellElement) => {\n  let column = {\n    width: TABLE_CELL_MIN_WIDTH\n  };\n  if (!editor || !cellElement) return column;\n  const cellPath = findPath(editor, cellElement);\n  if (!cellPath) return column;\n  const pathLength = cellPath.length;\n  const cellIndex = cellPath[pathLength - 1];\n  const tablePath = cellPath.slice(0, -2);\n  const tableElement = getNode(editor, tablePath);\n  const {\n    columns\n  } = tableElement;\n  const columnsCount = tableElement.children[0].children.length;\n  const pageEditAreaWidth = editor.width || PAGE_EDIT_AREA_WIDTH;\n  if (columns) {\n    column = columns[cellIndex];\n  }\n  return column || {\n    width: Math.max(TABLE_CELL_MIN_WIDTH, parseInt(pageEditAreaWidth / columnsCount))\n  };\n};\nexport const getFirstTableCell = element => {\n  let tableCellElement = element;\n  while (tableCellElement && !(tableCellElement.hasAttribute('row-index') && tableCellElement.hasAttribute('cell-index'))) {\n    tableCellElement = tableCellElement.parentNode;\n  }\n  return tableCellElement;\n};\nexport const elementHasImage = element => {\n  if (!element) return false;\n  if (!Array.isArray(element.children) || element.children.length === 0) return false;\n  return element.children.some(child => {\n    if (child.type === ELEMENT_TYPE.IMAGE) return true;\n    if (ObjectUtils.hasProperty(child, 'children')) {\n      return elementHasImage(child);\n    }\n    return false;\n  });\n};\nexport const isSelectedAllCell = editor => {\n  const {\n    tableSize\n  } = getSelectedInfo(editor);\n  return ObjectUtils.isSameObject(editor.tableSelectedRange, {\n    minColIndex: 0,\n    maxColIndex: tableSize[1] - 1,\n    minRowIndex: 0,\n    maxRowIndex: tableSize[0] - 1\n  });\n};\nexport const insertMultipleRowsAndColumns = (editor, rows, columns) => {\n  const {\n    table,\n    tablePath,\n    tableSize,\n    rowIndex,\n    cellIndex\n  } = getSelectedInfo(editor);\n  let newTable = deepCopy(table);\n  const eventBus = EventBus.getInstance();\n  eventBus.dispatch(INTERNAL_EVENT.CANCEL_TABLE_SELECT_RANGE);\n  const insertRows = rows.slice(tableSize[0] - rowIndex);\n  const insertColumns = columns.slice(tableSize[1] - cellIndex);\n  const validInsertRows = insertRows.slice(0, Math.min(TABLE_MAX_ROWS - tableSize[0], insertRows.length));\n  const validInsertColumns = insertColumns.slice(0, Math.min(TABLE_MAX_COLUMNS - tableSize[1], columns.length));\n  for (let i = 0; i < validInsertRows.length; i++) {\n    const insertRow = validInsertRows[i];\n    const row = generateTableRow(editor, tableSize[1], rowIndex);\n    row.style = insertRow.style;\n    newTable.children.push(row);\n  }\n  if (validInsertColumns.length > 0) {\n    newTable.columns = [...table.columns, ...validInsertColumns];\n  }\n  for (let j = 0; j < validInsertColumns.length; j++) {\n    for (let i = 0; i < tableSize[0] + validInsertRows.length; i++) {\n      const newCell = generateTableCell(editor);\n      newTable.children[i].children.push(newCell);\n    }\n  }\n  for (let i = rowIndex; i < Math.min(TABLE_MAX_ROWS, rowIndex + rows.length); i++) {\n    const row = rows[i - rowIndex];\n    const cells = row.children;\n    for (let j = cellIndex; j < Math.min(TABLE_MAX_COLUMNS, cellIndex + columns.length); j++) {\n      const replaceCellIndex = j - cellIndex;\n      const replaceCell = cells[replaceCellIndex];\n      newTable.children[i].children[j].children = replacePastedDataId(replaceCell.children);\n    }\n  }\n  replaceNode(editor, {\n    at: tablePath,\n    nodes: newTable\n  });\n  focusEditor(editor, [...tablePath, rowIndex, cellIndex, 0]);\n  const {\n    focus: newFocus\n  } = editor.selection;\n  Transforms.select(editor, {\n    focus: newFocus,\n    anchor: newFocus\n  });\n  return;\n};\nexport const setTableFragmentData = (editor, dataTransfer) => {\n  const selectedNode = getSelectedNodeByType(editor, ELEMENT_TYPE.TABLE);\n  const fragment = editor.getFragment();\n  const string = JSON.stringify(fragment);\n  const encoded = window.btoa(encodeURIComponent(string));\n  dataTransfer.setData(\"application/\".concat(CLIPBOARD_FORMAT_KEY), encoded);\n  const tableDom = document.createElement('table');\n  const {\n    minColIndex,\n    maxColIndex,\n    minRowIndex,\n    maxRowIndex\n  } = editor.tableSelectedRange;\n  const tablePath = findPath(editor, selectedNode);\n  for (let i = minRowIndex; i <= maxRowIndex; i++) {\n    const tr = document.createElement('tr');\n    for (let j = minColIndex; j <= maxColIndex; j++) {\n      const path = [...tablePath, i, j];\n      const node = getNode(editor, path);\n      const td = document.createElement('td');\n      const div = document.createElement('div');\n      div.innerHTML = ReactEditor.toDOMNode(editor, node).innerHTML;\n      td.appendChild(div);\n      tr.appendChild(td);\n    }\n    tableDom.appendChild(tr);\n  }\n  tableDom.setAttribute('data-slate-fragment', encoded);\n  const div = document.createElement('div');\n  div.appendChild(tableDom);\n  dataTransfer.setData('text/html', div.innerHTML);\n  dataTransfer.setData('text/plain', div.innerText);\n  return dataTransfer;\n};\nexport const deleteTableRangeData = editor => {\n  const {\n    tableSelectedRange\n  } = editor;\n  const {\n    minRowIndex,\n    maxRowIndex,\n    minColIndex,\n    maxColIndex\n  } = tableSelectedRange;\n  const {\n    tablePath\n  } = getSelectedInfo(editor);\n  let forceCellPath;\n  for (let i = minRowIndex; i <= maxRowIndex; i++) {\n    for (let j = minColIndex; j <= maxColIndex; j++) {\n      const path = [...tablePath, i, j];\n      const node = getNode(editor, path);\n      if (!forceCellPath && (Node.string(node) || elementHasImage(node))) {\n        forceCellPath = path;\n      }\n      const firstNode = node.children[0];\n      replaceNodeChildren(editor, {\n        at: path,\n        nodes: _objectSpread(_objectSpread({}, firstNode), {}, {\n          text: ''\n        })\n      });\n    }\n  }\n  if (forceCellPath) {\n    editor.tableSelectedRange = EMPTY_SELECTED_RANGE;\n    const eventBus = EventBus.getInstance();\n    eventBus.dispatch(INTERNAL_EVENT.CANCEL_TABLE_SELECT_RANGE);\n    focusEditor(editor, forceCellPath);\n    const {\n      focus: newFocus\n    } = editor.selection;\n    Transforms.select(editor, {\n      focus: newFocus,\n      anchor: newFocus\n    });\n  }\n};\nexport const deleteHandler = editor => {\n  const {\n    selection,\n    tableSelectedRange\n  } = editor;\n  if (selection == null) return '';\n  if (!ObjectUtils.isSameObject(tableSelectedRange, EMPTY_SELECTED_RANGE)) {\n    if (isSelectedAllCell(editor)) return 'table';\n    return 'range';\n  }\n  const [cellNodeEntry] = Editor.nodes(editor, {\n    match: n => {\n      let type = getNodeType(n);\n      if (!type && isTextNode(n) && n.id) {\n        const parentNode = getParentNode(editor.children, n.id);\n        type = getNodeType(parentNode);\n      }\n      return type === ELEMENT_TYPE.TABLE_CELL;\n    }\n  });\n  if (cellNodeEntry) {\n    const [, cellPath] = cellNodeEntry;\n    const start = Editor.start(editor, cellPath);\n    if (Point.equals(selection.anchor, start)) {\n      return 'default';\n    }\n  }\n  return '';\n};\nexport const isTableLocation = (editor, location) => {\n  const tables = Editor.nodes(editor, {\n    at: location,\n    match: n => {\n      let type = getNodeType(n);\n      if (!type && isTextNode(n) && n.id) {\n        const parentNode = getParentNode(editor.children, n.id);\n        type = getNodeType(parentNode);\n      }\n      return type === ELEMENT_TYPE.TABLE_CELL;\n    }\n  });\n  let hasTable = false;\n  // eslint-disable-next-line no-unused-vars\n  for (const table of tables) {\n    hasTable = true;\n  }\n  return hasTable;\n};\nexport const isCursorAtCellEnd = function (cell) {\n  let cursor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (!cell) return false;\n  const childrenCount = cell.children.length;\n  const lastChildren = cell.children[childrenCount - 1];\n  const textCount = lastChildren.text.length;\n  return cursor === textCount;\n};\nexport const isCursorAtCellStart = function () {\n  let cursor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  return cursor === 0;\n};\nexport const focusCell = function (editor, event) {\n  let keyboardName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  const {\n    tableSize,\n    tablePath,\n    rowIndex,\n    cellIndex,\n    cell\n  } = getSelectedInfo(editor);\n  const tableParentPath = tablePath.slice(0, -1);\n  const tableIndex = tablePath[tablePath.length - 1];\n  const {\n    selection\n  } = editor;\n  const {\n    focus\n  } = selection;\n  if (keyboardName === KEYBOARD.UP) {\n    if (!isCursorAtCellStart(focus.offset)) {\n      setTimeout(() => {\n        if (getSelectedNodeByType(editor, ELEMENT_TYPE.TABLE)) {\n          const {\n            cellIndex: newCellIndex\n          } = getSelectedInfo(editor);\n          if (Math.abs(newCellIndex - cellIndex) !== 0) {\n            if (rowIndex === 0) {\n              if (tableIndex !== 0) {\n                focusEditor(editor, [...tableParentPath, tableIndex - 1]);\n              }\n              return;\n            }\n            focusEditor(editor, [...tableParentPath, tableIndex, rowIndex - 1, cellIndex]);\n            const {\n              focus: newFocus\n            } = editor.selection;\n            Transforms.select(editor, {\n              focus: newFocus,\n              anchor: newFocus\n            });\n          }\n        }\n      }, 10);\n      return;\n    }\n    event.preventDefault();\n    if (rowIndex === 0) {\n      if (tableIndex !== 0) {\n        focusEditor(editor, [...tableParentPath, tableIndex - 1]);\n      }\n      return;\n    }\n    focusEditor(editor, [...tableParentPath, tableIndex, rowIndex - 1, cellIndex]);\n    const {\n      focus: newFocus\n    } = editor.selection;\n    Transforms.select(editor, {\n      focus: newFocus,\n      anchor: newFocus\n    });\n  }\n  if (keyboardName === KEYBOARD.RIGHT) {\n    if (!isCursorAtCellEnd(cell, focus.offset)) return;\n    event.preventDefault();\n    if (rowIndex === tableSize[0] - 1 && cellIndex === tableSize[1] - 1) {\n      focusEditor(editor, [...tableParentPath, tableIndex + 1]);\n      return;\n    }\n    if (cellIndex === tableSize[1] - 1) {\n      focusEditor(editor, [...tableParentPath, tableIndex, rowIndex + 1, 0]);\n    } else {\n      focusEditor(editor, [...tableParentPath, tableIndex, rowIndex, cellIndex + 1]);\n    }\n    const {\n      anchor: newAnchor\n    } = editor.selection;\n    Transforms.select(editor, {\n      focus: newAnchor,\n      anchor: newAnchor\n    });\n  }\n  if (keyboardName === KEYBOARD.DOWN) {\n    if (!isCursorAtCellEnd(cell, focus.offset)) {\n      setTimeout(() => {\n        if (getSelectedNodeByType(editor, ELEMENT_TYPE.TABLE)) {\n          const {\n            cellIndex: newCellIndex\n          } = getSelectedInfo(editor);\n          if (Math.abs(newCellIndex - cellIndex) !== 0) {\n            if (rowIndex === tableSize[0] - 1) {\n              const nextNode = getNode(editor, [...tableParentPath, tableIndex + 1]);\n              if (!nextNode) return;\n              focusEditor(editor, [...tableParentPath, tableIndex + 1]);\n              return;\n            }\n            focusEditor(editor, [...tableParentPath, tableIndex, rowIndex + 1, cellIndex]);\n            const {\n              anchor: newAnchor\n            } = editor.selection;\n            Transforms.select(editor, {\n              focus: newAnchor,\n              anchor: newAnchor\n            });\n          }\n        }\n      }, 10);\n      return;\n    }\n    event.preventDefault();\n    if (rowIndex === tableSize[0] - 1) {\n      const nextNode = getNode([...tableParentPath, tableIndex + 1]);\n      if (!nextNode) return;\n      focusEditor(editor, [...tableParentPath, tableIndex + 1]);\n      return;\n    }\n    focusEditor(editor, [...tableParentPath, tableIndex, rowIndex + 1, cellIndex]);\n    const {\n      anchor: newAnchor\n    } = editor.selection;\n    Transforms.select(editor, {\n      focus: newAnchor,\n      anchor: newAnchor\n    });\n  }\n  if (keyboardName === KEYBOARD.LEFT) {\n    if (!isCursorAtCellStart(focus.offset)) return;\n    event.preventDefault();\n    if (rowIndex === 0 && cellIndex === 0) {\n      if (tableIndex !== 0) {\n        focusEditor(editor, [...tableParentPath, tableIndex - 1]);\n      }\n      return;\n    }\n    if (cellIndex === 0) {\n      focusEditor(editor, [...tableParentPath, tableIndex, rowIndex - 1, tableSize[1] - 1]);\n    } else {\n      focusEditor(editor, [...tableParentPath, tableIndex, rowIndex, cellIndex - 1]);\n    }\n    const {\n      focus: newFocus\n    } = editor.selection;\n    Transforms.select(editor, {\n      focus: newFocus,\n      anchor: newFocus\n    });\n  }\n};\nexport const isLastTableCell = (editor, cellNode) => {\n  if (cellNode[0].type !== ELEMENT_TYPE.TABLE_CELL) return false;\n  const {\n    tableSize\n  } = getSelectedInfo(editor);\n  const lastRowIndex = tableSize[0] - 1;\n  const lastColumnIndex = tableSize[1] - 1;\n  const cellNodePath = cellNode[1];\n  const cellNodePathDeep = cellNodePath.length;\n  return cellNodePath[cellNodePathDeep - 1] === lastColumnIndex && cellNodePath[cellNodePathDeep - 2] === lastRowIndex;\n};\nconst getValidColor = color => {\n  if (!color) return '';\n  const validColor = color.length === 4 ? '#' + color.slice(1, 4).repeat(2) : color;\n  return validColor.toUpperCase();\n};\nexport const colorBlend = (c1, c2, ratio) => {\n  const color1 = getValidColor(c1);\n  const color2 = getValidColor(c2);\n  if (!color1 && !color2) return 'unset';\n  if (color1 && !color2) return color1;\n  if (!color1 && color2) return color2;\n  if (color1 === '#FFFFFF') return color2;\n  if (color2 === '#FFFFFF') return color1;\n  const validRatio = Math.max(Math.min(Number(ratio), 1), 0);\n  let r1 = parseInt(color1.substring(1, 3), 16);\n  let g1 = parseInt(color1.substring(3, 5), 16);\n  let b1 = parseInt(color1.substring(5, 7), 16);\n  let r2 = parseInt(color2.substring(1, 3), 16);\n  let g2 = parseInt(color2.substring(3, 5), 16);\n  let b2 = parseInt(color2.substring(5, 7), 16);\n  let r = Math.round(r1 * (1 - validRatio) + r2 * validRatio);\n  let g = Math.round(g1 * (1 - validRatio) + g2 * validRatio);\n  let b = Math.round(b1 * (1 - validRatio) + b2 * validRatio);\n  r = ('0' + (r || 0).toString(16)).slice(-2);\n  g = ('0' + (g || 0).toString(16)).slice(-2);\n  b = ('0' + (b || 0).toString(16)).slice(-2);\n  return '#' + r + g + b;\n};\nexport const getRowHeight = (element, rowIndex) => {\n  const {\n    style = {}\n  } = element;\n  const rowHeight = style[TABLE_ROW_STYLE.MIN_HEIGHT] || TABLE_ROW_MIN_HEIGHT;\n  return rowIndex === 0 ? rowHeight + 1 : rowHeight;\n};\nexport const getRowDomHeight = (editor, row) => {\n  let height = 0;\n  for (const cell of row.children) {\n    const {\n      is_combined,\n      rowspan = 1\n    } = cell;\n    if (is_combined || rowspan > 1) continue;\n    let cellDom = null;\n    try {\n      cellDom = ReactEditor.toDOMNode(editor, cell);\n    } catch (error) {\n      if (!cellDom) break;\n    }\n    height = cellDom.getBoundingClientRect().height;\n    break;\n  }\n  // if the row is empty, get the height from style\n  if (!height) {\n    height = row.style[TABLE_ROW_STYLE.MIN_HEIGHT] || TABLE_ROW_MIN_HEIGHT;\n  }\n  return height;\n};\nconst normalizeTableCell = (editor, cell) => {\n  if (!cell) return generateTableCell(editor);\n  let newCell = _objectSpread({\n    children: [{\n      text: '',\n      id: slugid.nice()\n    }]\n  }, cell);\n\n  // normalize cell children\n  let newCellChildren = [];\n  newCell.children.forEach(cellChild => {\n    const cellChildType = cellChild.type;\n    if (cellChildType === ELEMENT_TYPE.PARAGRAPH) {\n      newCellChildren.push(...cellChild.children);\n    } else {\n      newCellChildren.push(cellChild);\n    }\n  });\n  newCell.children = newCellChildren.map(item => {\n    if (item.BOLD) {\n      item.bold = item.BOLD;\n      delete item['BOLD'];\n    }\n    if (item.ITALIC) {\n      item.italic = item.ITALIC;\n      delete item['ITALIC'];\n    }\n    return item;\n  });\n\n  // normalize cell style\n  if (newCell.data) {\n    const cellStyle = _objectSpread({}, newCell.data);\n    delete newCell['data'];\n    Object.keys(cellStyle).forEach(cellStyleKey => {\n      if (cellStyleKey === 'align') {\n        cellStyle['text_align'] = cellStyle['align'];\n        delete cellStyle['align'];\n      }\n    });\n    newCell.style = cellStyle;\n  }\n  return newCell;\n};\nexport const normalizeTableELement = (editor, element) => {\n  if (element.type !== ELEMENT_TYPE.TABLE) {\n    const size = [element.children.length, element.children[0].children.length];\n    return generateEmptyTable(editor, {\n      size\n    });\n  }\n  let newElement = _objectSpread({}, element);\n  for (let i = 0; i < element.children.length; i++) {\n    const row = newElement.children[i];\n    for (let j = 0; j < row.children.length; j++) {\n      row.children[j] = normalizeTableCell(editor, row.children[j]);\n    }\n    newElement.children[i] = row;\n  }\n  return newElement;\n};\nexport const insertTableByTemplate = (editor, alternateColor) => {\n  const size = [4, 4];\n  const tableNode = generateEmptyTable(editor, {\n    size,\n    alternate_highlight_color: alternateColor,\n    alternate_highlight: true\n  });\n  const path = Editor.path(editor, editor.selection);\n  const insertPosition = getInsertPosition(editor);\n  handleInsertTable(editor, insertPosition, path, tableNode);\n};\n\n/**\n * @param {Editor} editor\n * @param {InsertPosition} insertPosition\n * @param {Path} path\n * @param {Node} tableNode\n * Insert table by insertPosition\n */\nexport const handleInsertTable = (editor, insertPosition, path, tableNode) => {\n  const {\n    selection\n  } = editor;\n  if (insertPosition === INSERT_POSITION.BEFORE) {\n    const insertPath = [path[0]];\n    Transforms.insertNodes(editor, tableNode, {\n      at: insertPath\n    });\n  } else if (insertPosition === INSERT_POSITION.AFTER) {\n    const insertPath = [path[0] + 1];\n    Transforms.insertNodes(editor, tableNode, {\n      at: insertPath\n    });\n  } else if (insertPosition === INSERT_POSITION.CURRENT) {\n    Transforms.splitNodes(editor, {\n      at: selection,\n      always: true\n    });\n    Transforms.insertNodes(editor, tableNode, {\n      at: selection.anchor\n    });\n  }\n};\nexport const getInsertPosition = editor => {\n  const {\n    selection\n  } = editor;\n  if (!selection) return INSERT_POSITION.CURRENT;\n  if (!Range.isCollapsed(selection)) return INSERT_POSITION.CURRENT;\n  const aboveNodeEntry = getAboveBlockNode(editor);\n  if (!aboveNodeEntry) return INSERT_POSITION.CURRENT;\n  const isAtStart = Editor.isStart(editor, selection.anchor, aboveNodeEntry[1]);\n  if (isAtStart) return INSERT_POSITION.BEFORE;\n  const isAtEnd = Editor.isEnd(editor, selection.anchor, aboveNodeEntry[1]);\n  if (isAtEnd) return INSERT_POSITION.AFTER;\n  return INSERT_POSITION.CURRENT;\n};\nexport const generateInheritStyle = (allowedInheritStyleList, style, cell) => {\n  const inheritStyle = _objectSpread({}, cell['inherit_style']) || {};\n  for (const key in style) {\n    if (Object.hasOwnProperty.call(style, key) && allowedInheritStyleList.includes(key)) {\n      inheritStyle[key] = style[key];\n    }\n  }\n  return inheritStyle;\n};\nexport const getCellInheritStyles = (editor, tablePath, rowIndex, colIndex) => {\n  var _table$children$rowIn, _tableCell$inherit_st;\n  const [tableNodeEntry] = Editor.nodes(editor, {\n    match: n => n.type === ELEMENT_TYPE.TABLE,\n    at: tablePath\n  });\n  if (!tableNodeEntry) return {};\n  const table = tableNodeEntry[0];\n  const tableCell = (_table$children$rowIn = table.children[rowIndex]) === null || _table$children$rowIn === void 0 ? void 0 : _table$children$rowIn.children[colIndex];\n  if (!tableCell) return {};\n  return (_tableCell$inherit_st = tableCell['inherit_style']) !== null && _tableCell$inherit_st !== void 0 ? _tableCell$inherit_st : {};\n};\nexport const getCellHighlightClassName = (primaryColorClassName, rowIndex) => {\n  let className = '';\n  if (rowIndex === 0) {\n    className = primaryColorClassName;\n  } else if (rowIndex % 2 === 0) {\n    className = TABLE_ALTERNATE_HIGHLIGHT_CLASS_MAP[primaryColorClassName];\n  }\n  return className;\n};\nexport const focusClosestCellWhenJustifyCellSize = (editor, adjustingCell) => {\n  const cellPath = ReactEditor.findPath(editor, adjustingCell);\n  focusEditor(editor, Editor.end(editor, cellPath));\n};\n\n// Search main cell of combined cell\nconst searchCombinedMainCell = (table, startRowIndex, startColIndex) => {\n  for (let rowIndex = startRowIndex; rowIndex >= 0; rowIndex--) {\n    const row = table.children[rowIndex];\n    for (let cellIndex = startColIndex; cellIndex >= 0; cellIndex--) {\n      const currentCell = row.children[cellIndex];\n      const {\n        colspan = 0,\n        rowspan = 0\n      } = currentCell;\n      if (colspan <= 1 && rowspan <= 1) continue;\n      const isInColRange = cellIndex + colspan >= startColIndex;\n      const isInRowRange = rowIndex + rowspan >= startRowIndex;\n      if (isInColRange && isInRowRange) {\n        return {\n          currentCell,\n          rowIndex,\n          cellIndex\n        };\n      } else break;\n    }\n  }\n};\nexport const getResizeMaskCellInfo = (editor, table, rowIndex, cellIndex) => {\n  // The cell shown cursor as resize (mouse is on this cell)\n  const focusCellIndex = cellIndex;\n  let focusCell = table.children[rowIndex].children[cellIndex];\n  // The cell dominating resize handlers (the true cell to be resized)\n  let cell = table.children[rowIndex].children[cellIndex];\n  // Resolve combined cell\n  if (cell.is_combined) {\n    const targetCellInfo = searchCombinedMainCell(table, rowIndex, cellIndex);\n    cellIndex = targetCellInfo.cellIndex;\n    rowIndex = targetCellInfo.rowIndex;\n    cell = targetCellInfo.currentCell;\n  }\n  const columns = table.columns;\n  const focussedCell = ReactEditor.toDOMNode(editor, cell);\n  const {\n    colspan,\n    rowspan\n  } = focusCell;\n  let width = columns[cellIndex].width;\n  let height = focussedCell.getBoundingClientRect().height;\n  // Calculate cell width and height\n  if (colspan > 1) {\n    let index = cellIndex + 1;\n    while (index < cellIndex + colspan) {\n      width += columns[index].width;\n      index++;\n    }\n  }\n  if (rowspan > 1) {\n    let index = rowIndex + 1;\n    while (index < rowIndex + rowspan) {\n      const currentCell = table.children[index].children[cellIndex];\n      const currentHeight = ReactEditor.toDOMNode(editor, currentCell).getBoundingClientRect().height;\n      height += currentHeight;\n      index++;\n    }\n  }\n  return {\n    width,\n    height,\n    top: focussedCell.offsetTop,\n    left: focussedCell.offsetLeft,\n    rowIndex,\n    cellIndex,\n    cell,\n    focusCellIndex\n  };\n};\n\n// Table alternate highlight\nexport const getHighlightClass = (editor, cellPath) => {\n  var _tableEntry$;\n  const [tableEntry] = Editor.nodes(editor, {\n    at: cellPath,\n    match: n => n.type === ELEMENT_TYPE.TABLE\n  });\n  const {\n    alternate_highlight,\n    alternate_highlight_color\n  } = ((_tableEntry$ = tableEntry[0]) === null || _tableEntry$ === void 0 ? void 0 : _tableEntry$.ui) || {};\n  if (!alternate_highlight) return '';\n  const rowIndex = cellPath[cellPath.length - 2];\n  const className = getCellHighlightClassName(alternate_highlight_color, rowIndex);\n  return className;\n};\n\n// Correct the selected range when combined cell are selected\nexport const adjustCombinedCellRange = (table, range) => {\n  const {\n    minRowIndex,\n    maxRowIndex,\n    minColIndex,\n    maxColIndex\n  } = range;\n  const firstCell = table.children[minRowIndex].children[minColIndex];\n  const {\n    colspan = 0,\n    rowspan = 0\n  } = firstCell;\n  if (rowspan > 1 || colspan > 1) {\n    const isRowCombined = minRowIndex + rowspan === maxRowIndex + 1;\n    const isColCombined = minColIndex + colspan === maxColIndex + 1;\n    if (isRowCombined && isColCombined) return EMPTY_SELECTED_RANGE;\n  }\n  return range;\n};\n\n/**\n *  Do not reset table selected range, when drag table column / row\n * @param {MouseEvent} event\n * @returns {Boolean}\n */\nexport const isPreventResetTableSelectedRange = event => {\n  const {\n    target\n  } = event;\n  const draggable = target.getAttribute('draggable');\n  const isColumnHeader = target.classList.contains('sdoc-table-column-header');\n  const isRowHeader = target.classList.contains('sdoc-table-row-header');\n  const isHeader = isColumnHeader || isRowHeader;\n  const isPreventReset = isHeader || draggable === 'true';\n  return isPreventReset;\n};\n\n/**\n * Check drag type, column or row\n */\nexport const getTableDragType = (table, selectedRange) => {\n  const rowCount = table.children.length;\n  const {\n    minRowIndex,\n    maxRowIndex\n  } = selectedRange;\n  const isSelectColumn = minRowIndex === 0 && maxRowIndex === rowCount - 1;\n  return isSelectColumn ? DRAG_HANDLER_COLUMN : DRAG_HANDLER_ROW;\n};\nconst updateTableColumns = (editor, table, targetColIndex, startColIndex, endColIndex) => {\n  const columns = [...table.columns];\n  const deleteCount = endColIndex - startColIndex + 1;\n  const newColumns = columns.splice(startColIndex, deleteCount);\n  columns.splice(targetColIndex, 0, ...newColumns);\n  updateColumnWidth(editor, table, columns);\n};\nexport const moveColumns = (editor, targetColIndex, startColIndex, endColIndex) => {\n  // Get selected table information\n  const {\n    table,\n    tablePath\n  } = getSelectedInfo(editor);\n  // Check if moving columns forward or backward\n  const isMoveToFroward = targetColIndex < startColIndex;\n\n  // Iterate over each row in the table\n  table.children.forEach((row, rowIndex) => {\n    if (isMoveToFroward) {\n      // Calculate target and source paths for moving columns forward\n      const targetPath = [...tablePath, rowIndex, targetColIndex];\n      const sourcePath = [...tablePath, rowIndex, endColIndex];\n\n      // Move columns forward by inserting nodes\n      for (let insertIndex = endColIndex; insertIndex >= startColIndex; insertIndex--) {\n        const insertNode = row.children[insertIndex];\n        Transforms.removeNodes(editor, {\n          at: sourcePath\n        });\n        Transforms.insertNodes(editor, insertNode, {\n          at: targetPath\n        });\n      }\n    } else {\n      // Calculate target and source paths for moving columns backward\n      const targetPath = [...tablePath, rowIndex, targetColIndex - 1];\n      const sourcePath = [...tablePath, rowIndex, startColIndex];\n\n      // Move columns backward by inserting nodes\n      for (let insertIndex = startColIndex; insertIndex <= endColIndex; insertIndex++) {\n        const insertNode = row.children[insertIndex];\n        Transforms.removeNodes(editor, {\n          at: sourcePath\n        });\n        Transforms.insertNodes(editor, insertNode, {\n          at: targetPath\n        });\n      }\n    }\n  });\n\n  // Update table columns after moving\n  updateTableColumns(editor, table, targetColIndex, startColIndex, endColIndex);\n\n  // Set new selected range after moving columns\n  const newSelectRange = {\n    minRowIndex: 0,\n    maxRowIndex: table.children.length - 1,\n    minColIndex: targetColIndex,\n    maxColIndex: targetColIndex + endColIndex - startColIndex\n  };\n  setTableSelectedRange(editor, newSelectRange);\n};\n\n/**\n * Calculate the new selected range after dragging a column or row in the table.\n * @param {Object} table - The table object containing columns and rows.\n * @param {string} moveType - The type of drag operation (DRAG_HANDLER_COLUMN for column, DRAG_HANDLER_ROW for row).\n * @param {number} targetIndex - The index of the target column or row after dragging.\n * @param {number} startIndex - The index of the starting column or row before dragging.\n * @param {number} endIndex - The index of the ending column or row before dragging.\n * @returns {Object} - The new selected range after the drag operation.\n */\nexport const getTableSelectedRangeAfterDrag = (table, moveType, targetIndex, startIndex, endIndex) => {\n  // Calculate the total number of columns and rows in the table\n  const colCount = table.columns.length;\n  const rowCount = table.children.length;\n\n  // Initialize the new selected range with full table range\n  const newSelectRange = {\n    minRowIndex: 0,\n    maxRowIndex: rowCount - 1,\n    minColIndex: 0,\n    maxColIndex: colCount - 1\n  };\n\n  // Determine if the drag movement is forward or backward\n  const isMoveToFroward = targetIndex < startIndex;\n\n  // Adjust selected range based on the type of drag operation\n  if (moveType === DRAG_HANDLER_COLUMN) {\n    if (isMoveToFroward) {\n      newSelectRange.minColIndex = targetIndex;\n      newSelectRange.maxColIndex = targetIndex + endIndex - startIndex;\n    } else {\n      const moveCount = endIndex - startIndex + 1;\n      newSelectRange.minColIndex = targetIndex - moveCount;\n      newSelectRange.maxColIndex = targetIndex - 1;\n    }\n  } else {\n    if (isMoveToFroward) {\n      newSelectRange.minRowIndex = targetIndex;\n      newSelectRange.maxRowIndex = targetIndex + endIndex - startIndex;\n    } else {\n      const moveCount = endIndex - startIndex + 1;\n      newSelectRange.minRowIndex = targetIndex - moveCount;\n      newSelectRange.maxRowIndex = targetIndex - 1;\n    }\n  }\n  return newSelectRange;\n};\nexport const moveRows = (editor, targetRowIndex, startRowIndex, endRowIndex) => {\n  const {\n    table,\n    tablePath\n  } = getSelectedInfo(editor);\n  const isMoveToFroward = targetRowIndex < startRowIndex;\n  const targetPath = [...tablePath, isMoveToFroward ? targetRowIndex : targetRowIndex - 1];\n  const sourcePath = [...tablePath, isMoveToFroward ? endRowIndex : startRowIndex];\n  if (isMoveToFroward) {\n    for (let insertIndex = endRowIndex; insertIndex >= startRowIndex; insertIndex--) {\n      const insertNode = table.children[insertIndex];\n      Transforms.removeNodes(editor, {\n        at: sourcePath\n      });\n      Transforms.insertNodes(editor, insertNode, {\n        at: targetPath\n      });\n    }\n  } else {\n    for (let insertIndex = startRowIndex; insertIndex <= endRowIndex; insertIndex++) {\n      const insertNode = table.children[insertIndex];\n      Transforms.removeNodes(editor, {\n        at: sourcePath\n      });\n      Transforms.insertNodes(editor, insertNode, {\n        at: targetPath\n      });\n    }\n  }\n  const newSelectRange = {\n    minRowIndex: targetRowIndex,\n    maxRowIndex: targetRowIndex + endRowIndex - startRowIndex,\n    minColIndex: 0,\n    maxColIndex: table.children.length - 1\n  };\n  setTableSelectedRange(editor, newSelectRange);\n};\nexport const generateDragMoveElement = tipText => {\n  const canvasId = 'sdoc-drag-image';\n  let canvas = document.getElementById(canvasId);\n  if (!canvas) {\n    let dpr = window.devicePixelRatio;\n    canvas = document.createElement('canvas');\n    canvas.width = 115;\n    canvas.height = 30;\n    canvas.id = canvasId;\n    document.body.appendChild(canvas);\n    let {\n      width: cssWidth,\n      height: cssHeight\n    } = canvas.getBoundingClientRect();\n    canvas.style.width = canvas.width + 'px';\n    canvas.style.height = canvas.height + 'px';\n    canvas.width = dpr * cssWidth;\n    canvas.height = dpr * cssHeight;\n    canvas.style.position = 'fixed';\n  }\n  canvas.style.display = 'block';\n  const context = canvas.getContext('2d');\n  context.clearRect(0, 0, canvas.width, canvas.height);\n  context.fillStyle = 'rgb(241,243,246)';\n  context.fillRect(0, 0, canvas.width, canvas.height);\n  context.font = '22px Arial';\n  context.textBaseline = 'middle';\n  context.textAlign = 'center';\n  context.fillStyle = 'black';\n  context.fillText(tipText, canvas.width / 2, canvas.height / 2);\n  return canvas;\n};\nexport const isHideDragHandlerLine = (editor, displayType, table, cellPath, isDragOverCellHalf) => {\n  const pathLength = cellPath.length;\n  let rowIndex = cellPath[pathLength - 2];\n  let cellIndex = cellPath[pathLength - 1];\n\n  // Check is above cell selected\n  let currentCellDom = ReactEditor.toDOMNode(editor, table.children[rowIndex].children[cellIndex]);\n  let isCurrentCellSelected = currentCellDom.classList.contains(CELL_SELECTED);\n  if (isCurrentCellSelected) return true;\n  if (isDragOverCellHalf) {\n    if (displayType === DRAG_HANDLER_COLUMN) {\n      cellIndex = cellIndex + 1;\n    } else {\n      rowIndex = rowIndex + 1;\n    }\n  }\n  const isEndOfRowOrColumn = displayType === DRAG_HANDLER_COLUMN && cellIndex === table.columns.length || displayType === DRAG_HANDLER_ROW && rowIndex === table.children.length;\n  if (isEndOfRowOrColumn) return false;\n  let preCellDom = null;\n  if (displayType === DRAG_HANDLER_COLUMN && cellIndex > 0) {\n    const prevCell = table.children[rowIndex].children[cellIndex - 1];\n    preCellDom = ReactEditor.toDOMNode(editor, prevCell);\n  } else if (displayType === DRAG_HANDLER_ROW && rowIndex > 0) {\n    const prevCell = table.children[rowIndex - 1].children[cellIndex];\n    preCellDom = ReactEditor.toDOMNode(editor, prevCell);\n  }\n\n  // Check is above cell selected\n  currentCellDom = ReactEditor.toDOMNode(editor, table.children[rowIndex].children[cellIndex]);\n  isCurrentCellSelected = currentCellDom.classList.contains(CELL_SELECTED);\n  if (isCurrentCellSelected) return true;\n\n  // Check if the previous cell is selected\n  const isPrevCellSelected = preCellDom && preCellDom.classList.contains(CELL_SELECTED);\n  if (isPrevCellSelected) return true;\n  let isCombined = false;\n  // Check if the combined cell\n  if (displayType === DRAG_HANDLER_COLUMN) {\n    isCombined = table.children.some(row => row.children[cellIndex - isDragOverCellHalf].is_combined);\n  } else {\n    isCombined = table.children[rowIndex - isDragOverCellHalf].children.some(cell => cell.is_combined);\n  }\n  if (isCombined) return true;\n\n  // Check is the last column\n  if (displayType === DRAG_HANDLER_COLUMN) {\n    const isLastColumn = cellIndex === table.columns.length - 1;\n    if (isLastColumn) return false;\n  }\n};\nexport const getTableRowSelectedRange = (table, rowIndex) => {\n  const row = table.children[rowIndex];\n  const columnCount = row.children.length;\n  let minRowIndex = rowIndex;\n  let maxRowIndex = rowIndex;\n  let minColIndex = 0;\n  let maxColIndex = columnCount - 1;\n  const findRowRange = findRowIndex => {\n    let checkRow = table.children[findRowIndex];\n    const combinedIndexes = checkRow.children.reduce((acc, cell, index) => {\n      if (cell.is_combined) acc.push(index);\n      if (cell.rowspan > 1) {\n        maxRowIndex = Math.max(maxRowIndex, findRowIndex + cell.rowspan - 1);\n        findRowRange(maxRowIndex);\n      }\n      return acc;\n    }, []);\n    combinedIndexes.some(combinedIndex => {\n      const {\n        rowIndex: mainCellRowIndex,\n        currentCell\n      } = searchCombinedMainCell(table, findRowIndex, combinedIndex);\n      if (minRowIndex > mainCellRowIndex) {\n        minRowIndex = mainCellRowIndex;\n        findRowRange(minRowIndex, 0);\n        return false;\n      } else if (maxRowIndex < mainCellRowIndex + currentCell.rowspan - 1) {\n        maxRowIndex = mainCellRowIndex + currentCell.rowspan - 1;\n        findRowRange(maxRowIndex, 0);\n        return false;\n      }\n      return false;\n    });\n  };\n  findRowRange(rowIndex);\n  return {\n    minRowIndex,\n    maxRowIndex,\n    minColIndex,\n    maxColIndex\n  };\n};\nexport const getTableColumnSelectedRange = (table, columnIndex) => {\n  let minRowIndex = 0;\n  let maxRowIndex = table.children.length - 1;\n  let minColIndex = columnIndex;\n  let maxColIndex = columnIndex;\n  const findColRange = findColIndex => {\n    let combinedIndexes = [];\n    table.children.forEach((row, rowIndex) => {\n      const cell = row.children[findColIndex];\n      if (cell.is_combined) combinedIndexes.push(rowIndex);\n      if (cell.colspan > 1) {\n        maxColIndex = Math.max(maxColIndex, findColIndex + cell.colspan - 1);\n        findColRange(maxColIndex);\n      }\n    });\n    combinedIndexes.some(combinedIndex => {\n      const {\n        cellIndex: mainCellColIndex,\n        currentCell\n      } = searchCombinedMainCell(table, combinedIndex, findColIndex);\n      if (minColIndex > mainCellColIndex) {\n        minColIndex = mainCellColIndex;\n        findColRange(minColIndex, 0);\n        return false;\n      } else if (maxColIndex < mainCellColIndex + currentCell.colspan - 1) {\n        maxColIndex = mainCellColIndex + currentCell.colspan - 1;\n        findColRange(maxColIndex, 0);\n        return false;\n      }\n      return false;\n    });\n  };\n  findColRange(columnIndex);\n  return {\n    minRowIndex,\n    maxRowIndex,\n    minColIndex,\n    maxColIndex\n  };\n};\nexport const isTableWidthFitScreen = editor => {\n  const {\n    table\n  } = getSelectedInfo(editor);\n  const tableNode = ReactEditor.toDOMNode(editor, table);\n  if (!tableNode) return;\n  const tableDom = tableNode.querySelector('.sdoc-table-scroll-wrapper');\n  const {\n    width: tableWidth\n  } = tableDom.getBoundingClientRect();\n  const sdocWidth = editor.width;\n  if (tableWidth >= sdocWidth) return true;\n  return false;\n};\nexport const fitTableColumnToScreen = editor => {\n  const {\n    table,\n    tablePath\n  } = getSelectedInfo(editor);\n  const colCount = table.columns.length;\n  const columnWidth = Math.max(TABLE_CELL_MIN_WIDTH, parseInt(editor.width / colCount));\n  const columns = table.columns.map(column => _objectSpread(_objectSpread({}, column), {}, {\n    width: columnWidth\n  }));\n  Transforms.setNodes(editor, {\n    columns\n  }, {\n    at: tablePath\n  });\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}