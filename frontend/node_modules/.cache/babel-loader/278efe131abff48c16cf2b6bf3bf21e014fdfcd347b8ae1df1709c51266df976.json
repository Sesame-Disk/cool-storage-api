{"ast":null,"code":"\"use strict\";\n\nvar _objectWithoutProperties = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/objectWithoutProperties.js\").default;\nvar _toConsumableArray = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _slicedToArray = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _objectSpread = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _excluded = [\"at\"];\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTextNode = exports.isStartPoint = exports.isSelectionAtBlockStart = exports.isSelectionAtBlockEnd = exports.isRangeAcrossBlocks = exports.isLastNode = exports.isLastChild = exports.isFirstNode = exports.isFirstChild = exports.isEndPoint = exports.isBlockTextEmptyAfterSelection = exports.isBlockAboveEmpty = exports.isAncestorEmpty = exports.getSelectedNodeEntryByTypes = exports.getSelectedNodeEntryByType = exports.getSelectedNodeByTypes = exports.getSelectedNodeByType = exports.getSelectedElems = exports.getQueryOptions = exports.getPreviousPath = exports.getPrevNode = exports.getParentNode = exports.getNodes = exports.getNodeType = exports.getNodePathById = exports.getNodeEntries = exports.getNode = exports.getNextSiblingNodes = exports.getNextNode = exports.getLastChildPath = exports.getLastChild = exports.getInlineNodes = exports.getEditorString = exports.getDeepInlineChildren = exports.getCommonNode = exports.getChildren = exports.getAboveNode = exports.getAboveBlockNode = exports.findPath = exports.findNode = exports.findDescendant = void 0;\nvar _slate = require(\"slate\");\nvar _slateReact = require(\"slate-react\");\nvar _slugid = _interopRequireDefault(require(\"slugid\"));\nvar _utils = require(\"../utils\");\nvar _elementTypes = require(\"../../constants/element-types\");\n// options\nvar getQueryOptions = function getQueryOptions(editor, options) {\n  var _match = options.match,\n    block = options.block;\n  var newMatch = undefined;\n  if (_match || block) {\n    newMatch = function newMatch(n, path) {\n      return (0, _utils.match)(n, path, _match) && (!block || _slate.Editor.isBlock(editor, n));\n    };\n  }\n  return _objectSpread(_objectSpread({}, options), {}, {\n    match: newMatch\n  });\n};\nexports.getQueryOptions = getQueryOptions;\nvar findPath = function findPath(editor, node, defaultPath) {\n  try {\n    return _slateReact.ReactEditor.findPath(editor, node);\n  } catch (_unused) {\n    return defaultPath;\n  }\n};\n\n// get node\nexports.findPath = findPath;\nvar getNode = function getNode(editor, path) {\n  var node = null;\n  try {\n    node = _slate.Node.get(editor, path);\n  } catch (err) {\n    node = null;\n  }\n  return node;\n};\nexports.getNode = getNode;\nvar getNodeType = function getNodeType(node) {\n  return _slate.Element.isElement(node) ? node.type : '';\n};\nexports.getNodeType = getNodeType;\nvar getParentNode = function getParentNode(nodes, nodeId) {\n  var parentNode;\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var childrenNodes = node.children;\n    if (!Array.isArray(childrenNodes)) continue;\n    if (childrenNodes.find(function (node) {\n      return node.id === nodeId;\n    })) {\n      parentNode = node;\n    } else {\n      parentNode = getParentNode(childrenNodes, nodeId);\n    }\n    if (!parentNode) continue;\n    break;\n  }\n  return parentNode;\n};\nexports.getParentNode = getParentNode;\nvar getNodes = function getNodes(node, options) {\n  return _slate.Node.nodes(node, options);\n};\nexports.getNodes = getNodes;\nvar getCommonNode = function getCommonNode(root, path, ancestor) {\n  return _slate.Node.common(root, path, ancestor);\n};\nexports.getCommonNode = getCommonNode;\nvar getSelectedNodeByType = function getSelectedNodeByType(editor, type) {\n  var match = function match(n) {\n    return getNodeType(n) === type;\n  };\n  var _slate$Editor$nodes = _slate.Editor.nodes(editor, {\n      match: match,\n      universal: true\n    }),\n    _slate$Editor$nodes2 = _slicedToArray(_slate$Editor$nodes, 1),\n    nodeEntry = _slate$Editor$nodes2[0];\n  return nodeEntry ? nodeEntry[0] : null;\n};\nexports.getSelectedNodeByType = getSelectedNodeByType;\nvar getSelectedNodeByTypes = function getSelectedNodeByTypes(editor, types) {\n  var match = function match(n) {\n    return types.includes(getNodeType(n));\n  };\n  var _slate$Editor$nodes3 = _slate.Editor.nodes(editor, {\n      match: match,\n      universal: true\n    }),\n    _slate$Editor$nodes4 = _slicedToArray(_slate$Editor$nodes3, 1),\n    nodeEntry = _slate$Editor$nodes4[0];\n  return nodeEntry ? nodeEntry[0] : null;\n};\nexports.getSelectedNodeByTypes = getSelectedNodeByTypes;\nvar getSelectedNodeEntryByType = function getSelectedNodeEntryByType(editor, type) {\n  var match = function match(n) {\n    return getNodeType(n) === type;\n  };\n  var _slate$Editor$nodes5 = _slate.Editor.nodes(editor, {\n      match: match,\n      universal: false\n    }),\n    _slate$Editor$nodes6 = _slicedToArray(_slate$Editor$nodes5, 1),\n    nodeEntry = _slate$Editor$nodes6[0];\n  return nodeEntry ? nodeEntry : null;\n};\nexports.getSelectedNodeEntryByType = getSelectedNodeEntryByType;\nvar getSelectedNodeEntryByTypes = function getSelectedNodeEntryByTypes(editor, types) {\n  var match = function match(n) {\n    return types.includes(getNodeType(n));\n  };\n  var _slate$Editor$nodes7 = _slate.Editor.nodes(editor, {\n      match: match,\n      universal: false\n    }),\n    _slate$Editor$nodes8 = _slicedToArray(_slate$Editor$nodes7, 1),\n    nodeEntry = _slate$Editor$nodes8[0];\n  return nodeEntry ? nodeEntry : null;\n};\nexports.getSelectedNodeEntryByTypes = getSelectedNodeEntryByTypes;\nvar getNodeEntries = function getNodeEntries(editor, options) {\n  return _slate.Editor.nodes(editor, getQueryOptions(editor, options));\n};\nexports.getNodeEntries = getNodeEntries;\nvar getEditorString = function getEditorString(editor, at, options) {\n  if (!at) return '';\n  try {\n    return _slate.Editor.string(editor, at, options);\n  } catch (error) {\n    return '';\n  }\n};\n\n// children & child\nexports.getEditorString = getEditorString;\nvar getChildren = function getChildren(nodeEntry) {\n  var _nodeEntry = _slicedToArray(nodeEntry, 2),\n    node = _nodeEntry[0],\n    path = _nodeEntry[1];\n  if (_slate.Element.isAncestor(node)) {\n    var children = node.children;\n    return children.map(function (child, index) {\n      var childPath = path.concat([index]);\n      return [child, childPath];\n    });\n  }\n  return [];\n};\nexports.getChildren = getChildren;\nvar getLastChild = function getLastChild(nodeEntry) {\n  var _nodeEntry2 = _slicedToArray(nodeEntry, 2),\n    node = _nodeEntry2[0],\n    path = _nodeEntry2[1];\n  if (_slate.Text.isText(node)) return null;\n  if (!node.children.length) return null;\n  var children = node.children;\n  return [children[children.length - 1], path.concat([children.length - 1])];\n};\nexports.getLastChild = getLastChild;\nvar getDeepInlineChildren = function getDeepInlineChildren(editor, _ref) {\n  var children = _ref.children;\n  var inlineChildren = [];\n  var _iterator = _createForOfIteratorHelper(children),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var child = _step.value;\n      if (_slate.Editor.isBlock(editor, child[0])) {\n        inlineChildren.push.apply(inlineChildren, _toConsumableArray(getDeepInlineChildren(editor, {\n          children: getChildren(child)\n        })));\n      } else {\n        inlineChildren.push(child);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return inlineChildren;\n};\nexports.getDeepInlineChildren = getDeepInlineChildren;\nvar getLastChildPath = function getLastChildPath(nodeEntry) {\n  var lastChild = getLastChild(nodeEntry);\n  if (!lastChild) return nodeEntry[1].concat([-1]);\n  return lastChild[1];\n};\nexports.getLastChildPath = getLastChildPath;\nvar getPreviousPath = function getPreviousPath(path) {\n  if (path.length === 0) return;\n  var last = path[path.length - 1];\n  if (last <= 0) return;\n  return path.slice(0, -1).concat(last - 1);\n};\nexports.getPreviousPath = getPreviousPath;\nvar isFirstChild = function isFirstChild(nodeEntry, childPath) {\n  var children = getChildren(nodeEntry);\n  var firstChild = children[0] || [];\n  var firstChildPath = firstChild[1];\n  return _slate.Path.equals(firstChildPath, childPath);\n};\nexports.isFirstChild = isFirstChild;\nvar isLastChild = function isLastChild(nodeEntry, childPath) {\n  var lastChildPath = getLastChildPath(nodeEntry);\n  return _slate.Path.equals(lastChildPath, childPath);\n};\nexports.isLastChild = isLastChild;\nvar getSelectedElems = function getSelectedElems(editor) {\n  var elems = [];\n  var nodeEntries = _slate.Editor.nodes(editor, {\n    universal: true\n  });\n  var _iterator2 = _createForOfIteratorHelper(nodeEntries),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var nodeEntry = _step2.value;\n      var _nodeEntry3 = _slicedToArray(nodeEntry, 1),\n        node = _nodeEntry3[0];\n      if (_slate.Element.isElement(node)) elems.push(node);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return elems;\n};\n\n// siblings\nexports.getSelectedElems = getSelectedElems;\nvar getNextSiblingNodes = function getNextSiblingNodes(ancestorEntry, path) {\n  var _ancestorEntry = _slicedToArray(ancestorEntry, 2),\n    ancestor = _ancestorEntry[0],\n    ancestorPath = _ancestorEntry[1];\n  var leafIndex = path[ancestorPath.length];\n  var siblings = [];\n  var ancestorChildren = ancestor.children;\n  if (leafIndex + 1 < ancestor.children.length) {\n    for (var i = leafIndex + 1; i < ancestor.children.length; i++) {\n      siblings.push(ancestorChildren[i]);\n    }\n  }\n  return siblings;\n};\n\n// parent\nexports.getNextSiblingNodes = getNextSiblingNodes;\nvar getAboveNode = function getAboveNode(editor, options) {\n  return _slate.Editor.above(editor, getQueryOptions(editor, options));\n};\nexports.getAboveNode = getAboveNode;\nvar getAboveBlockNode = function getAboveBlockNode(editor, options) {\n  return getAboveNode(editor, _objectSpread(_objectSpread({}, options), {}, {\n    block: true\n  }));\n};\nexports.getAboveBlockNode = getAboveBlockNode;\nvar getPrevNode = function getPrevNode(editor) {\n  var _getAboveNode = getAboveNode(editor, {\n      mode: 'lowest',\n      match: function match(n) {\n        return _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n);\n      }\n    }),\n    _getAboveNode2 = _slicedToArray(_getAboveNode, 2),\n    lowerNode = _getAboveNode2[0],\n    lowerPath = _getAboveNode2[1];\n  var _getAboveNode3 = getAboveNode(editor, {\n      mode: 'highest',\n      match: function match(n) {\n        return _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n);\n      }\n    }),\n    _getAboveNode4 = _slicedToArray(_getAboveNode3, 2),\n    heightNode = _getAboveNode4[0],\n    heightPath = _getAboveNode4[1];\n  var prevNode = null;\n  try {\n    prevNode = _slate.Editor.previous(editor, {\n      at: lowerPath,\n      match: function match(n) {\n        return _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n);\n      }\n    });\n  } catch (error) {\n    prevNode = null;\n  }\n  if (lowerNode.id !== heightNode.id && !prevNode) {\n    try {\n      prevNode = _slate.Editor.previous(editor, {\n        at: heightPath,\n        match: function match(n) {\n          return _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n);\n        }\n      });\n    } catch (error) {\n      prevNode = null;\n    }\n  }\n  return prevNode;\n};\nexports.getPrevNode = getPrevNode;\nvar getNextNode = function getNextNode(editor) {\n  var _getAboveNode5 = getAboveNode(editor, {\n      mode: 'lowest',\n      match: function match(n) {\n        return _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n);\n      }\n    }),\n    _getAboveNode6 = _slicedToArray(_getAboveNode5, 2),\n    lowerNode = _getAboveNode6[0],\n    lowerPath = _getAboveNode6[1];\n  var _getAboveNode7 = getAboveNode(editor, {\n      mode: 'highest',\n      match: function match(n) {\n        return _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n);\n      }\n    }),\n    _getAboveNode8 = _slicedToArray(_getAboveNode7, 2),\n    heightNode = _getAboveNode8[0],\n    heightPath = _getAboveNode8[1];\n  var nextNode = null;\n  try {\n    nextNode = _slate.Editor.next(editor, {\n      at: lowerPath,\n      match: function match(n) {\n        return _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n);\n      }\n    });\n  } catch (error) {\n    nextNode = null;\n  }\n  if (lowerNode.id !== heightNode.id && !nextNode) {\n    try {\n      nextNode = _slate.Editor.next(editor, {\n        at: heightPath,\n        match: function match(n) {\n          return _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n);\n        }\n      });\n    } catch (error) {\n      nextNode = null;\n    }\n  }\n  return nextNode;\n};\n\n// find node\nexports.getNextNode = getNextNode;\nvar findNode = function findNode(editor, options) {\n  var nodeEntries = _slate.Editor.nodes(editor, _objectSpread({\n    at: editor.selection || []\n  }, getQueryOptions(editor, options)));\n  var _nodeEntries = Array.from(nodeEntries);\n  if (_nodeEntries[0]) {\n    return _nodeEntries[0];\n  }\n  return undefined;\n};\nexports.findNode = findNode;\nvar findDescendant = function findDescendant(editor, options) {\n  var _options$at = options.at,\n    at = _options$at === void 0 ? editor.selection : _options$at,\n    _options$reverse = options.reverse,\n    reverse = _options$reverse === void 0 ? false : _options$reverse,\n    _options$voids = options.voids,\n    voids = _options$voids === void 0 ? false : _options$voids,\n    _match = options.match;\n  if (!at) return;\n  var from;\n  var to;\n  if (_slate.Span.isSpan(at)) {\n    var _at = _slicedToArray(at, 2);\n    from = _at[0];\n    to = _at[1];\n  } else if (_slate.Range.isRange(at)) {\n    var first = _slate.Editor.first(editor, at);\n    var last = _slate.Editor.last(editor, at);\n    from = reverse ? last : first;\n    to = reverse ? first : last;\n  }\n  var root = [editor, []];\n  if (_slate.Path.isPath(at)) {\n    root = _slate.Editor.node(editor, at);\n  }\n  var nodeEntries = _slate.Node.descendants(root[0], {\n    from: from,\n    to: to,\n    reverse: reverse,\n    pass: function pass(_ref2) {\n      var _ref3 = _slicedToArray(_ref2, 1),\n        n = _ref3[0];\n      return voids ? false : _slate.Editor.isVoid(editor, n);\n    }\n  });\n  var _iterator3 = _createForOfIteratorHelper(nodeEntries),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _step3$value = _slicedToArray(_step3.value, 2),\n        node = _step3$value[0],\n        path = _step3$value[1];\n      if ((0, _utils.match)(node, path, _match)) {\n        return [node, at.concat(path)];\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return undefined;\n};\n\n// is\nexports.findDescendant = findDescendant;\nvar isStartPoint = function isStartPoint(editor, point, at) {\n  return !!point && _slate.Editor.isStart(editor, point, at);\n};\nexports.isStartPoint = isStartPoint;\nvar isEndPoint = function isEndPoint(editor, point, at) {\n  return !!point && _slate.Editor.isEnd(editor, point, at);\n};\nexports.isEndPoint = isEndPoint;\nvar isBlockTextEmptyAfterSelection = function isBlockTextEmptyAfterSelection(editor) {\n  if (!editor.selection) return false;\n  var blockAbove = _slate.Editor.above(editor, {\n    block: true\n  });\n  if (!blockAbove) return false;\n  var cursor = editor.selection.focus;\n  var selectionParentEntry = _slate.Editor.parent(editor, editor.selection);\n  if (!selectionParentEntry) return false;\n  var _selectionParentEntry = _slicedToArray(selectionParentEntry, 2),\n    selectionParentPath = _selectionParentEntry[1];\n  if (!isEndPoint(editor, cursor, selectionParentPath)) return false;\n  var siblingNodes = getNextSiblingNodes(blockAbove, cursor.path);\n  if (siblingNodes.length) {\n    // 子节点包含 文本节点\n    var _iterator4 = _createForOfIteratorHelper(siblingNodes),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var siblingNode = _step4.value;\n        if (_slate.Text.isText(siblingNode) && siblingNode.text) {\n          return false;\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  } else {\n    return isEndPoint(editor, cursor, blockAbove[1]);\n  }\n  return true;\n};\nexports.isBlockTextEmptyAfterSelection = isBlockTextEmptyAfterSelection;\nvar isRangeAcrossBlocks = function isRangeAcrossBlocks(editor) {\n  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    at = _ref4.at,\n    options = _objectWithoutProperties(_ref4, _excluded);\n  if (!at) at = editor.selection;\n  if (!at) return;\n  var _slate$Range$edges = _slate.Range.edges(at),\n    _slate$Range$edges2 = _slicedToArray(_slate$Range$edges, 2),\n    start = _slate$Range$edges2[0],\n    end = _slate$Range$edges2[1];\n  var startBlock = getAboveBlockNode(editor, _objectSpread({\n    at: start\n  }, options));\n  var endBlock = getAboveBlockNode(editor, _objectSpread({\n    at: end\n  }, options));\n  if (!startBlock && !endBlock) return;\n  if (!startBlock || !endBlock) return true;\n  return !_slate.Path.equals(startBlock[1], endBlock[1]);\n};\nexports.isRangeAcrossBlocks = isRangeAcrossBlocks;\nvar isAncestorEmpty = function isAncestorEmpty(editor, node) {\n  return !_slate.Node.string(node) && !node.children.some(function (n) {\n    return _slate.Editor.isInline(editor, n);\n  });\n};\nexports.isAncestorEmpty = isAncestorEmpty;\nvar isBlockAboveEmpty = function isBlockAboveEmpty(editor) {\n  var _getAboveBlockNode;\n  var block = (_getAboveBlockNode = getAboveBlockNode(editor)) === null || _getAboveBlockNode === void 0 ? void 0 : _getAboveBlockNode[0];\n  if (!block) return false;\n  return isAncestorEmpty(editor, block);\n};\nexports.isBlockAboveEmpty = isBlockAboveEmpty;\nvar isSelectionAtBlockStart = function isSelectionAtBlockStart(editor, options) {\n  var _getAboveBlockNode2;\n  var selection = editor.selection;\n  if (!selection) return false;\n  var path = (_getAboveBlockNode2 = getAboveBlockNode(editor, options)) === null || _getAboveBlockNode2 === void 0 ? void 0 : _getAboveBlockNode2[1];\n  if (!path) return false;\n  return isStartPoint(editor, selection.focus, path) || _slate.Range.isExpanded(editor.selection) && isStartPoint(editor, selection.anchor, path);\n};\nexports.isSelectionAtBlockStart = isSelectionAtBlockStart;\nvar isSelectionAtBlockEnd = function isSelectionAtBlockEnd(editor, options) {\n  var _getAboveBlockNode3, _editor$selection;\n  var path = (_getAboveBlockNode3 = getAboveBlockNode(editor, options)) === null || _getAboveBlockNode3 === void 0 ? void 0 : _getAboveBlockNode3[1];\n  return !!path && isEndPoint(editor, (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.focus, path);\n};\nexports.isSelectionAtBlockEnd = isSelectionAtBlockEnd;\nvar isFirstNode = function isFirstNode(editor, node) {\n  var editorChildren = editor.children || [];\n  return editorChildren[0] === node;\n};\nexports.isFirstNode = isFirstNode;\nvar isLastNode = function isLastNode(editor, node) {\n  var editorChildren = editor.children || [];\n  var editorChildrenLength = editorChildren.length;\n  return editorChildren[editorChildrenLength - 1] === node;\n};\nexports.isLastNode = isLastNode;\nvar isTextNode = function isTextNode(node) {\n  if (!node) return false;\n  if (Reflect.has(node, 'children')) return false;\n};\nexports.isTextNode = isTextNode;\nvar getInlineNodes = function getInlineNodes(node) {\n  if (!node.type) return [node];\n  // image\n  if (node.type === _elementTypes.IMAGE) return [node];\n  // link\n  if (node.type === _elementTypes.LINK) return [node];\n  // column\n  if (node.type === _elementTypes.COLUMN) return [node];\n  var children = node.children;\n  var defaultNode = {\n    id: _slugid.default.nice(),\n    text: ''\n  };\n  if (!children) return [defaultNode];\n  var result = children.map(function (item) {\n    // text\n    if (!item.type) return item;\n    // image\n    if (item.type === _elementTypes.IMAGE) return item;\n    // link\n    if (item.type === _elementTypes.LINK) return item;\n    // column\n    if (item.type === _elementTypes.COLUMN) return item;\n    return getInlineNodes(node);\n  });\n  return result.flat();\n};\nexports.getInlineNodes = getInlineNodes;\nvar getNodePathById = function getNodePathById(rootNode, nodeId) {\n  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  if (rootNode.id === nodeId) return path;\n  var _rootNode$children = rootNode.children,\n    children = _rootNode$children === void 0 ? [] : _rootNode$children;\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    path.push(i);\n    var nodePath = getNodePathById(child, nodeId, path);\n    if (nodePath) return nodePath;\n    path.pop();\n  }\n  return null;\n};\nexports.getNodePathById = getNodePathById;","map":{"version":3,"names":["_objectWithoutProperties","require","default","_toConsumableArray","_createForOfIteratorHelper","_slicedToArray","_objectSpread","_excluded","_interopRequireDefault","Object","defineProperty","exports","value","isTextNode","isStartPoint","isSelectionAtBlockStart","isSelectionAtBlockEnd","isRangeAcrossBlocks","isLastNode","isLastChild","isFirstNode","isFirstChild","isEndPoint","isBlockTextEmptyAfterSelection","isBlockAboveEmpty","isAncestorEmpty","getSelectedNodeEntryByTypes","getSelectedNodeEntryByType","getSelectedNodeByTypes","getSelectedNodeByType","getSelectedElems","getQueryOptions","getPreviousPath","getPrevNode","getParentNode","getNodes","getNodeType","getNodePathById","getNodeEntries","getNode","getNextSiblingNodes","getNextNode","getLastChildPath","getLastChild","getInlineNodes","getEditorString","getDeepInlineChildren","getCommonNode","getChildren","getAboveNode","getAboveBlockNode","findPath","findNode","findDescendant","_slate","_slateReact","_slugid","_utils","_elementTypes","editor","options","_match","match","block","newMatch","undefined","n","path","Editor","isBlock","node","defaultPath","ReactEditor","_unused","Node","get","err","Element","isElement","type","nodes","nodeId","parentNode","i","length","childrenNodes","children","Array","isArray","find","id","root","ancestor","common","_slate$Editor$nodes","universal","_slate$Editor$nodes2","nodeEntry","types","includes","_slate$Editor$nodes3","_slate$Editor$nodes4","_slate$Editor$nodes5","_slate$Editor$nodes6","_slate$Editor$nodes7","_slate$Editor$nodes8","at","string","error","_nodeEntry","isAncestor","map","child","index","childPath","concat","_nodeEntry2","Text","isText","_ref","inlineChildren","_iterator","_step","s","done","push","apply","e","f","lastChild","last","slice","firstChild","firstChildPath","Path","equals","lastChildPath","elems","nodeEntries","_iterator2","_step2","_nodeEntry3","ancestorEntry","_ancestorEntry","ancestorPath","leafIndex","siblings","ancestorChildren","above","_getAboveNode","mode","_getAboveNode2","lowerNode","lowerPath","_getAboveNode3","_getAboveNode4","heightNode","heightPath","prevNode","previous","_getAboveNode5","_getAboveNode6","_getAboveNode7","_getAboveNode8","nextNode","next","selection","_nodeEntries","from","_options$at","_options$reverse","reverse","_options$voids","voids","to","Span","isSpan","_at","Range","isRange","first","isPath","descendants","pass","_ref2","_ref3","isVoid","_iterator3","_step3","_step3$value","point","isStart","isEnd","blockAbove","cursor","focus","selectionParentEntry","parent","_selectionParentEntry","selectionParentPath","siblingNodes","_iterator4","_step4","siblingNode","text","_ref4","arguments","_slate$Range$edges","edges","_slate$Range$edges2","start","end","startBlock","endBlock","some","isInline","_getAboveBlockNode","_getAboveBlockNode2","isExpanded","anchor","_getAboveBlockNode3","_editor$selection","editorChildren","editorChildrenLength","Reflect","has","IMAGE","LINK","COLUMN","defaultNode","nice","result","item","flat","rootNode","_rootNode$children","nodePath","pop"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/seafile-editor/dist/extension/core/queries/index.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTextNode = exports.isStartPoint = exports.isSelectionAtBlockStart = exports.isSelectionAtBlockEnd = exports.isRangeAcrossBlocks = exports.isLastNode = exports.isLastChild = exports.isFirstNode = exports.isFirstChild = exports.isEndPoint = exports.isBlockTextEmptyAfterSelection = exports.isBlockAboveEmpty = exports.isAncestorEmpty = exports.getSelectedNodeEntryByTypes = exports.getSelectedNodeEntryByType = exports.getSelectedNodeByTypes = exports.getSelectedNodeByType = exports.getSelectedElems = exports.getQueryOptions = exports.getPreviousPath = exports.getPrevNode = exports.getParentNode = exports.getNodes = exports.getNodeType = exports.getNodePathById = exports.getNodeEntries = exports.getNode = exports.getNextSiblingNodes = exports.getNextNode = exports.getLastChildPath = exports.getLastChild = exports.getInlineNodes = exports.getEditorString = exports.getDeepInlineChildren = exports.getCommonNode = exports.getChildren = exports.getAboveNode = exports.getAboveBlockNode = exports.findPath = exports.findNode = exports.findDescendant = void 0;\nvar _slate = require(\"slate\");\nvar _slateReact = require(\"slate-react\");\nvar _slugid = _interopRequireDefault(require(\"slugid\"));\nvar _utils = require(\"../utils\");\nvar _elementTypes = require(\"../../constants/element-types\");\n// options\nconst getQueryOptions = (editor, options) => {\n  const {\n    match: _match,\n    block\n  } = options;\n  let newMatch = undefined;\n  if (_match || block) {\n    newMatch = (n, path) => (0, _utils.match)(n, path, _match) && (!block || _slate.Editor.isBlock(editor, n));\n  }\n  return {\n    ...options,\n    match: newMatch\n  };\n};\nexports.getQueryOptions = getQueryOptions;\nconst findPath = (editor, node, defaultPath) => {\n  try {\n    return _slateReact.ReactEditor.findPath(editor, node);\n  } catch {\n    return defaultPath;\n  }\n};\n\n// get node\nexports.findPath = findPath;\nconst getNode = (editor, path) => {\n  let node = null;\n  try {\n    node = _slate.Node.get(editor, path);\n  } catch (err) {\n    node = null;\n  }\n  return node;\n};\nexports.getNode = getNode;\nconst getNodeType = node => {\n  return _slate.Element.isElement(node) ? node.type : '';\n};\nexports.getNodeType = getNodeType;\nconst getParentNode = (nodes, nodeId) => {\n  let parentNode;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const {\n      children: childrenNodes\n    } = node;\n    if (!Array.isArray(childrenNodes)) continue;\n    if (childrenNodes.find(node => node.id === nodeId)) {\n      parentNode = node;\n    } else {\n      parentNode = getParentNode(childrenNodes, nodeId);\n    }\n    if (!parentNode) continue;\n    break;\n  }\n  return parentNode;\n};\nexports.getParentNode = getParentNode;\nconst getNodes = (node, options) => {\n  return _slate.Node.nodes(node, options);\n};\nexports.getNodes = getNodes;\nconst getCommonNode = (root, path, ancestor) => {\n  return _slate.Node.common(root, path, ancestor);\n};\nexports.getCommonNode = getCommonNode;\nconst getSelectedNodeByType = (editor, type) => {\n  const match = n => getNodeType(n) === type;\n  const [nodeEntry] = _slate.Editor.nodes(editor, {\n    match,\n    universal: true\n  });\n  return nodeEntry ? nodeEntry[0] : null;\n};\nexports.getSelectedNodeByType = getSelectedNodeByType;\nconst getSelectedNodeByTypes = (editor, types) => {\n  const match = n => types.includes(getNodeType(n));\n  const [nodeEntry] = _slate.Editor.nodes(editor, {\n    match,\n    universal: true\n  });\n  return nodeEntry ? nodeEntry[0] : null;\n};\nexports.getSelectedNodeByTypes = getSelectedNodeByTypes;\nconst getSelectedNodeEntryByType = (editor, type) => {\n  const match = n => getNodeType(n) === type;\n  const [nodeEntry] = _slate.Editor.nodes(editor, {\n    match,\n    universal: false\n  });\n  return nodeEntry ? nodeEntry : null;\n};\nexports.getSelectedNodeEntryByType = getSelectedNodeEntryByType;\nconst getSelectedNodeEntryByTypes = (editor, types) => {\n  const match = n => types.includes(getNodeType(n));\n  const [nodeEntry] = _slate.Editor.nodes(editor, {\n    match,\n    universal: false\n  });\n  return nodeEntry ? nodeEntry : null;\n};\nexports.getSelectedNodeEntryByTypes = getSelectedNodeEntryByTypes;\nconst getNodeEntries = (editor, options) => {\n  return _slate.Editor.nodes(editor, getQueryOptions(editor, options));\n};\nexports.getNodeEntries = getNodeEntries;\nconst getEditorString = (editor, at, options) => {\n  if (!at) return '';\n  try {\n    return _slate.Editor.string(editor, at, options);\n  } catch (error) {\n    return '';\n  }\n};\n\n// children & child\nexports.getEditorString = getEditorString;\nconst getChildren = nodeEntry => {\n  const [node, path] = nodeEntry;\n  if (_slate.Element.isAncestor(node)) {\n    const {\n      children\n    } = node;\n    return children.map((child, index) => {\n      const childPath = path.concat([index]);\n      return [child, childPath];\n    });\n  }\n  return [];\n};\nexports.getChildren = getChildren;\nconst getLastChild = nodeEntry => {\n  const [node, path] = nodeEntry;\n  if (_slate.Text.isText(node)) return null;\n  if (!node.children.length) return null;\n  const children = node.children;\n  return [children[children.length - 1], path.concat([children.length - 1])];\n};\nexports.getLastChild = getLastChild;\nconst getDeepInlineChildren = (editor, _ref) => {\n  let {\n    children\n  } = _ref;\n  const inlineChildren = [];\n  for (let child of children) {\n    if (_slate.Editor.isBlock(editor, child[0])) {\n      inlineChildren.push(...getDeepInlineChildren(editor, {\n        children: getChildren(child)\n      }));\n    } else {\n      inlineChildren.push(child);\n    }\n  }\n  return inlineChildren;\n};\nexports.getDeepInlineChildren = getDeepInlineChildren;\nconst getLastChildPath = nodeEntry => {\n  const lastChild = getLastChild(nodeEntry);\n  if (!lastChild) return nodeEntry[1].concat([-1]);\n  return lastChild[1];\n};\nexports.getLastChildPath = getLastChildPath;\nconst getPreviousPath = path => {\n  if (path.length === 0) return;\n  const last = path[path.length - 1];\n  if (last <= 0) return;\n  return path.slice(0, -1).concat(last - 1);\n};\nexports.getPreviousPath = getPreviousPath;\nconst isFirstChild = (nodeEntry, childPath) => {\n  const children = getChildren(nodeEntry);\n  const firstChild = children[0] || [];\n  const firstChildPath = firstChild[1];\n  return _slate.Path.equals(firstChildPath, childPath);\n};\nexports.isFirstChild = isFirstChild;\nconst isLastChild = (nodeEntry, childPath) => {\n  const lastChildPath = getLastChildPath(nodeEntry);\n  return _slate.Path.equals(lastChildPath, childPath);\n};\nexports.isLastChild = isLastChild;\nconst getSelectedElems = editor => {\n  const elems = [];\n  const nodeEntries = _slate.Editor.nodes(editor, {\n    universal: true\n  });\n  for (let nodeEntry of nodeEntries) {\n    const [node] = nodeEntry;\n    if (_slate.Element.isElement(node)) elems.push(node);\n  }\n  return elems;\n};\n\n// siblings\nexports.getSelectedElems = getSelectedElems;\nconst getNextSiblingNodes = (ancestorEntry, path) => {\n  const [ancestor, ancestorPath] = ancestorEntry;\n  const leafIndex = path[ancestorPath.length];\n  const siblings = [];\n  const ancestorChildren = ancestor.children;\n  if (leafIndex + 1 < ancestor.children.length) {\n    for (let i = leafIndex + 1; i < ancestor.children.length; i++) {\n      siblings.push(ancestorChildren[i]);\n    }\n  }\n  return siblings;\n};\n\n// parent\nexports.getNextSiblingNodes = getNextSiblingNodes;\nconst getAboveNode = (editor, options) => {\n  return _slate.Editor.above(editor, getQueryOptions(editor, options));\n};\nexports.getAboveNode = getAboveNode;\nconst getAboveBlockNode = (editor, options) => {\n  return getAboveNode(editor, {\n    ...options,\n    block: true\n  });\n};\nexports.getAboveBlockNode = getAboveBlockNode;\nconst getPrevNode = editor => {\n  const [lowerNode, lowerPath] = getAboveNode(editor, {\n    mode: 'lowest',\n    match: n => _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n)\n  });\n  const [heightNode, heightPath] = getAboveNode(editor, {\n    mode: 'highest',\n    match: n => _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n)\n  });\n  let prevNode = null;\n  try {\n    prevNode = _slate.Editor.previous(editor, {\n      at: lowerPath,\n      match: n => _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n)\n    });\n  } catch (error) {\n    prevNode = null;\n  }\n  if (lowerNode.id !== heightNode.id && !prevNode) {\n    try {\n      prevNode = _slate.Editor.previous(editor, {\n        at: heightPath,\n        match: n => _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n)\n      });\n    } catch (error) {\n      prevNode = null;\n    }\n  }\n  return prevNode;\n};\nexports.getPrevNode = getPrevNode;\nconst getNextNode = editor => {\n  const [lowerNode, lowerPath] = getAboveNode(editor, {\n    mode: 'lowest',\n    match: n => _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n)\n  });\n  const [heightNode, heightPath] = getAboveNode(editor, {\n    mode: 'highest',\n    match: n => _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n)\n  });\n  let nextNode = null;\n  try {\n    nextNode = _slate.Editor.next(editor, {\n      at: lowerPath,\n      match: n => _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n)\n    });\n  } catch (error) {\n    nextNode = null;\n  }\n  if (lowerNode.id !== heightNode.id && !nextNode) {\n    try {\n      nextNode = _slate.Editor.next(editor, {\n        at: heightPath,\n        match: n => _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n)\n      });\n    } catch (error) {\n      nextNode = null;\n    }\n  }\n  return nextNode;\n};\n\n// find node\nexports.getNextNode = getNextNode;\nconst findNode = (editor, options) => {\n  const nodeEntries = _slate.Editor.nodes(editor, {\n    at: editor.selection || [],\n    ...getQueryOptions(editor, options)\n  });\n  const _nodeEntries = Array.from(nodeEntries);\n  if (_nodeEntries[0]) {\n    return _nodeEntries[0];\n  }\n  return undefined;\n};\nexports.findNode = findNode;\nconst findDescendant = (editor, options) => {\n  const {\n    at = editor.selection,\n    reverse = false,\n    voids = false,\n    match: _match\n  } = options;\n  if (!at) return;\n  let from;\n  let to;\n  if (_slate.Span.isSpan(at)) {\n    [from, to] = at;\n  } else if (_slate.Range.isRange(at)) {\n    const first = _slate.Editor.first(editor, at);\n    const last = _slate.Editor.last(editor, at);\n    from = reverse ? last : first;\n    to = reverse ? first : last;\n  }\n  let root = [editor, []];\n  if (_slate.Path.isPath(at)) {\n    root = _slate.Editor.node(editor, at);\n  }\n  const nodeEntries = _slate.Node.descendants(root[0], {\n    from,\n    to,\n    reverse,\n    pass: _ref2 => {\n      let [n] = _ref2;\n      return voids ? false : _slate.Editor.isVoid(editor, n);\n    }\n  });\n  for (const [node, path] of nodeEntries) {\n    if ((0, _utils.match)(node, path, _match)) {\n      return [node, at.concat(path)];\n    }\n  }\n  return undefined;\n};\n\n// is\nexports.findDescendant = findDescendant;\nconst isStartPoint = (editor, point, at) => {\n  return !!point && _slate.Editor.isStart(editor, point, at);\n};\nexports.isStartPoint = isStartPoint;\nconst isEndPoint = (editor, point, at) => {\n  return !!point && _slate.Editor.isEnd(editor, point, at);\n};\nexports.isEndPoint = isEndPoint;\nconst isBlockTextEmptyAfterSelection = editor => {\n  if (!editor.selection) return false;\n  const blockAbove = _slate.Editor.above(editor, {\n    block: true\n  });\n  if (!blockAbove) return false;\n  const cursor = editor.selection.focus;\n  const selectionParentEntry = _slate.Editor.parent(editor, editor.selection);\n  if (!selectionParentEntry) return false;\n  const [, selectionParentPath] = selectionParentEntry;\n  if (!isEndPoint(editor, cursor, selectionParentPath)) return false;\n  const siblingNodes = getNextSiblingNodes(blockAbove, cursor.path);\n  if (siblingNodes.length) {\n    // 子节点包含 文本节点\n    for (const siblingNode of siblingNodes) {\n      if (_slate.Text.isText(siblingNode) && siblingNode.text) {\n        return false;\n      }\n    }\n  } else {\n    return isEndPoint(editor, cursor, blockAbove[1]);\n  }\n  return true;\n};\nexports.isBlockTextEmptyAfterSelection = isBlockTextEmptyAfterSelection;\nconst isRangeAcrossBlocks = function (editor) {\n  let {\n    at,\n    ...options\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!at) at = editor.selection;\n  if (!at) return;\n  const [start, end] = _slate.Range.edges(at);\n  const startBlock = getAboveBlockNode(editor, {\n    at: start,\n    ...options\n  });\n  const endBlock = getAboveBlockNode(editor, {\n    at: end,\n    ...options\n  });\n  if (!startBlock && !endBlock) return;\n  if (!startBlock || !endBlock) return true;\n  return !_slate.Path.equals(startBlock[1], endBlock[1]);\n};\nexports.isRangeAcrossBlocks = isRangeAcrossBlocks;\nconst isAncestorEmpty = (editor, node) => {\n  return !_slate.Node.string(node) && !node.children.some(n => _slate.Editor.isInline(editor, n));\n};\nexports.isAncestorEmpty = isAncestorEmpty;\nconst isBlockAboveEmpty = editor => {\n  var _getAboveBlockNode;\n  const block = (_getAboveBlockNode = getAboveBlockNode(editor)) === null || _getAboveBlockNode === void 0 ? void 0 : _getAboveBlockNode[0];\n  if (!block) return false;\n  return isAncestorEmpty(editor, block);\n};\nexports.isBlockAboveEmpty = isBlockAboveEmpty;\nconst isSelectionAtBlockStart = (editor, options) => {\n  var _getAboveBlockNode2;\n  const {\n    selection\n  } = editor;\n  if (!selection) return false;\n  const path = (_getAboveBlockNode2 = getAboveBlockNode(editor, options)) === null || _getAboveBlockNode2 === void 0 ? void 0 : _getAboveBlockNode2[1];\n  if (!path) return false;\n  return isStartPoint(editor, selection.focus, path) || _slate.Range.isExpanded(editor.selection) && isStartPoint(editor, selection.anchor, path);\n};\nexports.isSelectionAtBlockStart = isSelectionAtBlockStart;\nconst isSelectionAtBlockEnd = (editor, options) => {\n  var _getAboveBlockNode3, _editor$selection;\n  const path = (_getAboveBlockNode3 = getAboveBlockNode(editor, options)) === null || _getAboveBlockNode3 === void 0 ? void 0 : _getAboveBlockNode3[1];\n  return !!path && isEndPoint(editor, (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.focus, path);\n};\nexports.isSelectionAtBlockEnd = isSelectionAtBlockEnd;\nconst isFirstNode = (editor, node) => {\n  const editorChildren = editor.children || [];\n  return editorChildren[0] === node;\n};\nexports.isFirstNode = isFirstNode;\nconst isLastNode = (editor, node) => {\n  const editorChildren = editor.children || [];\n  const editorChildrenLength = editorChildren.length;\n  return editorChildren[editorChildrenLength - 1] === node;\n};\nexports.isLastNode = isLastNode;\nconst isTextNode = node => {\n  if (!node) return false;\n  if (Reflect.has(node, 'children')) return false;\n};\nexports.isTextNode = isTextNode;\nconst getInlineNodes = node => {\n  if (!node.type) return [node];\n  // image\n  if (node.type === _elementTypes.IMAGE) return [node];\n  // link\n  if (node.type === _elementTypes.LINK) return [node];\n  // column\n  if (node.type === _elementTypes.COLUMN) return [node];\n  const {\n    children\n  } = node;\n  const defaultNode = {\n    id: _slugid.default.nice(),\n    text: ''\n  };\n  if (!children) return [defaultNode];\n  const result = children.map(item => {\n    // text\n    if (!item.type) return item;\n    // image\n    if (item.type === _elementTypes.IMAGE) return item;\n    // link\n    if (item.type === _elementTypes.LINK) return item;\n    // column\n    if (item.type === _elementTypes.COLUMN) return item;\n    return getInlineNodes(node);\n  });\n  return result.flat();\n};\nexports.getInlineNodes = getInlineNodes;\nconst getNodePathById = function (rootNode, nodeId) {\n  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  if (rootNode.id === nodeId) return path;\n  const {\n    children = []\n  } = rootNode;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    path.push(i);\n    const nodePath = getNodePathById(child, nodeId, path);\n    if (nodePath) return nodePath;\n    path.pop();\n  }\n  return null;\n};\nexports.getNodePathById = getNodePathById;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}