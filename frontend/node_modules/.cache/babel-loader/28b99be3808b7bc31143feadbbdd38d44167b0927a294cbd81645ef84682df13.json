{"ast":null,"code":"import _toConsumableArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _toArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { Element, Path, Transforms, Node, Editor } from '@seafile/slate';\nimport slugid from 'slugid';\nimport { LIST_ITEM, PARAGRAPH } from '../../../constants';\nimport { findNode, generateDefaultText, getCommonNode, getNode, getNodes } from '../../../core';\nimport { getListTypes } from '../queries';\nvar isListRoot = function isListRoot(node) {\n  return Element.isElement(node) && getListTypes().includes(node.type);\n};\nvar getFirstAncestorOfType = function getFirstAncestorOfType(root, entry, _ref) {\n  var type = _ref.type;\n  var ancestor = Path.parent(entry[1]);\n  while (getNode(root, ancestor).type !== type) {\n    ancestor = Path.parent(ancestor);\n  }\n  return [getNode(root, ancestor), ancestor];\n};\nvar findListItemsWithContent = function findListItemsWithContent(first) {\n  var prev = null;\n  var node = first;\n  while (isListRoot(node) || node.type === LIST_ITEM && node.children[0].type !== PARAGRAPH) {\n    prev = node;\n    var _node$children = _slicedToArray(node.children, 1);\n    node = _node$children[0];\n  }\n  return prev ? prev.children : [node];\n};\nvar trimList = function trimList(listRoot) {\n  if (!isListRoot(listRoot)) {\n    return [listRoot];\n  }\n  var _texts = Node.texts(listRoot);\n  var textEntries = Array.from(_texts);\n  var commonAncestorEntry = textEntries.reduce(function (commonAncestor, textEntry) {\n    return Path.isAncestor(commonAncestor[1], textEntry[1]) ? commonAncestor : getCommonNode(listRoot, textEntry[1], commonAncestor[1]);\n  }, getFirstAncestorOfType(listRoot, textEntries[0], {\n    type: LIST_ITEM\n  }));\n\n  // is ul/ol: return children\n  // is not ul/ol\n  var _ref3 = isListRoot(commonAncestorEntry[0]) ? commonAncestorEntry[0].children : [commonAncestorEntry[0]],\n    _ref4 = _toArray(_ref3),\n    first = _ref4[0],\n    rest = _ref4.slice(1);\n  return [].concat(_toConsumableArray(findListItemsWithContent(first)), _toConsumableArray(rest));\n};\nvar wrapNodeIntoListItem = function wrapNodeIntoListItem(node) {\n  return node.type === LIST_ITEM ? node : {\n    id: slugid.nice(),\n    type: LIST_ITEM,\n    children: [node]\n  };\n};\nvar isSingleLic = function isSingleLic(fragment) {\n  var isFragmentOnlyListRoot = fragment.length === 1 && isListRoot(fragment[0]);\n  return isFragmentOnlyListRoot && _toConsumableArray(getNodes({\n    children: fragment\n  })).filter(function (entry) {\n    return Element.isElement(entry[0]);\n  }).filter(function (_ref2) {\n    var _ref5 = _slicedToArray(_ref2, 1),\n      node = _ref5[0];\n    return node.type === PARAGRAPH;\n  }).length === 1;\n};\nexport var getTextAndListItemNodes = function getTextAndListItemNodes(editor, fragment, liEntry, licEntry) {\n  var _liEntry = _slicedToArray(liEntry, 2),\n    liPath = _liEntry[1];\n  var _licEntry = _slicedToArray(licEntry, 2),\n    licNode = _licEntry[0],\n    licPath = _licEntry[1];\n  var isEmptyNode = !Node.string(licNode);\n  // format copied fragment\n  // first: lic, path: [...liPath, 0, 0]\n  // rest: children, path: [...liPath, 1, 0]\n  var _fragment$flatMap$map = fragment.flatMap(trimList).map(wrapNodeIntoListItem),\n    _fragment$flatMap$map2 = _toArray(_fragment$flatMap$map),\n    first = _fragment$flatMap$map2[0],\n    rest = _fragment$flatMap$map2.slice(1);\n  var textNode = null;\n  var listItemNodes = [];\n  if (isListRoot(fragment[0])) {\n    if (isSingleLic(fragment)) {\n      textNode = first;\n      listItemNodes = rest;\n    } else if (isEmptyNode) {\n      var li = getNode(editor, liPath);\n      var _li$children = _toArray(li.children),\n        currentSubLists = _li$children.slice(1); // old\n\n      var _first$children = _toArray(first.children),\n        newLic = _first$children[0],\n        newSubLists = _first$children.slice(1); // copied\n      // insert copied contents\n      Transforms.insertNodes(editor, newLic, {\n        at: Path.next(licPath),\n        select: true\n      });\n      Transforms.removeNodes(editor, {\n        at: licPath\n      });\n      if (newSubLists.length) {\n        if (currentSubLists.length) {\n          var path = [].concat(_toConsumableArray(liPath), [1, 0]);\n          Transforms.insertNodes(editor, newSubLists[0].children, {\n            at: path,\n            select: true\n          });\n        } else {\n          Transforms.insertNodes(editor, newSubLists, {\n            at: Path.next(licPath),\n            select: true\n          });\n        }\n      }\n      textNode = generateDefaultText();\n      listItemNodes = rest;\n    } else {\n      textNode = generateDefaultText();\n      listItemNodes = [first].concat(_toConsumableArray(rest));\n    }\n  } else {\n    textNode = first;\n    listItemNodes = rest;\n    return {\n      textNode: textNode,\n      listItemNodes: listItemNodes\n    };\n  }\n  return {\n    textNode: textNode,\n    listItemNodes: listItemNodes\n  };\n};\nexport var insertFragmentList = function insertFragmentList(editor) {\n  var _insertFragment = editor.insertFragment;\n  return function (fragment) {\n    Editor.withoutNormalizing(editor, function () {\n      var liEntry = findNode(editor, {\n        match: {\n          type: LIST_ITEM\n        },\n        mode: 'lowest'\n      });\n      if (!liEntry) {\n        var nodes = isListRoot(fragment[0]) ? [generateDefaultText()].concat(_toConsumableArray(fragment)) : fragment;\n        return _insertFragment(nodes);\n      }\n      Transforms.insertFragment(editor, [generateDefaultText()]); // need ' '\n\n      liEntry = findNode(editor, {\n        match: {\n          type: LIST_ITEM\n        },\n        mode: 'lowest'\n      });\n      var licEntry = findNode(editor, {\n        match: {\n          type: PARAGRAPH\n        },\n        mode: 'lowest'\n      });\n      if (!licEntry) {\n        var _nodes = isListRoot(fragment) ? [generateDefaultText()].concat(_toConsumableArray(fragment)) : fragment;\n        return _insertFragment(_nodes);\n      }\n      var _getTextAndListItemNo = getTextAndListItemNodes(editor, fragment, liEntry, licEntry),\n        textNode = _getTextAndListItemNo.textNode,\n        listItemNodes = _getTextAndListItemNo.listItemNodes;\n      Transforms.insertFragment(editor, [textNode]);\n      var _liEntry2 = liEntry,\n        _liEntry3 = _slicedToArray(_liEntry2, 2),\n        liPath = _liEntry3[1];\n      return Transforms.insertNodes(editor, listItemNodes, {\n        at: Path.next(liPath),\n        select: true\n      });\n    });\n  };\n};","map":{"version":3,"names":["Element","Path","Transforms","Node","Editor","slugid","LIST_ITEM","PARAGRAPH","findNode","generateDefaultText","getCommonNode","getNode","getNodes","getListTypes","isListRoot","node","isElement","includes","type","getFirstAncestorOfType","root","entry","_ref","ancestor","parent","findListItemsWithContent","first","prev","children","_node$children","_slicedToArray","trimList","listRoot","_texts","texts","textEntries","Array","from","commonAncestorEntry","reduce","commonAncestor","textEntry","isAncestor","_ref3","_ref4","_toArray","rest","slice","concat","_toConsumableArray","wrapNodeIntoListItem","id","nice","isSingleLic","fragment","isFragmentOnlyListRoot","length","filter","_ref2","_ref5","getTextAndListItemNodes","editor","liEntry","licEntry","_liEntry","liPath","_licEntry","licNode","licPath","isEmptyNode","string","_fragment$flatMap$map","flatMap","map","_fragment$flatMap$map2","textNode","listItemNodes","li","_li$children","currentSubLists","_first$children","newLic","newSubLists","insertNodes","at","next","select","removeNodes","path","insertFragmentList","_insertFragment","insertFragment","withoutNormalizing","match","mode","nodes","_getTextAndListItemNo","_liEntry2","_liEntry3"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/plugins/list/plugin/insert-fragment-list.js"],"sourcesContent":["import { Element, Path, Transforms, Node, Editor } from '@seafile/slate';\nimport slugid from 'slugid';\nimport { LIST_ITEM, PARAGRAPH } from '../../../constants';\nimport { findNode, generateDefaultText, getCommonNode, getNode, getNodes } from '../../../core';\nimport { getListTypes } from '../queries';\nconst isListRoot = node => {\n  return Element.isElement(node) && getListTypes().includes(node.type);\n};\nconst getFirstAncestorOfType = (root, entry, _ref) => {\n  let {\n    type\n  } = _ref;\n  let ancestor = Path.parent(entry[1]);\n  while (getNode(root, ancestor).type !== type) {\n    ancestor = Path.parent(ancestor);\n  }\n  return [getNode(root, ancestor), ancestor];\n};\nconst findListItemsWithContent = first => {\n  let prev = null;\n  let node = first;\n  while (isListRoot(node) || node.type === LIST_ITEM && node.children[0].type !== PARAGRAPH) {\n    prev = node;\n    [node] = node.children;\n  }\n  return prev ? prev.children : [node];\n};\nconst trimList = listRoot => {\n  if (!isListRoot(listRoot)) {\n    return [listRoot];\n  }\n  const _texts = Node.texts(listRoot);\n  const textEntries = Array.from(_texts);\n  const commonAncestorEntry = textEntries.reduce((commonAncestor, textEntry) => {\n    return Path.isAncestor(commonAncestor[1], textEntry[1]) ? commonAncestor : getCommonNode(listRoot, textEntry[1], commonAncestor[1]);\n  }, getFirstAncestorOfType(listRoot, textEntries[0], {\n    type: LIST_ITEM\n  }));\n\n  // is ul/ol: return children\n  // is not ul/ol\n  const [first, ...rest] = isListRoot(commonAncestorEntry[0]) ? commonAncestorEntry[0].children : [commonAncestorEntry[0]];\n  return [...findListItemsWithContent(first), ...rest];\n};\nconst wrapNodeIntoListItem = node => {\n  return node.type === LIST_ITEM ? node : {\n    id: slugid.nice(),\n    type: LIST_ITEM,\n    children: [node]\n  };\n};\nconst isSingleLic = fragment => {\n  const isFragmentOnlyListRoot = fragment.length === 1 && isListRoot(fragment[0]);\n  return isFragmentOnlyListRoot && [...getNodes({\n    children: fragment\n  })].filter(entry => Element.isElement(entry[0])).filter(_ref2 => {\n    let [node] = _ref2;\n    return node.type === PARAGRAPH;\n  }).length === 1;\n};\nexport const getTextAndListItemNodes = (editor, fragment, liEntry, licEntry) => {\n  const [, liPath] = liEntry;\n  const [licNode, licPath] = licEntry;\n  const isEmptyNode = !Node.string(licNode);\n  // format copied fragment\n  // first: lic, path: [...liPath, 0, 0]\n  // rest: children, path: [...liPath, 1, 0]\n  const [first, ...rest] = fragment.flatMap(trimList).map(wrapNodeIntoListItem);\n  let textNode = null;\n  let listItemNodes = [];\n  if (isListRoot(fragment[0])) {\n    if (isSingleLic(fragment)) {\n      textNode = first;\n      listItemNodes = rest;\n    } else if (isEmptyNode) {\n      const li = getNode(editor, liPath);\n      const [, ...currentSubLists] = li.children; // old\n\n      const [newLic, ...newSubLists] = first.children; // copied\n      // insert copied contents\n      Transforms.insertNodes(editor, newLic, {\n        at: Path.next(licPath),\n        select: true\n      });\n      Transforms.removeNodes(editor, {\n        at: licPath\n      });\n      if (newSubLists.length) {\n        if (currentSubLists.length) {\n          const path = [...liPath, 1, 0];\n          Transforms.insertNodes(editor, newSubLists[0].children, {\n            at: path,\n            select: true\n          });\n        } else {\n          Transforms.insertNodes(editor, newSubLists, {\n            at: Path.next(licPath),\n            select: true\n          });\n        }\n      }\n      textNode = generateDefaultText();\n      listItemNodes = rest;\n    } else {\n      textNode = generateDefaultText();\n      listItemNodes = [first, ...rest];\n    }\n  } else {\n    textNode = first;\n    listItemNodes = rest;\n    return {\n      textNode,\n      listItemNodes\n    };\n  }\n  return {\n    textNode,\n    listItemNodes\n  };\n};\nexport const insertFragmentList = editor => {\n  const {\n    insertFragment: _insertFragment\n  } = editor;\n  return fragment => {\n    Editor.withoutNormalizing(editor, () => {\n      let liEntry = findNode(editor, {\n        match: {\n          type: LIST_ITEM\n        },\n        mode: 'lowest'\n      });\n      if (!liEntry) {\n        const nodes = isListRoot(fragment[0]) ? [generateDefaultText(), ...fragment] : fragment;\n        return _insertFragment(nodes);\n      }\n      Transforms.insertFragment(editor, [generateDefaultText()]); // need ' '\n\n      liEntry = findNode(editor, {\n        match: {\n          type: LIST_ITEM\n        },\n        mode: 'lowest'\n      });\n      const licEntry = findNode(editor, {\n        match: {\n          type: PARAGRAPH\n        },\n        mode: 'lowest'\n      });\n      if (!licEntry) {\n        const nodes = isListRoot(fragment) ? [generateDefaultText(), ...fragment] : fragment;\n        return _insertFragment(nodes);\n      }\n      const {\n        textNode,\n        listItemNodes\n      } = getTextAndListItemNodes(editor, fragment, liEntry, licEntry);\n      Transforms.insertFragment(editor, [textNode]);\n      const [, liPath] = liEntry;\n      return Transforms.insertNodes(editor, listItemNodes, {\n        at: Path.next(liPath),\n        select: true\n      });\n    });\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}