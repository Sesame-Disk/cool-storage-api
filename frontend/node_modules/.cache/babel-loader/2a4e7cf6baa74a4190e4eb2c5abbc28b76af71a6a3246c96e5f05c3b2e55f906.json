{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { Editor, Text } from '@seafile/slate';\nimport { CODE_BLOCK, CODE_LINE } from '../../constants';\nimport { getNodeType } from '../../core';\nexport var isMenuDisabled = function isMenuDisabled(editor) {\n  var readonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (readonly) return true;\n  if (editor.selection == null) return true;\n  var _Editor$nodes = Editor.nodes(editor, {\n      match: function match(n) {\n        var type = getNodeType(n);\n        if ([CODE_BLOCK, CODE_LINE].includes(type)) return true; // code-block\n        if (Editor.isVoid(editor, n)) return true; // void node\n\n        return false;\n      },\n      universal: true\n    }),\n    _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n    match = _Editor$nodes2[0];\n  if (match) return true;\n  return false;\n};\nvar removeMarks = function removeMarks(editor, textNode) {\n  // Iterate text node properties, clearing styles\n  var keys = Object.keys(textNode);\n  keys.forEach(function (key) {\n    if (key === 'text') {\n      // Keep only the text attribute （Text attributes are necessary）\n      return;\n    }\n    // All other attributes are deleted\n    Editor.removeMark(editor, key);\n  });\n};\nexport var clearStyles = function clearStyles(editor) {\n  var nodeEntries = Editor.nodes(editor, {\n    match: function match(n) {\n      return Text.isText(n);\n    },\n    universal: true\n  });\n  var _iterator = _createForOfIteratorHelper(nodeEntries),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var nodeEntry = _step.value;\n      // single text node\n      var n = nodeEntry[0];\n      removeMarks(editor, n);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};","map":{"version":3,"names":["Editor","Text","CODE_BLOCK","CODE_LINE","getNodeType","isMenuDisabled","editor","readonly","arguments","length","undefined","selection","_Editor$nodes","nodes","match","n","type","includes","isVoid","universal","_Editor$nodes2","_slicedToArray","removeMarks","textNode","keys","Object","forEach","key","removeMark","clearStyles","nodeEntries","isText","_iterator","_createForOfIteratorHelper","_step","s","done","nodeEntry","value","err","e","f"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/plugins/clear-format/helpers.js"],"sourcesContent":["import { Editor, Text } from '@seafile/slate';\nimport { CODE_BLOCK, CODE_LINE } from '../../constants';\nimport { getNodeType } from '../../core';\nexport const isMenuDisabled = function (editor) {\n  let readonly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (readonly) return true;\n  if (editor.selection == null) return true;\n  const [match] = Editor.nodes(editor, {\n    match: n => {\n      const type = getNodeType(n);\n      if ([CODE_BLOCK, CODE_LINE].includes(type)) return true; // code-block\n      if (Editor.isVoid(editor, n)) return true; // void node\n\n      return false;\n    },\n    universal: true\n  });\n  if (match) return true;\n  return false;\n};\nconst removeMarks = (editor, textNode) => {\n  // Iterate text node properties, clearing styles\n  const keys = Object.keys(textNode);\n  keys.forEach(key => {\n    if (key === 'text') {\n      // Keep only the text attribute （Text attributes are necessary）\n      return;\n    }\n    // All other attributes are deleted\n    Editor.removeMark(editor, key);\n  });\n};\nexport const clearStyles = editor => {\n  const nodeEntries = Editor.nodes(editor, {\n    match: n => Text.isText(n),\n    universal: true\n  });\n  for (const nodeEntry of nodeEntries) {\n    // single text node\n    const n = nodeEntry[0];\n    removeMarks(editor, n);\n  }\n};"],"mappings":";;AAAA,SAASA,MAAM,EAAEC,IAAI,QAAQ,gBAAgB;AAC7C,SAASC,UAAU,EAAEC,SAAS,QAAQ,iBAAiB;AACvD,SAASC,WAAW,QAAQ,YAAY;AACxC,OAAO,IAAMC,cAAc,GAAG,SAAjBA,cAAcA,CAAaC,MAAM,EAAE;EAC9C,IAAIC,QAAQ,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;EACxF,IAAID,QAAQ,EAAE,OAAO,IAAI;EACzB,IAAID,MAAM,CAACK,SAAS,IAAI,IAAI,EAAE,OAAO,IAAI;EACzC,IAAAC,aAAA,GAAgBZ,MAAM,CAACa,KAAK,CAACP,MAAM,EAAE;MACnCQ,KAAK,EAAE,SAAAA,MAAAC,CAAC,EAAI;QACV,IAAMC,IAAI,GAAGZ,WAAW,CAACW,CAAC,CAAC;QAC3B,IAAI,CAACb,UAAU,EAAEC,SAAS,CAAC,CAACc,QAAQ,CAACD,IAAI,CAAC,EAAE,OAAO,IAAI,CAAC,CAAC;QACzD,IAAIhB,MAAM,CAACkB,MAAM,CAACZ,MAAM,EAAES,CAAC,CAAC,EAAE,OAAO,IAAI,CAAC,CAAC;;QAE3C,OAAO,KAAK;MACd,CAAC;MACDI,SAAS,EAAE;IACb,CAAC,CAAC;IAAAC,cAAA,GAAAC,cAAA,CAAAT,aAAA;IATKE,KAAK,GAAAM,cAAA;EAUZ,IAAIN,KAAK,EAAE,OAAO,IAAI;EACtB,OAAO,KAAK;AACd,CAAC;AACD,IAAMQ,WAAW,GAAG,SAAdA,WAAWA,CAAIhB,MAAM,EAAEiB,QAAQ,EAAK;EACxC;EACA,IAAMC,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACD,QAAQ,CAAC;EAClCC,IAAI,CAACE,OAAO,CAAC,UAAAC,GAAG,EAAI;IAClB,IAAIA,GAAG,KAAK,MAAM,EAAE;MAClB;MACA;IACF;IACA;IACA3B,MAAM,CAAC4B,UAAU,CAACtB,MAAM,EAAEqB,GAAG,CAAC;EAChC,CAAC,CAAC;AACJ,CAAC;AACD,OAAO,IAAME,WAAW,GAAG,SAAdA,WAAWA,CAAGvB,MAAM,EAAI;EACnC,IAAMwB,WAAW,GAAG9B,MAAM,CAACa,KAAK,CAACP,MAAM,EAAE;IACvCQ,KAAK,EAAE,SAAAA,MAAAC,CAAC;MAAA,OAAId,IAAI,CAAC8B,MAAM,CAAChB,CAAC,CAAC;IAAA;IAC1BI,SAAS,EAAE;EACb,CAAC,CAAC;EAAC,IAAAa,SAAA,GAAAC,0BAAA,CACqBH,WAAW;IAAAI,KAAA;EAAA;IAAnC,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAjB,CAAA,IAAAqB,IAAA,GAAqC;MAAA,IAA1BC,SAAS,GAAAH,KAAA,CAAAI,KAAA;MAClB;MACA,IAAMvB,CAAC,GAAGsB,SAAS,CAAC,CAAC,CAAC;MACtBf,WAAW,CAAChB,MAAM,EAAES,CAAC,CAAC;IACxB;EAAC,SAAAwB,GAAA;IAAAP,SAAA,CAAAQ,CAAA,CAAAD,GAAA;EAAA;IAAAP,SAAA,CAAAS,CAAA;EAAA;AACH,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}