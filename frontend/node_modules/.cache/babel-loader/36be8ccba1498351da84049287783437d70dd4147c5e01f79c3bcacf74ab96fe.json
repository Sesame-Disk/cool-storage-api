{"ast":null,"code":"import _toConsumableArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n// Port of `edit_map.rs` from `markdown-rs`.\n// This should move to `markdown-js` later.\n\n// Deal with several changes in events, batching them together.\n//\n// Preferably, changes should be kept to a minimum.\n// Sometimes, it’s needed to change the list of events, because parsing can be\n// messy, and it helps to expose a cleaner interface of events to the compiler\n// and other users.\n// It can also help to merge many adjacent similar events.\n// And, in other cases, it’s needed to parse subcontent: pass some events\n// through another tokenizer and inject the result.\n\n/**\n * @typedef {[number, number, Array<Event>]} Change\n * @typedef {[number, number, number]} Jump\n */\n\n/**\n * Tracks a bunch of edits.\n */\nexport var EditMap = /*#__PURE__*/function () {\n  /**\n   * Create a new edit map.\n   */\n  function EditMap() {\n    _classCallCheck(this, EditMap);\n    /**\n     * Record of changes.\n     *\n     * @type {Array<Change>}\n     */\n    this.map = [];\n  }\n\n  /**\n   * Create an edit: a remove and/or add at a certain place.\n   *\n   * @param {number} index\n   * @param {number} remove\n   * @param {Array<Event>} add\n   * @returns {undefined}\n   */\n  _createClass(EditMap, [{\n    key: \"add\",\n    value: function add(index, remove, _add) {\n      addImpl(this, index, remove, _add);\n    }\n\n    // To do: add this when moving to `micromark`.\n    // /**\n    //  * Create an edit: but insert `add` before existing additions.\n    //  *\n    //  * @param {number} index\n    //  * @param {number} remove\n    //  * @param {Array<Event>} add\n    //  * @returns {undefined}\n    //  */\n    // addBefore(index, remove, add) {\n    //   addImpl(this, index, remove, add, true)\n    // }\n\n    /**\n     * Done, change the events.\n     *\n     * @param {Array<Event>} events\n     * @returns {undefined}\n     */\n  }, {\n    key: \"consume\",\n    value: function consume(events) {\n      this.map.sort(function (a, b) {\n        return a[0] - b[0];\n      });\n\n      /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\n      if (this.map.length === 0) {\n        return;\n      }\n\n      // To do: if links are added in events, like they are in `markdown-rs`,\n      // this is needed.\n      // // Calculate jumps: where items in the current list move to.\n      // /** @type {Array<Jump>} */\n      // const jumps = []\n      // let index = 0\n      // let addAcc = 0\n      // let removeAcc = 0\n      // while (index < this.map.length) {\n      //   const [at, remove, add] = this.map[index]\n      //   removeAcc += remove\n      //   addAcc += add.length\n      //   jumps.push([at, removeAcc, addAcc])\n      //   index += 1\n      // }\n      //\n      // . shiftLinks(events, jumps)\n\n      var index = this.map.length;\n      /** @type {Array<Array<Event>>} */\n      var vecs = [];\n      while (index > 0) {\n        index -= 1;\n        vecs.push(events.slice(this.map[index][0] + this.map[index][1]), this.map[index][2]);\n\n        // Truncate rest.\n        events.length = this.map[index][0];\n      }\n      vecs.push(_toConsumableArray(events));\n      events.length = 0;\n      var slice = vecs.pop();\n      while (slice) {\n        events.push.apply(events, _toConsumableArray(slice));\n        slice = vecs.pop();\n      }\n\n      // Truncate everything.\n      this.map.length = 0;\n    }\n  }]);\n  return EditMap;\n}();\n\n/**\n * Create an edit.\n *\n * @param {EditMap} editMap\n * @param {number} at\n * @param {number} remove\n * @param {Array<Event>} add\n * @returns {undefined}\n */\nfunction addImpl(editMap, at, remove, add) {\n  var index = 0;\n\n  /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\n  if (remove === 0 && add.length === 0) {\n    return;\n  }\n  while (index < editMap.map.length) {\n    if (editMap.map[index][0] === at) {\n      var _editMap$map$index$;\n      editMap.map[index][1] += remove;\n\n      // To do: before not used by tables, use when moving to micromark.\n      // if (before) {\n      //   add.push(...editMap.map[index][2])\n      //   editMap.map[index][2] = add\n      // } else {\n      (_editMap$map$index$ = editMap.map[index][2]).push.apply(_editMap$map$index$, _toConsumableArray(add));\n      // }\n\n      return;\n    }\n    index += 1;\n  }\n  editMap.map.push([at, remove, add]);\n}\n\n// /**\n//  * Shift `previous` and `next` links according to `jumps`.\n//  *\n//  * This fixes links in case there are events removed or added between them.\n//  *\n//  * @param {Array<Event>} events\n//  * @param {Array<Jump>} jumps\n//  */\n// function shiftLinks(events, jumps) {\n//   let jumpIndex = 0\n//   let index = 0\n//   let add = 0\n//   let rm = 0\n\n//   while (index < events.length) {\n//     const rmCurr = rm\n\n//     while (jumpIndex < jumps.length && jumps[jumpIndex][0] <= index) {\n//       add = jumps[jumpIndex][2]\n//       rm = jumps[jumpIndex][1]\n//       jumpIndex += 1\n//     }\n\n//     // Ignore items that will be removed.\n//     if (rm > rmCurr) {\n//       index += rm - rmCurr\n//     } else {\n//       // ?\n//       // if let Some(link) = &events[index].link {\n//       //     if let Some(next) = link.next {\n//       //         events[next].link.as_mut().unwrap().previous = Some(index + add - rm);\n//       //         while jumpIndex < jumps.len() && jumps[jumpIndex].0 <= next {\n//       //             add = jumps[jumpIndex].2;\n//       //             rm = jumps[jumpIndex].1;\n//       //             jumpIndex += 1;\n//       //         }\n//       //         events[index].link.as_mut().unwrap().next = Some(next + add - rm);\n//       //         index = next;\n//       //         continue;\n//       //     }\n//       // }\n//       index += 1\n//     }\n//   }\n// }","map":{"version":3,"names":["EditMap","_classCallCheck","map","_createClass","key","value","add","index","remove","addImpl","consume","events","sort","a","b","length","vecs","push","slice","_toConsumableArray","pop","apply","editMap","at","_editMap$map$index$"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/micromark-extension-gfm-table/lib/edit-map.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n// Port of `edit_map.rs` from `markdown-rs`.\n// This should move to `markdown-js` later.\n\n// Deal with several changes in events, batching them together.\n//\n// Preferably, changes should be kept to a minimum.\n// Sometimes, it’s needed to change the list of events, because parsing can be\n// messy, and it helps to expose a cleaner interface of events to the compiler\n// and other users.\n// It can also help to merge many adjacent similar events.\n// And, in other cases, it’s needed to parse subcontent: pass some events\n// through another tokenizer and inject the result.\n\n/**\n * @typedef {[number, number, Array<Event>]} Change\n * @typedef {[number, number, number]} Jump\n */\n\n/**\n * Tracks a bunch of edits.\n */\nexport class EditMap {\n  /**\n   * Create a new edit map.\n   */\n  constructor() {\n    /**\n     * Record of changes.\n     *\n     * @type {Array<Change>}\n     */\n    this.map = []\n  }\n\n  /**\n   * Create an edit: a remove and/or add at a certain place.\n   *\n   * @param {number} index\n   * @param {number} remove\n   * @param {Array<Event>} add\n   * @returns {undefined}\n   */\n  add(index, remove, add) {\n    addImpl(this, index, remove, add)\n  }\n\n  // To do: add this when moving to `micromark`.\n  // /**\n  //  * Create an edit: but insert `add` before existing additions.\n  //  *\n  //  * @param {number} index\n  //  * @param {number} remove\n  //  * @param {Array<Event>} add\n  //  * @returns {undefined}\n  //  */\n  // addBefore(index, remove, add) {\n  //   addImpl(this, index, remove, add, true)\n  // }\n\n  /**\n   * Done, change the events.\n   *\n   * @param {Array<Event>} events\n   * @returns {undefined}\n   */\n  consume(events) {\n    this.map.sort(function (a, b) {\n      return a[0] - b[0]\n    })\n\n    /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\n    if (this.map.length === 0) {\n      return\n    }\n\n    // To do: if links are added in events, like they are in `markdown-rs`,\n    // this is needed.\n    // // Calculate jumps: where items in the current list move to.\n    // /** @type {Array<Jump>} */\n    // const jumps = []\n    // let index = 0\n    // let addAcc = 0\n    // let removeAcc = 0\n    // while (index < this.map.length) {\n    //   const [at, remove, add] = this.map[index]\n    //   removeAcc += remove\n    //   addAcc += add.length\n    //   jumps.push([at, removeAcc, addAcc])\n    //   index += 1\n    // }\n    //\n    // . shiftLinks(events, jumps)\n\n    let index = this.map.length\n    /** @type {Array<Array<Event>>} */\n    const vecs = []\n    while (index > 0) {\n      index -= 1\n      vecs.push(\n        events.slice(this.map[index][0] + this.map[index][1]),\n        this.map[index][2]\n      )\n\n      // Truncate rest.\n      events.length = this.map[index][0]\n    }\n    vecs.push([...events])\n    events.length = 0\n    let slice = vecs.pop()\n    while (slice) {\n      events.push(...slice)\n      slice = vecs.pop()\n    }\n\n    // Truncate everything.\n    this.map.length = 0\n  }\n}\n\n/**\n * Create an edit.\n *\n * @param {EditMap} editMap\n * @param {number} at\n * @param {number} remove\n * @param {Array<Event>} add\n * @returns {undefined}\n */\nfunction addImpl(editMap, at, remove, add) {\n  let index = 0\n\n  /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */\n  if (remove === 0 && add.length === 0) {\n    return\n  }\n  while (index < editMap.map.length) {\n    if (editMap.map[index][0] === at) {\n      editMap.map[index][1] += remove\n\n      // To do: before not used by tables, use when moving to micromark.\n      // if (before) {\n      //   add.push(...editMap.map[index][2])\n      //   editMap.map[index][2] = add\n      // } else {\n      editMap.map[index][2].push(...add)\n      // }\n\n      return\n    }\n    index += 1\n  }\n  editMap.map.push([at, remove, add])\n}\n\n// /**\n//  * Shift `previous` and `next` links according to `jumps`.\n//  *\n//  * This fixes links in case there are events removed or added between them.\n//  *\n//  * @param {Array<Event>} events\n//  * @param {Array<Jump>} jumps\n//  */\n// function shiftLinks(events, jumps) {\n//   let jumpIndex = 0\n//   let index = 0\n//   let add = 0\n//   let rm = 0\n\n//   while (index < events.length) {\n//     const rmCurr = rm\n\n//     while (jumpIndex < jumps.length && jumps[jumpIndex][0] <= index) {\n//       add = jumps[jumpIndex][2]\n//       rm = jumps[jumpIndex][1]\n//       jumpIndex += 1\n//     }\n\n//     // Ignore items that will be removed.\n//     if (rm > rmCurr) {\n//       index += rm - rmCurr\n//     } else {\n//       // ?\n//       // if let Some(link) = &events[index].link {\n//       //     if let Some(next) = link.next {\n//       //         events[next].link.as_mut().unwrap().previous = Some(index + add - rm);\n//       //         while jumpIndex < jumps.len() && jumps[jumpIndex].0 <= next {\n//       //             add = jumps[jumpIndex].2;\n//       //             rm = jumps[jumpIndex].1;\n//       //             jumpIndex += 1;\n//       //         }\n//       //         events[index].link.as_mut().unwrap().next = Some(next + add - rm);\n//       //         index = next;\n//       //         continue;\n//       //     }\n//       // }\n//       index += 1\n//     }\n//   }\n// }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}