{"ast":null,"code":"import _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport { Editor, Node, Range, Text, Transforms } from '@seafile/slate';\nimport EventBus from '../../../utils/event-bus';\nimport { INTERNAL_EVENT } from '../../../constants';\nimport { MENTION, MENTION_TEMP } from '../../constants/element-type';\nimport { insertTemporaryMentionInput, getMentionTempIptEntry, transformToText, getMentionEntry, getPrevMentionIptEntry } from './helper';\nimport { KeyCodes } from '../../../../constants';\nimport { focusEditor } from '../../core';\nvar withMention = function withMention(editor) {\n  var insertText = editor.insertText,\n    onHotKeyDown = editor.onHotKeyDown,\n    isInline = editor.isInline,\n    deleteBackward = editor.deleteBackward,\n    deleteForward = editor.deleteForward,\n    normalizeNode = editor.normalizeNode;\n  var newEditor = editor;\n  var eventBus = EventBus.getInstance();\n  newEditor.insertText = function (text) {\n    var selection = editor.selection;\n    if (text === '@' && !getMentionTempIptEntry(editor)) {\n      insertTemporaryMentionInput(newEditor);\n      var anchor = selection.anchor;\n      var path = Editor.path(editor, anchor);\n      var abovePath = path.slice(0, path.length - 1);\n      var focusPath = abovePath.concat(path.at(-1) + 1);\n      focusEditor(editor, focusPath);\n      return;\n    }\n    var prevNodeEntry = Editor.previous(editor);\n    if (prevNodeEntry) {\n      var aboveNodeEntry = Editor.above(editor, {\n        match: function match(n) {\n          return n.type === MENTION_TEMP;\n        },\n        at: prevNodeEntry[1]\n      });\n      if (aboveNodeEntry) {\n        var _text$match;\n        var inputCnCharacter = (_text$match = text.match(/^[\\u4e00-\\u9fa5]+$/)) === null || _text$match === void 0 ? void 0 : _text$match.input;\n        if (inputCnCharacter) {\n          var insertPoint = Editor.end(editor, aboveNodeEntry[1]);\n          var nextNodeEntry = Editor.next(editor, {\n            at: aboveNodeEntry[1]\n          });\n          Transforms.insertText(editor, text, {\n            at: insertPoint\n          });\n          if (nextNodeEntry) {\n            var _nextNodeEntry = _slicedToArray(nextNodeEntry, 2),\n              nextNode = _nextNodeEntry[0],\n              nextPath = _nextNodeEntry[1];\n            if (Text.isText(nextNode) && nextNode.text === '') {\n              Transforms.removeNodes(editor, {\n                at: nextPath\n              });\n            }\n          }\n          return focusEditor(editor, _objectSpread(_objectSpread({}, insertPoint), {}, {\n            offset: insertPoint.offset + text.length\n          }));\n        }\n      }\n    }\n    return insertText(text);\n  };\n  newEditor.deleteBackward = function (unit) {\n    var mentionTempInputEntry = getMentionTempIptEntry(editor);\n    if (mentionTempInputEntry) {\n      var selection = editor.selection;\n      if (selection && Range.isCollapsed(selection)) {\n        var _mentionTempInputEntr = _slicedToArray(mentionTempInputEntry, 2),\n          node = _mentionTempInputEntr[0],\n          path = _mentionTempInputEntr[1];\n        var contentString = Node.string(node);\n        if (!contentString) {\n          return Transforms.delete(editor, {\n            at: path\n          });\n        }\n      }\n    }\n\n    // Delete mention, when in mention\n    var prevNodeEntry = Editor.previous(editor);\n    if (prevNodeEntry) {\n      var aboveNodeEntry = Editor.above(editor, {\n        match: function match(n) {\n          return n.type === MENTION;\n        },\n        at: prevNodeEntry[1]\n      });\n      var mentionEntry = getMentionEntry(editor);\n      if (mentionEntry || aboveNodeEntry) {\n        var _selection = editor.selection;\n        if (_selection && Range.isCollapsed(_selection)) {\n          var _ref2 = mentionEntry || aboveNodeEntry,\n            _ref3 = _slicedToArray(_ref2, 2),\n            mentionPath = _ref3[1];\n          return Transforms.removeNodes(editor, {\n            at: mentionPath\n          });\n        }\n      }\n    }\n    return deleteBackward(unit);\n  };\n  newEditor.deleteForward = function (unit) {\n    var mentionEntry = Editor.next(editor, {\n      match: function match(n) {\n        return n.type === MENTION;\n      }\n    });\n    if (mentionEntry) {\n      var _mentionEntry = _slicedToArray(mentionEntry, 2),\n        mentionPath = _mentionEntry[1];\n      return Transforms.removeNodes(editor, {\n        at: mentionPath\n      });\n    }\n    return deleteForward(unit);\n  };\n  newEditor.onHotKeyDown = function (event) {\n    var mentionTempIptEntry = getMentionTempIptEntry(editor);\n    if (mentionTempIptEntry) {\n      var _mentionTempIptEntry = _slicedToArray(mentionTempIptEntry, 2),\n        mentionTempIptPath = _mentionTempIptEntry[1];\n      var DownArrow = KeyCodes.DownArrow,\n        UpArrow = KeyCodes.UpArrow,\n        Enter = KeyCodes.Enter,\n        Esc = KeyCodes.Esc,\n        RightArrow = KeyCodes.RightArrow,\n        LeftArrow = KeyCodes.LeftArrow;\n      var keyCode = event.keyCode;\n      if (keyCode === RightArrow || keyCode === LeftArrow) {\n        var selection = editor.selection;\n        if (!selection) return;\n        if (!Range.isCollapsed(selection)) return;\n        if (keyCode === RightArrow) {\n          if (Editor.isEnd(editor, selection.focus, mentionTempIptPath)) return transformToText(newEditor);\n        }\n        if (keyCode === LeftArrow) {\n          if (Editor.isStart(editor, selection.focus, mentionTempIptPath)) {\n            event.preventDefault();\n            return transformToText(newEditor, false);\n          }\n        }\n      }\n\n      // Handle by collaborators list\n      var interceptorKeyCodes = [DownArrow, UpArrow, Enter, Esc];\n      if (interceptorKeyCodes.includes(keyCode)) {\n        event.preventDefault();\n        eventBus.dispatch(INTERNAL_EVENT.HANDLE_MENTION_TEMP_CHOSEN, {\n          event: event\n        });\n        return;\n      }\n    }\n    var mentionEntry = getMentionEntry(editor);\n    if (mentionEntry) {\n      var _mentionEntry2 = _slicedToArray(mentionEntry, 2),\n        mentionPath = _mentionEntry2[1];\n      var _RightArrow = KeyCodes.RightArrow,\n        _LeftArrow = KeyCodes.LeftArrow;\n      var _keyCode = event.keyCode;\n      if (_keyCode === _RightArrow || _keyCode === _LeftArrow) {\n        event.preventDefault();\n        if (_keyCode === _LeftArrow) {\n          var beginPoint = Editor.start(editor, mentionPath);\n          var focusPoint = Editor.before(editor, beginPoint, {\n            distance: 1\n          });\n          focusEditor(newEditor, focusPoint);\n        } else {\n          var endPoint = Editor.end(editor, mentionPath);\n          var _focusPoint = Editor.after(editor, endPoint, {\n            distance: 1\n          });\n          focusEditor(newEditor, _focusPoint);\n        }\n      }\n    }\n    return onHotKeyDown && onHotKeyDown(event);\n  };\n  newEditor.onCompositionUpdate = function (event) {\n    var mentionTempIptEntry = getMentionTempIptEntry(newEditor);\n    if (mentionTempIptEntry) {\n      var data = event.data;\n      var compositionText = data.replace(/\\'/g, '');\n      eventBus.dispatch(INTERNAL_EVENT.UPDATE_MENTION_TEMP_CONTENT, {\n        compositionText: compositionText\n      });\n      return true;\n    }\n  };\n  newEditor.onCompositionStart = function (event) {\n    var mentionTempIptEntry = getMentionTempIptEntry(editor);\n    if (mentionTempIptEntry) {\n      event.preventDefault();\n      return true;\n    }\n  };\n  newEditor.onCompositionEnd = function (event) {\n    var PrevMentionIptEntry = getPrevMentionIptEntry(newEditor);\n    if (PrevMentionIptEntry) {\n      var data = event.data;\n      var insertPoint = Editor.end(editor, PrevMentionIptEntry[1]);\n      var nextNodeEntry = Editor.next(editor, {\n        at: PrevMentionIptEntry[1]\n      });\n      Transforms.insertText(editor, data, {\n        at: insertPoint\n      });\n      event.preventDefault();\n      focusEditor(editor, _objectSpread(_objectSpread({}, insertPoint), {}, {\n        offset: insertPoint.offset + data.length\n      }));\n      if (nextNodeEntry) {\n        var _nextNodeEntry2 = _slicedToArray(nextNodeEntry, 2),\n          nextNode = _nextNodeEntry2[0],\n          nextPath = _nextNodeEntry2[1];\n        if (Text.isText(nextNode) && nextNode.text === '') {\n          Transforms.removeNodes(editor, {\n            at: nextPath\n          });\n        }\n      }\n      return true;\n    }\n  };\n  newEditor.isInline = function (element) {\n    if ([MENTION, MENTION_TEMP].includes(element.type)) {\n      return true;\n    }\n    return isInline(element);\n  };\n  newEditor.normalizeNode = function (_ref) {\n    var _ref4 = _slicedToArray(_ref, 2),\n      node = _ref4[0],\n      path = _ref4[1];\n    var mentionEntry = getMentionEntry(editor);\n    if (mentionEntry) {\n      var nextEntry = Editor.next(editor, {\n        at: mentionEntry[1]\n      });\n      var focusPoint = Editor.start(editor, nextEntry[1]);\n      focusEditor(editor, focusPoint);\n    }\n    return normalizeNode([node, path]);\n  };\n  return newEditor;\n};\nexport default withMention;","map":{"version":3,"names":["_objectSpread","Editor","Node","Range","Text","Transforms","EventBus","INTERNAL_EVENT","MENTION","MENTION_TEMP","insertTemporaryMentionInput","getMentionTempIptEntry","transformToText","getMentionEntry","getPrevMentionIptEntry","KeyCodes","focusEditor","withMention","editor","insertText","onHotKeyDown","isInline","deleteBackward","deleteForward","normalizeNode","newEditor","eventBus","getInstance","text","selection","anchor","path","abovePath","slice","length","focusPath","concat","at","prevNodeEntry","previous","aboveNodeEntry","above","match","n","type","_text$match","inputCnCharacter","input","insertPoint","end","nextNodeEntry","next","_nextNodeEntry","_slicedToArray","nextNode","nextPath","isText","removeNodes","offset","unit","mentionTempInputEntry","isCollapsed","_mentionTempInputEntr","node","contentString","string","delete","mentionEntry","_ref2","_ref3","mentionPath","_mentionEntry","event","mentionTempIptEntry","_mentionTempIptEntry","mentionTempIptPath","DownArrow","UpArrow","Enter","Esc","RightArrow","LeftArrow","keyCode","isEnd","focus","isStart","preventDefault","interceptorKeyCodes","includes","dispatch","HANDLE_MENTION_TEMP_CHOSEN","_mentionEntry2","beginPoint","start","focusPoint","before","distance","endPoint","after","onCompositionUpdate","data","compositionText","replace","UPDATE_MENTION_TEMP_CONTENT","onCompositionStart","onCompositionEnd","PrevMentionIptEntry","_nextNodeEntry2","element","_ref","_ref4","nextEntry"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/plugins/mention/plugin.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport { Editor, Node, Range, Text, Transforms } from '@seafile/slate';\nimport EventBus from '../../../utils/event-bus';\nimport { INTERNAL_EVENT } from '../../../constants';\nimport { MENTION, MENTION_TEMP } from '../../constants/element-type';\nimport { insertTemporaryMentionInput, getMentionTempIptEntry, transformToText, getMentionEntry, getPrevMentionIptEntry } from './helper';\nimport { KeyCodes } from '../../../../constants';\nimport { focusEditor } from '../../core';\nconst withMention = editor => {\n  const {\n    insertText,\n    onHotKeyDown,\n    isInline,\n    deleteBackward,\n    deleteForward,\n    normalizeNode\n  } = editor;\n  const newEditor = editor;\n  const eventBus = EventBus.getInstance();\n  newEditor.insertText = text => {\n    const {\n      selection\n    } = editor;\n    if (text === '@' && !getMentionTempIptEntry(editor)) {\n      insertTemporaryMentionInput(newEditor);\n      const {\n        anchor\n      } = selection;\n      const path = Editor.path(editor, anchor);\n      const abovePath = path.slice(0, path.length - 1);\n      const focusPath = abovePath.concat(path.at(-1) + 1);\n      focusEditor(editor, focusPath);\n      return;\n    }\n    const prevNodeEntry = Editor.previous(editor);\n    if (prevNodeEntry) {\n      const aboveNodeEntry = Editor.above(editor, {\n        match: n => n.type === MENTION_TEMP,\n        at: prevNodeEntry[1]\n      });\n      if (aboveNodeEntry) {\n        var _text$match;\n        const inputCnCharacter = (_text$match = text.match(/^[\\u4e00-\\u9fa5]+$/)) === null || _text$match === void 0 ? void 0 : _text$match.input;\n        if (inputCnCharacter) {\n          const insertPoint = Editor.end(editor, aboveNodeEntry[1]);\n          const nextNodeEntry = Editor.next(editor, {\n            at: aboveNodeEntry[1]\n          });\n          Transforms.insertText(editor, text, {\n            at: insertPoint\n          });\n          if (nextNodeEntry) {\n            const [nextNode, nextPath] = nextNodeEntry;\n            if (Text.isText(nextNode) && nextNode.text === '') {\n              Transforms.removeNodes(editor, {\n                at: nextPath\n              });\n            }\n          }\n          return focusEditor(editor, _objectSpread(_objectSpread({}, insertPoint), {}, {\n            offset: insertPoint.offset + text.length\n          }));\n        }\n      }\n    }\n    return insertText(text);\n  };\n  newEditor.deleteBackward = unit => {\n    const mentionTempInputEntry = getMentionTempIptEntry(editor);\n    if (mentionTempInputEntry) {\n      const {\n        selection\n      } = editor;\n      if (selection && Range.isCollapsed(selection)) {\n        const [node, path] = mentionTempInputEntry;\n        const contentString = Node.string(node);\n        if (!contentString) {\n          return Transforms.delete(editor, {\n            at: path\n          });\n        }\n      }\n    }\n\n    // Delete mention, when in mention\n    const prevNodeEntry = Editor.previous(editor);\n    if (prevNodeEntry) {\n      const aboveNodeEntry = Editor.above(editor, {\n        match: n => n.type === MENTION,\n        at: prevNodeEntry[1]\n      });\n      const mentionEntry = getMentionEntry(editor);\n      if (mentionEntry || aboveNodeEntry) {\n        const {\n          selection\n        } = editor;\n        if (selection && Range.isCollapsed(selection)) {\n          const [, mentionPath] = mentionEntry || aboveNodeEntry;\n          return Transforms.removeNodes(editor, {\n            at: mentionPath\n          });\n        }\n      }\n    }\n    return deleteBackward(unit);\n  };\n  newEditor.deleteForward = unit => {\n    const mentionEntry = Editor.next(editor, {\n      match: n => n.type === MENTION\n    });\n    if (mentionEntry) {\n      const [, mentionPath] = mentionEntry;\n      return Transforms.removeNodes(editor, {\n        at: mentionPath\n      });\n    }\n    return deleteForward(unit);\n  };\n  newEditor.onHotKeyDown = event => {\n    const mentionTempIptEntry = getMentionTempIptEntry(editor);\n    if (mentionTempIptEntry) {\n      const [, mentionTempIptPath] = mentionTempIptEntry;\n      const {\n        DownArrow,\n        UpArrow,\n        Enter,\n        Esc,\n        RightArrow,\n        LeftArrow\n      } = KeyCodes;\n      const {\n        keyCode\n      } = event;\n      if (keyCode === RightArrow || keyCode === LeftArrow) {\n        const {\n          selection\n        } = editor;\n        if (!selection) return;\n        if (!Range.isCollapsed(selection)) return;\n        if (keyCode === RightArrow) {\n          if (Editor.isEnd(editor, selection.focus, mentionTempIptPath)) return transformToText(newEditor);\n        }\n        if (keyCode === LeftArrow) {\n          if (Editor.isStart(editor, selection.focus, mentionTempIptPath)) {\n            event.preventDefault();\n            return transformToText(newEditor, false);\n          }\n        }\n      }\n\n      // Handle by collaborators list\n      const interceptorKeyCodes = [DownArrow, UpArrow, Enter, Esc];\n      if (interceptorKeyCodes.includes(keyCode)) {\n        event.preventDefault();\n        eventBus.dispatch(INTERNAL_EVENT.HANDLE_MENTION_TEMP_CHOSEN, {\n          event\n        });\n        return;\n      }\n    }\n    const mentionEntry = getMentionEntry(editor);\n    if (mentionEntry) {\n      const [, mentionPath] = mentionEntry;\n      const {\n        RightArrow,\n        LeftArrow\n      } = KeyCodes;\n      const {\n        keyCode\n      } = event;\n      if (keyCode === RightArrow || keyCode === LeftArrow) {\n        event.preventDefault();\n        if (keyCode === LeftArrow) {\n          const beginPoint = Editor.start(editor, mentionPath);\n          const focusPoint = Editor.before(editor, beginPoint, {\n            distance: 1\n          });\n          focusEditor(newEditor, focusPoint);\n        } else {\n          const endPoint = Editor.end(editor, mentionPath);\n          const focusPoint = Editor.after(editor, endPoint, {\n            distance: 1\n          });\n          focusEditor(newEditor, focusPoint);\n        }\n      }\n    }\n    return onHotKeyDown && onHotKeyDown(event);\n  };\n  newEditor.onCompositionUpdate = event => {\n    const mentionTempIptEntry = getMentionTempIptEntry(newEditor);\n    if (mentionTempIptEntry) {\n      const {\n        data\n      } = event;\n      const compositionText = data.replace(/\\'/g, '');\n      eventBus.dispatch(INTERNAL_EVENT.UPDATE_MENTION_TEMP_CONTENT, {\n        compositionText\n      });\n      return true;\n    }\n  };\n  newEditor.onCompositionStart = event => {\n    const mentionTempIptEntry = getMentionTempIptEntry(editor);\n    if (mentionTempIptEntry) {\n      event.preventDefault();\n      return true;\n    }\n  };\n  newEditor.onCompositionEnd = event => {\n    const PrevMentionIptEntry = getPrevMentionIptEntry(newEditor);\n    if (PrevMentionIptEntry) {\n      const {\n        data\n      } = event;\n      const insertPoint = Editor.end(editor, PrevMentionIptEntry[1]);\n      const nextNodeEntry = Editor.next(editor, {\n        at: PrevMentionIptEntry[1]\n      });\n      Transforms.insertText(editor, data, {\n        at: insertPoint\n      });\n      event.preventDefault();\n      focusEditor(editor, _objectSpread(_objectSpread({}, insertPoint), {}, {\n        offset: insertPoint.offset + data.length\n      }));\n      if (nextNodeEntry) {\n        const [nextNode, nextPath] = nextNodeEntry;\n        if (Text.isText(nextNode) && nextNode.text === '') {\n          Transforms.removeNodes(editor, {\n            at: nextPath\n          });\n        }\n      }\n      return true;\n    }\n  };\n  newEditor.isInline = element => {\n    if ([MENTION, MENTION_TEMP].includes(element.type)) {\n      return true;\n    }\n    return isInline(element);\n  };\n  newEditor.normalizeNode = _ref => {\n    let [node, path] = _ref;\n    const mentionEntry = getMentionEntry(editor);\n    if (mentionEntry) {\n      const nextEntry = Editor.next(editor, {\n        at: mentionEntry[1]\n      });\n      const focusPoint = Editor.start(editor, nextEntry[1]);\n      focusEditor(editor, focusPoint);\n    }\n    return normalizeNode([node, path]);\n  };\n  return newEditor;\n};\nexport default withMention;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}