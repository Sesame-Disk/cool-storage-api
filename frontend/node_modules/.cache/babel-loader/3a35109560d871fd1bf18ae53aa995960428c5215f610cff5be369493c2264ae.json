{"ast":null,"code":"var specialForm = /^(block|let*|return-from|catch|load-time-value|setq|eval-when|locally|symbol-macrolet|flet|macrolet|tagbody|function|multiple-value-call|the|go|multiple-value-prog1|throw|if|progn|unwind-protect|labels|progv|let|quote)$/;\nvar assumeBody = /^with|^def|^do|^prog|case$|^cond$|bind$|when$|unless$/;\nvar numLiteral = /^(?:[+\\-]?(?:\\d+|\\d*\\.\\d+)(?:[efd][+\\-]?\\d+)?|[+\\-]?\\d+(?:\\/[+\\-]?\\d+)?|#b[+\\-]?[01]+|#o[+\\-]?[0-7]+|#x[+\\-]?[\\da-f]+)/;\nvar symbol = /[^\\s'`,@()\\[\\]\";]/;\nvar type;\nfunction readSym(stream) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"\\\\\") stream.next();else if (!symbol.test(ch)) {\n      stream.backUp(1);\n      break;\n    }\n  }\n  return stream.current();\n}\nfunction base(stream, state) {\n  if (stream.eatSpace()) {\n    type = \"ws\";\n    return null;\n  }\n  if (stream.match(numLiteral)) return \"number\";\n  var ch = stream.next();\n  if (ch == \"\\\\\") ch = stream.next();\n  if (ch == '\"') return (state.tokenize = inString)(stream, state);else if (ch == \"(\") {\n    type = \"open\";\n    return \"bracket\";\n  } else if (ch == \")\" || ch == \"]\") {\n    type = \"close\";\n    return \"bracket\";\n  } else if (ch == \";\") {\n    stream.skipToEnd();\n    type = \"ws\";\n    return \"comment\";\n  } else if (/['`,@]/.test(ch)) return null;else if (ch == \"|\") {\n    if (stream.skipTo(\"|\")) {\n      stream.next();\n      return \"variableName\";\n    } else {\n      stream.skipToEnd();\n      return \"error\";\n    }\n  } else if (ch == \"#\") {\n    var ch = stream.next();\n    if (ch == \"(\") {\n      type = \"open\";\n      return \"bracket\";\n    } else if (/[+\\-=\\.']/.test(ch)) return null;else if (/\\d/.test(ch) && stream.match(/^\\d*#/)) return null;else if (ch == \"|\") return (state.tokenize = inComment)(stream, state);else if (ch == \":\") {\n      readSym(stream);\n      return \"meta\";\n    } else if (ch == \"\\\\\") {\n      stream.next();\n      readSym(stream);\n      return \"string.special\";\n    } else return \"error\";\n  } else {\n    var name = readSym(stream);\n    if (name == \".\") return null;\n    type = \"symbol\";\n    if (name == \"nil\" || name == \"t\" || name.charAt(0) == \":\") return \"atom\";\n    if (state.lastType == \"open\" && (specialForm.test(name) || assumeBody.test(name))) return \"keyword\";\n    if (name.charAt(0) == \"&\") return \"variableName.special\";\n    return \"variableName\";\n  }\n}\nfunction inString(stream, state) {\n  var escaped = false,\n    next;\n  while (next = stream.next()) {\n    if (next == '\"' && !escaped) {\n      state.tokenize = base;\n      break;\n    }\n    escaped = !escaped && next == \"\\\\\";\n  }\n  return \"string\";\n}\nfunction inComment(stream, state) {\n  var next, last;\n  while (next = stream.next()) {\n    if (next == \"#\" && last == \"|\") {\n      state.tokenize = base;\n      break;\n    }\n    last = next;\n  }\n  type = \"ws\";\n  return \"comment\";\n}\nexport var commonLisp = {\n  name: \"commonlisp\",\n  startState: function startState() {\n    return {\n      ctx: {\n        prev: null,\n        start: 0,\n        indentTo: 0\n      },\n      lastType: null,\n      tokenize: base\n    };\n  },\n  token: function token(stream, state) {\n    if (stream.sol() && typeof state.ctx.indentTo != \"number\") state.ctx.indentTo = state.ctx.start + 1;\n    type = null;\n    var style = state.tokenize(stream, state);\n    if (type != \"ws\") {\n      if (state.ctx.indentTo == null) {\n        if (type == \"symbol\" && assumeBody.test(stream.current())) state.ctx.indentTo = state.ctx.start + stream.indentUnit;else state.ctx.indentTo = \"next\";\n      } else if (state.ctx.indentTo == \"next\") {\n        state.ctx.indentTo = stream.column();\n      }\n      state.lastType = type;\n    }\n    if (type == \"open\") state.ctx = {\n      prev: state.ctx,\n      start: stream.column(),\n      indentTo: null\n    };else if (type == \"close\") state.ctx = state.ctx.prev || state.ctx;\n    return style;\n  },\n  indent: function indent(state) {\n    var i = state.ctx.indentTo;\n    return typeof i == \"number\" ? i : state.ctx.start + 1;\n  },\n  languageData: {\n    commentTokens: {\n      line: \";;\",\n      block: {\n        open: \"#|\",\n        close: \"|#\"\n      }\n    },\n    closeBrackets: {\n      brackets: [\"(\", \"[\", \"{\", '\"']\n    }\n  }\n};","map":{"version":3,"names":["specialForm","assumeBody","numLiteral","symbol","type","readSym","stream","ch","next","test","backUp","current","base","state","eatSpace","match","tokenize","inString","skipToEnd","skipTo","inComment","name","charAt","lastType","escaped","last","commonLisp","startState","ctx","prev","start","indentTo","token","sol","style","indentUnit","column","indent","i","languageData","commentTokens","line","block","open","close","closeBrackets","brackets"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@codemirror/legacy-modes/mode/commonlisp.js"],"sourcesContent":["var specialForm = /^(block|let*|return-from|catch|load-time-value|setq|eval-when|locally|symbol-macrolet|flet|macrolet|tagbody|function|multiple-value-call|the|go|multiple-value-prog1|throw|if|progn|unwind-protect|labels|progv|let|quote)$/;\nvar assumeBody = /^with|^def|^do|^prog|case$|^cond$|bind$|when$|unless$/;\nvar numLiteral = /^(?:[+\\-]?(?:\\d+|\\d*\\.\\d+)(?:[efd][+\\-]?\\d+)?|[+\\-]?\\d+(?:\\/[+\\-]?\\d+)?|#b[+\\-]?[01]+|#o[+\\-]?[0-7]+|#x[+\\-]?[\\da-f]+)/;\nvar symbol = /[^\\s'`,@()\\[\\]\";]/;\nvar type;\n\nfunction readSym(stream) {\n  var ch;\n  while (ch = stream.next()) {\n    if (ch == \"\\\\\") stream.next();\n    else if (!symbol.test(ch)) { stream.backUp(1); break; }\n  }\n  return stream.current();\n}\n\nfunction base(stream, state) {\n  if (stream.eatSpace()) {type = \"ws\"; return null;}\n  if (stream.match(numLiteral)) return \"number\";\n  var ch = stream.next();\n  if (ch == \"\\\\\") ch = stream.next();\n\n  if (ch == '\"') return (state.tokenize = inString)(stream, state);\n  else if (ch == \"(\") { type = \"open\"; return \"bracket\"; }\n  else if (ch == \")\" || ch == \"]\") { type = \"close\"; return \"bracket\"; }\n  else if (ch == \";\") { stream.skipToEnd(); type = \"ws\"; return \"comment\"; }\n  else if (/['`,@]/.test(ch)) return null;\n  else if (ch == \"|\") {\n    if (stream.skipTo(\"|\")) { stream.next(); return \"variableName\"; }\n    else { stream.skipToEnd(); return \"error\"; }\n  } else if (ch == \"#\") {\n    var ch = stream.next();\n    if (ch == \"(\") { type = \"open\"; return \"bracket\"; }\n    else if (/[+\\-=\\.']/.test(ch)) return null;\n    else if (/\\d/.test(ch) && stream.match(/^\\d*#/)) return null;\n    else if (ch == \"|\") return (state.tokenize = inComment)(stream, state);\n    else if (ch == \":\") { readSym(stream); return \"meta\"; }\n    else if (ch == \"\\\\\") { stream.next(); readSym(stream); return \"string.special\" }\n    else return \"error\";\n  } else {\n    var name = readSym(stream);\n    if (name == \".\") return null;\n    type = \"symbol\";\n    if (name == \"nil\" || name == \"t\" || name.charAt(0) == \":\") return \"atom\";\n    if (state.lastType == \"open\" && (specialForm.test(name) || assumeBody.test(name))) return \"keyword\";\n    if (name.charAt(0) == \"&\") return \"variableName.special\";\n    return \"variableName\";\n  }\n}\n\nfunction inString(stream, state) {\n  var escaped = false, next;\n  while (next = stream.next()) {\n    if (next == '\"' && !escaped) { state.tokenize = base; break; }\n    escaped = !escaped && next == \"\\\\\";\n  }\n  return \"string\";\n}\n\nfunction inComment(stream, state) {\n  var next, last;\n  while (next = stream.next()) {\n    if (next == \"#\" && last == \"|\") { state.tokenize = base; break; }\n    last = next;\n  }\n  type = \"ws\";\n  return \"comment\";\n}\n\nexport const commonLisp = {\n  name: \"commonlisp\",\n  startState: function () {\n    return {ctx: {prev: null, start: 0, indentTo: 0}, lastType: null, tokenize: base};\n  },\n\n  token: function (stream, state) {\n    if (stream.sol() && typeof state.ctx.indentTo != \"number\")\n      state.ctx.indentTo = state.ctx.start + 1;\n\n    type = null;\n    var style = state.tokenize(stream, state);\n    if (type != \"ws\") {\n      if (state.ctx.indentTo == null) {\n        if (type == \"symbol\" && assumeBody.test(stream.current()))\n          state.ctx.indentTo = state.ctx.start + stream.indentUnit;\n        else\n          state.ctx.indentTo = \"next\";\n      } else if (state.ctx.indentTo == \"next\") {\n        state.ctx.indentTo = stream.column();\n      }\n      state.lastType = type;\n    }\n    if (type == \"open\") state.ctx = {prev: state.ctx, start: stream.column(), indentTo: null};\n    else if (type == \"close\") state.ctx = state.ctx.prev || state.ctx;\n    return style;\n  },\n\n  indent: function (state) {\n    var i = state.ctx.indentTo;\n    return typeof i == \"number\" ? i : state.ctx.start + 1;\n  },\n\n  languageData: {\n    commentTokens: {line: \";;\", block: {open: \"#|\", close: \"|#\"}},\n    closeBrackets: {brackets: [\"(\", \"[\", \"{\", '\"']}\n  }\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}