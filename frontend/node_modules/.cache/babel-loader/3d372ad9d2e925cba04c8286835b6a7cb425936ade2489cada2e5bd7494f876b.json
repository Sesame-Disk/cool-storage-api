{"ast":null,"code":"import _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _inherits from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createClass from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { isPlainObject } from 'is-plain-object';\nimport { Text, Range, Node, Element, createEditor as createEditor$1 } from 'slate';\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\r\n * A weak map to hold anchor tokens.\r\n */\nvar ANCHOR = new WeakMap();\n/**\r\n * A weak map to hold focus tokens.\r\n */\n\nvar FOCUS = new WeakMap();\n/**\r\n * All tokens inherit from a single constructor for `instanceof` checking.\r\n */\nvar Token = /*#__PURE__*/_createClass(function Token() {\n  _classCallCheck(this, Token);\n});\n/**\r\n * Anchor tokens represent the selection's anchor point.\r\n */\nvar AnchorToken = /*#__PURE__*/function (_Token) {\n  _inherits(AnchorToken, _Token);\n  var _super = _createSuper(AnchorToken);\n  function AnchorToken() {\n    var _this;\n    _classCallCheck(this, AnchorToken);\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _this = _super.call(this);\n    var offset = props.offset,\n      path = props.path;\n    _this.offset = offset;\n    _this.path = path;\n    return _this;\n  }\n  return _createClass(AnchorToken);\n}(Token);\n/**\r\n * Focus tokens represent the selection's focus point.\r\n */\nvar FocusToken = /*#__PURE__*/function (_Token2) {\n  _inherits(FocusToken, _Token2);\n  var _super2 = _createSuper(FocusToken);\n  function FocusToken() {\n    var _this2;\n    _classCallCheck(this, FocusToken);\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _this2 = _super2.call(this);\n    var offset = props.offset,\n      path = props.path;\n    _this2.offset = offset;\n    _this2.path = path;\n    return _this2;\n  }\n  return _createClass(FocusToken);\n}(Token);\n/**\r\n * Add an anchor token to the end of a text node.\r\n */\nvar addAnchorToken = function addAnchorToken(text, token) {\n  var offset = text.text.length;\n  ANCHOR.set(text, [offset, token]);\n};\n/**\r\n * Get the offset if a text node has an associated anchor token.\r\n */\n\nvar getAnchorOffset = function getAnchorOffset(text) {\n  return ANCHOR.get(text);\n};\n/**\r\n * Add a focus token to the end of a text node.\r\n */\n\nvar addFocusToken = function addFocusToken(text, token) {\n  var offset = text.text.length;\n  FOCUS.set(text, [offset, token]);\n};\n/**\r\n * Get the offset if a text node has an associated focus token.\r\n */\n\nvar getFocusOffset = function getFocusOffset(text) {\n  return FOCUS.get(text);\n};\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys$1(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$1(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n/**\r\n * Resolve the descedants of a node by normalizing the children that can be\r\n * passed into a hyperscript creator function.\r\n */\n\nvar STRINGS = new WeakSet();\nvar resolveDescendants = function resolveDescendants(children) {\n  var nodes = [];\n  var addChild = function addChild(child) {\n    if (child == null) {\n      return;\n    }\n    var prev = nodes[nodes.length - 1];\n    if (typeof child === 'string') {\n      var text = {\n        text: child\n      };\n      STRINGS.add(text);\n      child = text;\n    }\n    if (Text.isText(child)) {\n      var c = child; // HACK: fix typescript complaining\n\n      if (Text.isText(prev) && STRINGS.has(prev) && STRINGS.has(c) && Text.equals(prev, c, {\n        loose: true\n      })) {\n        prev.text += c.text;\n      } else {\n        nodes.push(c);\n      }\n    } else if (Element.isElement(child)) {\n      nodes.push(child);\n    } else if (child instanceof Token) {\n      var n = nodes[nodes.length - 1];\n      if (!Text.isText(n)) {\n        addChild('');\n        n = nodes[nodes.length - 1];\n      }\n      if (child instanceof AnchorToken) {\n        addAnchorToken(n, child);\n      } else if (child instanceof FocusToken) {\n        addFocusToken(n, child);\n      }\n    } else {\n      throw new Error(\"Unexpected hyperscript child object: \".concat(child));\n    }\n  };\n  var _iterator = _createForOfIteratorHelper(children.flat(Infinity)),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var child = _step.value;\n      addChild(child);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return nodes;\n};\n/**\r\n * Create an anchor token.\r\n */\n\nfunction createAnchor(tagName, attributes, children) {\n  return new AnchorToken(attributes);\n}\n/**\r\n * Create an anchor and a focus token.\r\n */\n\nfunction createCursor(tagName, attributes, children) {\n  return [new AnchorToken(attributes), new FocusToken(attributes)];\n}\n/**\r\n * Create an `Element` object.\r\n */\n\nfunction createElement(tagName, attributes, children) {\n  return _objectSpread$1(_objectSpread$1({}, attributes), {}, {\n    children: resolveDescendants(children)\n  });\n}\n/**\r\n * Create a focus token.\r\n */\n\nfunction createFocus(tagName, attributes, children) {\n  return new FocusToken(attributes);\n}\n/**\r\n * Create a fragment.\r\n */\n\nfunction createFragment(tagName, attributes, children) {\n  return resolveDescendants(children);\n}\n/**\r\n * Create a `Selection` object.\r\n */\n\nfunction createSelection(tagName, attributes, children) {\n  var anchor = children.find(function (c) {\n    return c instanceof AnchorToken;\n  });\n  var focus = children.find(function (c) {\n    return c instanceof FocusToken;\n  });\n  if (!anchor || anchor.offset == null || anchor.path == null) {\n    throw new Error(\"The <selection> hyperscript tag must have an <anchor> tag as a child with `path` and `offset` attributes defined.\");\n  }\n  if (!focus || focus.offset == null || focus.path == null) {\n    throw new Error(\"The <selection> hyperscript tag must have a <focus> tag as a child with `path` and `offset` attributes defined.\");\n  }\n  return _objectSpread$1({\n    anchor: {\n      offset: anchor.offset,\n      path: anchor.path\n    },\n    focus: {\n      offset: focus.offset,\n      path: focus.path\n    }\n  }, attributes);\n}\n/**\r\n * Create a `Text` object.\r\n */\n\nfunction createText(tagName, attributes, children) {\n  var nodes = resolveDescendants(children);\n  if (nodes.length > 1) {\n    throw new Error(\"The <text> hyperscript tag must only contain a single node's worth of children.\");\n  }\n  var _nodes = _slicedToArray(nodes, 1),\n    node = _nodes[0];\n  if (node == null) {\n    node = {\n      text: ''\n    };\n  }\n  if (!Text.isText(node)) {\n    throw new Error(\"\\n    The <text> hyperscript tag can only contain text content as children.\");\n  } // COMPAT: If they used the <text> tag we want to guarantee that it won't be\n  // merge with other string children.\n\n  STRINGS.delete(node);\n  Object.assign(node, attributes);\n  return node;\n}\n/**\r\n * Create a top-level `Editor` object.\r\n */\n\nvar createEditor = function createEditor(makeEditor) {\n  return function (tagName, attributes, children) {\n    var otherChildren = [];\n    var selectionChild;\n    var _iterator2 = _createForOfIteratorHelper(children),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var child = _step2.value;\n        if (Range.isRange(child)) {\n          selectionChild = child;\n        } else {\n          otherChildren.push(child);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    var descendants = resolveDescendants(otherChildren);\n    var selection = {};\n    var editor = makeEditor();\n    Object.assign(editor, attributes);\n    editor.children = descendants; // Search the document's texts to see if any of them have tokens associated\n    // that need incorporated into the selection.\n    var _iterator3 = _createForOfIteratorHelper(Node.texts(editor)),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _step3$value = _slicedToArray(_step3.value, 2),\n          node = _step3$value[0],\n          path = _step3$value[1];\n        var anchor = getAnchorOffset(node);\n        var focus = getFocusOffset(node);\n        if (anchor != null) {\n          var _anchor = anchor,\n            _anchor2 = _slicedToArray(_anchor, 1),\n            offset = _anchor2[0];\n          selection.anchor = {\n            path: path,\n            offset: offset\n          };\n        }\n        if (focus != null) {\n          var _focus = focus,\n            _focus2 = _slicedToArray(_focus, 1),\n            _offset = _focus2[0];\n          selection.focus = {\n            path: path,\n            offset: _offset\n          };\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    if (selection.anchor && !selection.focus) {\n      throw new Error(\"Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<anchor />`. For collapsed selections, use `<cursor />` instead.\");\n    }\n    if (!selection.anchor && selection.focus) {\n      throw new Error(\"Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<focus />`. For collapsed selections, use `<cursor />` instead.\");\n    }\n    if (selectionChild != null) {\n      editor.selection = selectionChild;\n    } else if (Range.isRange(selection)) {\n      editor.selection = selection;\n    }\n    return editor;\n  };\n};\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n/**\r\n * The default creators for Slate objects.\r\n */\n\nvar DEFAULT_CREATORS = {\n  anchor: createAnchor,\n  cursor: createCursor,\n  editor: createEditor(createEditor$1),\n  element: createElement,\n  focus: createFocus,\n  fragment: createFragment,\n  selection: createSelection,\n  text: createText\n};\n/**\r\n * Create a Slate hyperscript function with `options`.\r\n */\n\nvar createHyperscript = function createHyperscript() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _options$elements = options.elements,\n    elements = _options$elements === void 0 ? {} : _options$elements;\n  var elementCreators = normalizeElements(elements);\n  var creators = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_CREATORS), elementCreators), options.creators);\n  var jsx = createFactory(creators);\n  return jsx;\n};\n/**\r\n * Create a Slate hyperscript function with `options`.\r\n */\n\nvar createFactory = function createFactory(creators) {\n  var jsx = function jsx(tagName, attributes) {\n    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      children[_key - 2] = arguments[_key];\n    }\n    var creator = creators[tagName];\n    if (!creator) {\n      throw new Error(\"No hyperscript creator found for tag: <\".concat(tagName, \">\"));\n    }\n    if (attributes == null) {\n      attributes = {};\n    }\n    if (!isPlainObject(attributes)) {\n      children = [attributes].concat(children);\n      attributes = {};\n    }\n    children = children.filter(function (child) {\n      return Boolean(child);\n    }).flat();\n    var ret = creator(tagName, attributes, children);\n    return ret;\n  };\n  return jsx;\n};\n/**\r\n * Normalize a dictionary of element shorthands into creator functions.\r\n */\n\nvar normalizeElements = function normalizeElements(elements) {\n  var creators = {};\n  var _loop = function _loop(tagName) {\n    var props = elements[tagName];\n    if (typeof props !== 'object') {\n      throw new Error(\"Properties specified for a hyperscript shorthand should be an object, but for the custom element <\".concat(tagName, \">  tag you passed: \").concat(props));\n    }\n    creators[tagName] = function (tagName, attributes, children) {\n      return createElement('element', _objectSpread(_objectSpread({}, props), attributes), children);\n    };\n  };\n  for (var tagName in elements) {\n    _loop(tagName);\n  }\n  return creators;\n};\n\n/**\r\n * The default hyperscript factory that ships with Slate, without custom tags.\r\n */\n\nvar jsx = createHyperscript();\nexport { createEditor, createHyperscript, createText, jsx };","map":{"version":3,"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","ANCHOR","WeakMap","FOCUS","Token","_createClass","_classCallCheck","AnchorToken","_Token","_inherits","_super","_createSuper","_this","props","arguments","length","undefined","call","offset","path","FocusToken","_Token2","_super2","_this2","addAnchorToken","text","token","set","getAnchorOffset","get","addFocusToken","getFocusOffset","STRINGS","WeakSet","resolveDescendants","children","nodes","addChild","child","prev","add","Text","isText","c","has","equals","loose","push","Element","isElement","n","Error","concat","_iterator","_createForOfIteratorHelper","flat","Infinity","_step","s","done","err","e","f","createAnchor","tagName","attributes","createCursor","createElement","_objectSpread$1","createFocus","createFragment","createSelection","anchor","find","focus","createText","_nodes","_slicedToArray","node","delete","assign","createEditor","makeEditor","otherChildren","selectionChild","_iterator2","_step2","Range","isRange","descendants","selection","editor","_iterator3","Node","texts","_step3","_step3$value","_anchor","_anchor2","_focus","_focus2","_offset","DEFAULT_CREATORS","cursor","createEditor$1","element","fragment","createHyperscript","options","_options$elements","elements","elementCreators","normalizeElements","creators","_objectSpread","jsx","createFactory","Array","_len","_key","creator","isPlainObject","filter","Boolean","ret","_loop"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/.yarn/cache/@babel-runtime-npm-7.15.3-6333c71362-2f0b8d2d4e.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/slate-hyperscript/src/tokens.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/slate-hyperscript/src/creators.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/slate-hyperscript/src/hyperscript.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/slate-hyperscript/src/index.ts"],"sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import { Node, Path, Text } from 'slate'\n\n/**\n * A weak map to hold anchor tokens.\n */\n\nconst ANCHOR: WeakMap<Node, [number, AnchorToken]> = new WeakMap()\n\n/**\n * A weak map to hold focus tokens.\n */\n\nconst FOCUS: WeakMap<Node, [number, FocusToken]> = new WeakMap()\n\n/**\n * All tokens inherit from a single constructor for `instanceof` checking.\n */\n\nexport class Token {}\n\n/**\n * Anchor tokens represent the selection's anchor point.\n */\n\nexport class AnchorToken extends Token {\n  offset?: number\n  path?: Path\n\n  constructor(\n    props: {\n      offset?: number\n      path?: Path\n    } = {}\n  ) {\n    super()\n    const { offset, path } = props\n    this.offset = offset\n    this.path = path\n  }\n}\n\n/**\n * Focus tokens represent the selection's focus point.\n */\n\nexport class FocusToken extends Token {\n  offset?: number\n  path?: Path\n\n  constructor(\n    props: {\n      offset?: number\n      path?: Path\n    } = {}\n  ) {\n    super()\n    const { offset, path } = props\n    this.offset = offset\n    this.path = path\n  }\n}\n\n/**\n * Add an anchor token to the end of a text node.\n */\n\nexport const addAnchorToken = (text: Text, token: AnchorToken) => {\n  const offset = text.text.length\n  ANCHOR.set(text, [offset, token])\n}\n\n/**\n * Get the offset if a text node has an associated anchor token.\n */\n\nexport const getAnchorOffset = (\n  text: Text\n): [number, AnchorToken] | undefined => {\n  return ANCHOR.get(text)\n}\n\n/**\n * Add a focus token to the end of a text node.\n */\n\nexport const addFocusToken = (text: Text, token: FocusToken) => {\n  const offset = text.text.length\n  FOCUS.set(text, [offset, token])\n}\n\n/**\n * Get the offset if a text node has an associated focus token.\n */\n\nexport const getFocusOffset = (\n  text: Text\n): [number, FocusToken] | undefined => {\n  return FOCUS.get(text)\n}\n","import { Element, Descendant, Node, Range, Text, Editor } from 'slate'\nimport {\n  AnchorToken,\n  FocusToken,\n  Token,\n  addAnchorToken,\n  addFocusToken,\n  getAnchorOffset,\n  getFocusOffset,\n} from './tokens'\n\n/**\n * Resolve the descedants of a node by normalizing the children that can be\n * passed into a hyperscript creator function.\n */\n\nconst STRINGS: WeakSet<Text> = new WeakSet()\n\nconst resolveDescendants = (children: any[]): Descendant[] => {\n  const nodes: Node[] = []\n\n  const addChild = (child: Node | Token): void => {\n    if (child == null) {\n      return\n    }\n\n    const prev = nodes[nodes.length - 1]\n\n    if (typeof child === 'string') {\n      const text = { text: child }\n      STRINGS.add(text)\n      child = text\n    }\n\n    if (Text.isText(child)) {\n      const c = child // HACK: fix typescript complaining\n\n      if (\n        Text.isText(prev) &&\n        STRINGS.has(prev) &&\n        STRINGS.has(c) &&\n        Text.equals(prev, c, { loose: true })\n      ) {\n        prev.text += c.text\n      } else {\n        nodes.push(c)\n      }\n    } else if (Element.isElement(child)) {\n      nodes.push(child)\n    } else if (child instanceof Token) {\n      let n = nodes[nodes.length - 1]\n\n      if (!Text.isText(n)) {\n        addChild('')\n        n = nodes[nodes.length - 1] as Text\n      }\n\n      if (child instanceof AnchorToken) {\n        addAnchorToken(n, child)\n      } else if (child instanceof FocusToken) {\n        addFocusToken(n, child)\n      }\n    } else {\n      throw new Error(`Unexpected hyperscript child object: ${child}`)\n    }\n  }\n\n  for (const child of children.flat(Infinity)) {\n    addChild(child)\n  }\n\n  return nodes\n}\n\n/**\n * Create an anchor token.\n */\n\nexport function createAnchor(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): AnchorToken {\n  return new AnchorToken(attributes)\n}\n\n/**\n * Create an anchor and a focus token.\n */\n\nexport function createCursor(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Token[] {\n  return [new AnchorToken(attributes), new FocusToken(attributes)]\n}\n\n/**\n * Create an `Element` object.\n */\n\nexport function createElement(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Element {\n  return { ...attributes, children: resolveDescendants(children) }\n}\n\n/**\n * Create a focus token.\n */\n\nexport function createFocus(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): FocusToken {\n  return new FocusToken(attributes)\n}\n\n/**\n * Create a fragment.\n */\n\nexport function createFragment(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Descendant[] {\n  return resolveDescendants(children)\n}\n\n/**\n * Create a `Selection` object.\n */\n\nexport function createSelection(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Range {\n  const anchor: AnchorToken = children.find(c => c instanceof AnchorToken)\n  const focus: FocusToken = children.find(c => c instanceof FocusToken)\n\n  if (!anchor || anchor.offset == null || anchor.path == null) {\n    throw new Error(\n      `The <selection> hyperscript tag must have an <anchor> tag as a child with \\`path\\` and \\`offset\\` attributes defined.`\n    )\n  }\n\n  if (!focus || focus.offset == null || focus.path == null) {\n    throw new Error(\n      `The <selection> hyperscript tag must have a <focus> tag as a child with \\`path\\` and \\`offset\\` attributes defined.`\n    )\n  }\n\n  return {\n    anchor: {\n      offset: anchor.offset,\n      path: anchor.path,\n    },\n    focus: {\n      offset: focus.offset,\n      path: focus.path,\n    },\n    ...attributes,\n  }\n}\n\n/**\n * Create a `Text` object.\n */\n\nexport function createText(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Text {\n  const nodes = resolveDescendants(children)\n\n  if (nodes.length > 1) {\n    throw new Error(\n      `The <text> hyperscript tag must only contain a single node's worth of children.`\n    )\n  }\n\n  let [node] = nodes\n\n  if (node == null) {\n    node = { text: '' }\n  }\n\n  if (!Text.isText(node)) {\n    throw new Error(`\n    The <text> hyperscript tag can only contain text content as children.`)\n  }\n\n  // COMPAT: If they used the <text> tag we want to guarantee that it won't be\n  // merge with other string children.\n  STRINGS.delete(node)\n\n  Object.assign(node, attributes)\n  return node\n}\n\n/**\n * Create a top-level `Editor` object.\n */\n\nexport const createEditor = (makeEditor: () => Editor) => (\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Editor => {\n  const otherChildren: any[] = []\n  let selectionChild: Range | undefined\n\n  for (const child of children) {\n    if (Range.isRange(child)) {\n      selectionChild = child\n    } else {\n      otherChildren.push(child)\n    }\n  }\n\n  const descendants = resolveDescendants(otherChildren)\n  const selection: Partial<Range> = {}\n  const editor = makeEditor()\n  Object.assign(editor, attributes)\n  editor.children = descendants as Element[]\n\n  // Search the document's texts to see if any of them have tokens associated\n  // that need incorporated into the selection.\n  for (const [node, path] of Node.texts(editor)) {\n    const anchor = getAnchorOffset(node)\n    const focus = getFocusOffset(node)\n\n    if (anchor != null) {\n      const [offset] = anchor\n      selection.anchor = { path, offset }\n    }\n\n    if (focus != null) {\n      const [offset] = focus\n      selection.focus = { path, offset }\n    }\n  }\n\n  if (selection.anchor && !selection.focus) {\n    throw new Error(\n      `Slate hyperscript ranges must have both \\`<anchor />\\` and \\`<focus />\\` defined if one is defined, but you only defined \\`<anchor />\\`. For collapsed selections, use \\`<cursor />\\` instead.`\n    )\n  }\n\n  if (!selection.anchor && selection.focus) {\n    throw new Error(\n      `Slate hyperscript ranges must have both \\`<anchor />\\` and \\`<focus />\\` defined if one is defined, but you only defined \\`<focus />\\`. For collapsed selections, use \\`<cursor />\\` instead.`\n    )\n  }\n\n  if (selectionChild != null) {\n    editor.selection = selectionChild\n  } else if (Range.isRange(selection)) {\n    editor.selection = selection\n  }\n\n  return editor\n}\n","import { isPlainObject } from 'is-plain-object'\nimport { Element, createEditor as makeEditor } from 'slate'\nimport {\n  createAnchor,\n  createCursor,\n  createEditor,\n  createElement,\n  createFocus,\n  createFragment,\n  createSelection,\n  createText,\n} from './creators'\n\n/**\n * The default creators for Slate objects.\n */\n\nconst DEFAULT_CREATORS = {\n  anchor: createAnchor,\n  cursor: createCursor,\n  editor: createEditor(makeEditor),\n  element: createElement,\n  focus: createFocus,\n  fragment: createFragment,\n  selection: createSelection,\n  text: createText,\n}\n\n/**\n * `HyperscriptCreators` are dictionaries of `HyperscriptCreator` functions\n * keyed by tag name.\n */\n\ntype HyperscriptCreators<T = any> = Record<\n  string,\n  (tagName: string, attributes: { [key: string]: any }, children: any[]) => T\n>\n\n/**\n * `HyperscriptShorthands` are dictionaries of properties applied to specific\n * kind of object, keyed by tag name. They allow you to easily define custom\n * hyperscript tags for your domain.\n */\n\ntype HyperscriptShorthands = Record<string, Record<string, any>>\n\n/**\n * Create a Slate hyperscript function with `options`.\n */\n\nconst createHyperscript = (\n  options: {\n    creators?: HyperscriptCreators\n    elements?: HyperscriptShorthands\n  } = {}\n) => {\n  const { elements = {} } = options\n  const elementCreators = normalizeElements(elements)\n  const creators = {\n    ...DEFAULT_CREATORS,\n    ...elementCreators,\n    ...options.creators,\n  }\n\n  const jsx = createFactory(creators)\n  return jsx\n}\n\n/**\n * Create a Slate hyperscript function with `options`.\n */\n\nconst createFactory = <T extends HyperscriptCreators>(creators: T) => {\n  const jsx = <S extends keyof T & string>(\n    tagName: S,\n    attributes?: Object,\n    ...children: any[]\n  ): ReturnType<T[S]> => {\n    const creator = creators[tagName]\n\n    if (!creator) {\n      throw new Error(`No hyperscript creator found for tag: <${tagName}>`)\n    }\n\n    if (attributes == null) {\n      attributes = {}\n    }\n\n    if (!isPlainObject(attributes)) {\n      children = [attributes].concat(children)\n      attributes = {}\n    }\n\n    children = children.filter(child => Boolean(child)).flat()\n    const ret = creator(tagName, attributes, children)\n    return ret\n  }\n\n  return jsx\n}\n\n/**\n * Normalize a dictionary of element shorthands into creator functions.\n */\n\nconst normalizeElements = (elements: HyperscriptShorthands) => {\n  const creators: HyperscriptCreators<Element> = {}\n\n  for (const tagName in elements) {\n    const props = elements[tagName]\n\n    if (typeof props !== 'object') {\n      throw new Error(\n        `Properties specified for a hyperscript shorthand should be an object, but for the custom element <${tagName}>  tag you passed: ${props}`\n      )\n    }\n\n    creators[tagName] = (\n      tagName: string,\n      attributes: { [key: string]: any },\n      children: any[]\n    ) => {\n      return createElement('element', { ...props, ...attributes }, children)\n    }\n  }\n\n  return creators\n}\n\nexport { createHyperscript, HyperscriptCreators, HyperscriptShorthands }\n","import {\n  createHyperscript,\n  HyperscriptCreators,\n  HyperscriptShorthands,\n} from './hyperscript'\nimport { createEditor, createText } from './creators'\n\n/**\n * The default hyperscript factory that ships with Slate, without custom tags.\n */\n\nconst jsx = createHyperscript()\n\nexport {\n  jsx,\n  createHyperscript,\n  createEditor,\n  createText,\n  HyperscriptCreators,\n  HyperscriptShorthands,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}