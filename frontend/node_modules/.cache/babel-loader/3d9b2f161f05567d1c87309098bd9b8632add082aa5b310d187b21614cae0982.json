{"ast":null,"code":"import _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { Editor, Element, Transforms, Node, Path, Range } from '@seafile/slate';\nimport { focusEditor, generateDefaultText, generateEmptyElement, getSelectedNodeByType, getSelectedNodeEntryByType, isBlockAboveEmpty, isSelectionAtBlockStart } from '../../core';\nimport { BLOCKQUOTE, PARAGRAPH, CODE_BLOCK, TABLE } from '../../constants';\nimport { getFormattedElements, getFormattedRestElements } from './helpers';\nvar withBlockquote = function withBlockquote(editor) {\n  var insertBreak = editor.insertBreak,\n    deleteBackward = editor.deleteBackward,\n    insertFragment = editor.insertFragment;\n  var newEditor = editor;\n  newEditor.insertBreak = function () {\n    var selection = editor.selection;\n    if (selection == null) return insertBreak();\n    var _Editor$nodes = Editor.nodes(editor, {\n        match: function match(n) {\n          return Element.isElement(n) && n.type === BLOCKQUOTE;\n        },\n        universal: true\n      }),\n      _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n      quoteBlockEntry = _Editor$nodes2[0];\n    if (!quoteBlockEntry) return insertBreak();\n    var _Editor$nodes3 = Editor.nodes(newEditor, {\n        match: function match(n) {\n          return Element.isElement(n) && n.type === PARAGRAPH;\n        },\n        mode: 'lowest'\n      }),\n      _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1),\n      currentLineEntry = _Editor$nodes4[0];\n    // Exit blockquote when current line is empty\n    var isAtEnd = currentLineEntry[1].slice(-1)[0] === quoteBlockEntry[0].children.length - 1;\n    if (isAtEnd) {\n      var isEmptyLine = !(currentLineEntry && Editor.string(newEditor, currentLineEntry[1]).length);\n      if (isEmptyLine) {\n        var nextPath = Path.next(quoteBlockEntry[1]);\n        Transforms.moveNodes(newEditor, {\n          at: currentLineEntry[1],\n          to: nextPath\n        });\n        return;\n      }\n    }\n\n    // Insert new line\n    Transforms.insertNodes(editor, {\n      type: PARAGRAPH,\n      children: [generateDefaultText()]\n    }, {\n      at: newEditor.selection,\n      select: true\n    });\n  };\n  newEditor.deleteBackward = function (unit) {\n    var selection = newEditor.selection;\n    if (selection === null) {\n      deleteBackward(unit);\n      return;\n    }\n    var blockQuoteEntry = getSelectedNodeEntryByType(editor, BLOCKQUOTE);\n    if (blockQuoteEntry) {\n      var _blockQuoteEntry = _slicedToArray(blockQuoteEntry, 2),\n        blockQuotePath = _blockQuoteEntry[1];\n      var _Editor$nodes5 = Editor.nodes(newEditor, {\n          match: function match(n, p) {\n            return Element.isElement(n) && p.length === blockQuotePath.length + 1 && n.type === PARAGRAPH;\n          }\n        }),\n        _Editor$nodes6 = _slicedToArray(_Editor$nodes5, 1),\n        currentLineEntry = _Editor$nodes6[0];\n      if (!currentLineEntry) return deleteBackward(unit);\n      var _currentLineEntry = _slicedToArray(currentLineEntry, 2),\n        currentLinePath = _currentLineEntry[1];\n      var currentLineIndex = currentLinePath[blockQuotePath.length];\n      // Transforms to paragraph when Select at the beginning of the first line\n      if (currentLineIndex === 0 && isBlockAboveEmpty(newEditor)) {\n        var emptyParagraph = generateEmptyElement(PARAGRAPH);\n        Transforms.removeNodes(editor, {\n          at: blockQuoteEntry[1]\n        });\n        Transforms.insertNodes(newEditor, emptyParagraph, {\n          at: blockQuoteEntry[1]\n        });\n        var focusPoint = Editor.end(newEditor, blockQuoteEntry[1]);\n        focusEditor(newEditor, focusPoint);\n        return;\n      }\n      // Merge with previous line when Select at the beginning of the line\n      if (isSelectionAtBlockStart(editor)) {\n        var lineText = Node.string(currentLineEntry[0]);\n        var previousNodeEntry = Editor.previous(editor, {\n          at: currentLineEntry[1]\n        });\n        if (!previousNodeEntry) return;\n        var _focusPoint = Editor.end(newEditor, previousNodeEntry[1]);\n        Transforms.insertText(newEditor, lineText, {\n          at: Editor.end(newEditor, previousNodeEntry[1])\n        });\n        Transforms.removeNodes(editor, {\n          at: currentLineEntry[1]\n        });\n        focusEditor(newEditor, _focusPoint);\n        return;\n      }\n    }\n    deleteBackward(unit);\n  };\n  newEditor.insertFragment = function (data) {\n    // Paste into quote block\n    if (getSelectedNodeByType(newEditor, BLOCKQUOTE)) {\n      var lastIndex = data.findLastIndex(function (item) {\n        return [CODE_BLOCK, TABLE].includes(item === null || item === void 0 ? void 0 : item.type);\n      });\n      var elements = getFormattedElements(data.slice(0, lastIndex + 1));\n      var restElements = getFormattedRestElements(data.slice(lastIndex + 1));\n      var path = Editor.path(newEditor, newEditor.selection);\n\n      // Insert elements of quote block\n      if (restElements.length !== 0) {\n        if (Range.isCollapsed(editor.selection)) {\n          var paragraphEntry = getSelectedNodeEntryByType(newEditor, PARAGRAPH);\n          if (paragraphEntry) {\n            var parentNodeEntry = Editor.parent(editor, paragraphEntry[1]);\n            if (parentNodeEntry && parentNodeEntry[0].type === BLOCKQUOTE) {\n              if (!Node.string(paragraphEntry[0]).length) {\n                insertFragment(data);\n                return Transforms.removeNodes(newEditor, {\n                  at: paragraphEntry[1]\n                });\n              }\n            }\n          }\n        }\n        // Insert text when inserting a single line paragraph\n        if (restElements.length === 1 && restElements[0].type === PARAGRAPH) {\n          var string = Node.string(restElements[0]);\n          Editor.insertText(newEditor, string);\n        } else {\n          Transforms.insertNodes(newEditor, restElements, {\n            at: [path[0], path[1] + 1]\n          });\n        }\n      }\n\n      // Insert elements above the quoted block\n      if (elements.length !== 0) {\n        Transforms.insertNodes(newEditor, elements, {\n          at: [path[0]]\n        });\n      }\n      return;\n    }\n    return insertFragment(data);\n  };\n  return newEditor;\n};\nexport default withBlockquote;","map":{"version":3,"names":["Editor","Element","Transforms","Node","Path","Range","focusEditor","generateDefaultText","generateEmptyElement","getSelectedNodeByType","getSelectedNodeEntryByType","isBlockAboveEmpty","isSelectionAtBlockStart","BLOCKQUOTE","PARAGRAPH","CODE_BLOCK","TABLE","getFormattedElements","getFormattedRestElements","withBlockquote","editor","insertBreak","deleteBackward","insertFragment","newEditor","selection","_Editor$nodes","nodes","match","n","isElement","type","universal","_Editor$nodes2","_slicedToArray","quoteBlockEntry","_Editor$nodes3","mode","_Editor$nodes4","currentLineEntry","isAtEnd","slice","children","length","isEmptyLine","string","nextPath","next","moveNodes","at","to","insertNodes","select","unit","blockQuoteEntry","_blockQuoteEntry","blockQuotePath","_Editor$nodes5","p","_Editor$nodes6","_currentLineEntry","currentLinePath","currentLineIndex","emptyParagraph","removeNodes","focusPoint","end","lineText","previousNodeEntry","previous","insertText","data","lastIndex","findLastIndex","item","includes","elements","restElements","path","isCollapsed","paragraphEntry","parentNodeEntry","parent"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/plugins/blockquote/plugin.js"],"sourcesContent":["import { Editor, Element, Transforms, Node, Path, Range } from '@seafile/slate';\nimport { focusEditor, generateDefaultText, generateEmptyElement, getSelectedNodeByType, getSelectedNodeEntryByType, isBlockAboveEmpty, isSelectionAtBlockStart } from '../../core';\nimport { BLOCKQUOTE, PARAGRAPH, CODE_BLOCK, TABLE } from '../../constants';\nimport { getFormattedElements, getFormattedRestElements } from './helpers';\nconst withBlockquote = editor => {\n  const {\n    insertBreak,\n    deleteBackward,\n    insertFragment\n  } = editor;\n  const newEditor = editor;\n  newEditor.insertBreak = () => {\n    const {\n      selection\n    } = editor;\n    if (selection == null) return insertBreak();\n    const [quoteBlockEntry] = Editor.nodes(editor, {\n      match: n => Element.isElement(n) && n.type === BLOCKQUOTE,\n      universal: true\n    });\n    if (!quoteBlockEntry) return insertBreak();\n    const [currentLineEntry] = Editor.nodes(newEditor, {\n      match: n => Element.isElement(n) && n.type === PARAGRAPH,\n      mode: 'lowest'\n    });\n    // Exit blockquote when current line is empty\n    const isAtEnd = currentLineEntry[1].slice(-1)[0] === quoteBlockEntry[0].children.length - 1;\n    if (isAtEnd) {\n      const isEmptyLine = !(currentLineEntry && Editor.string(newEditor, currentLineEntry[1]).length);\n      if (isEmptyLine) {\n        const nextPath = Path.next(quoteBlockEntry[1]);\n        Transforms.moveNodes(newEditor, {\n          at: currentLineEntry[1],\n          to: nextPath\n        });\n        return;\n      }\n    }\n\n    // Insert new line\n    Transforms.insertNodes(editor, {\n      type: PARAGRAPH,\n      children: [generateDefaultText()]\n    }, {\n      at: newEditor.selection,\n      select: true\n    });\n  };\n  newEditor.deleteBackward = unit => {\n    const {\n      selection\n    } = newEditor;\n    if (selection === null) {\n      deleteBackward(unit);\n      return;\n    }\n    const blockQuoteEntry = getSelectedNodeEntryByType(editor, BLOCKQUOTE);\n    if (blockQuoteEntry) {\n      const [, blockQuotePath] = blockQuoteEntry;\n      const [currentLineEntry] = Editor.nodes(newEditor, {\n        match: (n, p) => Element.isElement(n) && p.length === blockQuotePath.length + 1 && n.type === PARAGRAPH\n      });\n      if (!currentLineEntry) return deleteBackward(unit);\n      const [, currentLinePath] = currentLineEntry;\n      const currentLineIndex = currentLinePath[blockQuotePath.length];\n      // Transforms to paragraph when Select at the beginning of the first line\n      if (currentLineIndex === 0 && isBlockAboveEmpty(newEditor)) {\n        const emptyParagraph = generateEmptyElement(PARAGRAPH);\n        Transforms.removeNodes(editor, {\n          at: blockQuoteEntry[1]\n        });\n        Transforms.insertNodes(newEditor, emptyParagraph, {\n          at: blockQuoteEntry[1]\n        });\n        const focusPoint = Editor.end(newEditor, blockQuoteEntry[1]);\n        focusEditor(newEditor, focusPoint);\n        return;\n      }\n      // Merge with previous line when Select at the beginning of the line\n      if (isSelectionAtBlockStart(editor)) {\n        const lineText = Node.string(currentLineEntry[0]);\n        const previousNodeEntry = Editor.previous(editor, {\n          at: currentLineEntry[1]\n        });\n        if (!previousNodeEntry) return;\n        const focusPoint = Editor.end(newEditor, previousNodeEntry[1]);\n        Transforms.insertText(newEditor, lineText, {\n          at: Editor.end(newEditor, previousNodeEntry[1])\n        });\n        Transforms.removeNodes(editor, {\n          at: currentLineEntry[1]\n        });\n        focusEditor(newEditor, focusPoint);\n        return;\n      }\n    }\n    deleteBackward(unit);\n  };\n  newEditor.insertFragment = data => {\n    // Paste into quote block\n    if (getSelectedNodeByType(newEditor, BLOCKQUOTE)) {\n      const lastIndex = data.findLastIndex(item => [CODE_BLOCK, TABLE].includes(item === null || item === void 0 ? void 0 : item.type));\n      let elements = getFormattedElements(data.slice(0, lastIndex + 1));\n      let restElements = getFormattedRestElements(data.slice(lastIndex + 1));\n      const path = Editor.path(newEditor, newEditor.selection);\n\n      // Insert elements of quote block\n      if (restElements.length !== 0) {\n        if (Range.isCollapsed(editor.selection)) {\n          const paragraphEntry = getSelectedNodeEntryByType(newEditor, PARAGRAPH);\n          if (paragraphEntry) {\n            const parentNodeEntry = Editor.parent(editor, paragraphEntry[1]);\n            if (parentNodeEntry && parentNodeEntry[0].type === BLOCKQUOTE) {\n              if (!Node.string(paragraphEntry[0]).length) {\n                insertFragment(data);\n                return Transforms.removeNodes(newEditor, {\n                  at: paragraphEntry[1]\n                });\n              }\n            }\n          }\n        }\n        // Insert text when inserting a single line paragraph\n        if (restElements.length === 1 && restElements[0].type === PARAGRAPH) {\n          const string = Node.string(restElements[0]);\n          Editor.insertText(newEditor, string);\n        } else {\n          Transforms.insertNodes(newEditor, restElements, {\n            at: [path[0], path[1] + 1]\n          });\n        }\n      }\n\n      // Insert elements above the quoted block\n      if (elements.length !== 0) {\n        Transforms.insertNodes(newEditor, elements, {\n          at: [path[0]]\n        });\n      }\n      return;\n    }\n    return insertFragment(data);\n  };\n  return newEditor;\n};\nexport default withBlockquote;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}