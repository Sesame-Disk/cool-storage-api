{"ast":null,"code":"import _createClass from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport ObjectUtils from './object-utils';\nvar extendedWordChars = \"a-zA-Z\\\\u{C0}-\\\\u{FF}\\\\u{D8}-\\\\u{F6}\\\\u{F8}-\\\\u{2C6}\\\\u{2C8}-\\\\u{2D7}\\\\u{2DE}-\\\\u{2FF}\\\\u{1E00}-\\\\u{1EFF}\\\\u{4e00}-\\\\u{9fa5}\";\nvar tokenizeIncludingWhitespace = new RegExp(\"[\".concat(extendedWordChars, \"]+|\\\\s+|[^\").concat(extendedWordChars, \"]\"), 'ug');\nvar buildValues = function buildValues(diff, components, newString, oldString, valueType, useLongestToken) {\n  var componentPos = 0;\n  var componentLen = components.length;\n  var newPos = 0;\n  var oldPos = 0;\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        // eslint-disable-next-line no-loop-func\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value, valueType);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count), valueType);\n      }\n      newPos += component.count;\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count), valueType);\n      oldPos += component.count;\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n  var lastComponent = components[componentLen - 1];\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n  return components;\n};\nvar clonePath = function clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n};\nvar DiffText = /*#__PURE__*/_createClass(function DiffText(oldValue, newValue) {\n  var _this = this;\n  _classCallCheck(this, DiffText);\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  _defineProperty(this, \"done\", function (value) {\n    if (_this.callback) {\n      setTimeout(function () {\n        this.callback(undefined, value);\n      }, 0);\n      return true;\n    }\n    return value;\n  });\n  // Main worker method. checks all permutations of a given edit length for acceptance.\n  _defineProperty(this, \"execCompareLength\", function (bestPath) {\n    for (var diagonalPath = -1 * _this.comparePath; diagonalPath <= _this.comparePath; diagonalPath += 2) {\n      var basePath = void 0;\n      var addPath = bestPath[diagonalPath - 1];\n      var removePath = bestPath[diagonalPath + 1];\n      var oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n      if (addPath) {\n        // No one else is going to attempt to use this value, clear it\n        bestPath[diagonalPath - 1] = undefined;\n      }\n      var canAdd = addPath && addPath.newPos + 1 < _this.newLen;\n      var canRemove = removePath && 0 <= oldPos && oldPos < _this.oldLen;\n      if (!canAdd && !canRemove) {\n        // If this path is a terminal then prune\n        bestPath[diagonalPath] = undefined;\n        continue;\n      }\n\n      // Select the diagonal that we want to branch from. We select the prior\n      // path whose position in the new string is the farthest from the origin\n      // and does not pass the bounds of the diff graph\n      if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n        basePath = clonePath(removePath);\n        _this.pushComponent(basePath.components, undefined, true);\n      } else {\n        basePath = addPath; // No need to clone, we've pulled it from the list\n        basePath.newPos++;\n        _this.pushComponent(basePath.components, true, undefined);\n      }\n      oldPos = _this.extractCommon(basePath, _this.newValue, _this.oldValue, diagonalPath);\n\n      // If we have hit the end of both strings, then we are done\n      if (basePath.newPos + 1 >= _this.newLen && oldPos + 1 >= _this.oldLen) {\n        return _this.done(buildValues(_this, basePath.components, _this.newValue, _this.oldValue, _this.valueType, _this.useLongestToken));\n      } else {\n        // Otherwise track this path as a potential candidate and continue.\n        bestPath[diagonalPath] = basePath;\n      }\n    }\n    _this.comparePath++;\n  });\n  _defineProperty(this, \"exec\", function (bestPath) {\n    setTimeout(function () {\n      if (this.comparePath > this.maxEditLength) {\n        return this.callback();\n      }\n      if (!this.execCompareLength(bestPath)) {\n        this.exec(bestPath);\n      }\n    }, 0);\n  });\n  _defineProperty(this, \"pushComponent\", function (components, added, removed) {\n    var last = components[components.length - 1];\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  });\n  _defineProperty(this, \"extractCommon\", function (basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length;\n    var oldLen = oldString.length;\n    var newPos = basePath.newPos;\n    var oldPos = newPos - diagonalPath;\n    var commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && _this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n    basePath.newPos = newPos;\n    return oldPos;\n  });\n  _defineProperty(this, \"equals\", function (left, right) {\n    if (_this.options.ignoreCase) {\n      left = left.toLowerCase();\n      right = right.toLowerCase();\n    }\n    return left.trim() === right.trim();\n  });\n  _defineProperty(this, \"removeEmpty\", function (array, type) {\n    if (type === 'Array') return array;\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  });\n  _defineProperty(this, \"tokenize\", function (value, valueType) {\n    if (valueType === 'Array') {\n      return value.slice();\n    }\n    var parts = value.match(tokenizeIncludingWhitespace) || [];\n    var tokens = [];\n    var prevPart = null;\n    parts.forEach(function (part) {\n      if (/\\s/.test(part)) {\n        if (prevPart == null) {\n          tokens.push(part);\n        } else {\n          tokens.push(tokens.pop() + part);\n        }\n      } else if (/\\s/.test(prevPart)) {\n        if (tokens[tokens.length - 1] === prevPart) {\n          tokens.push(tokens.pop() + part);\n        } else {\n          tokens.push(prevPart + part);\n        }\n      } else {\n        tokens.push(part);\n      }\n      prevPart = part;\n    });\n    return tokens;\n  });\n  _defineProperty(this, \"join\", function (value, valueType) {\n    if (valueType === 'Array') return value;\n    // Tokens being joined here will always have appeared consecutively in the\n    // same text, so we can simply strip off the leading whitespace from all the\n    // tokens except the first (and except any whitespace-only tokens - but such\n    // a token will always be the first and only token anyway) and then join them\n    // and the whitespace around words and punctuation will end up correct.\n    return value.map(function (token, i) {\n      if (i === 0) {\n        return token;\n      } else {\n        return token.replace(/^\\s+/, '');\n      }\n    }).join('');\n  });\n  _defineProperty(this, \"getDiffs\", function () {\n    if (!_this.canCompare) {\n      return [{\n        value: _this.oldValue,\n        removed: true\n      }, {\n        value: _this.newValue,\n        added: true\n      }];\n    }\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }];\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    var oldPos = _this.extractCommon(bestPath[0], _this.newValue, _this.oldValue, 0);\n    if (bestPath[0].newPos + 1 >= _this.newLen && oldPos + 1 >= _this.oldLen) {\n      // Identity per the equality and tokenizer\n      return _this.done([{\n        value: _this.join(_this.newValue, _this.valueType),\n        count: _this.oldValue.length\n      }]);\n    }\n\n    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execCompareLength until a value\n    // is produced, or until the edit length exceeds options.maxEditLength (if given),\n    // in which case it will return undefined.\n    if (_this.callback) {\n      _this.exec(bestPath);\n    } else {\n      while (_this.comparePath <= _this.maxEditLength) {\n        var ret = _this.execCompareLength(bestPath);\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  });\n  this.oldValue = oldValue;\n  this.newValue = newValue;\n  var oldValueType = ObjectUtils.getDataType(oldValue);\n  var newValueType = ObjectUtils.getDataType(newValue);\n  this.canCompare = true;\n  if (oldValueType !== newValueType) {\n    this.canCompare = false;\n    return;\n  }\n  this.valueType = newValueType;\n  this.callback = options.callback;\n  var optionsType = ObjectUtils.getDataType(options);\n  if (optionsType === 'function') {\n    this.callback = options;\n    this.options = {};\n  } else {\n    this.options = {};\n  }\n  this.comparePath = 1;\n  this.oldValue = this.removeEmpty(this.tokenize(oldValue, oldValueType), oldValueType);\n  this.oldLen = this.oldValue.length;\n  this.newValue = this.removeEmpty(this.tokenize(newValue, newValueType), newValueType);\n  this.newLen = this.newValue.length;\n  this.maxEditLength = this.newLen + this.oldLen;\n  if (this.options.maxEditLength) {\n    this.maxEditLength = Math.min(this.maxEditLength, this.options.maxEditLength);\n  }\n});\nexport default DiffText;","map":{"version":3,"names":["_defineProperty","ObjectUtils","extendedWordChars","tokenizeIncludingWhitespace","RegExp","concat","buildValues","diff","components","newString","oldString","valueType","useLongestToken","componentPos","componentLen","length","newPos","oldPos","component","removed","added","value","slice","count","map","i","oldValue","join","tmp","lastComponent","equals","pop","clonePath","path","DiffText","_createClass","newValue","_this","_classCallCheck","options","arguments","undefined","callback","setTimeout","bestPath","diagonalPath","comparePath","basePath","addPath","removePath","canAdd","newLen","canRemove","oldLen","pushComponent","extractCommon","done","maxEditLength","execCompareLength","exec","last","push","commonCount","left","right","ignoreCase","toLowerCase","trim","array","type","ret","parts","match","tokens","prevPart","forEach","part","test","token","replace","canCompare","oldValueType","getDataType","newValueType","optionsType","removeEmpty","tokenize","Math","min"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/utils/diff-text.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport ObjectUtils from './object-utils';\nconst extendedWordChars = 'a-zA-Z\\\\u{C0}-\\\\u{FF}\\\\u{D8}-\\\\u{F6}\\\\u{F8}-\\\\u{2C6}\\\\u{2C8}-\\\\u{2D7}\\\\u{2DE}-\\\\u{2FF}\\\\u{1E00}-\\\\u{1EFF}\\\\u{4e00}-\\\\u{9fa5}';\nconst tokenizeIncludingWhitespace = new RegExp(\"[\".concat(extendedWordChars, \"]+|\\\\s+|[^\").concat(extendedWordChars, \"]\"), 'ug');\nconst buildValues = (diff, components, newString, oldString, valueType, useLongestToken) => {\n  let componentPos = 0;\n  let componentLen = components.length;\n  let newPos = 0;\n  let oldPos = 0;\n  for (; componentPos < componentLen; componentPos++) {\n    let component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        let value = newString.slice(newPos, newPos + component.count);\n        // eslint-disable-next-line no-loop-func\n        value = value.map((value, i) => {\n          let oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value, valueType);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count), valueType);\n      }\n      newPos += component.count;\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count), valueType);\n      oldPos += component.count;\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        let tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n  let lastComponent = components[componentLen - 1];\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n  return components;\n};\nconst clonePath = path => {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n};\nclass DiffText {\n  constructor(oldValue, newValue) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _defineProperty(this, \"done\", value => {\n      if (this.callback) {\n        setTimeout(function () {\n          this.callback(undefined, value);\n        }, 0);\n        return true;\n      }\n      return value;\n    });\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    _defineProperty(this, \"execCompareLength\", bestPath => {\n      for (let diagonalPath = -1 * this.comparePath; diagonalPath <= this.comparePath; diagonalPath += 2) {\n        let basePath;\n        let addPath = bestPath[diagonalPath - 1];\n        let removePath = bestPath[diagonalPath + 1];\n        let oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n        let canAdd = addPath && addPath.newPos + 1 < this.newLen;\n        let canRemove = removePath && 0 <= oldPos && oldPos < this.oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          this.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n          basePath.newPos++;\n          this.pushComponent(basePath.components, true, undefined);\n        }\n        oldPos = this.extractCommon(basePath, this.newValue, this.oldValue, diagonalPath);\n\n        // If we have hit the end of both strings, then we are done\n        if (basePath.newPos + 1 >= this.newLen && oldPos + 1 >= this.oldLen) {\n          return this.done(buildValues(this, basePath.components, this.newValue, this.oldValue, this.valueType, this.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n      this.comparePath++;\n    });\n    _defineProperty(this, \"exec\", bestPath => {\n      setTimeout(function () {\n        if (this.comparePath > this.maxEditLength) {\n          return this.callback();\n        }\n        if (!this.execCompareLength(bestPath)) {\n          this.exec(bestPath);\n        }\n      }, 0);\n    });\n    _defineProperty(this, \"pushComponent\", (components, added, removed) => {\n      let last = components[components.length - 1];\n      if (last && last.added === added && last.removed === removed) {\n        // We need to clone here as the component clone operation is just\n        // as shallow array clone\n        components[components.length - 1] = {\n          count: last.count + 1,\n          added: added,\n          removed: removed\n        };\n      } else {\n        components.push({\n          count: 1,\n          added: added,\n          removed: removed\n        });\n      }\n    });\n    _defineProperty(this, \"extractCommon\", (basePath, newString, oldString, diagonalPath) => {\n      let newLen = newString.length;\n      let oldLen = oldString.length;\n      let newPos = basePath.newPos;\n      let oldPos = newPos - diagonalPath;\n      let commonCount = 0;\n      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n        newPos++;\n        oldPos++;\n        commonCount++;\n      }\n      if (commonCount) {\n        basePath.components.push({\n          count: commonCount\n        });\n      }\n      basePath.newPos = newPos;\n      return oldPos;\n    });\n    _defineProperty(this, \"equals\", (left, right) => {\n      if (this.options.ignoreCase) {\n        left = left.toLowerCase();\n        right = right.toLowerCase();\n      }\n      return left.trim() === right.trim();\n    });\n    _defineProperty(this, \"removeEmpty\", (array, type) => {\n      if (type === 'Array') return array;\n      let ret = [];\n      for (let i = 0; i < array.length; i++) {\n        if (array[i]) {\n          ret.push(array[i]);\n        }\n      }\n      return ret;\n    });\n    _defineProperty(this, \"tokenize\", (value, valueType) => {\n      if (valueType === 'Array') {\n        return value.slice();\n      }\n      let parts = value.match(tokenizeIncludingWhitespace) || [];\n      const tokens = [];\n      let prevPart = null;\n      parts.forEach(part => {\n        if (/\\s/.test(part)) {\n          if (prevPart == null) {\n            tokens.push(part);\n          } else {\n            tokens.push(tokens.pop() + part);\n          }\n        } else if (/\\s/.test(prevPart)) {\n          if (tokens[tokens.length - 1] === prevPart) {\n            tokens.push(tokens.pop() + part);\n          } else {\n            tokens.push(prevPart + part);\n          }\n        } else {\n          tokens.push(part);\n        }\n        prevPart = part;\n      });\n      return tokens;\n    });\n    _defineProperty(this, \"join\", (value, valueType) => {\n      if (valueType === 'Array') return value;\n      // Tokens being joined here will always have appeared consecutively in the\n      // same text, so we can simply strip off the leading whitespace from all the\n      // tokens except the first (and except any whitespace-only tokens - but such\n      // a token will always be the first and only token anyway) and then join them\n      // and the whitespace around words and punctuation will end up correct.\n      return value.map((token, i) => {\n        if (i === 0) {\n          return token;\n        } else {\n          return token.replace(/^\\s+/, '');\n        }\n      }).join('');\n    });\n    _defineProperty(this, \"getDiffs\", () => {\n      if (!this.canCompare) {\n        return [{\n          value: this.oldValue,\n          removed: true\n        }, {\n          value: this.newValue,\n          added: true\n        }];\n      }\n      let bestPath = [{\n        newPos: -1,\n        components: []\n      }];\n\n      // Seed editLength = 0, i.e. the content starts with the same values\n      let oldPos = this.extractCommon(bestPath[0], this.newValue, this.oldValue, 0);\n      if (bestPath[0].newPos + 1 >= this.newLen && oldPos + 1 >= this.oldLen) {\n        // Identity per the equality and tokenizer\n        return this.done([{\n          value: this.join(this.newValue, this.valueType),\n          count: this.oldValue.length\n        }]);\n      }\n\n      // Performs the length of edit iteration. Is a bit fugly as this has to support the\n      // sync and async mode which is never fun. Loops over execCompareLength until a value\n      // is produced, or until the edit length exceeds options.maxEditLength (if given),\n      // in which case it will return undefined.\n      if (this.callback) {\n        this.exec(bestPath);\n      } else {\n        while (this.comparePath <= this.maxEditLength) {\n          let ret = this.execCompareLength(bestPath);\n          if (ret) {\n            return ret;\n          }\n        }\n      }\n    });\n    this.oldValue = oldValue;\n    this.newValue = newValue;\n    const oldValueType = ObjectUtils.getDataType(oldValue);\n    const newValueType = ObjectUtils.getDataType(newValue);\n    this.canCompare = true;\n    if (oldValueType !== newValueType) {\n      this.canCompare = false;\n      return;\n    }\n    this.valueType = newValueType;\n    this.callback = options.callback;\n    const optionsType = ObjectUtils.getDataType(options);\n    if (optionsType === 'function') {\n      this.callback = options;\n      this.options = {};\n    } else {\n      this.options = {};\n    }\n    this.comparePath = 1;\n    this.oldValue = this.removeEmpty(this.tokenize(oldValue, oldValueType), oldValueType);\n    this.oldLen = this.oldValue.length;\n    this.newValue = this.removeEmpty(this.tokenize(newValue, newValueType), newValueType);\n    this.newLen = this.newValue.length;\n    this.maxEditLength = this.newLen + this.oldLen;\n    if (this.options.maxEditLength) {\n      this.maxEditLength = Math.min(this.maxEditLength, this.options.maxEditLength);\n    }\n  }\n}\nexport default DiffText;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}