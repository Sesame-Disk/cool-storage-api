{"ast":null,"code":"/*jshint -W030 */\nvar tagRE = /(?:<!--[\\S\\s]*?-->|<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\nvar parseTag = require('./parse-tag');\n// re-used obj for quick lookups of components\nvar empty = Object.create ? Object.create(null) : {};\n// common logic for pushing a child node onto a list\nfunction pushTextNode(list, html, level, start, ignoreWhitespace) {\n  // calculate correct end of the content slice in case there's\n  // no tag after the text node.\n  var end = html.indexOf('<', start);\n  var content = html.slice(start, end === -1 ? undefined : end);\n  // if a node is nothing but whitespace, collapse it as the spec states:\n  // https://www.w3.org/TR/html4/struct/text.html#h-9.1\n  if (/^\\s*$/.test(content)) {\n    content = ' ';\n  }\n  // don't add whitespace-only text nodes if they would be trailing text nodes\n  // or if they would be leading whitespace-only text nodes:\n  //  * end > -1 indicates this is not a trailing text node\n  //  * leading node is when level is -1 and list has length 0\n  if (!ignoreWhitespace && end > -1 && level + list.length >= 0 || content !== ' ') {\n    list.push({\n      type: 'text',\n      content: content\n    });\n  }\n}\nmodule.exports = function parse(html, options) {\n  options || (options = {});\n  options.components || (options.components = empty);\n  var result = [];\n  var current;\n  var level = -1;\n  var arr = [];\n  var byTag = {};\n  var inComponent = false;\n  html.replace(tagRE, function (tag, index) {\n    if (inComponent) {\n      if (tag !== '</' + current.name + '>') {\n        return;\n      } else {\n        inComponent = false;\n      }\n    }\n    var isOpen = tag.charAt(1) !== '/';\n    var isComment = tag.indexOf('<!--') === 0;\n    var start = index + tag.length;\n    var nextChar = html.charAt(start);\n    var parent;\n    if (isOpen && !isComment) {\n      level++;\n      current = parseTag(tag);\n      if (current.type === 'tag' && options.components[current.name]) {\n        current.type = 'component';\n        inComponent = true;\n      }\n      if (!current.voidElement && !inComponent && nextChar && nextChar !== '<') {\n        pushTextNode(current.children, html, level, start, options.ignoreWhitespace);\n      }\n      byTag[current.tagName] = current;\n\n      // if we're at root, push new base node\n      if (level === 0) {\n        result.push(current);\n      }\n      parent = arr[level - 1];\n      if (parent) {\n        parent.children.push(current);\n      }\n      arr[level] = current;\n    }\n    if (isComment || !isOpen || current.voidElement) {\n      if (!isComment) {\n        level--;\n      }\n      if (!inComponent && nextChar !== '<' && nextChar) {\n        // trailing text node\n        // if we're at the root, push a base text node. otherwise add as\n        // a child to the current node.\n        parent = level === -1 ? result : arr[level].children;\n        pushTextNode(parent, html, level, start, options.ignoreWhitespace);\n      }\n    }\n  });\n\n  // If the \"html\" passed isn't actually html, add it as a text node.\n  if (!result.length && html.length) {\n    pushTextNode(result, html, 0, 0, options.ignoreWhitespace);\n  }\n  return result;\n};","map":{"version":3,"names":["tagRE","parseTag","require","empty","Object","create","pushTextNode","list","html","level","start","ignoreWhitespace","end","indexOf","content","slice","undefined","test","length","push","type","module","exports","parse","options","components","result","current","arr","byTag","inComponent","replace","tag","index","name","isOpen","charAt","isComment","nextChar","parent","voidElement","children","tagName"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/html-parse-stringify2/lib/parse.js"],"sourcesContent":["/*jshint -W030 */\nvar tagRE = /(?:<!--[\\S\\s]*?-->|<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>)/g;\nvar parseTag = require('./parse-tag');\n// re-used obj for quick lookups of components\nvar empty = Object.create ? Object.create(null) : {};\n// common logic for pushing a child node onto a list\nfunction pushTextNode(list, html, level, start, ignoreWhitespace) {\n    // calculate correct end of the content slice in case there's\n    // no tag after the text node.\n    var end = html.indexOf('<', start);\n    var content = html.slice(start, end === -1 ? undefined : end);\n    // if a node is nothing but whitespace, collapse it as the spec states:\n    // https://www.w3.org/TR/html4/struct/text.html#h-9.1\n    if (/^\\s*$/.test(content)) {\n        content = ' ';\n    }\n    // don't add whitespace-only text nodes if they would be trailing text nodes\n    // or if they would be leading whitespace-only text nodes:\n    //  * end > -1 indicates this is not a trailing text node\n    //  * leading node is when level is -1 and list has length 0\n    if ((!ignoreWhitespace && end > -1 && level + list.length >= 0) || content !== ' ') {\n        list.push({\n            type: 'text',\n            content: content\n        });\n    }\n}\n\nmodule.exports = function parse(html, options) {\n    options || (options = {});\n    options.components || (options.components = empty);\n    var result = [];\n    var current;\n    var level = -1;\n    var arr = [];\n    var byTag = {};\n    var inComponent = false;\n\n    html.replace(tagRE, function (tag, index) {\n        if (inComponent) {\n            if (tag !== ('</' + current.name + '>')) {\n                return;\n            } else {\n                inComponent = false;\n            }\n        }\n\n        var isOpen = tag.charAt(1) !== '/';\n        var isComment = tag.indexOf('<!--') === 0;\n        var start = index + tag.length;\n        var nextChar = html.charAt(start);\n        var parent;\n\n        if (isOpen && !isComment) {\n            level++;\n\n            current = parseTag(tag);\n            if (current.type === 'tag' && options.components[current.name]) {\n                current.type = 'component';\n                inComponent = true;\n            }\n\n            if (!current.voidElement && !inComponent && nextChar && nextChar !== '<') {\n                pushTextNode(current.children, html, level, start, options.ignoreWhitespace);\n            }\n\n            byTag[current.tagName] = current;\n\n            // if we're at root, push new base node\n            if (level === 0) {\n                result.push(current);\n            }\n\n            parent = arr[level - 1];\n\n            if (parent) {\n                parent.children.push(current);\n            }\n\n            arr[level] = current;\n        }\n\n        if (isComment || !isOpen || current.voidElement) {\n            if (!isComment) {\n                level--;\n            }\n            if (!inComponent && nextChar !== '<' && nextChar) {\n                // trailing text node\n                // if we're at the root, push a base text node. otherwise add as\n                // a child to the current node.\n                parent = level === -1 ? result : arr[level].children;\n                pushTextNode(parent, html, level, start, options.ignoreWhitespace);\n            }\n        }\n    });\n\n    // If the \"html\" passed isn't actually html, add it as a text node.\n    if (!result.length && html.length) {\n        pushTextNode(result, html, 0, 0, options.ignoreWhitespace);\n    }\n\n    return result;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}