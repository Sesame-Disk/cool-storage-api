{"ast":null,"code":"function wordRegExp(words, end) {\n  return new RegExp((end ? \"\" : \"^\") + \"(?:\" + words.join(\"|\") + \")\" + (end ? \"$\" : \"\\\\b\"));\n}\nfunction chain(tokenize, stream, state) {\n  state.tokenize.push(tokenize);\n  return tokenize(stream, state);\n}\nvar operators = /^(?:[-+/%|&^]|\\*\\*?|[<>]{2})/;\nvar conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;\nvar indexingOperators = /^(?:\\[\\][?=]?)/;\nvar anotherOperators = /^(?:\\.(?:\\.{2})?|->|[?:])/;\nvar idents = /^[a-z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar types = /^[A-Z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar keywords = wordRegExp([\"abstract\", \"alias\", \"as\", \"asm\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"do\", \"else\", \"elsif\", \"end\", \"ensure\", \"enum\", \"extend\", \"for\", \"fun\", \"if\", \"include\", \"instance_sizeof\", \"lib\", \"macro\", \"module\", \"next\", \"of\", \"out\", \"pointerof\", \"private\", \"protected\", \"rescue\", \"return\", \"require\", \"select\", \"sizeof\", \"struct\", \"super\", \"then\", \"type\", \"typeof\", \"uninitialized\", \"union\", \"unless\", \"until\", \"when\", \"while\", \"with\", \"yield\", \"__DIR__\", \"__END_LINE__\", \"__FILE__\", \"__LINE__\"]);\nvar atomWords = wordRegExp([\"true\", \"false\", \"nil\", \"self\"]);\nvar indentKeywordsArray = [\"def\", \"fun\", \"macro\", \"class\", \"module\", \"struct\", \"lib\", \"enum\", \"union\", \"do\", \"for\"];\nvar indentKeywords = wordRegExp(indentKeywordsArray);\nvar indentExpressionKeywordsArray = [\"if\", \"unless\", \"case\", \"while\", \"until\", \"begin\", \"then\"];\nvar indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);\nvar dedentKeywordsArray = [\"end\", \"else\", \"elsif\", \"rescue\", \"ensure\"];\nvar dedentKeywords = wordRegExp(dedentKeywordsArray);\nvar dedentPunctualsArray = [\"\\\\)\", \"\\\\}\", \"\\\\]\"];\nvar dedentPunctuals = new RegExp(\"^(?:\" + dedentPunctualsArray.join(\"|\") + \")$\");\nvar nextTokenizer = {\n  \"def\": tokenFollowIdent,\n  \"fun\": tokenFollowIdent,\n  \"macro\": tokenMacroDef,\n  \"class\": tokenFollowType,\n  \"module\": tokenFollowType,\n  \"struct\": tokenFollowType,\n  \"lib\": tokenFollowType,\n  \"enum\": tokenFollowType,\n  \"union\": tokenFollowType\n};\nvar matching = {\n  \"[\": \"]\",\n  \"{\": \"}\",\n  \"(\": \")\",\n  \"<\": \">\"\n};\nfunction tokenBase(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  // Macros\n  if (state.lastToken != \"\\\\\" && stream.match(\"{%\", false)) {\n    return chain(tokenMacro(\"%\", \"%\"), stream, state);\n  }\n  if (state.lastToken != \"\\\\\" && stream.match(\"{{\", false)) {\n    return chain(tokenMacro(\"{\", \"}\"), stream, state);\n  }\n\n  // Comments\n  if (stream.peek() == \"#\") {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Variables and keywords\n  var matched;\n  if (stream.match(idents)) {\n    stream.eat(/[?!]/);\n    matched = stream.current();\n    if (stream.eat(\":\")) {\n      return \"atom\";\n    } else if (state.lastToken == \".\") {\n      return \"property\";\n    } else if (keywords.test(matched)) {\n      if (indentKeywords.test(matched)) {\n        if (!(matched == \"fun\" && state.blocks.indexOf(\"lib\") >= 0) && !(matched == \"def\" && state.lastToken == \"abstract\")) {\n          state.blocks.push(matched);\n          state.currentIndent += 1;\n        }\n      } else if ((state.lastStyle == \"operator\" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {\n        state.blocks.push(matched);\n        state.currentIndent += 1;\n      } else if (matched == \"end\") {\n        state.blocks.pop();\n        state.currentIndent -= 1;\n      }\n      if (nextTokenizer.hasOwnProperty(matched)) {\n        state.tokenize.push(nextTokenizer[matched]);\n      }\n      return \"keyword\";\n    } else if (atomWords.test(matched)) {\n      return \"atom\";\n    }\n    return \"variable\";\n  }\n\n  // Class variables and instance variables\n  // or attributes\n  if (stream.eat(\"@\")) {\n    if (stream.peek() == \"[\") {\n      return chain(tokenNest(\"[\", \"]\", \"meta\"), stream, state);\n    }\n    stream.eat(\"@\");\n    stream.match(idents) || stream.match(types);\n    return \"propertyName\";\n  }\n\n  // Constants and types\n  if (stream.match(types)) {\n    return \"tag\";\n  }\n\n  // Symbols or ':' operator\n  if (stream.eat(\":\")) {\n    if (stream.eat(\"\\\"\")) {\n      return chain(tokenQuote(\"\\\"\", \"atom\", false), stream, state);\n    } else if (stream.match(idents) || stream.match(types) || stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {\n      return \"atom\";\n    }\n    stream.eat(\":\");\n    return \"operator\";\n  }\n\n  // Strings\n  if (stream.eat(\"\\\"\")) {\n    return chain(tokenQuote(\"\\\"\", \"string\", true), stream, state);\n  }\n\n  // Strings or regexps or macro variables or '%' operator\n  if (stream.peek() == \"%\") {\n    var style = \"string\";\n    var embed = true;\n    var delim;\n    if (stream.match(\"%r\")) {\n      // Regexps\n      style = \"string.special\";\n      delim = stream.next();\n    } else if (stream.match(\"%w\")) {\n      embed = false;\n      delim = stream.next();\n    } else if (stream.match(\"%q\")) {\n      embed = false;\n      delim = stream.next();\n    } else {\n      if (delim = stream.match(/^%([^\\w\\s=])/)) {\n        delim = delim[1];\n      } else if (stream.match(/^%[a-zA-Z_\\u009F-\\uFFFF][\\w\\u009F-\\uFFFF]*/)) {\n        // Macro variables\n        return \"meta\";\n      } else if (stream.eat('%')) {\n        // '%' operator\n        return \"operator\";\n      }\n    }\n    if (matching.hasOwnProperty(delim)) {\n      delim = matching[delim];\n    }\n    return chain(tokenQuote(delim, style, embed), stream, state);\n  }\n\n  // Here Docs\n  if (matched = stream.match(/^<<-('?)([A-Z]\\w*)\\1/)) {\n    return chain(tokenHereDoc(matched[2], !matched[1]), stream, state);\n  }\n\n  // Characters\n  if (stream.eat(\"'\")) {\n    stream.match(/^(?:[^']|\\\\(?:[befnrtv0'\"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\\{[0-9a-fA-F]{1,6}\\})))/);\n    stream.eat(\"'\");\n    return \"atom\";\n  }\n\n  // Numbers\n  if (stream.eat(\"0\")) {\n    if (stream.eat(\"x\")) {\n      stream.match(/^[0-9a-fA-F_]+/);\n    } else if (stream.eat(\"o\")) {\n      stream.match(/^[0-7_]+/);\n    } else if (stream.eat(\"b\")) {\n      stream.match(/^[01_]+/);\n    }\n    return \"number\";\n  }\n  if (stream.eat(/^\\d/)) {\n    stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+-]?\\d+)?/);\n    return \"number\";\n  }\n\n  // Operators\n  if (stream.match(operators)) {\n    stream.eat(\"=\"); // Operators can follow assign symbol.\n    return \"operator\";\n  }\n  if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {\n    return \"operator\";\n  }\n\n  // Parens and braces\n  if (matched = stream.match(/[({[]/, false)) {\n    matched = matched[0];\n    return chain(tokenNest(matched, matching[matched], null), stream, state);\n  }\n\n  // Escapes\n  if (stream.eat(\"\\\\\")) {\n    stream.next();\n    return \"meta\";\n  }\n  stream.next();\n  return null;\n}\nfunction tokenNest(begin, end, style, started) {\n  return function (stream, state) {\n    if (!started && stream.match(begin)) {\n      state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);\n      state.currentIndent += 1;\n      return style;\n    }\n    var nextStyle = tokenBase(stream, state);\n    if (stream.current() === end) {\n      state.tokenize.pop();\n      state.currentIndent -= 1;\n      nextStyle = style;\n    }\n    return nextStyle;\n  };\n}\nfunction tokenMacro(begin, end, started) {\n  return function (stream, state) {\n    if (!started && stream.match(\"{\" + begin)) {\n      state.currentIndent += 1;\n      state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);\n      return \"meta\";\n    }\n    if (stream.match(end + \"}\")) {\n      state.currentIndent -= 1;\n      state.tokenize.pop();\n      return \"meta\";\n    }\n    return tokenBase(stream, state);\n  };\n}\nfunction tokenMacroDef(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n  var matched;\n  if (matched = stream.match(idents)) {\n    if (matched == \"def\") {\n      return \"keyword\";\n    }\n    stream.eat(/[?!]/);\n  }\n  state.tokenize.pop();\n  return \"def\";\n}\nfunction tokenFollowIdent(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n  if (stream.match(idents)) {\n    stream.eat(/[!?]/);\n  } else {\n    stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);\n  }\n  state.tokenize.pop();\n  return \"def\";\n}\nfunction tokenFollowType(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n  stream.match(types);\n  state.tokenize.pop();\n  return \"def\";\n}\nfunction tokenQuote(end, style, embed) {\n  return function (stream, state) {\n    var escaped = false;\n    while (stream.peek()) {\n      if (!escaped) {\n        if (stream.match(\"{%\", false)) {\n          state.tokenize.push(tokenMacro(\"%\", \"%\"));\n          return style;\n        }\n        if (stream.match(\"{{\", false)) {\n          state.tokenize.push(tokenMacro(\"{\", \"}\"));\n          return style;\n        }\n        if (embed && stream.match(\"#{\", false)) {\n          state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n          return style;\n        }\n        var ch = stream.next();\n        if (ch == end) {\n          state.tokenize.pop();\n          return style;\n        }\n        escaped = embed && ch == \"\\\\\";\n      } else {\n        stream.next();\n        escaped = false;\n      }\n    }\n    return style;\n  };\n}\nfunction tokenHereDoc(phrase, embed) {\n  return function (stream, state) {\n    if (stream.sol()) {\n      stream.eatSpace();\n      if (stream.match(phrase)) {\n        state.tokenize.pop();\n        return \"string\";\n      }\n    }\n    var escaped = false;\n    while (stream.peek()) {\n      if (!escaped) {\n        if (stream.match(\"{%\", false)) {\n          state.tokenize.push(tokenMacro(\"%\", \"%\"));\n          return \"string\";\n        }\n        if (stream.match(\"{{\", false)) {\n          state.tokenize.push(tokenMacro(\"{\", \"}\"));\n          return \"string\";\n        }\n        if (embed && stream.match(\"#{\", false)) {\n          state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n          return \"string\";\n        }\n        escaped = embed && stream.next() == \"\\\\\";\n      } else {\n        stream.next();\n        escaped = false;\n      }\n    }\n    return \"string\";\n  };\n}\nexport var crystal = {\n  name: \"crystal\",\n  startState: function startState() {\n    return {\n      tokenize: [tokenBase],\n      currentIndent: 0,\n      lastToken: null,\n      lastStyle: null,\n      blocks: []\n    };\n  },\n  token: function token(stream, state) {\n    var style = state.tokenize[state.tokenize.length - 1](stream, state);\n    var token = stream.current();\n    if (style && style != \"comment\") {\n      state.lastToken = token;\n      state.lastStyle = style;\n    }\n    return style;\n  },\n  indent: function indent(state, textAfter, cx) {\n    textAfter = textAfter.replace(/^\\s*(?:\\{%)?\\s*|\\s*(?:%\\})?\\s*$/g, \"\");\n    if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {\n      return cx.unit * (state.currentIndent - 1);\n    }\n    return cx.unit * state.currentIndent;\n  },\n  languageData: {\n    indentOnInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),\n    commentTokens: {\n      line: \"#\"\n    }\n  }\n};","map":{"version":3,"names":["wordRegExp","words","end","RegExp","join","chain","tokenize","stream","state","push","operators","conditionalOperators","indexingOperators","anotherOperators","idents","types","keywords","atomWords","indentKeywordsArray","indentKeywords","indentExpressionKeywordsArray","indentExpressionKeywords","dedentKeywordsArray","dedentKeywords","dedentPunctualsArray","dedentPunctuals","nextTokenizer","tokenFollowIdent","tokenMacroDef","tokenFollowType","matching","tokenBase","eatSpace","lastToken","match","tokenMacro","peek","skipToEnd","matched","eat","current","test","blocks","indexOf","currentIndent","lastStyle","pop","hasOwnProperty","tokenNest","tokenQuote","style","embed","delim","next","tokenHereDoc","begin","started","length","nextStyle","escaped","ch","phrase","sol","crystal","name","startState","token","indent","textAfter","cx","replace","unit","languageData","indentOnInput","concat","commentTokens","line"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@codemirror/legacy-modes/mode/crystal.js"],"sourcesContent":["function wordRegExp(words, end) {\n  return new RegExp((end ? \"\" : \"^\") + \"(?:\" + words.join(\"|\") + \")\" + (end ? \"$\" : \"\\\\b\"));\n}\n\nfunction chain(tokenize, stream, state) {\n  state.tokenize.push(tokenize);\n  return tokenize(stream, state);\n}\n\nvar operators = /^(?:[-+/%|&^]|\\*\\*?|[<>]{2})/;\nvar conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;\nvar indexingOperators = /^(?:\\[\\][?=]?)/;\nvar anotherOperators = /^(?:\\.(?:\\.{2})?|->|[?:])/;\nvar idents = /^[a-z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar types = /^[A-Z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\nvar keywords = wordRegExp([\n  \"abstract\", \"alias\", \"as\", \"asm\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"do\",\n  \"else\", \"elsif\", \"end\", \"ensure\", \"enum\", \"extend\", \"for\", \"fun\", \"if\",\n  \"include\", \"instance_sizeof\", \"lib\", \"macro\", \"module\", \"next\", \"of\", \"out\", \"pointerof\",\n  \"private\", \"protected\", \"rescue\", \"return\", \"require\", \"select\", \"sizeof\", \"struct\",\n  \"super\", \"then\", \"type\", \"typeof\", \"uninitialized\", \"union\", \"unless\", \"until\", \"when\", \"while\", \"with\",\n  \"yield\", \"__DIR__\", \"__END_LINE__\", \"__FILE__\", \"__LINE__\"\n]);\nvar atomWords = wordRegExp([\"true\", \"false\", \"nil\", \"self\"]);\nvar indentKeywordsArray = [\n  \"def\", \"fun\", \"macro\",\n  \"class\", \"module\", \"struct\", \"lib\", \"enum\", \"union\",\n  \"do\", \"for\"\n];\nvar indentKeywords = wordRegExp(indentKeywordsArray);\nvar indentExpressionKeywordsArray = [\"if\", \"unless\", \"case\", \"while\", \"until\", \"begin\", \"then\"];\nvar indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);\nvar dedentKeywordsArray = [\"end\", \"else\", \"elsif\", \"rescue\", \"ensure\"];\nvar dedentKeywords = wordRegExp(dedentKeywordsArray);\nvar dedentPunctualsArray = [\"\\\\)\", \"\\\\}\", \"\\\\]\"];\nvar dedentPunctuals = new RegExp(\"^(?:\" + dedentPunctualsArray.join(\"|\") + \")$\");\nvar nextTokenizer = {\n  \"def\": tokenFollowIdent, \"fun\": tokenFollowIdent, \"macro\": tokenMacroDef,\n  \"class\": tokenFollowType, \"module\": tokenFollowType, \"struct\": tokenFollowType,\n  \"lib\": tokenFollowType, \"enum\": tokenFollowType, \"union\": tokenFollowType\n};\nvar matching = {\"[\": \"]\", \"{\": \"}\", \"(\": \")\", \"<\": \">\"};\n\nfunction tokenBase(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  // Macros\n  if (state.lastToken != \"\\\\\" && stream.match(\"{%\", false)) {\n    return chain(tokenMacro(\"%\", \"%\"), stream, state);\n  }\n\n  if (state.lastToken != \"\\\\\" && stream.match(\"{{\", false)) {\n    return chain(tokenMacro(\"{\", \"}\"), stream, state);\n  }\n\n  // Comments\n  if (stream.peek() == \"#\") {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Variables and keywords\n  var matched;\n  if (stream.match(idents)) {\n    stream.eat(/[?!]/);\n\n    matched = stream.current();\n    if (stream.eat(\":\")) {\n      return \"atom\";\n    } else if (state.lastToken == \".\") {\n      return \"property\";\n    } else if (keywords.test(matched)) {\n      if (indentKeywords.test(matched)) {\n        if (!(matched == \"fun\" && state.blocks.indexOf(\"lib\") >= 0) && !(matched == \"def\" && state.lastToken == \"abstract\")) {\n          state.blocks.push(matched);\n          state.currentIndent += 1;\n        }\n      } else if ((state.lastStyle == \"operator\" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {\n        state.blocks.push(matched);\n        state.currentIndent += 1;\n      } else if (matched == \"end\") {\n        state.blocks.pop();\n        state.currentIndent -= 1;\n      }\n\n      if (nextTokenizer.hasOwnProperty(matched)) {\n        state.tokenize.push(nextTokenizer[matched]);\n      }\n\n      return \"keyword\";\n    } else if (atomWords.test(matched)) {\n      return \"atom\";\n    }\n\n    return \"variable\";\n  }\n\n  // Class variables and instance variables\n  // or attributes\n  if (stream.eat(\"@\")) {\n    if (stream.peek() == \"[\") {\n      return chain(tokenNest(\"[\", \"]\", \"meta\"), stream, state);\n    }\n\n    stream.eat(\"@\");\n    stream.match(idents) || stream.match(types);\n    return \"propertyName\";\n  }\n\n  // Constants and types\n  if (stream.match(types)) {\n    return \"tag\";\n  }\n\n  // Symbols or ':' operator\n  if (stream.eat(\":\")) {\n    if (stream.eat(\"\\\"\")) {\n      return chain(tokenQuote(\"\\\"\", \"atom\", false), stream, state);\n    } else if (stream.match(idents) || stream.match(types) ||\n               stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {\n      return \"atom\";\n    }\n    stream.eat(\":\");\n    return \"operator\";\n  }\n\n  // Strings\n  if (stream.eat(\"\\\"\")) {\n    return chain(tokenQuote(\"\\\"\", \"string\", true), stream, state);\n  }\n\n  // Strings or regexps or macro variables or '%' operator\n  if (stream.peek() == \"%\") {\n    var style = \"string\";\n    var embed = true;\n    var delim;\n\n    if (stream.match(\"%r\")) {\n      // Regexps\n      style = \"string.special\";\n      delim = stream.next();\n    } else if (stream.match(\"%w\")) {\n      embed = false;\n      delim = stream.next();\n    } else if (stream.match(\"%q\")) {\n      embed = false;\n      delim = stream.next();\n    } else {\n      if(delim = stream.match(/^%([^\\w\\s=])/)) {\n        delim = delim[1];\n      } else if (stream.match(/^%[a-zA-Z_\\u009F-\\uFFFF][\\w\\u009F-\\uFFFF]*/)) {\n        // Macro variables\n        return \"meta\";\n      } else if (stream.eat('%')) {\n        // '%' operator\n        return \"operator\";\n      }\n    }\n\n    if (matching.hasOwnProperty(delim)) {\n      delim = matching[delim];\n    }\n    return chain(tokenQuote(delim, style, embed), stream, state);\n  }\n\n  // Here Docs\n  if (matched = stream.match(/^<<-('?)([A-Z]\\w*)\\1/)) {\n    return chain(tokenHereDoc(matched[2], !matched[1]), stream, state)\n  }\n\n  // Characters\n  if (stream.eat(\"'\")) {\n    stream.match(/^(?:[^']|\\\\(?:[befnrtv0'\"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\\{[0-9a-fA-F]{1,6}\\})))/);\n    stream.eat(\"'\");\n    return \"atom\";\n  }\n\n  // Numbers\n  if (stream.eat(\"0\")) {\n    if (stream.eat(\"x\")) {\n      stream.match(/^[0-9a-fA-F_]+/);\n    } else if (stream.eat(\"o\")) {\n      stream.match(/^[0-7_]+/);\n    } else if (stream.eat(\"b\")) {\n      stream.match(/^[01_]+/);\n    }\n    return \"number\";\n  }\n\n  if (stream.eat(/^\\d/)) {\n    stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+-]?\\d+)?/);\n    return \"number\";\n  }\n\n  // Operators\n  if (stream.match(operators)) {\n    stream.eat(\"=\"); // Operators can follow assign symbol.\n    return \"operator\";\n  }\n\n  if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {\n    return \"operator\";\n  }\n\n  // Parens and braces\n  if (matched = stream.match(/[({[]/, false)) {\n    matched = matched[0];\n    return chain(tokenNest(matched, matching[matched], null), stream, state);\n  }\n\n  // Escapes\n  if (stream.eat(\"\\\\\")) {\n    stream.next();\n    return \"meta\";\n  }\n\n  stream.next();\n  return null;\n}\n\nfunction tokenNest(begin, end, style, started) {\n  return function (stream, state) {\n    if (!started && stream.match(begin)) {\n      state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);\n      state.currentIndent += 1;\n      return style;\n    }\n\n    var nextStyle = tokenBase(stream, state);\n    if (stream.current() === end) {\n      state.tokenize.pop();\n      state.currentIndent -= 1;\n      nextStyle = style;\n    }\n\n    return nextStyle;\n  };\n}\n\nfunction tokenMacro(begin, end, started) {\n  return function (stream, state) {\n    if (!started && stream.match(\"{\" + begin)) {\n      state.currentIndent += 1;\n      state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);\n      return \"meta\";\n    }\n\n    if (stream.match(end + \"}\")) {\n      state.currentIndent -= 1;\n      state.tokenize.pop();\n      return \"meta\";\n    }\n\n    return tokenBase(stream, state);\n  };\n}\n\nfunction tokenMacroDef(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  var matched;\n  if (matched = stream.match(idents)) {\n    if (matched == \"def\") {\n      return \"keyword\";\n    }\n    stream.eat(/[?!]/);\n  }\n\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenFollowIdent(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  if (stream.match(idents)) {\n    stream.eat(/[!?]/);\n  } else {\n    stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);\n  }\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenFollowType(stream, state) {\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  stream.match(types);\n  state.tokenize.pop();\n  return \"def\";\n}\n\nfunction tokenQuote(end, style, embed) {\n  return function (stream, state) {\n    var escaped = false;\n\n    while (stream.peek()) {\n      if (!escaped) {\n        if (stream.match(\"{%\", false)) {\n          state.tokenize.push(tokenMacro(\"%\", \"%\"));\n          return style;\n        }\n\n        if (stream.match(\"{{\", false)) {\n          state.tokenize.push(tokenMacro(\"{\", \"}\"));\n          return style;\n        }\n\n        if (embed && stream.match(\"#{\", false)) {\n          state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n          return style;\n        }\n\n        var ch = stream.next();\n\n        if (ch == end) {\n          state.tokenize.pop();\n          return style;\n        }\n\n        escaped = embed && ch == \"\\\\\";\n      } else {\n        stream.next();\n        escaped = false;\n      }\n    }\n\n    return style;\n  };\n}\n\nfunction tokenHereDoc(phrase, embed) {\n  return function (stream, state) {\n    if (stream.sol()) {\n      stream.eatSpace()\n      if (stream.match(phrase)) {\n        state.tokenize.pop();\n        return \"string\";\n      }\n    }\n\n    var escaped = false;\n    while (stream.peek()) {\n      if (!escaped) {\n        if (stream.match(\"{%\", false)) {\n          state.tokenize.push(tokenMacro(\"%\", \"%\"));\n          return \"string\";\n        }\n\n        if (stream.match(\"{{\", false)) {\n          state.tokenize.push(tokenMacro(\"{\", \"}\"));\n          return \"string\";\n        }\n\n        if (embed && stream.match(\"#{\", false)) {\n          state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n          return \"string\";\n        }\n\n        escaped = embed && stream.next() == \"\\\\\";\n      } else {\n        stream.next();\n        escaped = false;\n      }\n    }\n\n    return \"string\";\n  }\n}\n\nexport const crystal = {\n  name: \"crystal\",\n  startState: function () {\n    return {\n      tokenize: [tokenBase],\n      currentIndent: 0,\n      lastToken: null,\n      lastStyle: null,\n      blocks: []\n    };\n  },\n\n  token: function (stream, state) {\n    var style = state.tokenize[state.tokenize.length - 1](stream, state);\n    var token = stream.current();\n\n    if (style && style != \"comment\") {\n      state.lastToken = token;\n      state.lastStyle = style;\n    }\n\n    return style;\n  },\n\n  indent: function (state, textAfter, cx) {\n    textAfter = textAfter.replace(/^\\s*(?:\\{%)?\\s*|\\s*(?:%\\})?\\s*$/g, \"\");\n\n    if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {\n      return cx.unit * (state.currentIndent - 1);\n    }\n\n    return cx.unit * state.currentIndent;\n  },\n\n  languageData: {\n    indentOnInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),\n    commentTokens: {line: \"#\"}\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}