{"ast":null,"code":"import _toConsumableArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\n/**\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Doctype} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n * @typedef {import('hast').Text} Text\n */\n\n/**\n * @typedef {[string, ...Array<Exclude<Properties[keyof Properties], Array<any>> | RegExp>] | string} PropertyDefinition\n *   Definition for a property.\n *\n * @typedef Schema\n *   Schema that defines what nodes and properties are allowed.\n *\n *   The default schema is `defaultSchema`, which follows how GitHub cleans.\n *   If any top-level key is missing in the given schema, the corresponding\n *   value of the default schema is used.\n *\n *   To extend the standard schema with a few changes, clone `defaultSchema`\n *   like so:\n *\n *   ```js\n *   import deepmerge from 'deepmerge'\n *   import {h} from 'hastscript'\n *   import {defaultSchema, sanitize} from 'hast-util-sanitize'\n *\n *   // This allows `className` on all elements.\n *   const schema = deepmerge(defaultSchema, {attributes: {'*': ['className']}})\n *\n *   const tree = sanitize(h('div', {className: ['foo']}), schema)\n *\n *   // `tree` still has `className`.\n *   console.log(tree)\n *   // {\n *   //   type: 'element',\n *   //   tagName: 'div',\n *   //   properties: {className: ['foo']},\n *   //   children: []\n *   // }\n *   ```\n * @property {boolean | null | undefined} [allowComments=false]\n *   Whether to allow comment nodes (default: `false`).\n *\n *   For example:\n *\n *   ```js\n *   allowComments: true\n *   ```\n * @property {boolean | null | undefined} [allowDoctypes=false]\n *   Whether to allow doctype nodes (default: `false`).\n *\n *   For example:\n *\n *   ```js\n *   allowDoctypes: true\n *   ```\n * @property {Record<string, Array<string>> | null | undefined} [ancestors]\n *   Map of tag names to a list of tag names which are required ancestors\n *   (default: `defaultSchema.ancestors`).\n *\n *   Elements with these tag names will be ignored if they occur outside of one\n *   of their allowed parents.\n *\n *   For example:\n *\n *   ```js\n *   ancestors: {\n *     tbody: ['table'],\n *     // â€¦\n *     tr: ['table']\n *   }\n *   ```\n * @property {Record<string, Array<PropertyDefinition>> | null | undefined} [attributes]\n *   Map of tag names to allowed property names (default:\n *   `defaultSchema.attributes`).\n *\n *   The special key `'*'` as a tag name defines property names allowed on all\n *   elements.\n *\n *   The special value `'data*'` as a property name can be used to allow all\n *   `data` properties.\n *\n *   For example:\n *\n *   ```js\n *   attributes: {\n *     'ariaDescribedBy', 'ariaLabel', 'ariaLabelledBy', â€¦, 'href'\n *     // â€¦\n *     '*': [\n *       'abbr',\n *       'accept',\n *       'acceptCharset',\n *       // â€¦\n *       'vAlign',\n *       'value',\n *       'width'\n *     ]\n *   }\n *   ```\n *\n *   Instead of a single string in the array, which allows any property value\n *   for the field, you can use an array to allow several values.\n *   For example, `input: ['type']` allows `type` set to any value on `input`s.\n *   But `input: [['type', 'checkbox', 'radio']]` allows `type` when set to\n *   `'checkbox'` or `'radio'`.\n *\n *   You can use regexes, so for example `span: [['className', /^hljs-/]]`\n *   allows any class that starts with `hljs-` on `span`s.\n *\n *   When comma- or space-separated values are used (such as `className`), each\n *   value in is checked individually.\n *   For example, to allow certain classes on `span`s for syntax highlighting,\n *   use `span: [['className', 'number', 'operator', 'token']]`.\n *   This will allow `'number'`, `'operator'`, and `'token'` classes, but drop\n *   others.\n * @property {Array<string> | null | undefined} [clobber]\n *   List of property names that clobber (default: `defaultSchema.clobber`).\n *\n *   For example:\n *\n *   ```js\n *   clobber: ['ariaDescribedBy', 'ariaLabelledBy', 'id', 'name']\n *   ```\n * @property {string | null | undefined} [clobberPrefix]\n *   Prefix to use before clobbering properties (default:\n *   `defaultSchema.clobberPrefix`).\n *\n *   For example:\n *\n *   ```js\n *   clobberPrefix: 'user-content-'\n *   ```\n * @property {Record<string, Array<string> | null | undefined> | null | undefined} [protocols]\n *   Map of *property names* to allowed protocols (default:\n *   `defaultSchema.protocols`).\n *\n *   This defines URLs that are always allowed to have local URLs (relative to\n *   the current website, such as `this`, `#this`, `/this`, or `?this`), and\n *   only allowed to have remote URLs (such as `https://example.com`) if they\n *   use a known protocol.\n *\n *   For example:\n *\n *   ```js\n *   protocols: {\n *     cite: ['http', 'https'],\n *     // â€¦\n *     src: ['http', 'https']\n *   }\n *   ```\n * @property {Record<string, Record<string, Properties[keyof Properties]>> | null | undefined} [required]\n *   Map of tag names to required property names with a default value\n *   (default: `defaultSchema.required`).\n *\n *   This defines properties that must be set.\n *   If a field does not exist (after the element was made safe), these will be\n *   added with the given value.\n *\n *   For example:\n *\n *   ```js\n *   required: {\n *     input: {disabled: true, type: 'checkbox'}\n *   }\n *   ```\n *\n *   > ðŸ‘‰ **Note**: properties are first checked based on `schema.attributes`,\n *   > then on `schema.required`.\n *   > That means properties could be removed by `attributes` and then added\n *   > again with `required`.\n * @property {Array<string> | null | undefined} [strip]\n *   List of tag names to strip from the tree (default: `defaultSchema.strip`).\n *\n *   By default, unsafe elements (those not in `schema.tagNames`) are replaced\n *   by what they contain.\n *   This option can drop their contents.\n *\n *   For example:\n *\n *   ```js\n *   strip: ['script']\n *   ```\n * @property {Array<string> | null | undefined} [tagNames]\n *   List of allowed tag names (default: `defaultSchema.tagNames`).\n *\n *   For example:\n *\n *   ```js\n *   tagNames: [\n *     'a',\n *     'b',\n *     // â€¦\n *     'ul',\n *     'var'\n *   ]\n *   ```\n *\n * @typedef State\n *   Info passed around.\n * @property {Readonly<Schema>} schema\n *   Schema.\n * @property {Array<string>} stack\n *   Tag names of ancestors.\n */\n\nimport structuredClone from '@ungap/structured-clone';\nimport { position } from 'unist-util-position';\nimport { defaultSchema } from './schema.js';\nvar own = {}.hasOwnProperty;\n\n/**\n * Sanitize a tree.\n *\n * @param {Readonly<Nodes>} node\n *   Unsafe tree.\n * @param {Readonly<Schema> | null | undefined} [options]\n *   Configuration (default: `defaultSchema`).\n * @returns {Nodes}\n *   New, safe tree.\n */\nexport function sanitize(node, options) {\n  /** @type {Nodes} */\n  var ctx = {\n    type: 'root',\n    children: []\n  };\n\n  /** @type {State} */\n  var state = {\n    schema: options ? _objectSpread(_objectSpread({}, defaultSchema), options) : defaultSchema,\n    stack: []\n  };\n  var replace = transform(state, node);\n  if (replace) {\n    if (Array.isArray(replace)) {\n      if (replace.length === 1) {\n        ctx = replace[0];\n      } else {\n        ctx.children = replace;\n      }\n    } else {\n      ctx = replace;\n    }\n  }\n  return ctx;\n}\n\n/**\n * Sanitize `node`.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} node\n *   Unsafe node.\n * @returns {Array<ElementContent> | Nodes | undefined}\n *   Safe result.\n */\nfunction transform(state, node) {\n  if (node && typeof node === 'object') {\n    var unsafe = /** @type {Record<string, Readonly<unknown>>} */node;\n    var type = typeof unsafe.type === 'string' ? unsafe.type : '';\n    switch (type) {\n      case 'comment':\n        {\n          return comment(state, unsafe);\n        }\n      case 'doctype':\n        {\n          return doctype(state, unsafe);\n        }\n      case 'element':\n        {\n          return element(state, unsafe);\n        }\n      case 'root':\n        {\n          return root(state, unsafe);\n        }\n      case 'text':\n        {\n          return text(state, unsafe);\n        }\n      default:\n    }\n  }\n}\n\n/**\n * Make a safe comment.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe comment-like value.\n * @returns {Comment | undefined}\n *   Safe comment (if with `allowComments`).\n */\nfunction comment(state, unsafe) {\n  if (state.schema.allowComments) {\n    // See <https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments>\n    var result = typeof unsafe.value === 'string' ? unsafe.value : '';\n    var index = result.indexOf('-->');\n    var value = index < 0 ? result : result.slice(0, index);\n\n    /** @type {Comment} */\n    var node = {\n      type: 'comment',\n      value: value\n    };\n    patch(node, unsafe);\n    return node;\n  }\n}\n\n/**\n * Make a safe doctype.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe doctype-like value.\n * @returns {Doctype | undefined}\n *   Safe doctype (if with `allowDoctypes`).\n */\nfunction doctype(state, unsafe) {\n  if (state.schema.allowDoctypes) {\n    /** @type {Doctype} */\n    var node = {\n      type: 'doctype'\n    };\n    patch(node, unsafe);\n    return node;\n  }\n}\n\n/**\n * Make a safe element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe element-like value.\n * @returns {Array<ElementContent> | Element | undefined}\n *   Safe element.\n */\nfunction element(state, unsafe) {\n  var name = typeof unsafe.tagName === 'string' ? unsafe.tagName : '';\n  state.stack.push(name);\n  var content = /** @type {Array<ElementContent>} */\n  children(state, unsafe.children);\n  var props = properties(state, unsafe.properties);\n  state.stack.pop();\n  var safeElement = false;\n  if (name && name !== '*' && (!state.schema.tagNames || state.schema.tagNames.includes(name))) {\n    safeElement = true;\n\n    // Some nodes can break out of their context if they donâ€™t have a certain\n    // ancestor.\n    if (state.schema.ancestors && own.call(state.schema.ancestors, name)) {\n      var ancestors = state.schema.ancestors[name];\n      var index = -1;\n      safeElement = false;\n      while (++index < ancestors.length) {\n        if (state.stack.includes(ancestors[index])) {\n          safeElement = true;\n        }\n      }\n    }\n  }\n  if (!safeElement) {\n    return state.schema.strip && !state.schema.strip.includes(name) ? content : undefined;\n  }\n\n  /** @type {Element} */\n  var node = {\n    type: 'element',\n    tagName: name,\n    properties: props,\n    children: content\n  };\n  patch(node, unsafe);\n  return node;\n}\n\n/**\n * Make a safe root.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe root-like value.\n * @returns {Root}\n *   Safe root.\n */\nfunction root(state, unsafe) {\n  var content = /** @type {Array<RootContent>} */\n  children(state, unsafe.children);\n\n  /** @type {Root} */\n  var node = {\n    type: 'root',\n    children: content\n  };\n  patch(node, unsafe);\n  return node;\n}\n\n/**\n * Make a safe text.\n *\n * @param {State} _\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe text-like value.\n * @returns {Text}\n *   Safe text.\n */\nfunction text(_, unsafe) {\n  var value = typeof unsafe.value === 'string' ? unsafe.value : '';\n  /** @type {Text} */\n  var node = {\n    type: 'text',\n    value: value\n  };\n  patch(node, unsafe);\n  return node;\n}\n\n/**\n * Make children safe.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} children\n *   Unsafe value.\n * @returns {Array<Nodes>}\n *   Safe children.\n */\nfunction children(state, children) {\n  /** @type {Array<Nodes>} */\n  var results = [];\n  if (Array.isArray(children)) {\n    var childrenUnknown = /** @type {Array<Readonly<unknown>>} */children;\n    var index = -1;\n    while (++index < childrenUnknown.length) {\n      var value = transform(state, childrenUnknown[index]);\n      if (value) {\n        if (Array.isArray(value)) {\n          results.push.apply(results, _toConsumableArray(value));\n        } else {\n          results.push(value);\n        }\n      }\n    }\n  }\n  return results;\n}\n\n/**\n * Make element properties safe.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} properties\n *   Unsafe value.\n * @returns {Properties}\n *   Safe value.\n */\nfunction properties(state, properties) {\n  var tagName = state.stack[state.stack.length - 1];\n  var attributes = state.schema.attributes;\n  var required = state.schema.required;\n  var specific = attributes && own.call(attributes, tagName) ? attributes[tagName] : undefined;\n  var defaults = attributes && own.call(attributes, '*') ? attributes['*'] : undefined;\n  var props = /** @type {Readonly<Record<string, Readonly<unknown>>>} */\n  properties && typeof properties === 'object' ? properties : {};\n  /** @type {Properties} */\n  var result = {};\n  /** @type {string} */\n  var key;\n  for (key in props) {\n    if (own.call(props, key)) {\n      var unsafe = props[key];\n      var safe = propertyValue(state, findDefinition(specific, key), key, unsafe);\n      if (safe === null || safe === undefined) {\n        safe = propertyValue(state, findDefinition(defaults, key), key, unsafe);\n      }\n      if (safe !== null && safe !== undefined) {\n        result[key] = safe;\n      }\n    }\n  }\n  if (required && own.call(required, tagName)) {\n    var _properties = required[tagName];\n    for (key in _properties) {\n      if (own.call(_properties, key) && !own.call(result, key)) {\n        result[key] = _properties[key];\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Sanitize a property value.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition> | undefined} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value (but an array).\n * @returns {Array<number | string> | boolean | number | string | undefined}\n *   Safe value.\n */\nfunction propertyValue(state, definition, key, value) {\n  return definition ? Array.isArray(value) ? propertyValueMany(state, definition, key, value) : propertyValuePrimitive(state, definition, key, value) : undefined;\n}\n\n/**\n * Sanitize a property value which is a list.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition>} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<Array<Readonly<unknown>>>} values\n *   Unsafe value (but an array).\n * @returns {Array<number | string>}\n *   Safe value.\n */\nfunction propertyValueMany(state, definition, key, values) {\n  var index = -1;\n  /** @type {Array<number | string>} */\n  var result = [];\n  while (++index < values.length) {\n    var value = propertyValuePrimitive(state, definition, key, values[index]);\n    if (typeof value === 'number' || typeof value === 'string') {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\n/**\n * Sanitize a property value which is a primitive.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition>} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value (but not an array).\n * @returns {boolean | number | string | undefined}\n *   Safe value.\n */\nfunction propertyValuePrimitive(state, definition, key, value) {\n  if (typeof value !== 'boolean' && typeof value !== 'number' && typeof value !== 'string') {\n    return;\n  }\n  if (!safeProtocol(state, key, value)) {\n    return;\n  }\n\n  // Just a string, or only one item in an array, means all values are OK.\n  // More than one item means an allow list.\n  if (typeof definition === 'object' && definition.length > 1) {\n    var ok = false;\n    var index = 0; // Ignore `key`, which is the first item.\n\n    while (++index < definition.length) {\n      var allowed = definition[index];\n\n      // Expression.\n      if (allowed && typeof allowed === 'object' && 'flags' in allowed) {\n        if (allowed.test(String(value))) {\n          ok = true;\n          break;\n        }\n      }\n      // Primitive.\n      else if (allowed === value) {\n        ok = true;\n        break;\n      }\n    }\n    if (!ok) return;\n  }\n  return state.schema.clobber && state.schema.clobberPrefix && state.schema.clobber.includes(key) ? state.schema.clobberPrefix + value : value;\n}\n\n/**\n * Check whether `value` is a safe URL.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value.\n * @returns {boolean}\n *   Whether itâ€™s a safe value.\n */\nfunction safeProtocol(state, key, value) {\n  var protocols = state.schema.protocols && own.call(state.schema.protocols, key) ? state.schema.protocols[key] : undefined;\n\n  // No protocols defined? Then everything is fine.\n  if (!protocols || protocols.length === 0) {\n    return true;\n  }\n  var url = String(value);\n  var colon = url.indexOf(':');\n  var questionMark = url.indexOf('?');\n  var numberSign = url.indexOf('#');\n  var slash = url.indexOf('/');\n  if (colon < 0 ||\n  // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.\n  slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign) {\n    return true;\n  }\n  var index = -1;\n  while (++index < protocols.length) {\n    var protocol = protocols[index];\n    if (colon === protocol.length && url.slice(0, protocol.length) === protocol) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Add data and position.\n *\n * @param {Nodes} node\n *   Node to patch safe data and position on.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe node-like value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(node, unsafe) {\n  var cleanPosition = position(\n  // @ts-expect-error: looks like a node.\n  unsafe);\n  if (unsafe.data) {\n    node.data = structuredClone(unsafe.data);\n  }\n  if (cleanPosition) node.position = cleanPosition;\n}\n\n/**\n *\n * @param {Readonly<Array<PropertyDefinition>> | undefined} definitions\n * @param {string} key\n * @returns {Readonly<PropertyDefinition> | undefined}\n */\nfunction findDefinition(definitions, key) {\n  /** @type {PropertyDefinition | undefined} */\n  var dataDefault;\n  var index = -1;\n  if (definitions) {\n    while (++index < definitions.length) {\n      var entry = definitions[index];\n      var name = typeof entry === 'string' ? entry : entry[0];\n      if (name === key) {\n        return entry;\n      }\n      if (name === 'data*') dataDefault = entry;\n    }\n  }\n  if (key.length > 4 && key.slice(0, 4).toLowerCase() === 'data') {\n    return dataDefault;\n  }\n}","map":{"version":3,"names":["structuredClone","position","defaultSchema","own","hasOwnProperty","sanitize","node","options","ctx","type","children","state","schema","_objectSpread","stack","replace","transform","Array","isArray","length","unsafe","comment","doctype","element","root","text","allowComments","result","value","index","indexOf","slice","patch","allowDoctypes","name","tagName","push","content","props","properties","pop","safeElement","tagNames","includes","ancestors","call","strip","undefined","_","results","childrenUnknown","apply","_toConsumableArray","attributes","required","specific","defaults","key","safe","propertyValue","findDefinition","definition","propertyValueMany","propertyValuePrimitive","values","safeProtocol","ok","allowed","test","String","clobber","clobberPrefix","protocols","url","colon","questionMark","numberSign","slash","protocol","cleanPosition","data","definitions","dataDefault","entry","toLowerCase"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/hast-util-sanitize/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Doctype} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n * @typedef {import('hast').Text} Text\n */\n\n/**\n * @typedef {[string, ...Array<Exclude<Properties[keyof Properties], Array<any>> | RegExp>] | string} PropertyDefinition\n *   Definition for a property.\n *\n * @typedef Schema\n *   Schema that defines what nodes and properties are allowed.\n *\n *   The default schema is `defaultSchema`, which follows how GitHub cleans.\n *   If any top-level key is missing in the given schema, the corresponding\n *   value of the default schema is used.\n *\n *   To extend the standard schema with a few changes, clone `defaultSchema`\n *   like so:\n *\n *   ```js\n *   import deepmerge from 'deepmerge'\n *   import {h} from 'hastscript'\n *   import {defaultSchema, sanitize} from 'hast-util-sanitize'\n *\n *   // This allows `className` on all elements.\n *   const schema = deepmerge(defaultSchema, {attributes: {'*': ['className']}})\n *\n *   const tree = sanitize(h('div', {className: ['foo']}), schema)\n *\n *   // `tree` still has `className`.\n *   console.log(tree)\n *   // {\n *   //   type: 'element',\n *   //   tagName: 'div',\n *   //   properties: {className: ['foo']},\n *   //   children: []\n *   // }\n *   ```\n * @property {boolean | null | undefined} [allowComments=false]\n *   Whether to allow comment nodes (default: `false`).\n *\n *   For example:\n *\n *   ```js\n *   allowComments: true\n *   ```\n * @property {boolean | null | undefined} [allowDoctypes=false]\n *   Whether to allow doctype nodes (default: `false`).\n *\n *   For example:\n *\n *   ```js\n *   allowDoctypes: true\n *   ```\n * @property {Record<string, Array<string>> | null | undefined} [ancestors]\n *   Map of tag names to a list of tag names which are required ancestors\n *   (default: `defaultSchema.ancestors`).\n *\n *   Elements with these tag names will be ignored if they occur outside of one\n *   of their allowed parents.\n *\n *   For example:\n *\n *   ```js\n *   ancestors: {\n *     tbody: ['table'],\n *     // â€¦\n *     tr: ['table']\n *   }\n *   ```\n * @property {Record<string, Array<PropertyDefinition>> | null | undefined} [attributes]\n *   Map of tag names to allowed property names (default:\n *   `defaultSchema.attributes`).\n *\n *   The special key `'*'` as a tag name defines property names allowed on all\n *   elements.\n *\n *   The special value `'data*'` as a property name can be used to allow all\n *   `data` properties.\n *\n *   For example:\n *\n *   ```js\n *   attributes: {\n *     'ariaDescribedBy', 'ariaLabel', 'ariaLabelledBy', â€¦, 'href'\n *     // â€¦\n *     '*': [\n *       'abbr',\n *       'accept',\n *       'acceptCharset',\n *       // â€¦\n *       'vAlign',\n *       'value',\n *       'width'\n *     ]\n *   }\n *   ```\n *\n *   Instead of a single string in the array, which allows any property value\n *   for the field, you can use an array to allow several values.\n *   For example, `input: ['type']` allows `type` set to any value on `input`s.\n *   But `input: [['type', 'checkbox', 'radio']]` allows `type` when set to\n *   `'checkbox'` or `'radio'`.\n *\n *   You can use regexes, so for example `span: [['className', /^hljs-/]]`\n *   allows any class that starts with `hljs-` on `span`s.\n *\n *   When comma- or space-separated values are used (such as `className`), each\n *   value in is checked individually.\n *   For example, to allow certain classes on `span`s for syntax highlighting,\n *   use `span: [['className', 'number', 'operator', 'token']]`.\n *   This will allow `'number'`, `'operator'`, and `'token'` classes, but drop\n *   others.\n * @property {Array<string> | null | undefined} [clobber]\n *   List of property names that clobber (default: `defaultSchema.clobber`).\n *\n *   For example:\n *\n *   ```js\n *   clobber: ['ariaDescribedBy', 'ariaLabelledBy', 'id', 'name']\n *   ```\n * @property {string | null | undefined} [clobberPrefix]\n *   Prefix to use before clobbering properties (default:\n *   `defaultSchema.clobberPrefix`).\n *\n *   For example:\n *\n *   ```js\n *   clobberPrefix: 'user-content-'\n *   ```\n * @property {Record<string, Array<string> | null | undefined> | null | undefined} [protocols]\n *   Map of *property names* to allowed protocols (default:\n *   `defaultSchema.protocols`).\n *\n *   This defines URLs that are always allowed to have local URLs (relative to\n *   the current website, such as `this`, `#this`, `/this`, or `?this`), and\n *   only allowed to have remote URLs (such as `https://example.com`) if they\n *   use a known protocol.\n *\n *   For example:\n *\n *   ```js\n *   protocols: {\n *     cite: ['http', 'https'],\n *     // â€¦\n *     src: ['http', 'https']\n *   }\n *   ```\n * @property {Record<string, Record<string, Properties[keyof Properties]>> | null | undefined} [required]\n *   Map of tag names to required property names with a default value\n *   (default: `defaultSchema.required`).\n *\n *   This defines properties that must be set.\n *   If a field does not exist (after the element was made safe), these will be\n *   added with the given value.\n *\n *   For example:\n *\n *   ```js\n *   required: {\n *     input: {disabled: true, type: 'checkbox'}\n *   }\n *   ```\n *\n *   > ðŸ‘‰ **Note**: properties are first checked based on `schema.attributes`,\n *   > then on `schema.required`.\n *   > That means properties could be removed by `attributes` and then added\n *   > again with `required`.\n * @property {Array<string> | null | undefined} [strip]\n *   List of tag names to strip from the tree (default: `defaultSchema.strip`).\n *\n *   By default, unsafe elements (those not in `schema.tagNames`) are replaced\n *   by what they contain.\n *   This option can drop their contents.\n *\n *   For example:\n *\n *   ```js\n *   strip: ['script']\n *   ```\n * @property {Array<string> | null | undefined} [tagNames]\n *   List of allowed tag names (default: `defaultSchema.tagNames`).\n *\n *   For example:\n *\n *   ```js\n *   tagNames: [\n *     'a',\n *     'b',\n *     // â€¦\n *     'ul',\n *     'var'\n *   ]\n *   ```\n *\n * @typedef State\n *   Info passed around.\n * @property {Readonly<Schema>} schema\n *   Schema.\n * @property {Array<string>} stack\n *   Tag names of ancestors.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {position} from 'unist-util-position'\nimport {defaultSchema} from './schema.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Sanitize a tree.\n *\n * @param {Readonly<Nodes>} node\n *   Unsafe tree.\n * @param {Readonly<Schema> | null | undefined} [options]\n *   Configuration (default: `defaultSchema`).\n * @returns {Nodes}\n *   New, safe tree.\n */\nexport function sanitize(node, options) {\n  /** @type {Nodes} */\n  let ctx = {type: 'root', children: []}\n\n  /** @type {State} */\n  const state = {\n    schema: options ? {...defaultSchema, ...options} : defaultSchema,\n    stack: []\n  }\n  const replace = transform(state, node)\n\n  if (replace) {\n    if (Array.isArray(replace)) {\n      if (replace.length === 1) {\n        ctx = replace[0]\n      } else {\n        ctx.children = replace\n      }\n    } else {\n      ctx = replace\n    }\n  }\n\n  return ctx\n}\n\n/**\n * Sanitize `node`.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} node\n *   Unsafe node.\n * @returns {Array<ElementContent> | Nodes | undefined}\n *   Safe result.\n */\nfunction transform(state, node) {\n  if (node && typeof node === 'object') {\n    const unsafe = /** @type {Record<string, Readonly<unknown>>} */ (node)\n    const type = typeof unsafe.type === 'string' ? unsafe.type : ''\n\n    switch (type) {\n      case 'comment': {\n        return comment(state, unsafe)\n      }\n\n      case 'doctype': {\n        return doctype(state, unsafe)\n      }\n\n      case 'element': {\n        return element(state, unsafe)\n      }\n\n      case 'root': {\n        return root(state, unsafe)\n      }\n\n      case 'text': {\n        return text(state, unsafe)\n      }\n\n      default:\n    }\n  }\n}\n\n/**\n * Make a safe comment.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe comment-like value.\n * @returns {Comment | undefined}\n *   Safe comment (if with `allowComments`).\n */\nfunction comment(state, unsafe) {\n  if (state.schema.allowComments) {\n    // See <https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments>\n    const result = typeof unsafe.value === 'string' ? unsafe.value : ''\n    const index = result.indexOf('-->')\n    const value = index < 0 ? result : result.slice(0, index)\n\n    /** @type {Comment} */\n    const node = {type: 'comment', value}\n\n    patch(node, unsafe)\n\n    return node\n  }\n}\n\n/**\n * Make a safe doctype.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe doctype-like value.\n * @returns {Doctype | undefined}\n *   Safe doctype (if with `allowDoctypes`).\n */\nfunction doctype(state, unsafe) {\n  if (state.schema.allowDoctypes) {\n    /** @type {Doctype} */\n    const node = {type: 'doctype'}\n\n    patch(node, unsafe)\n\n    return node\n  }\n}\n\n/**\n * Make a safe element.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe element-like value.\n * @returns {Array<ElementContent> | Element | undefined}\n *   Safe element.\n */\nfunction element(state, unsafe) {\n  const name = typeof unsafe.tagName === 'string' ? unsafe.tagName : ''\n\n  state.stack.push(name)\n\n  const content = /** @type {Array<ElementContent>} */ (\n    children(state, unsafe.children)\n  )\n  const props = properties(state, unsafe.properties)\n\n  state.stack.pop()\n\n  let safeElement = false\n\n  if (\n    name &&\n    name !== '*' &&\n    (!state.schema.tagNames || state.schema.tagNames.includes(name))\n  ) {\n    safeElement = true\n\n    // Some nodes can break out of their context if they donâ€™t have a certain\n    // ancestor.\n    if (state.schema.ancestors && own.call(state.schema.ancestors, name)) {\n      const ancestors = state.schema.ancestors[name]\n      let index = -1\n\n      safeElement = false\n\n      while (++index < ancestors.length) {\n        if (state.stack.includes(ancestors[index])) {\n          safeElement = true\n        }\n      }\n    }\n  }\n\n  if (!safeElement) {\n    return state.schema.strip && !state.schema.strip.includes(name)\n      ? content\n      : undefined\n  }\n\n  /** @type {Element} */\n  const node = {\n    type: 'element',\n    tagName: name,\n    properties: props,\n    children: content\n  }\n\n  patch(node, unsafe)\n\n  return node\n}\n\n/**\n * Make a safe root.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe root-like value.\n * @returns {Root}\n *   Safe root.\n */\nfunction root(state, unsafe) {\n  const content = /** @type {Array<RootContent>} */ (\n    children(state, unsafe.children)\n  )\n\n  /** @type {Root} */\n  const node = {type: 'root', children: content}\n\n  patch(node, unsafe)\n\n  return node\n}\n\n/**\n * Make a safe text.\n *\n * @param {State} _\n *   Info passed around.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe text-like value.\n * @returns {Text}\n *   Safe text.\n */\nfunction text(_, unsafe) {\n  const value = typeof unsafe.value === 'string' ? unsafe.value : ''\n  /** @type {Text} */\n  const node = {type: 'text', value}\n\n  patch(node, unsafe)\n\n  return node\n}\n\n/**\n * Make children safe.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} children\n *   Unsafe value.\n * @returns {Array<Nodes>}\n *   Safe children.\n */\nfunction children(state, children) {\n  /** @type {Array<Nodes>} */\n  const results = []\n\n  if (Array.isArray(children)) {\n    const childrenUnknown = /** @type {Array<Readonly<unknown>>} */ (children)\n    let index = -1\n\n    while (++index < childrenUnknown.length) {\n      const value = transform(state, childrenUnknown[index])\n\n      if (value) {\n        if (Array.isArray(value)) {\n          results.push(...value)\n        } else {\n          results.push(value)\n        }\n      }\n    }\n  }\n\n  return results\n}\n\n/**\n * Make element properties safe.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<unknown>} properties\n *   Unsafe value.\n * @returns {Properties}\n *   Safe value.\n */\nfunction properties(state, properties) {\n  const tagName = state.stack[state.stack.length - 1]\n  const attributes = state.schema.attributes\n  const required = state.schema.required\n  const specific =\n    attributes && own.call(attributes, tagName)\n      ? attributes[tagName]\n      : undefined\n  const defaults =\n    attributes && own.call(attributes, '*') ? attributes['*'] : undefined\n  const props = /** @type {Readonly<Record<string, Readonly<unknown>>>} */ (\n    properties && typeof properties === 'object' ? properties : {}\n  )\n  /** @type {Properties} */\n  const result = {}\n  /** @type {string} */\n  let key\n\n  for (key in props) {\n    if (own.call(props, key)) {\n      const unsafe = props[key]\n      let safe = propertyValue(\n        state,\n        findDefinition(specific, key),\n        key,\n        unsafe\n      )\n\n      if (safe === null || safe === undefined) {\n        safe = propertyValue(state, findDefinition(defaults, key), key, unsafe)\n      }\n\n      if (safe !== null && safe !== undefined) {\n        result[key] = safe\n      }\n    }\n  }\n\n  if (required && own.call(required, tagName)) {\n    const properties = required[tagName]\n\n    for (key in properties) {\n      if (own.call(properties, key) && !own.call(result, key)) {\n        result[key] = properties[key]\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Sanitize a property value.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition> | undefined} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value (but an array).\n * @returns {Array<number | string> | boolean | number | string | undefined}\n *   Safe value.\n */\nfunction propertyValue(state, definition, key, value) {\n  return definition\n    ? Array.isArray(value)\n      ? propertyValueMany(state, definition, key, value)\n      : propertyValuePrimitive(state, definition, key, value)\n    : undefined\n}\n\n/**\n * Sanitize a property value which is a list.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition>} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<Array<Readonly<unknown>>>} values\n *   Unsafe value (but an array).\n * @returns {Array<number | string>}\n *   Safe value.\n */\nfunction propertyValueMany(state, definition, key, values) {\n  let index = -1\n  /** @type {Array<number | string>} */\n  const result = []\n\n  while (++index < values.length) {\n    const value = propertyValuePrimitive(state, definition, key, values[index])\n\n    if (typeof value === 'number' || typeof value === 'string') {\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Sanitize a property value which is a primitive.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Readonly<PropertyDefinition>} definition\n *   Definition.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value (but not an array).\n * @returns {boolean | number | string | undefined}\n *   Safe value.\n */\nfunction propertyValuePrimitive(state, definition, key, value) {\n  if (\n    typeof value !== 'boolean' &&\n    typeof value !== 'number' &&\n    typeof value !== 'string'\n  ) {\n    return\n  }\n\n  if (!safeProtocol(state, key, value)) {\n    return\n  }\n\n  // Just a string, or only one item in an array, means all values are OK.\n  // More than one item means an allow list.\n  if (typeof definition === 'object' && definition.length > 1) {\n    let ok = false\n    let index = 0 // Ignore `key`, which is the first item.\n\n    while (++index < definition.length) {\n      const allowed = definition[index]\n\n      // Expression.\n      if (allowed && typeof allowed === 'object' && 'flags' in allowed) {\n        if (allowed.test(String(value))) {\n          ok = true\n          break\n        }\n      }\n      // Primitive.\n      else if (allowed === value) {\n        ok = true\n        break\n      }\n    }\n\n    if (!ok) return\n  }\n\n  return state.schema.clobber &&\n    state.schema.clobberPrefix &&\n    state.schema.clobber.includes(key)\n    ? state.schema.clobberPrefix + value\n    : value\n}\n\n/**\n * Check whether `value` is a safe URL.\n *\n * @param {State} state\n *   Info passed around.\n * @param {string} key\n *   Field name.\n * @param {Readonly<unknown>} value\n *   Unsafe value.\n * @returns {boolean}\n *   Whether itâ€™s a safe value.\n */\nfunction safeProtocol(state, key, value) {\n  const protocols =\n    state.schema.protocols && own.call(state.schema.protocols, key)\n      ? state.schema.protocols[key]\n      : undefined\n\n  // No protocols defined? Then everything is fine.\n  if (!protocols || protocols.length === 0) {\n    return true\n  }\n\n  const url = String(value)\n  const colon = url.indexOf(':')\n  const questionMark = url.indexOf('?')\n  const numberSign = url.indexOf('#')\n  const slash = url.indexOf('/')\n\n  if (\n    colon < 0 ||\n    // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign)\n  ) {\n    return true\n  }\n\n  let index = -1\n\n  while (++index < protocols.length) {\n    const protocol = protocols[index]\n\n    if (\n      colon === protocol.length &&\n      url.slice(0, protocol.length) === protocol\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Add data and position.\n *\n * @param {Nodes} node\n *   Node to patch safe data and position on.\n * @param {Readonly<Record<string, Readonly<unknown>>>} unsafe\n *   Unsafe node-like value.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(node, unsafe) {\n  const cleanPosition = position(\n    // @ts-expect-error: looks like a node.\n    unsafe\n  )\n\n  if (unsafe.data) {\n    node.data = structuredClone(unsafe.data)\n  }\n\n  if (cleanPosition) node.position = cleanPosition\n}\n\n/**\n *\n * @param {Readonly<Array<PropertyDefinition>> | undefined} definitions\n * @param {string} key\n * @returns {Readonly<PropertyDefinition> | undefined}\n */\nfunction findDefinition(definitions, key) {\n  /** @type {PropertyDefinition | undefined} */\n  let dataDefault\n  let index = -1\n\n  if (definitions) {\n    while (++index < definitions.length) {\n      const entry = definitions[index]\n      const name = typeof entry === 'string' ? entry : entry[0]\n\n      if (name === key) {\n        return entry\n      }\n\n      if (name === 'data*') dataDefault = entry\n    }\n  }\n\n  if (key.length > 4 && key.slice(0, 4).toLowerCase() === 'data') {\n    return dataDefault\n  }\n}\n"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAOA,eAAe,MAAM,yBAAyB;AACrD,SAAQC,QAAQ,QAAO,qBAAqB;AAC5C,SAAQC,aAAa,QAAO,aAAa;AAEzC,IAAMC,GAAG,GAAG,CAAC,CAAC,CAACC,cAAc;;AAE7B;AACA;AACA;AACA;AACA;AA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}