{"ast":null,"code":"import { Transforms, Node, Editor, Element, Path } from '@seafile/slate';\nimport slugid from 'slugid';\nimport { ReactEditor } from '@seafile/slate-react';\nimport copy from 'copy-to-clipboard';\nimport { toggleList } from '../../plugins/list/transforms';\nimport { generateEmptyElement } from '../../core';\nimport { generateEmptyList } from '../../plugins/list/model';\nimport { setClipboardCodeBlockData } from '../../plugins/code-block/helpers';\nimport { ORDERED_LIST, UNORDERED_LIST, PARAGRAPH, CHECK_LIST_ITEM, IMAGE, TABLE, CODE_BLOCK, BLOCKQUOTE, LIST_ITEM_CORRELATION_TYPE, ADD_POSITION_OFFSET_TYPE, INSERT_POSITION, ELEMENT_TYPE, CALL_OUT } from '../../constants';\nimport { EMPTY_SELECTED_RANGE } from '../../plugins/table/constants';\nimport { unwrapCallout, wrapCallout } from '../../plugins/callout/helper';\nimport { getHeaderHeight } from '../../../utils/dom-utils';\nexport var onSetNodeType = function onSetNodeType(editor, element, type) {\n  if (!type) return;\n  if (type === CALL_OUT) {\n    wrapCallout(editor);\n    return;\n  }\n  if ([ORDERED_LIST, UNORDERED_LIST].includes(type)) {\n    toggleList(editor, type);\n    return;\n  }\n  if (type === CHECK_LIST_ITEM) {\n    var newType = element.type === CHECK_LIST_ITEM ? PARAGRAPH : CHECK_LIST_ITEM;\n    Transforms.setNodes(editor, {\n      type: newType\n    });\n    return;\n  }\n  if (type === BLOCKQUOTE && LIST_ITEM_CORRELATION_TYPE.includes(element.type)) {\n    Transforms.wrapNodes(editor, {\n      id: slugid.nice(),\n      type: BLOCKQUOTE\n    }, {\n      mode: 'highest',\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    });\n    return;\n  }\n  Transforms.setNodes(editor, {\n    type: type\n  });\n};\nexport var setSelection = function setSelection(editor, element) {\n  if (element) {\n    var path = ReactEditor.findPath(editor, element);\n    Transforms.select(editor, path);\n  }\n};\nexport var onCopyNode = function onCopyNode(editor, element) {\n  if (element.type === ELEMENT_TYPE.CODE_BLOCK) {\n    setClipboardCodeBlockData(element);\n    return;\n  }\n  if (element.type === ELEMENT_TYPE.TABLE) {\n    var tableSize = [element.children.length, element.children[0].children.length];\n    var tableSelectedRange = {\n      minRowIndex: 0,\n      maxRowIndex: tableSize[0] - 1,\n      minColIndex: 0,\n      maxColIndex: tableSize[1] - 1\n    };\n    editor.tableSelectedRange = tableSelectedRange;\n  }\n  var newData = editor.setFragmentData(new DataTransfer());\n  copy('copy', {\n    onCopy: function onCopy(clipboardData) {\n      newData.types.forEach(function (type) {\n        var data = newData.getData(type);\n        clipboardData.setData(type, data);\n      });\n    }\n  });\n  if (element.type === ELEMENT_TYPE.TABLE) {\n    editor.tableSelectedRange = EMPTY_SELECTED_RANGE;\n  }\n};\nexport var onDeleteNode = function onDeleteNode(editor, element) {\n  if (element.type === CALL_OUT) {\n    unwrapCallout(editor);\n    return;\n  }\n  var path = ReactEditor.findPath(editor, element);\n  Transforms.removeNodes(editor, {\n    at: path\n  });\n};\nexport var getDomTopHeight = function getDomTopHeight(editor, dom, slateNode) {\n  var rect = dom.getBoundingClientRect();\n  var offsetY = 0;\n  var iconOffset = 4; // ensure icon is in the middle of the line\n  var headerHeight = getHeaderHeight(editor);\n  var paddingTop = parseFloat(window.getComputedStyle(dom).getPropertyValue('padding-top'));\n  var lineHeight = parseFloat(window.getComputedStyle(dom).getPropertyValue('line-height'));\n  var disToolBarHeight = 12; // side toolbar icon is 12 px\n  if (ADD_POSITION_OFFSET_TYPE.includes(slateNode.type)) {\n    offsetY = lineHeight / 2 + paddingTop - disToolBarHeight / 2;\n  }\n  return rect.y - headerHeight + offsetY - iconOffset;\n};\nexport var isVoidNode = function isVoidNode(node) {\n  if (!node) return true;\n  var hasImage = node.children.find(function (n) {\n    return n.type === IMAGE;\n  });\n  var isTable = node.type === TABLE;\n  var isCodeBlock = node.type === CODE_BLOCK;\n  var isCallout = node.type === CALL_OUT;\n  return Node.string(node) === '' && !hasImage && !isTable && !isCodeBlock && !isCallout;\n};\nexport var isNotSupportTransform = function isNotSupportTransform(node) {\n  if (node.type && [CODE_BLOCK, TABLE, CALL_OUT].includes(node.type)) {\n    return true;\n  }\n  return false;\n};\nexport var insertElement = function insertElement(editor, type, insertPosition) {\n  if (insertPosition === INSERT_POSITION.AFTER) {\n    var p = generateEmptyElement(PARAGRAPH);\n    var path = Editor.path(editor, editor.selection);\n    Transforms.insertNodes(editor, p, {\n      at: [path[0] + 1]\n    });\n    Transforms.select(editor, [path[0] + 1]);\n  }\n  // Insertion position is current or after\n  Transforms.setNodes(editor, {\n    type: type\n  });\n};\nexport var getNodeEntry = function getNodeEntry(editor, el) {\n  var node = ReactEditor.toSlateNode(editor, el);\n  var path = ReactEditor.findPath(editor, node);\n  if (isList(editor, path)) {\n    path = path.slice(0, path.length - 1);\n  }\n  if (node && path) return [node, path];\n  return [];\n};\nexport var isBlockquote = function isBlockquote(editor, path) {\n  var _nodeEntry$;\n  var nodeEntry = Editor.node(editor, path);\n  if (nodeEntry && ((_nodeEntry$ = nodeEntry[0]) === null || _nodeEntry$ === void 0 ? void 0 : _nodeEntry$.type) === BLOCKQUOTE) {\n    return true;\n  }\n  return false;\n};\nexport var isList = function isList(editor, path) {\n  var _nodeEntry$2;\n  var nodeEntry = Editor.node(editor, [path[0]]);\n  if (nodeEntry && [ORDERED_LIST, UNORDERED_LIST].includes((_nodeEntry$2 = nodeEntry[0]) === null || _nodeEntry$2 === void 0 ? void 0 : _nodeEntry$2.type)) {\n    return true;\n  }\n  if (path.length > 1 && isBlockquote(editor, [path[0]])) {\n    var _nodeEntry$3;\n    var _nodeEntry = Editor.node(editor, [path[0], path[1]]);\n    if ([ORDERED_LIST, UNORDERED_LIST].includes((_nodeEntry$3 = _nodeEntry[0]) === null || _nodeEntry$3 === void 0 ? void 0 : _nodeEntry$3.type)) {\n      return true;\n    }\n  }\n  return false;\n};\nexport var getListNode = function getListNode(editor, path) {\n  var listType = Editor.node(editor, [path[0]])[0].type;\n  if (listType === BLOCKQUOTE) {\n    listType = Editor.node(editor, [path[0], path[1]])[0].type;\n  }\n  var listItem = Editor.node(editor, path)[0];\n  var listNode = generateEmptyList(listType);\n  listNode.children[0] = listItem;\n  return listNode;\n};\nexport var onWrapListItem = function onWrapListItem(editor, targetPath, sourcePath) {\n  var nextPath = Path.next(targetPath);\n  var listNode = getListNode(editor, sourcePath);\n  Transforms.removeNodes(editor, {\n    at: sourcePath\n  });\n  Transforms.insertNodes(editor, listNode, {\n    at: nextPath\n  });\n  return;\n};","map":{"version":3,"names":["Transforms","Node","Editor","Element","Path","slugid","ReactEditor","copy","toggleList","generateEmptyElement","generateEmptyList","setClipboardCodeBlockData","ORDERED_LIST","UNORDERED_LIST","PARAGRAPH","CHECK_LIST_ITEM","IMAGE","TABLE","CODE_BLOCK","BLOCKQUOTE","LIST_ITEM_CORRELATION_TYPE","ADD_POSITION_OFFSET_TYPE","INSERT_POSITION","ELEMENT_TYPE","CALL_OUT","EMPTY_SELECTED_RANGE","unwrapCallout","wrapCallout","getHeaderHeight","onSetNodeType","editor","element","type","includes","newType","setNodes","wrapNodes","id","nice","mode","match","n","isElement","isBlock","setSelection","path","findPath","select","onCopyNode","tableSize","children","length","tableSelectedRange","minRowIndex","maxRowIndex","minColIndex","maxColIndex","newData","setFragmentData","DataTransfer","onCopy","clipboardData","types","forEach","data","getData","setData","onDeleteNode","removeNodes","at","getDomTopHeight","dom","slateNode","rect","getBoundingClientRect","offsetY","iconOffset","headerHeight","paddingTop","parseFloat","window","getComputedStyle","getPropertyValue","lineHeight","disToolBarHeight","y","isVoidNode","node","hasImage","find","isTable","isCodeBlock","isCallout","string","isNotSupportTransform","insertElement","insertPosition","AFTER","p","selection","insertNodes","getNodeEntry","el","toSlateNode","isList","slice","isBlockquote","_nodeEntry$","nodeEntry","_nodeEntry$2","_nodeEntry$3","getListNode","listType","listItem","listNode","onWrapListItem","targetPath","sourcePath","nextPath","next"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/toolbar/side-toolbar/helpers.js"],"sourcesContent":["import { Transforms, Node, Editor, Element, Path } from '@seafile/slate';\nimport slugid from 'slugid';\nimport { ReactEditor } from '@seafile/slate-react';\nimport copy from 'copy-to-clipboard';\nimport { toggleList } from '../../plugins/list/transforms';\nimport { generateEmptyElement } from '../../core';\nimport { generateEmptyList } from '../../plugins/list/model';\nimport { setClipboardCodeBlockData } from '../../plugins/code-block/helpers';\nimport { ORDERED_LIST, UNORDERED_LIST, PARAGRAPH, CHECK_LIST_ITEM, IMAGE, TABLE, CODE_BLOCK, BLOCKQUOTE, LIST_ITEM_CORRELATION_TYPE, ADD_POSITION_OFFSET_TYPE, INSERT_POSITION, ELEMENT_TYPE, CALL_OUT } from '../../constants';\nimport { EMPTY_SELECTED_RANGE } from '../../plugins/table/constants';\nimport { unwrapCallout, wrapCallout } from '../../plugins/callout/helper';\nimport { getHeaderHeight } from '../../../utils/dom-utils';\nexport const onSetNodeType = (editor, element, type) => {\n  if (!type) return;\n  if (type === CALL_OUT) {\n    wrapCallout(editor);\n    return;\n  }\n  if ([ORDERED_LIST, UNORDERED_LIST].includes(type)) {\n    toggleList(editor, type);\n    return;\n  }\n  if (type === CHECK_LIST_ITEM) {\n    const newType = element.type === CHECK_LIST_ITEM ? PARAGRAPH : CHECK_LIST_ITEM;\n    Transforms.setNodes(editor, {\n      type: newType\n    });\n    return;\n  }\n  if (type === BLOCKQUOTE && LIST_ITEM_CORRELATION_TYPE.includes(element.type)) {\n    Transforms.wrapNodes(editor, {\n      id: slugid.nice(),\n      type: BLOCKQUOTE\n    }, {\n      mode: 'highest',\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n)\n    });\n    return;\n  }\n  Transforms.setNodes(editor, {\n    type: type\n  });\n};\nexport const setSelection = (editor, element) => {\n  if (element) {\n    const path = ReactEditor.findPath(editor, element);\n    Transforms.select(editor, path);\n  }\n};\nexport const onCopyNode = (editor, element) => {\n  if (element.type === ELEMENT_TYPE.CODE_BLOCK) {\n    setClipboardCodeBlockData(element);\n    return;\n  }\n  if (element.type === ELEMENT_TYPE.TABLE) {\n    const tableSize = [element.children.length, element.children[0].children.length];\n    const tableSelectedRange = {\n      minRowIndex: 0,\n      maxRowIndex: tableSize[0] - 1,\n      minColIndex: 0,\n      maxColIndex: tableSize[1] - 1\n    };\n    editor.tableSelectedRange = tableSelectedRange;\n  }\n  const newData = editor.setFragmentData(new DataTransfer());\n  copy('copy', {\n    onCopy: clipboardData => {\n      newData.types.forEach(type => {\n        const data = newData.getData(type);\n        clipboardData.setData(type, data);\n      });\n    }\n  });\n  if (element.type === ELEMENT_TYPE.TABLE) {\n    editor.tableSelectedRange = EMPTY_SELECTED_RANGE;\n  }\n};\nexport const onDeleteNode = (editor, element) => {\n  if (element.type === CALL_OUT) {\n    unwrapCallout(editor);\n    return;\n  }\n  const path = ReactEditor.findPath(editor, element);\n  Transforms.removeNodes(editor, {\n    at: path\n  });\n};\nexport const getDomTopHeight = (editor, dom, slateNode) => {\n  const rect = dom.getBoundingClientRect();\n  let offsetY = 0;\n  const iconOffset = 4; // ensure icon is in the middle of the line\n  const headerHeight = getHeaderHeight(editor);\n  const paddingTop = parseFloat(window.getComputedStyle(dom).getPropertyValue('padding-top'));\n  const lineHeight = parseFloat(window.getComputedStyle(dom).getPropertyValue('line-height'));\n  const disToolBarHeight = 12; // side toolbar icon is 12 px\n  if (ADD_POSITION_OFFSET_TYPE.includes(slateNode.type)) {\n    offsetY = lineHeight / 2 + paddingTop - disToolBarHeight / 2;\n  }\n  return rect.y - headerHeight + offsetY - iconOffset;\n};\nexport const isVoidNode = node => {\n  if (!node) return true;\n  const hasImage = node.children.find(n => n.type === IMAGE);\n  const isTable = node.type === TABLE;\n  const isCodeBlock = node.type === CODE_BLOCK;\n  const isCallout = node.type === CALL_OUT;\n  return Node.string(node) === '' && !hasImage && !isTable && !isCodeBlock && !isCallout;\n};\nexport const isNotSupportTransform = node => {\n  if (node.type && [CODE_BLOCK, TABLE, CALL_OUT].includes(node.type)) {\n    return true;\n  }\n  return false;\n};\nexport const insertElement = (editor, type, insertPosition) => {\n  if (insertPosition === INSERT_POSITION.AFTER) {\n    const p = generateEmptyElement(PARAGRAPH);\n    const path = Editor.path(editor, editor.selection);\n    Transforms.insertNodes(editor, p, {\n      at: [path[0] + 1]\n    });\n    Transforms.select(editor, [path[0] + 1]);\n  }\n  // Insertion position is current or after\n  Transforms.setNodes(editor, {\n    type\n  });\n};\nexport const getNodeEntry = (editor, el) => {\n  const node = ReactEditor.toSlateNode(editor, el);\n  let path = ReactEditor.findPath(editor, node);\n  if (isList(editor, path)) {\n    path = path.slice(0, path.length - 1);\n  }\n  if (node && path) return [node, path];\n  return [];\n};\nexport const isBlockquote = (editor, path) => {\n  var _nodeEntry$;\n  const nodeEntry = Editor.node(editor, path);\n  if (nodeEntry && ((_nodeEntry$ = nodeEntry[0]) === null || _nodeEntry$ === void 0 ? void 0 : _nodeEntry$.type) === BLOCKQUOTE) {\n    return true;\n  }\n  return false;\n};\nexport const isList = (editor, path) => {\n  var _nodeEntry$2;\n  const nodeEntry = Editor.node(editor, [path[0]]);\n  if (nodeEntry && [ORDERED_LIST, UNORDERED_LIST].includes((_nodeEntry$2 = nodeEntry[0]) === null || _nodeEntry$2 === void 0 ? void 0 : _nodeEntry$2.type)) {\n    return true;\n  }\n  if (path.length > 1 && isBlockquote(editor, [path[0]])) {\n    var _nodeEntry$3;\n    const nodeEntry = Editor.node(editor, [path[0], path[1]]);\n    if ([ORDERED_LIST, UNORDERED_LIST].includes((_nodeEntry$3 = nodeEntry[0]) === null || _nodeEntry$3 === void 0 ? void 0 : _nodeEntry$3.type)) {\n      return true;\n    }\n  }\n  return false;\n};\nexport const getListNode = (editor, path) => {\n  let listType = Editor.node(editor, [path[0]])[0].type;\n  if (listType === BLOCKQUOTE) {\n    listType = Editor.node(editor, [path[0], path[1]])[0].type;\n  }\n  const listItem = Editor.node(editor, path)[0];\n  const listNode = generateEmptyList(listType);\n  listNode.children[0] = listItem;\n  return listNode;\n};\nexport const onWrapListItem = (editor, targetPath, sourcePath) => {\n  const nextPath = Path.next(targetPath);\n  const listNode = getListNode(editor, sourcePath);\n  Transforms.removeNodes(editor, {\n    at: sourcePath\n  });\n  Transforms.insertNodes(editor, listNode, {\n    at: nextPath\n  });\n  return;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}