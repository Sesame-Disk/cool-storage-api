{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _createClass from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport { parser } from '@lezer/xml';\nimport { syntaxTree, LRLanguage, indentNodeProp, foldNodeProp, bracketMatchingHandle, LanguageSupport } from '@codemirror/language';\nfunction tagName(doc, tag) {\n  var name = tag && tag.getChild(\"TagName\");\n  return name ? doc.sliceString(name.from, name.to) : \"\";\n}\nfunction elementName(doc, tree) {\n  var tag = tree && tree.firstChild;\n  return !tag || tag.name != \"OpenTag\" ? \"\" : tagName(doc, tag);\n}\nfunction attrName(doc, tag, pos) {\n  var attr = tag && tag.getChildren(\"Attribute\").find(function (a) {\n    return a.from <= pos && a.to >= pos;\n  });\n  var name = attr && attr.getChild(\"AttributeName\");\n  return name ? doc.sliceString(name.from, name.to) : \"\";\n}\nfunction findParentElement(tree) {\n  for (var cur = tree && tree.parent; cur; cur = cur.parent) if (cur.name == \"Element\") return cur;\n  return null;\n}\nfunction findLocation(state, pos) {\n  var _a;\n  var at = syntaxTree(state).resolveInner(pos, -1),\n    inTag = null;\n  for (var cur = at; !inTag && cur.parent; cur = cur.parent) if (cur.name == \"OpenTag\" || cur.name == \"CloseTag\" || cur.name == \"SelfClosingTag\" || cur.name == \"MismatchedCloseTag\") inTag = cur;\n  if (inTag && (inTag.to > pos || inTag.lastChild.type.isError)) {\n    var elt = inTag.parent;\n    if (at.name == \"TagName\") return inTag.name == \"CloseTag\" || inTag.name == \"MismatchedCloseTag\" ? {\n      type: \"closeTag\",\n      from: at.from,\n      context: elt\n    } : {\n      type: \"openTag\",\n      from: at.from,\n      context: findParentElement(elt)\n    };\n    if (at.name == \"AttributeName\") return {\n      type: \"attrName\",\n      from: at.from,\n      context: inTag\n    };\n    if (at.name == \"AttributeValue\") return {\n      type: \"attrValue\",\n      from: at.from,\n      context: inTag\n    };\n    var before = at == inTag || at.name == \"Attribute\" ? at.childBefore(pos) : at;\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"StartTag\") return {\n      type: \"openTag\",\n      from: pos,\n      context: findParentElement(elt)\n    };\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"StartCloseTag\" && before.to <= pos) return {\n      type: \"closeTag\",\n      from: pos,\n      context: elt\n    };\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"Is\") return {\n      type: \"attrValue\",\n      from: pos,\n      context: inTag\n    };\n    if (before) return {\n      type: \"attrName\",\n      from: pos,\n      context: inTag\n    };\n    return null;\n  } else if (at.name == \"StartCloseTag\") {\n    return {\n      type: \"closeTag\",\n      from: pos,\n      context: at.parent\n    };\n  }\n  while (at.parent && at.to == pos && !((_a = at.lastChild) === null || _a === void 0 ? void 0 : _a.type.isError)) at = at.parent;\n  if (at.name == \"Element\" || at.name == \"Text\" || at.name == \"Document\") return {\n    type: \"tag\",\n    from: pos,\n    context: at.name == \"Element\" ? at : findParentElement(at)\n  };\n  return null;\n}\nvar Element = /*#__PURE__*/_createClass(function Element(spec, attrs, attrValues) {\n  _classCallCheck(this, Element);\n  this.attrs = attrs;\n  this.attrValues = attrValues;\n  this.children = [];\n  this.name = spec.name;\n  this.completion = Object.assign(Object.assign({\n    type: \"type\"\n  }, spec.completion || {}), {\n    label: this.name\n  });\n  this.openCompletion = Object.assign(Object.assign({}, this.completion), {\n    label: \"<\" + this.name\n  });\n  this.closeCompletion = Object.assign(Object.assign({}, this.completion), {\n    label: \"</\" + this.name + \">\",\n    boost: 2\n  });\n  this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), {\n    label: this.name + \">\"\n  });\n  this.text = spec.textContent ? spec.textContent.map(function (s) {\n    return {\n      label: s,\n      type: \"text\"\n    };\n  }) : [];\n});\nvar Identifier = /^[:\\-\\.\\w\\u00b7-\\uffff]*$/;\nfunction attrCompletion(spec) {\n  return Object.assign(Object.assign({\n    type: \"property\"\n  }, spec.completion || {}), {\n    label: spec.name\n  });\n}\nfunction valueCompletion(spec) {\n  return typeof spec == \"string\" ? {\n    label: \"\\\"\".concat(spec, \"\\\"\"),\n    type: \"constant\"\n  } : /^\"/.test(spec.label) ? spec : Object.assign(Object.assign({}, spec), {\n    label: \"\\\"\".concat(spec.label, \"\\\"\")\n  });\n}\n/**\nCreate a completion source for the given schema.\n*/\nfunction completeFromSchema(eltSpecs, attrSpecs) {\n  var allAttrs = [],\n    globalAttrs = [];\n  var attrValues = Object.create(null);\n  var _iterator = _createForOfIteratorHelper(attrSpecs),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _s = _step.value;\n      var completion = attrCompletion(_s);\n      allAttrs.push(completion);\n      if (_s.global) globalAttrs.push(completion);\n      if (_s.values) attrValues[_s.name] = _s.values.map(valueCompletion);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var allElements = [],\n    topElements = [];\n  var byName = Object.create(null);\n  var _iterator2 = _createForOfIteratorHelper(eltSpecs),\n    _step2;\n  try {\n    var _loop = function _loop() {\n      var s = _step2.value;\n      var attrs = globalAttrs,\n        attrVals = attrValues;\n      if (s.attributes) attrs = attrs.concat(s.attributes.map(function (s) {\n        if (typeof s == \"string\") return allAttrs.find(function (a) {\n          return a.label == s;\n        }) || {\n          label: s,\n          type: \"property\"\n        };\n        if (s.values) {\n          if (attrVals == attrValues) attrVals = Object.create(attrVals);\n          attrVals[s.name] = s.values.map(valueCompletion);\n        }\n        return attrCompletion(s);\n      }));\n      var elt = new Element(s, attrs, attrVals);\n      byName[elt.name] = elt;\n      allElements.push(elt);\n      if (s.top) topElements.push(elt);\n    };\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  if (!topElements.length) topElements = allElements;\n  for (var i = 0; i < allElements.length; i++) {\n    var s = eltSpecs[i],\n      elt = allElements[i];\n    if (s.children) {\n      var _iterator3 = _createForOfIteratorHelper(s.children),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var ch = _step3.value;\n          if (byName[ch]) elt.children.push(byName[ch]);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    } else {\n      elt.children = allElements;\n    }\n  }\n  return function (cx) {\n    var _a;\n    var doc = cx.state.doc,\n      loc = findLocation(cx.state, cx.pos);\n    if (!loc || loc.type == \"tag\" && !cx.explicit) return null;\n    var type = loc.type,\n      from = loc.from,\n      context = loc.context;\n    if (type == \"openTag\") {\n      var children = topElements;\n      var parentName = elementName(doc, context);\n      if (parentName) {\n        var parent = byName[parentName];\n        children = (parent === null || parent === void 0 ? void 0 : parent.children) || allElements;\n      }\n      return {\n        from: from,\n        options: children.map(function (ch) {\n          return ch.completion;\n        }),\n        validFor: Identifier\n      };\n    } else if (type == \"closeTag\") {\n      var _parentName = elementName(doc, context);\n      return _parentName ? {\n        from: from,\n        to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == \">\" ? 1 : 0),\n        options: [((_a = byName[_parentName]) === null || _a === void 0 ? void 0 : _a.closeNameCompletion) || {\n          label: _parentName + \">\",\n          type: \"type\"\n        }],\n        validFor: Identifier\n      } : null;\n    } else if (type == \"attrName\") {\n      var _parent = byName[tagName(doc, context)];\n      return {\n        from: from,\n        options: (_parent === null || _parent === void 0 ? void 0 : _parent.attrs) || globalAttrs,\n        validFor: Identifier\n      };\n    } else if (type == \"attrValue\") {\n      var attr = attrName(doc, context, from);\n      if (!attr) return null;\n      var _parent2 = byName[tagName(doc, context)];\n      var values = ((_parent2 === null || _parent2 === void 0 ? void 0 : _parent2.attrValues) || attrValues)[attr];\n      if (!values || !values.length) return null;\n      return {\n        from: from,\n        to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == '\"' ? 1 : 0),\n        options: values,\n        validFor: /^\"[^\"]*\"?$/\n      };\n    } else if (type == \"tag\") {\n      var _parentName2 = elementName(doc, context),\n        _parent3 = byName[_parentName2];\n      var closing = [],\n        last = context && context.lastChild;\n      if (_parentName2 && (!last || last.name != \"CloseTag\" || tagName(doc, last) != _parentName2)) closing.push(_parent3 ? _parent3.closeCompletion : {\n        label: \"</\" + _parentName2 + \">\",\n        type: \"type\",\n        boost: 2\n      });\n      var options = closing.concat(((_parent3 === null || _parent3 === void 0 ? void 0 : _parent3.children) || (context ? allElements : topElements)).map(function (e) {\n        return e.openCompletion;\n      }));\n      if (context && (_parent3 === null || _parent3 === void 0 ? void 0 : _parent3.text.length)) {\n        var openTag = context.firstChild;\n        if (openTag.to > cx.pos - 20 && !/\\S/.test(cx.state.sliceDoc(openTag.to, cx.pos))) options = options.concat(_parent3.text);\n      }\n      return {\n        from: from,\n        options: options,\n        validFor: /^<\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/\n      };\n    } else {\n      return null;\n    }\n  };\n}\n\n/**\nA language provider based on the [Lezer XML\nparser](https://github.com/lezer-parser/xml), extended with\nhighlighting and indentation information.\n*/\nvar xmlLanguage = /*@__PURE__*/LRLanguage.define({\n  name: \"xml\",\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      Element: function Element(context) {\n        var closed = /^\\s*<\\//.test(context.textAfter);\n        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n      },\n      \"OpenTag CloseTag SelfClosingTag\": function OpenTagCloseTagSelfClosingTag(context) {\n        return context.column(context.node.from) + context.unit;\n      }\n    }), /*@__PURE__*/foldNodeProp.add({\n      Element: function Element(subtree) {\n        var first = subtree.firstChild,\n          last = subtree.lastChild;\n        if (!first || first.name != \"OpenTag\") return null;\n        return {\n          from: first.to,\n          to: last.name == \"CloseTag\" ? last.from : subtree.to\n        };\n      }\n    }), /*@__PURE__*/bracketMatchingHandle.add({\n      \"OpenTag CloseTag\": function OpenTagCloseTag(node) {\n        return node.getChild(\"TagName\");\n      }\n    })]\n  }),\n  languageData: {\n    commentTokens: {\n      block: {\n        open: \"<!--\",\n        close: \"-->\"\n      }\n    },\n    indentOnInput: /^\\s*<\\/$/\n  }\n});\n/**\nXML language support. Includes schema-based autocompletion when\nconfigured.\n*/\nfunction xml() {\n  var conf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new LanguageSupport(xmlLanguage, xmlLanguage.data.of({\n    autocomplete: completeFromSchema(conf.elements || [], conf.attributes || [])\n  }));\n}\nexport { completeFromSchema, xml, xmlLanguage };","map":{"version":3,"names":["parser","syntaxTree","LRLanguage","indentNodeProp","foldNodeProp","bracketMatchingHandle","LanguageSupport","tagName","doc","tag","name","getChild","sliceString","from","to","elementName","tree","firstChild","attrName","pos","attr","getChildren","find","a","findParentElement","cur","parent","findLocation","state","_a","at","resolveInner","inTag","lastChild","type","isError","elt","context","before","childBefore","Element","_createClass","spec","attrs","attrValues","_classCallCheck","children","completion","Object","assign","label","openCompletion","closeCompletion","boost","closeNameCompletion","text","textContent","map","s","Identifier","attrCompletion","valueCompletion","concat","test","completeFromSchema","eltSpecs","attrSpecs","allAttrs","globalAttrs","create","_iterator","_createForOfIteratorHelper","_step","n","done","value","push","global","values","err","e","f","allElements","topElements","byName","_iterator2","_step2","_loop","attrVals","attributes","top","length","i","_iterator3","_step3","ch","cx","loc","explicit","parentName","options","validFor","closing","last","openTag","sliceDoc","xmlLanguage","define","configure","props","add","closed","textAfter","lineIndent","node","unit","OpenTagCloseTagSelfClosingTag","column","subtree","first","OpenTagCloseTag","languageData","commentTokens","block","open","close","indentOnInput","xml","conf","arguments","undefined","data","of","autocomplete","elements"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@codemirror/lang-xml/dist/index.js"],"sourcesContent":["import { parser } from '@lezer/xml';\nimport { syntaxTree, LRLanguage, indentNodeProp, foldNodeProp, bracketMatchingHandle, LanguageSupport } from '@codemirror/language';\n\nfunction tagName(doc, tag) {\n    let name = tag && tag.getChild(\"TagName\");\n    return name ? doc.sliceString(name.from, name.to) : \"\";\n}\nfunction elementName(doc, tree) {\n    let tag = tree && tree.firstChild;\n    return !tag || tag.name != \"OpenTag\" ? \"\" : tagName(doc, tag);\n}\nfunction attrName(doc, tag, pos) {\n    let attr = tag && tag.getChildren(\"Attribute\").find(a => a.from <= pos && a.to >= pos);\n    let name = attr && attr.getChild(\"AttributeName\");\n    return name ? doc.sliceString(name.from, name.to) : \"\";\n}\nfunction findParentElement(tree) {\n    for (let cur = tree && tree.parent; cur; cur = cur.parent)\n        if (cur.name == \"Element\")\n            return cur;\n    return null;\n}\nfunction findLocation(state, pos) {\n    var _a;\n    let at = syntaxTree(state).resolveInner(pos, -1), inTag = null;\n    for (let cur = at; !inTag && cur.parent; cur = cur.parent)\n        if (cur.name == \"OpenTag\" || cur.name == \"CloseTag\" || cur.name == \"SelfClosingTag\" || cur.name == \"MismatchedCloseTag\")\n            inTag = cur;\n    if (inTag && (inTag.to > pos || inTag.lastChild.type.isError)) {\n        let elt = inTag.parent;\n        if (at.name == \"TagName\")\n            return inTag.name == \"CloseTag\" || inTag.name == \"MismatchedCloseTag\"\n                ? { type: \"closeTag\", from: at.from, context: elt }\n                : { type: \"openTag\", from: at.from, context: findParentElement(elt) };\n        if (at.name == \"AttributeName\")\n            return { type: \"attrName\", from: at.from, context: inTag };\n        if (at.name == \"AttributeValue\")\n            return { type: \"attrValue\", from: at.from, context: inTag };\n        let before = at == inTag || at.name == \"Attribute\" ? at.childBefore(pos) : at;\n        if ((before === null || before === void 0 ? void 0 : before.name) == \"StartTag\")\n            return { type: \"openTag\", from: pos, context: findParentElement(elt) };\n        if ((before === null || before === void 0 ? void 0 : before.name) == \"StartCloseTag\" && before.to <= pos)\n            return { type: \"closeTag\", from: pos, context: elt };\n        if ((before === null || before === void 0 ? void 0 : before.name) == \"Is\")\n            return { type: \"attrValue\", from: pos, context: inTag };\n        if (before)\n            return { type: \"attrName\", from: pos, context: inTag };\n        return null;\n    }\n    else if (at.name == \"StartCloseTag\") {\n        return { type: \"closeTag\", from: pos, context: at.parent };\n    }\n    while (at.parent && at.to == pos && !((_a = at.lastChild) === null || _a === void 0 ? void 0 : _a.type.isError))\n        at = at.parent;\n    if (at.name == \"Element\" || at.name == \"Text\" || at.name == \"Document\")\n        return { type: \"tag\", from: pos, context: at.name == \"Element\" ? at : findParentElement(at) };\n    return null;\n}\nclass Element {\n    constructor(spec, attrs, attrValues) {\n        this.attrs = attrs;\n        this.attrValues = attrValues;\n        this.children = [];\n        this.name = spec.name;\n        this.completion = Object.assign(Object.assign({ type: \"type\" }, spec.completion || {}), { label: this.name });\n        this.openCompletion = Object.assign(Object.assign({}, this.completion), { label: \"<\" + this.name });\n        this.closeCompletion = Object.assign(Object.assign({}, this.completion), { label: \"</\" + this.name + \">\", boost: 2 });\n        this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), { label: this.name + \">\" });\n        this.text = spec.textContent ? spec.textContent.map(s => ({ label: s, type: \"text\" })) : [];\n    }\n}\nconst Identifier = /^[:\\-\\.\\w\\u00b7-\\uffff]*$/;\nfunction attrCompletion(spec) {\n    return Object.assign(Object.assign({ type: \"property\" }, spec.completion || {}), { label: spec.name });\n}\nfunction valueCompletion(spec) {\n    return typeof spec == \"string\" ? { label: `\"${spec}\"`, type: \"constant\" }\n        : /^\"/.test(spec.label) ? spec\n            : Object.assign(Object.assign({}, spec), { label: `\"${spec.label}\"` });\n}\n/**\nCreate a completion source for the given schema.\n*/\nfunction completeFromSchema(eltSpecs, attrSpecs) {\n    let allAttrs = [], globalAttrs = [];\n    let attrValues = Object.create(null);\n    for (let s of attrSpecs) {\n        let completion = attrCompletion(s);\n        allAttrs.push(completion);\n        if (s.global)\n            globalAttrs.push(completion);\n        if (s.values)\n            attrValues[s.name] = s.values.map(valueCompletion);\n    }\n    let allElements = [], topElements = [];\n    let byName = Object.create(null);\n    for (let s of eltSpecs) {\n        let attrs = globalAttrs, attrVals = attrValues;\n        if (s.attributes)\n            attrs = attrs.concat(s.attributes.map(s => {\n                if (typeof s == \"string\")\n                    return allAttrs.find(a => a.label == s) || { label: s, type: \"property\" };\n                if (s.values) {\n                    if (attrVals == attrValues)\n                        attrVals = Object.create(attrVals);\n                    attrVals[s.name] = s.values.map(valueCompletion);\n                }\n                return attrCompletion(s);\n            }));\n        let elt = new Element(s, attrs, attrVals);\n        byName[elt.name] = elt;\n        allElements.push(elt);\n        if (s.top)\n            topElements.push(elt);\n    }\n    if (!topElements.length)\n        topElements = allElements;\n    for (let i = 0; i < allElements.length; i++) {\n        let s = eltSpecs[i], elt = allElements[i];\n        if (s.children) {\n            for (let ch of s.children)\n                if (byName[ch])\n                    elt.children.push(byName[ch]);\n        }\n        else {\n            elt.children = allElements;\n        }\n    }\n    return cx => {\n        var _a;\n        let { doc } = cx.state, loc = findLocation(cx.state, cx.pos);\n        if (!loc || (loc.type == \"tag\" && !cx.explicit))\n            return null;\n        let { type, from, context } = loc;\n        if (type == \"openTag\") {\n            let children = topElements;\n            let parentName = elementName(doc, context);\n            if (parentName) {\n                let parent = byName[parentName];\n                children = (parent === null || parent === void 0 ? void 0 : parent.children) || allElements;\n            }\n            return {\n                from,\n                options: children.map(ch => ch.completion),\n                validFor: Identifier\n            };\n        }\n        else if (type == \"closeTag\") {\n            let parentName = elementName(doc, context);\n            return parentName ? {\n                from,\n                to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == \">\" ? 1 : 0),\n                options: [((_a = byName[parentName]) === null || _a === void 0 ? void 0 : _a.closeNameCompletion) || { label: parentName + \">\", type: \"type\" }],\n                validFor: Identifier\n            } : null;\n        }\n        else if (type == \"attrName\") {\n            let parent = byName[tagName(doc, context)];\n            return {\n                from,\n                options: (parent === null || parent === void 0 ? void 0 : parent.attrs) || globalAttrs,\n                validFor: Identifier\n            };\n        }\n        else if (type == \"attrValue\") {\n            let attr = attrName(doc, context, from);\n            if (!attr)\n                return null;\n            let parent = byName[tagName(doc, context)];\n            let values = ((parent === null || parent === void 0 ? void 0 : parent.attrValues) || attrValues)[attr];\n            if (!values || !values.length)\n                return null;\n            return {\n                from,\n                to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == '\"' ? 1 : 0),\n                options: values,\n                validFor: /^\"[^\"]*\"?$/\n            };\n        }\n        else if (type == \"tag\") {\n            let parentName = elementName(doc, context), parent = byName[parentName];\n            let closing = [], last = context && context.lastChild;\n            if (parentName && (!last || last.name != \"CloseTag\" || tagName(doc, last) != parentName))\n                closing.push(parent ? parent.closeCompletion : { label: \"</\" + parentName + \">\", type: \"type\", boost: 2 });\n            let options = closing.concat(((parent === null || parent === void 0 ? void 0 : parent.children) || (context ? allElements : topElements)).map(e => e.openCompletion));\n            if (context && (parent === null || parent === void 0 ? void 0 : parent.text.length)) {\n                let openTag = context.firstChild;\n                if (openTag.to > cx.pos - 20 && !/\\S/.test(cx.state.sliceDoc(openTag.to, cx.pos)))\n                    options = options.concat(parent.text);\n            }\n            return {\n                from,\n                options,\n                validFor: /^<\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/\n            };\n        }\n        else {\n            return null;\n        }\n    };\n}\n\n/**\nA language provider based on the [Lezer XML\nparser](https://github.com/lezer-parser/xml), extended with\nhighlighting and indentation information.\n*/\nconst xmlLanguage = /*@__PURE__*/LRLanguage.define({\n    name: \"xml\",\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                Element(context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                \"OpenTag CloseTag SelfClosingTag\"(context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                Element(subtree) {\n                    let first = subtree.firstChild, last = subtree.lastChild;\n                    if (!first || first.name != \"OpenTag\")\n                        return null;\n                    return { from: first.to, to: last.name == \"CloseTag\" ? last.from : subtree.to };\n                }\n            }),\n            /*@__PURE__*/bracketMatchingHandle.add({\n                \"OpenTag CloseTag\": node => node.getChild(\"TagName\")\n            })\n        ]\n    }),\n    languageData: {\n        commentTokens: { block: { open: \"<!--\", close: \"-->\" } },\n        indentOnInput: /^\\s*<\\/$/\n    }\n});\n/**\nXML language support. Includes schema-based autocompletion when\nconfigured.\n*/\nfunction xml(conf = {}) {\n    return new LanguageSupport(xmlLanguage, xmlLanguage.data.of({\n        autocomplete: completeFromSchema(conf.elements || [], conf.attributes || [])\n    }));\n}\n\nexport { completeFromSchema, xml, xmlLanguage };\n"],"mappings":";;;AAAA,SAASA,MAAM,QAAQ,YAAY;AACnC,SAASC,UAAU,EAAEC,UAAU,EAAEC,cAAc,EAAEC,YAAY,EAAEC,qBAAqB,EAAEC,eAAe,QAAQ,sBAAsB;AAEnI,SAASC,OAAOA,CAACC,GAAG,EAAEC,GAAG,EAAE;EACvB,IAAIC,IAAI,GAAGD,GAAG,IAAIA,GAAG,CAACE,QAAQ,CAAC,SAAS,CAAC;EACzC,OAAOD,IAAI,GAAGF,GAAG,CAACI,WAAW,CAACF,IAAI,CAACG,IAAI,EAAEH,IAAI,CAACI,EAAE,CAAC,GAAG,EAAE;AAC1D;AACA,SAASC,WAAWA,CAACP,GAAG,EAAEQ,IAAI,EAAE;EAC5B,IAAIP,GAAG,GAAGO,IAAI,IAAIA,IAAI,CAACC,UAAU;EACjC,OAAO,CAACR,GAAG,IAAIA,GAAG,CAACC,IAAI,IAAI,SAAS,GAAG,EAAE,GAAGH,OAAO,CAACC,GAAG,EAAEC,GAAG,CAAC;AACjE;AACA,SAASS,QAAQA,CAACV,GAAG,EAAEC,GAAG,EAAEU,GAAG,EAAE;EAC7B,IAAIC,IAAI,GAAGX,GAAG,IAAIA,GAAG,CAACY,WAAW,CAAC,WAAW,CAAC,CAACC,IAAI,CAAC,UAAAC,CAAC;IAAA,OAAIA,CAAC,CAACV,IAAI,IAAIM,GAAG,IAAII,CAAC,CAACT,EAAE,IAAIK,GAAG;EAAA,EAAC;EACtF,IAAIT,IAAI,GAAGU,IAAI,IAAIA,IAAI,CAACT,QAAQ,CAAC,eAAe,CAAC;EACjD,OAAOD,IAAI,GAAGF,GAAG,CAACI,WAAW,CAACF,IAAI,CAACG,IAAI,EAAEH,IAAI,CAACI,EAAE,CAAC,GAAG,EAAE;AAC1D;AACA,SAASU,iBAAiBA,CAACR,IAAI,EAAE;EAC7B,KAAK,IAAIS,GAAG,GAAGT,IAAI,IAAIA,IAAI,CAACU,MAAM,EAAED,GAAG,EAAEA,GAAG,GAAGA,GAAG,CAACC,MAAM,EACrD,IAAID,GAAG,CAACf,IAAI,IAAI,SAAS,EACrB,OAAOe,GAAG;EAClB,OAAO,IAAI;AACf;AACA,SAASE,YAAYA,CAACC,KAAK,EAAET,GAAG,EAAE;EAC9B,IAAIU,EAAE;EACN,IAAIC,EAAE,GAAG7B,UAAU,CAAC2B,KAAK,CAAC,CAACG,YAAY,CAACZ,GAAG,EAAE,CAAC,CAAC,CAAC;IAAEa,KAAK,GAAG,IAAI;EAC9D,KAAK,IAAIP,GAAG,GAAGK,EAAE,EAAE,CAACE,KAAK,IAAIP,GAAG,CAACC,MAAM,EAAED,GAAG,GAAGA,GAAG,CAACC,MAAM,EACrD,IAAID,GAAG,CAACf,IAAI,IAAI,SAAS,IAAIe,GAAG,CAACf,IAAI,IAAI,UAAU,IAAIe,GAAG,CAACf,IAAI,IAAI,gBAAgB,IAAIe,GAAG,CAACf,IAAI,IAAI,oBAAoB,EACnHsB,KAAK,GAAGP,GAAG;EACnB,IAAIO,KAAK,KAAKA,KAAK,CAAClB,EAAE,GAAGK,GAAG,IAAIa,KAAK,CAACC,SAAS,CAACC,IAAI,CAACC,OAAO,CAAC,EAAE;IAC3D,IAAIC,GAAG,GAAGJ,KAAK,CAACN,MAAM;IACtB,IAAII,EAAE,CAACpB,IAAI,IAAI,SAAS,EACpB,OAAOsB,KAAK,CAACtB,IAAI,IAAI,UAAU,IAAIsB,KAAK,CAACtB,IAAI,IAAI,oBAAoB,GAC/D;MAAEwB,IAAI,EAAE,UAAU;MAAErB,IAAI,EAAEiB,EAAE,CAACjB,IAAI;MAAEwB,OAAO,EAAED;IAAI,CAAC,GACjD;MAAEF,IAAI,EAAE,SAAS;MAAErB,IAAI,EAAEiB,EAAE,CAACjB,IAAI;MAAEwB,OAAO,EAAEb,iBAAiB,CAACY,GAAG;IAAE,CAAC;IAC7E,IAAIN,EAAE,CAACpB,IAAI,IAAI,eAAe,EAC1B,OAAO;MAAEwB,IAAI,EAAE,UAAU;MAAErB,IAAI,EAAEiB,EAAE,CAACjB,IAAI;MAAEwB,OAAO,EAAEL;IAAM,CAAC;IAC9D,IAAIF,EAAE,CAACpB,IAAI,IAAI,gBAAgB,EAC3B,OAAO;MAAEwB,IAAI,EAAE,WAAW;MAAErB,IAAI,EAAEiB,EAAE,CAACjB,IAAI;MAAEwB,OAAO,EAAEL;IAAM,CAAC;IAC/D,IAAIM,MAAM,GAAGR,EAAE,IAAIE,KAAK,IAAIF,EAAE,CAACpB,IAAI,IAAI,WAAW,GAAGoB,EAAE,CAACS,WAAW,CAACpB,GAAG,CAAC,GAAGW,EAAE;IAC7E,IAAI,CAACQ,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAC5B,IAAI,KAAK,UAAU,EAC3E,OAAO;MAAEwB,IAAI,EAAE,SAAS;MAAErB,IAAI,EAAEM,GAAG;MAAEkB,OAAO,EAAEb,iBAAiB,CAACY,GAAG;IAAE,CAAC;IAC1E,IAAI,CAACE,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAC5B,IAAI,KAAK,eAAe,IAAI4B,MAAM,CAACxB,EAAE,IAAIK,GAAG,EACpG,OAAO;MAAEe,IAAI,EAAE,UAAU;MAAErB,IAAI,EAAEM,GAAG;MAAEkB,OAAO,EAAED;IAAI,CAAC;IACxD,IAAI,CAACE,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAAC5B,IAAI,KAAK,IAAI,EACrE,OAAO;MAAEwB,IAAI,EAAE,WAAW;MAAErB,IAAI,EAAEM,GAAG;MAAEkB,OAAO,EAAEL;IAAM,CAAC;IAC3D,IAAIM,MAAM,EACN,OAAO;MAAEJ,IAAI,EAAE,UAAU;MAAErB,IAAI,EAAEM,GAAG;MAAEkB,OAAO,EAAEL;IAAM,CAAC;IAC1D,OAAO,IAAI;EACf,CAAC,MACI,IAAIF,EAAE,CAACpB,IAAI,IAAI,eAAe,EAAE;IACjC,OAAO;MAAEwB,IAAI,EAAE,UAAU;MAAErB,IAAI,EAAEM,GAAG;MAAEkB,OAAO,EAAEP,EAAE,CAACJ;IAAO,CAAC;EAC9D;EACA,OAAOI,EAAE,CAACJ,MAAM,IAAII,EAAE,CAAChB,EAAE,IAAIK,GAAG,IAAI,EAAE,CAACU,EAAE,GAAGC,EAAE,CAACG,SAAS,MAAM,IAAI,IAAIJ,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACK,IAAI,CAACC,OAAO,CAAC,EAC3GL,EAAE,GAAGA,EAAE,CAACJ,MAAM;EAClB,IAAII,EAAE,CAACpB,IAAI,IAAI,SAAS,IAAIoB,EAAE,CAACpB,IAAI,IAAI,MAAM,IAAIoB,EAAE,CAACpB,IAAI,IAAI,UAAU,EAClE,OAAO;IAAEwB,IAAI,EAAE,KAAK;IAAErB,IAAI,EAAEM,GAAG;IAAEkB,OAAO,EAAEP,EAAE,CAACpB,IAAI,IAAI,SAAS,GAAGoB,EAAE,GAAGN,iBAAiB,CAACM,EAAE;EAAE,CAAC;EACjG,OAAO,IAAI;AACf;AAAC,IACKU,OAAO,gBAAAC,YAAA,CACT,SAAAD,QAAYE,IAAI,EAAEC,KAAK,EAAEC,UAAU,EAAE;EAAAC,eAAA,OAAAL,OAAA;EACjC,IAAI,CAACG,KAAK,GAAGA,KAAK;EAClB,IAAI,CAACC,UAAU,GAAGA,UAAU;EAC5B,IAAI,CAACE,QAAQ,GAAG,EAAE;EAClB,IAAI,CAACpC,IAAI,GAAGgC,IAAI,CAAChC,IAAI;EACrB,IAAI,CAACqC,UAAU,GAAGC,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC;IAAEf,IAAI,EAAE;EAAO,CAAC,EAAEQ,IAAI,CAACK,UAAU,IAAI,CAAC,CAAC,CAAC,EAAE;IAAEG,KAAK,EAAE,IAAI,CAACxC;EAAK,CAAC,CAAC;EAC7G,IAAI,CAACyC,cAAc,GAAGH,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACF,UAAU,CAAC,EAAE;IAAEG,KAAK,EAAE,GAAG,GAAG,IAAI,CAACxC;EAAK,CAAC,CAAC;EACnG,IAAI,CAAC0C,eAAe,GAAGJ,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACF,UAAU,CAAC,EAAE;IAAEG,KAAK,EAAE,IAAI,GAAG,IAAI,CAACxC,IAAI,GAAG,GAAG;IAAE2C,KAAK,EAAE;EAAE,CAAC,CAAC;EACrH,IAAI,CAACC,mBAAmB,GAAGN,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAACF,UAAU,CAAC,EAAE;IAAEG,KAAK,EAAE,IAAI,CAACxC,IAAI,GAAG;EAAI,CAAC,CAAC;EACxG,IAAI,CAAC6C,IAAI,GAAGb,IAAI,CAACc,WAAW,GAAGd,IAAI,CAACc,WAAW,CAACC,GAAG,CAAC,UAAAC,CAAC;IAAA,OAAK;MAAER,KAAK,EAAEQ,CAAC;MAAExB,IAAI,EAAE;IAAO,CAAC;EAAA,CAAC,CAAC,GAAG,EAAE;AAC/F,CAAC;AAEL,IAAMyB,UAAU,GAAG,2BAA2B;AAC9C,SAASC,cAAcA,CAAClB,IAAI,EAAE;EAC1B,OAAOM,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC;IAAEf,IAAI,EAAE;EAAW,CAAC,EAAEQ,IAAI,CAACK,UAAU,IAAI,CAAC,CAAC,CAAC,EAAE;IAAEG,KAAK,EAAER,IAAI,CAAChC;EAAK,CAAC,CAAC;AAC1G;AACA,SAASmD,eAAeA,CAACnB,IAAI,EAAE;EAC3B,OAAO,OAAOA,IAAI,IAAI,QAAQ,GAAG;IAAEQ,KAAK,OAAAY,MAAA,CAAMpB,IAAI,OAAG;IAAER,IAAI,EAAE;EAAW,CAAC,GACnE,IAAI,CAAC6B,IAAI,CAACrB,IAAI,CAACQ,KAAK,CAAC,GAAGR,IAAI,GACxBM,MAAM,CAACC,MAAM,CAACD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEP,IAAI,CAAC,EAAE;IAAEQ,KAAK,OAAAY,MAAA,CAAMpB,IAAI,CAACQ,KAAK;EAAI,CAAC,CAAC;AAClF;AACA;AACA;AACA;AACA,SAASc,kBAAkBA,CAACC,QAAQ,EAAEC,SAAS,EAAE;EAC7C,IAAIC,QAAQ,GAAG,EAAE;IAAEC,WAAW,GAAG,EAAE;EACnC,IAAIxB,UAAU,GAAGI,MAAM,CAACqB,MAAM,CAAC,IAAI,CAAC;EAAC,IAAAC,SAAA,GAAAC,0BAAA,CACvBL,SAAS;IAAAM,KAAA;EAAA;IAAvB,KAAAF,SAAA,CAAAZ,CAAA,MAAAc,KAAA,GAAAF,SAAA,CAAAG,CAAA,IAAAC,IAAA,GAAyB;MAAA,IAAhBhB,EAAC,GAAAc,KAAA,CAAAG,KAAA;MACN,IAAI5B,UAAU,GAAGa,cAAc,CAACF,EAAC,CAAC;MAClCS,QAAQ,CAACS,IAAI,CAAC7B,UAAU,CAAC;MACzB,IAAIW,EAAC,CAACmB,MAAM,EACRT,WAAW,CAACQ,IAAI,CAAC7B,UAAU,CAAC;MAChC,IAAIW,EAAC,CAACoB,MAAM,EACRlC,UAAU,CAACc,EAAC,CAAChD,IAAI,CAAC,GAAGgD,EAAC,CAACoB,MAAM,CAACrB,GAAG,CAACI,eAAe,CAAC;IAC1D;EAAC,SAAAkB,GAAA;IAAAT,SAAA,CAAAU,CAAA,CAAAD,GAAA;EAAA;IAAAT,SAAA,CAAAW,CAAA;EAAA;EACD,IAAIC,WAAW,GAAG,EAAE;IAAEC,WAAW,GAAG,EAAE;EACtC,IAAIC,MAAM,GAAGpC,MAAM,CAACqB,MAAM,CAAC,IAAI,CAAC;EAAC,IAAAgB,UAAA,GAAAd,0BAAA,CACnBN,QAAQ;IAAAqB,MAAA;EAAA;IAAA,IAAAC,KAAA,YAAAA,MAAA,EAAE;MAAA,IAAf7B,CAAC,GAAA4B,MAAA,CAAAX,KAAA;MACN,IAAIhC,KAAK,GAAGyB,WAAW;QAAEoB,QAAQ,GAAG5C,UAAU;MAC9C,IAAIc,CAAC,CAAC+B,UAAU,EACZ9C,KAAK,GAAGA,KAAK,CAACmB,MAAM,CAACJ,CAAC,CAAC+B,UAAU,CAAChC,GAAG,CAAC,UAAAC,CAAC,EAAI;QACvC,IAAI,OAAOA,CAAC,IAAI,QAAQ,EACpB,OAAOS,QAAQ,CAAC7C,IAAI,CAAC,UAAAC,CAAC;UAAA,OAAIA,CAAC,CAAC2B,KAAK,IAAIQ,CAAC;QAAA,EAAC,IAAI;UAAER,KAAK,EAAEQ,CAAC;UAAExB,IAAI,EAAE;QAAW,CAAC;QAC7E,IAAIwB,CAAC,CAACoB,MAAM,EAAE;UACV,IAAIU,QAAQ,IAAI5C,UAAU,EACtB4C,QAAQ,GAAGxC,MAAM,CAACqB,MAAM,CAACmB,QAAQ,CAAC;UACtCA,QAAQ,CAAC9B,CAAC,CAAChD,IAAI,CAAC,GAAGgD,CAAC,CAACoB,MAAM,CAACrB,GAAG,CAACI,eAAe,CAAC;QACpD;QACA,OAAOD,cAAc,CAACF,CAAC,CAAC;MAC5B,CAAC,CAAC,CAAC;MACP,IAAItB,GAAG,GAAG,IAAII,OAAO,CAACkB,CAAC,EAAEf,KAAK,EAAE6C,QAAQ,CAAC;MACzCJ,MAAM,CAAChD,GAAG,CAAC1B,IAAI,CAAC,GAAG0B,GAAG;MACtB8C,WAAW,CAACN,IAAI,CAACxC,GAAG,CAAC;MACrB,IAAIsB,CAAC,CAACgC,GAAG,EACLP,WAAW,CAACP,IAAI,CAACxC,GAAG,CAAC;IAC7B,CAAC;IAlBD,KAAAiD,UAAA,CAAA3B,CAAA,MAAA4B,MAAA,GAAAD,UAAA,CAAAZ,CAAA,IAAAC,IAAA;MAAAa,KAAA;IAAA;EAkBC,SAAAR,GAAA;IAAAM,UAAA,CAAAL,CAAA,CAAAD,GAAA;EAAA;IAAAM,UAAA,CAAAJ,CAAA;EAAA;EACD,IAAI,CAACE,WAAW,CAACQ,MAAM,EACnBR,WAAW,GAAGD,WAAW;EAC7B,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,WAAW,CAACS,MAAM,EAAEC,CAAC,EAAE,EAAE;IACzC,IAAIlC,CAAC,GAAGO,QAAQ,CAAC2B,CAAC,CAAC;MAAExD,GAAG,GAAG8C,WAAW,CAACU,CAAC,CAAC;IACzC,IAAIlC,CAAC,CAACZ,QAAQ,EAAE;MAAA,IAAA+C,UAAA,GAAAtB,0BAAA,CACGb,CAAC,CAACZ,QAAQ;QAAAgD,MAAA;MAAA;QAAzB,KAAAD,UAAA,CAAAnC,CAAA,MAAAoC,MAAA,GAAAD,UAAA,CAAApB,CAAA,IAAAC,IAAA,GACI;UAAA,IADKqB,EAAE,GAAAD,MAAA,CAAAnB,KAAA;UACP,IAAIS,MAAM,CAACW,EAAE,CAAC,EACV3D,GAAG,CAACU,QAAQ,CAAC8B,IAAI,CAACQ,MAAM,CAACW,EAAE,CAAC,CAAC;QAAA;MAAC,SAAAhB,GAAA;QAAAc,UAAA,CAAAb,CAAA,CAAAD,GAAA;MAAA;QAAAc,UAAA,CAAAZ,CAAA;MAAA;IAC1C,CAAC,MACI;MACD7C,GAAG,CAACU,QAAQ,GAAGoC,WAAW;IAC9B;EACJ;EACA,OAAO,UAAAc,EAAE,EAAI;IACT,IAAInE,EAAE;IACF,IAAErB,GAAG,GAAKwF,EAAE,CAACpE,KAAK,CAAhBpB,GAAG;MAAeyF,GAAG,GAAGtE,YAAY,CAACqE,EAAE,CAACpE,KAAK,EAAEoE,EAAE,CAAC7E,GAAG,CAAC;IAC5D,IAAI,CAAC8E,GAAG,IAAKA,GAAG,CAAC/D,IAAI,IAAI,KAAK,IAAI,CAAC8D,EAAE,CAACE,QAAS,EAC3C,OAAO,IAAI;IACf,IAAMhE,IAAI,GAAoB+D,GAAG,CAA3B/D,IAAI;MAAErB,IAAI,GAAcoF,GAAG,CAArBpF,IAAI;MAAEwB,OAAO,GAAK4D,GAAG,CAAf5D,OAAO;IACzB,IAAIH,IAAI,IAAI,SAAS,EAAE;MACnB,IAAIY,QAAQ,GAAGqC,WAAW;MAC1B,IAAIgB,UAAU,GAAGpF,WAAW,CAACP,GAAG,EAAE6B,OAAO,CAAC;MAC1C,IAAI8D,UAAU,EAAE;QACZ,IAAIzE,MAAM,GAAG0D,MAAM,CAACe,UAAU,CAAC;QAC/BrD,QAAQ,GAAG,CAACpB,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,MAAM,CAACoB,QAAQ,KAAKoC,WAAW;MAC/F;MACA,OAAO;QACHrE,IAAI,EAAJA,IAAI;QACJuF,OAAO,EAAEtD,QAAQ,CAACW,GAAG,CAAC,UAAAsC,EAAE;UAAA,OAAIA,EAAE,CAAChD,UAAU;QAAA,EAAC;QAC1CsD,QAAQ,EAAE1C;MACd,CAAC;IACL,CAAC,MACI,IAAIzB,IAAI,IAAI,UAAU,EAAE;MACzB,IAAIiE,WAAU,GAAGpF,WAAW,CAACP,GAAG,EAAE6B,OAAO,CAAC;MAC1C,OAAO8D,WAAU,GAAG;QAChBtF,IAAI,EAAJA,IAAI;QACJC,EAAE,EAAEkF,EAAE,CAAC7E,GAAG,IAAIX,GAAG,CAACI,WAAW,CAACoF,EAAE,CAAC7E,GAAG,EAAE6E,EAAE,CAAC7E,GAAG,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;QACjEiF,OAAO,EAAE,CAAC,CAAC,CAACvE,EAAE,GAAGuD,MAAM,CAACe,WAAU,CAAC,MAAM,IAAI,IAAItE,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACyB,mBAAmB,KAAK;UAAEJ,KAAK,EAAEiD,WAAU,GAAG,GAAG;UAAEjE,IAAI,EAAE;QAAO,CAAC,CAAC;QAC/ImE,QAAQ,EAAE1C;MACd,CAAC,GAAG,IAAI;IACZ,CAAC,MACI,IAAIzB,IAAI,IAAI,UAAU,EAAE;MACzB,IAAIR,OAAM,GAAG0D,MAAM,CAAC7E,OAAO,CAACC,GAAG,EAAE6B,OAAO,CAAC,CAAC;MAC1C,OAAO;QACHxB,IAAI,EAAJA,IAAI;QACJuF,OAAO,EAAE,CAAC1E,OAAM,KAAK,IAAI,IAAIA,OAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAM,CAACiB,KAAK,KAAKyB,WAAW;QACtFiC,QAAQ,EAAE1C;MACd,CAAC;IACL,CAAC,MACI,IAAIzB,IAAI,IAAI,WAAW,EAAE;MAC1B,IAAId,IAAI,GAAGF,QAAQ,CAACV,GAAG,EAAE6B,OAAO,EAAExB,IAAI,CAAC;MACvC,IAAI,CAACO,IAAI,EACL,OAAO,IAAI;MACf,IAAIM,QAAM,GAAG0D,MAAM,CAAC7E,OAAO,CAACC,GAAG,EAAE6B,OAAO,CAAC,CAAC;MAC1C,IAAIyC,MAAM,GAAG,CAAC,CAACpD,QAAM,KAAK,IAAI,IAAIA,QAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAM,CAACkB,UAAU,KAAKA,UAAU,EAAExB,IAAI,CAAC;MACtG,IAAI,CAAC0D,MAAM,IAAI,CAACA,MAAM,CAACa,MAAM,EACzB,OAAO,IAAI;MACf,OAAO;QACH9E,IAAI,EAAJA,IAAI;QACJC,EAAE,EAAEkF,EAAE,CAAC7E,GAAG,IAAIX,GAAG,CAACI,WAAW,CAACoF,EAAE,CAAC7E,GAAG,EAAE6E,EAAE,CAAC7E,GAAG,GAAG,CAAC,CAAC,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;QACjEiF,OAAO,EAAEtB,MAAM;QACfuB,QAAQ,EAAE;MACd,CAAC;IACL,CAAC,MACI,IAAInE,IAAI,IAAI,KAAK,EAAE;MACpB,IAAIiE,YAAU,GAAGpF,WAAW,CAACP,GAAG,EAAE6B,OAAO,CAAC;QAAEX,QAAM,GAAG0D,MAAM,CAACe,YAAU,CAAC;MACvE,IAAIG,OAAO,GAAG,EAAE;QAAEC,IAAI,GAAGlE,OAAO,IAAIA,OAAO,CAACJ,SAAS;MACrD,IAAIkE,YAAU,KAAK,CAACI,IAAI,IAAIA,IAAI,CAAC7F,IAAI,IAAI,UAAU,IAAIH,OAAO,CAACC,GAAG,EAAE+F,IAAI,CAAC,IAAIJ,YAAU,CAAC,EACpFG,OAAO,CAAC1B,IAAI,CAAClD,QAAM,GAAGA,QAAM,CAAC0B,eAAe,GAAG;QAAEF,KAAK,EAAE,IAAI,GAAGiD,YAAU,GAAG,GAAG;QAAEjE,IAAI,EAAE,MAAM;QAAEmB,KAAK,EAAE;MAAE,CAAC,CAAC;MAC9G,IAAI+C,OAAO,GAAGE,OAAO,CAACxC,MAAM,CAAC,CAAC,CAACpC,QAAM,KAAK,IAAI,IAAIA,QAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAM,CAACoB,QAAQ,MAAMT,OAAO,GAAG6C,WAAW,GAAGC,WAAW,CAAC,EAAE1B,GAAG,CAAC,UAAAuB,CAAC;QAAA,OAAIA,CAAC,CAAC7B,cAAc;MAAA,EAAC,CAAC;MACrK,IAAId,OAAO,KAAKX,QAAM,KAAK,IAAI,IAAIA,QAAM,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAM,CAAC6B,IAAI,CAACoC,MAAM,CAAC,EAAE;QACjF,IAAIa,OAAO,GAAGnE,OAAO,CAACpB,UAAU;QAChC,IAAIuF,OAAO,CAAC1F,EAAE,GAAGkF,EAAE,CAAC7E,GAAG,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC4C,IAAI,CAACiC,EAAE,CAACpE,KAAK,CAAC6E,QAAQ,CAACD,OAAO,CAAC1F,EAAE,EAAEkF,EAAE,CAAC7E,GAAG,CAAC,CAAC,EAC7EiF,OAAO,GAAGA,OAAO,CAACtC,MAAM,CAACpC,QAAM,CAAC6B,IAAI,CAAC;MAC7C;MACA,OAAO;QACH1C,IAAI,EAAJA,IAAI;QACJuF,OAAO,EAAPA,OAAO;QACPC,QAAQ,EAAE;MACd,CAAC;IACL,CAAC,MACI;MACD,OAAO,IAAI;IACf;EACJ,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAMK,WAAW,GAAG,aAAaxG,UAAU,CAACyG,MAAM,CAAC;EAC/CjG,IAAI,EAAE,KAAK;EACXV,MAAM,EAAE,aAAaA,MAAM,CAAC4G,SAAS,CAAC;IAClCC,KAAK,EAAE,CACH,aAAa1G,cAAc,CAAC2G,GAAG,CAAC;MAC5BtE,OAAO,WAAAA,QAACH,OAAO,EAAE;QACb,IAAI0E,MAAM,GAAG,SAAS,CAAChD,IAAI,CAAC1B,OAAO,CAAC2E,SAAS,CAAC;QAC9C,OAAO3E,OAAO,CAAC4E,UAAU,CAAC5E,OAAO,CAAC6E,IAAI,CAACrG,IAAI,CAAC,IAAIkG,MAAM,GAAG,CAAC,GAAG1E,OAAO,CAAC8E,IAAI,CAAC;MAC9E,CAAC;MACD,iCAAiC,WAAAC,8BAAC/E,OAAO,EAAE;QACvC,OAAOA,OAAO,CAACgF,MAAM,CAAChF,OAAO,CAAC6E,IAAI,CAACrG,IAAI,CAAC,GAAGwB,OAAO,CAAC8E,IAAI;MAC3D;IACJ,CAAC,CAAC,EACF,aAAa/G,YAAY,CAAC0G,GAAG,CAAC;MAC1BtE,OAAO,WAAAA,QAAC8E,OAAO,EAAE;QACb,IAAIC,KAAK,GAAGD,OAAO,CAACrG,UAAU;UAAEsF,IAAI,GAAGe,OAAO,CAACrF,SAAS;QACxD,IAAI,CAACsF,KAAK,IAAIA,KAAK,CAAC7G,IAAI,IAAI,SAAS,EACjC,OAAO,IAAI;QACf,OAAO;UAAEG,IAAI,EAAE0G,KAAK,CAACzG,EAAE;UAAEA,EAAE,EAAEyF,IAAI,CAAC7F,IAAI,IAAI,UAAU,GAAG6F,IAAI,CAAC1F,IAAI,GAAGyG,OAAO,CAACxG;QAAG,CAAC;MACnF;IACJ,CAAC,CAAC,EACF,aAAaT,qBAAqB,CAACyG,GAAG,CAAC;MACnC,kBAAkB,EAAE,SAAAU,gBAAAN,IAAI;QAAA,OAAIA,IAAI,CAACvG,QAAQ,CAAC,SAAS,CAAC;MAAA;IACxD,CAAC,CAAC;EAEV,CAAC,CAAC;EACF8G,YAAY,EAAE;IACVC,aAAa,EAAE;MAAEC,KAAK,EAAE;QAAEC,IAAI,EAAE,MAAM;QAAEC,KAAK,EAAE;MAAM;IAAE,CAAC;IACxDC,aAAa,EAAE;EACnB;AACJ,CAAC,CAAC;AACF;AACA;AACA;AACA;AACA,SAASC,GAAGA,CAAA,EAAY;EAAA,IAAXC,IAAI,GAAAC,SAAA,CAAAtC,MAAA,QAAAsC,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,CAAC,CAAC;EAClB,OAAO,IAAI3H,eAAe,CAACoG,WAAW,EAAEA,WAAW,CAACyB,IAAI,CAACC,EAAE,CAAC;IACxDC,YAAY,EAAErE,kBAAkB,CAACgE,IAAI,CAACM,QAAQ,IAAI,EAAE,EAAEN,IAAI,CAACvC,UAAU,IAAI,EAAE;EAC/E,CAAC,CAAC,CAAC;AACP;AAEA,SAASzB,kBAAkB,EAAE+D,GAAG,EAAErB,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}