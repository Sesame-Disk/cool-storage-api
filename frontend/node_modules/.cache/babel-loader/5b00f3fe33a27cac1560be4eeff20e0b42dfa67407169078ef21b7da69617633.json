{"ast":null,"code":"import _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport copy from 'copy-to-clipboard';\nimport { Transforms, Editor, Node } from '@seafile/slate';\nimport slugid from 'slugid';\nimport { CODE_BLOCK, CODE_LINE, INSERT_POSITION, PARAGRAPH } from '../../constants';\nimport { getNodeType, getSelectedNodeByType, getSelectedElems } from '../../core';\nimport { genCodeLangs } from './prismjs';\nimport { getCalloutEntry } from '../callout/helper';\nexport var isMenuDisabled = function isMenuDisabled(editor, readonly) {\n  if (readonly) return true;\n  var selection = editor.selection;\n  if (selection == null) return true;\n  if (getCalloutEntry(editor)) return true;\n  var selectedElems = getSelectedElems(editor);\n  var hasVoid = selectedElems.some(function (elem) {\n    return editor.isVoid(elem);\n  });\n  if (hasVoid) return true;\n  var isMatch = selectedElems.some(function (elem) {\n    var type = getNodeType(elem);\n    if (type === PARAGRAPH) return true;\n    return false;\n  });\n  if (isMatch) return false; // enable\n  return true; // disable\n};\n\nexport var getSelectCodeElem = function getSelectCodeElem(editor) {\n  var codeNode = getSelectedNodeByType(editor, CODE_BLOCK);\n  if (codeNode == null) return null;\n  return codeNode;\n};\nexport var getCodeBlockNode = function getCodeBlockNode(language) {\n  var node = {\n    id: slugid.nice(),\n    type: CODE_BLOCK,\n    language: language,\n    style: {\n      white_space: 'nowrap'\n    },\n    // default nowrap\n    children: [{\n      id: slugid.nice(),\n      type: CODE_LINE,\n      children: [{\n        text: '',\n        id: slugid.nice()\n      }]\n    }]\n  };\n  return node;\n};\nexport var changeToCodeBlock = function changeToCodeBlock(editor) {\n  var language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : INSERT_POSITION.CURRENT;\n  if (!editor.selection) return;\n  var strArr = []; // Summarizes the strings for the selected highest-level node\n  var path = Editor.path(editor, editor.selection, {\n    edge: 'start'\n  });\n  var newCodeBlockNode = getCodeBlockNode(language); // New code-block node\n\n  // Insert after\n  if (position === INSERT_POSITION.AFTER) {\n    strArr = [''];\n    newCodeBlockNode.children[0].children[0].text = strArr.join('\\n');\n    Transforms.insertNodes(editor, newCodeBlockNode, {\n      mode: 'highest',\n      at: [path[0] + 1]\n    });\n    Transforms.select(editor, [path[0] + 1, 0, 0]);\n    return;\n  }\n\n  // Insert current\n  if (position === INSERT_POSITION.CURRENT) {\n    // Select the plain text of the node\n    var nodeEntries = Editor.nodes(editor, {\n      match: function match(n) {\n        return editor.children.includes(n);\n      },\n      // Matches the selected node at the highest level\n      universal: true\n    });\n    var _iterator = _createForOfIteratorHelper(nodeEntries),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var nodeEntry = _step.value;\n        var _nodeEntry = _slicedToArray(nodeEntry, 1),\n          n = _nodeEntry[0];\n        if (n) strArr.push(Node.string(n));\n      }\n      // Deletes the selected node at the highest level\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    Transforms.removeNodes(editor, {\n      mode: 'highest'\n    });\n\n    // Modify location\n    var atPath = [path[0]];\n    var atPoint = {\n      anchor: {\n        offset: 0,\n        path: [path[0], 0, 0]\n      },\n      focus: {\n        offset: 0,\n        path: [path[0], 0, 0]\n      }\n    };\n    // Insert new node\n    newCodeBlockNode.children[0].children[0].text = strArr.join('\\n');\n    Transforms.insertNodes(editor, newCodeBlockNode, {\n      mode: 'highest',\n      at: atPath\n    });\n    queueMicrotask(function () {\n      Transforms.select(editor, atPoint);\n    });\n  }\n};\nexport var changeToPlainText = function changeToPlainText(editor) {\n  var elem = getSelectCodeElem(editor);\n  if (elem == null) return;\n\n  // Get code text\n  var str = Node.string(elem);\n\n  // Delete the highest level node, -> \"the code-block node\"\n  Transforms.removeNodes(editor, {\n    mode: 'highest'\n  });\n\n  // Insert p node\n  var pList = str.split('\\n').map(function (s) {\n    return {\n      id: elem.id,\n      type: PARAGRAPH,\n      children: [{\n        text: s,\n        id: slugid.nice()\n      }]\n    };\n  });\n  Transforms.insertNodes(editor, pList, {\n    mode: 'highest'\n  });\n};\nexport var setClipboardCodeBlockData = function setClipboardCodeBlockData(value) {\n  // Insert text into the clipboard for use on other pages\n  // Empty string cannot apply in `copy`\n  var text = value.children.map(function (line) {\n    return Node.string(line);\n  }).join('\\n') || ' ';\n  copy(text, {\n    format: 'text/plain',\n    onCopy: function onCopy(data) {\n      // Set the sdoc editor to format the data\n      data.setData('text/code-block', JSON.stringify(value));\n    }\n  });\n};\nexport var deleteBackwardByLength = function deleteBackwardByLength(editor, len) {\n  var i = len >= 4 ? 4 : len;\n  while (i > 0) {\n    Editor.deleteBackward(editor, 'word');\n    i--;\n  }\n};\nexport var getSelectedLangOption = function getSelectedLangOption(lang) {\n  var langs = genCodeLangs();\n  var selectedLangOption = langs.find(function (item) {\n    return item.value === lang;\n  });\n  return selectedLangOption || langs[0];\n};\nexport var getValidLang = function getValidLang(lang) {\n  var langOption = getSelectedLangOption(lang);\n  return langOption.value;\n};","map":{"version":3,"names":["copy","Transforms","Editor","Node","slugid","CODE_BLOCK","CODE_LINE","INSERT_POSITION","PARAGRAPH","getNodeType","getSelectedNodeByType","getSelectedElems","genCodeLangs","getCalloutEntry","isMenuDisabled","editor","readonly","selection","selectedElems","hasVoid","some","elem","isVoid","isMatch","type","getSelectCodeElem","codeNode","getCodeBlockNode","language","node","id","nice","style","white_space","children","text","changeToCodeBlock","arguments","length","undefined","position","CURRENT","strArr","path","edge","newCodeBlockNode","AFTER","join","insertNodes","mode","at","select","nodeEntries","nodes","match","n","includes","universal","_iterator","_createForOfIteratorHelper","_step","s","done","nodeEntry","value","_nodeEntry","_slicedToArray","push","string","err","e","f","removeNodes","atPath","atPoint","anchor","offset","focus","queueMicrotask","changeToPlainText","str","pList","split","map","setClipboardCodeBlockData","line","format","onCopy","data","setData","JSON","stringify","deleteBackwardByLength","len","i","deleteBackward","getSelectedLangOption","lang","langs","selectedLangOption","find","item","getValidLang","langOption"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/plugins/code-block/helpers.js"],"sourcesContent":["import copy from 'copy-to-clipboard';\nimport { Transforms, Editor, Node } from '@seafile/slate';\nimport slugid from 'slugid';\nimport { CODE_BLOCK, CODE_LINE, INSERT_POSITION, PARAGRAPH } from '../../constants';\nimport { getNodeType, getSelectedNodeByType, getSelectedElems } from '../../core';\nimport { genCodeLangs } from './prismjs';\nimport { getCalloutEntry } from '../callout/helper';\nexport const isMenuDisabled = (editor, readonly) => {\n  if (readonly) return true;\n  const {\n    selection\n  } = editor;\n  if (selection == null) return true;\n  if (getCalloutEntry(editor)) return true;\n  const selectedElems = getSelectedElems(editor);\n  const hasVoid = selectedElems.some(elem => editor.isVoid(elem));\n  if (hasVoid) return true;\n  const isMatch = selectedElems.some(elem => {\n    const type = getNodeType(elem);\n    if (type === PARAGRAPH) return true;\n    return false;\n  });\n  if (isMatch) return false; // enable\n  return true; // disable\n};\n\nexport const getSelectCodeElem = editor => {\n  const codeNode = getSelectedNodeByType(editor, CODE_BLOCK);\n  if (codeNode == null) return null;\n  return codeNode;\n};\nexport const getCodeBlockNode = language => {\n  const node = {\n    id: slugid.nice(),\n    type: CODE_BLOCK,\n    language,\n    style: {\n      white_space: 'nowrap'\n    },\n    // default nowrap\n    children: [{\n      id: slugid.nice(),\n      type: CODE_LINE,\n      children: [{\n        text: '',\n        id: slugid.nice()\n      }]\n    }]\n  };\n  return node;\n};\nexport const changeToCodeBlock = function (editor) {\n  let language = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  let position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : INSERT_POSITION.CURRENT;\n  if (!editor.selection) return;\n  let strArr = []; // Summarizes the strings for the selected highest-level node\n  const path = Editor.path(editor, editor.selection, {\n    edge: 'start'\n  });\n  const newCodeBlockNode = getCodeBlockNode(language); // New code-block node\n\n  // Insert after\n  if (position === INSERT_POSITION.AFTER) {\n    strArr = [''];\n    newCodeBlockNode.children[0].children[0].text = strArr.join('\\n');\n    Transforms.insertNodes(editor, newCodeBlockNode, {\n      mode: 'highest',\n      at: [path[0] + 1]\n    });\n    Transforms.select(editor, [path[0] + 1, 0, 0]);\n    return;\n  }\n\n  // Insert current\n  if (position === INSERT_POSITION.CURRENT) {\n    // Select the plain text of the node\n    const nodeEntries = Editor.nodes(editor, {\n      match: n => editor.children.includes(n),\n      // Matches the selected node at the highest level\n      universal: true\n    });\n    for (let nodeEntry of nodeEntries) {\n      const [n] = nodeEntry;\n      if (n) strArr.push(Node.string(n));\n    }\n    // Deletes the selected node at the highest level\n    Transforms.removeNodes(editor, {\n      mode: 'highest'\n    });\n\n    // Modify location\n    const atPath = [path[0]];\n    const atPoint = {\n      anchor: {\n        offset: 0,\n        path: [path[0], 0, 0]\n      },\n      focus: {\n        offset: 0,\n        path: [path[0], 0, 0]\n      }\n    };\n    // Insert new node\n    newCodeBlockNode.children[0].children[0].text = strArr.join('\\n');\n    Transforms.insertNodes(editor, newCodeBlockNode, {\n      mode: 'highest',\n      at: atPath\n    });\n    queueMicrotask(() => {\n      Transforms.select(editor, atPoint);\n    });\n  }\n};\nexport const changeToPlainText = editor => {\n  const elem = getSelectCodeElem(editor);\n  if (elem == null) return;\n\n  // Get code text\n  const str = Node.string(elem);\n\n  // Delete the highest level node, -> \"the code-block node\"\n  Transforms.removeNodes(editor, {\n    mode: 'highest'\n  });\n\n  // Insert p node\n  const pList = str.split('\\n').map(s => {\n    return {\n      id: elem.id,\n      type: PARAGRAPH,\n      children: [{\n        text: s,\n        id: slugid.nice()\n      }]\n    };\n  });\n  Transforms.insertNodes(editor, pList, {\n    mode: 'highest'\n  });\n};\nexport const setClipboardCodeBlockData = value => {\n  // Insert text into the clipboard for use on other pages\n  // Empty string cannot apply in `copy`\n  const text = value.children.map(line => Node.string(line)).join('\\n') || ' ';\n  copy(text, {\n    format: 'text/plain',\n    onCopy: data => {\n      // Set the sdoc editor to format the data\n      data.setData('text/code-block', JSON.stringify(value));\n    }\n  });\n};\nexport const deleteBackwardByLength = (editor, len) => {\n  let i = len >= 4 ? 4 : len;\n  while (i > 0) {\n    Editor.deleteBackward(editor, 'word');\n    i--;\n  }\n};\nexport const getSelectedLangOption = lang => {\n  const langs = genCodeLangs();\n  const selectedLangOption = langs.find(item => item.value === lang);\n  return selectedLangOption || langs[0];\n};\nexport const getValidLang = lang => {\n  const langOption = getSelectedLangOption(lang);\n  return langOption.value;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}