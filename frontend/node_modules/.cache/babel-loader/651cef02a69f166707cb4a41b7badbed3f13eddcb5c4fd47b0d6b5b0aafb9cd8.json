{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport { Editor, Transforms, Range } from '@seafile/slate';\nimport { toggleList } from '../list/transforms';\nimport { getSelectedNodeByType } from '../../core';\nimport { HEADER1, HEADER2, HEADER3, HEADER4, HEADER5, HEADER6, UNORDERED_LIST, BLOCKQUOTE, TEXT_STYLE_MAP, PARAGRAPH } from '../../constants';\nimport { setBlockQuoteType } from '../blockquote/helpers';\nimport { COMMENT_EDITOR } from '../../../constants';\n\n// Title shortcut\nvar TITLE_SHORT_CUT = {\n  '#': HEADER1,\n  '##': HEADER2,\n  '###': HEADER3,\n  '####': HEADER4,\n  '#####': HEADER5,\n  '######': HEADER6\n};\n\n// List shortcut\nvar LIST_SHORT_CUT = {\n  '*': UNORDERED_LIST,\n  '-': UNORDERED_LIST\n};\n\n// Reference shortcut key\nvar REFERENCE_SHORT_CUT = {\n  '>': BLOCKQUOTE\n};\nvar KEY_TO_TYPE_FOR_SPACE_DEFAULT_EDITOR = _objectSpread(_objectSpread(_objectSpread({}, TITLE_SHORT_CUT), LIST_SHORT_CUT), REFERENCE_SHORT_CUT);\nvar KEY_TO_TYPE_FOR_SPACE_COMMENT_EDITOR = _objectSpread({}, LIST_SHORT_CUT);\nvar KEY_TO_INLINE_TYPE_FOR_SPACE = {\n  // Inline shortcut keys\n  '**': TEXT_STYLE_MAP.BOLD,\n  '*': TEXT_STYLE_MAP.ITALIC,\n  '***': TEXT_STYLE_MAP.BOLD_ITALIC\n};\nvar getBeforeText = function getBeforeText(editor) {\n  var selection = editor.selection;\n  if (selection == null) return {\n    beforeText: '',\n    range: null\n  };\n  var anchor = selection.anchor,\n    focus = selection.focus;\n  var range = {\n    anchor: anchor,\n    focus: {\n      path: focus.path,\n      offset: 0\n    }\n  };\n  var beforeText = Editor.string(editor, range) || '';\n  return {\n    beforeText: beforeText,\n    range: range\n  };\n};\nvar withMarkDown = function withMarkDown(editor) {\n  var insertText = editor.insertText;\n  var newEditor = editor;\n  var KEY_TO_TYPE_FOR_SPACE = newEditor.editorType === COMMENT_EDITOR ? KEY_TO_TYPE_FOR_SPACE_COMMENT_EDITOR : KEY_TO_TYPE_FOR_SPACE_DEFAULT_EDITOR;\n\n  // When entering a space, convert markdown\n  newEditor.insertText = function (text) {\n    var selection = editor.selection;\n    if (selection == null) return insertText(text);\n    if (Range.isExpanded(selection)) return insertText(text);\n    if (getSelectedNodeByType(editor, PARAGRAPH) == null) return insertText(text); // It must be in paragraph\n    if (text !== ' ') return insertText(text); // The value must be an input space\n\n    // Gets the text before the space\n    var _getBeforeText = getBeforeText(editor),\n      beforeText = _getBeforeText.beforeText,\n      range = _getBeforeText.range;\n    if (!beforeText || !range) return insertText(text);\n\n    // Based on the keyword, find the type of element you want to convert\n    var type = KEY_TO_TYPE_FOR_SPACE[beforeText.trim()];\n    var italicAndBoldType = KEY_TO_INLINE_TYPE_FOR_SPACE[beforeText.slice(-3)];\n    var boldType = KEY_TO_INLINE_TYPE_FOR_SPACE[beforeText.slice(-2)];\n    var italicType = KEY_TO_INLINE_TYPE_FOR_SPACE[beforeText.slice(-1)];\n    if (!type && !boldType && !italicType && !italicAndBoldType) return insertText(text);\n    if (italicAndBoldType === TEXT_STYLE_MAP.BOLD_ITALIC) {\n      var restStr = beforeText === null || beforeText === void 0 ? void 0 : beforeText.slice(0, beforeText.length - 3);\n      var startOffset = restStr === null || restStr === void 0 ? void 0 : restStr.lastIndexOf('***');\n      var endOffset = (beforeText === null || beforeText === void 0 ? void 0 : beforeText.lastIndexOf('***')) + 3;\n      if (startOffset !== -3) {\n        Transforms.delete(editor, {\n          at: {\n            anchor: {\n              path: range.focus.path,\n              offset: startOffset\n            },\n            focus: _objectSpread({}, selection.focus)\n          },\n          voids: true\n        });\n        var newText = beforeText.slice(startOffset + 3, endOffset - 3);\n        Editor.addMark(editor, TEXT_STYLE_MAP.BOLD, true);\n        Editor.addMark(editor, TEXT_STYLE_MAP.ITALIC, true);\n        return insertText(newText);\n      }\n    }\n    if (boldType === TEXT_STYLE_MAP.BOLD) {\n      var _restStr = beforeText.slice(0, beforeText.length - 2);\n      var _startOffset = _restStr.lastIndexOf('**');\n      var _endOffset = beforeText.lastIndexOf('**') + 2;\n      if (_startOffset === -1) {\n        return insertText(text);\n      }\n      Transforms.delete(editor, {\n        at: {\n          anchor: {\n            path: range.focus.path,\n            offset: _startOffset\n          },\n          focus: _objectSpread({}, selection.focus)\n        },\n        voids: true\n      });\n      var newType = boldType.toLowerCase();\n      var _newText = beforeText.slice(_startOffset + 2, _endOffset - 2);\n      Editor.addMark(editor, newType, true);\n      return insertText(_newText);\n    }\n\n    // demos\n    // 1 '*'\n    // 2 'acd * add *'\n    if (italicType === TEXT_STYLE_MAP.ITALIC) {\n      var _restStr2 = beforeText === null || beforeText === void 0 ? void 0 : beforeText.slice(0, beforeText.length - 1);\n      var _startOffset2 = _restStr2 === null || _restStr2 === void 0 ? void 0 : _restStr2.lastIndexOf('*');\n      var _endOffset2 = (beforeText === null || beforeText === void 0 ? void 0 : beforeText.lastIndexOf('*')) + 1;\n      if (_startOffset2 === -1 && _restStr2.length > 0) {\n        return insertText(text);\n      }\n      if (_startOffset2 !== -1) {\n        Transforms.delete(editor, {\n          at: {\n            anchor: {\n              path: range.focus.path,\n              offset: _startOffset2\n            },\n            focus: _objectSpread({}, selection.focus)\n          },\n          voids: true\n        });\n        var _newType = italicType.toLowerCase();\n        var _newText2 = beforeText.slice(_startOffset2 + 1, _endOffset2 - 1);\n        Editor.addMark(editor, _newType, true);\n        return insertText(_newText2);\n      }\n    }\n\n    // Delete element\n    Transforms.select(editor, range);\n    Transforms.delete(editor);\n    if (type === UNORDERED_LIST) {\n      toggleList(editor, type);\n      return;\n    }\n    if (type === BLOCKQUOTE) {\n      setBlockQuoteType(editor, false);\n      return;\n    }\n    Transforms.setNodes(editor, {\n      type: type\n    });\n  };\n  return newEditor;\n};\nexport default withMarkDown;","map":{"version":3,"names":["_objectSpread","Editor","Transforms","Range","toggleList","getSelectedNodeByType","HEADER1","HEADER2","HEADER3","HEADER4","HEADER5","HEADER6","UNORDERED_LIST","BLOCKQUOTE","TEXT_STYLE_MAP","PARAGRAPH","setBlockQuoteType","COMMENT_EDITOR","TITLE_SHORT_CUT","LIST_SHORT_CUT","REFERENCE_SHORT_CUT","KEY_TO_TYPE_FOR_SPACE_DEFAULT_EDITOR","KEY_TO_TYPE_FOR_SPACE_COMMENT_EDITOR","KEY_TO_INLINE_TYPE_FOR_SPACE","BOLD","ITALIC","BOLD_ITALIC","getBeforeText","editor","selection","beforeText","range","anchor","focus","path","offset","string","withMarkDown","insertText","newEditor","KEY_TO_TYPE_FOR_SPACE","editorType","text","isExpanded","_getBeforeText","type","trim","italicAndBoldType","slice","boldType","italicType","restStr","length","startOffset","lastIndexOf","endOffset","delete","at","voids","newText","addMark","newType","toLowerCase","select","setNodes"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/plugins/markdown/plugin.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport { Editor, Transforms, Range } from '@seafile/slate';\nimport { toggleList } from '../list/transforms';\nimport { getSelectedNodeByType } from '../../core';\nimport { HEADER1, HEADER2, HEADER3, HEADER4, HEADER5, HEADER6, UNORDERED_LIST, BLOCKQUOTE, TEXT_STYLE_MAP, PARAGRAPH } from '../../constants';\nimport { setBlockQuoteType } from '../blockquote/helpers';\nimport { COMMENT_EDITOR } from '../../../constants';\n\n// Title shortcut\nconst TITLE_SHORT_CUT = {\n  '#': HEADER1,\n  '##': HEADER2,\n  '###': HEADER3,\n  '####': HEADER4,\n  '#####': HEADER5,\n  '######': HEADER6\n};\n\n// List shortcut\nconst LIST_SHORT_CUT = {\n  '*': UNORDERED_LIST,\n  '-': UNORDERED_LIST\n};\n\n// Reference shortcut key\nconst REFERENCE_SHORT_CUT = {\n  '>': BLOCKQUOTE\n};\nconst KEY_TO_TYPE_FOR_SPACE_DEFAULT_EDITOR = _objectSpread(_objectSpread(_objectSpread({}, TITLE_SHORT_CUT), LIST_SHORT_CUT), REFERENCE_SHORT_CUT);\nconst KEY_TO_TYPE_FOR_SPACE_COMMENT_EDITOR = _objectSpread({}, LIST_SHORT_CUT);\nconst KEY_TO_INLINE_TYPE_FOR_SPACE = {\n  // Inline shortcut keys\n  '**': TEXT_STYLE_MAP.BOLD,\n  '*': TEXT_STYLE_MAP.ITALIC,\n  '***': TEXT_STYLE_MAP.BOLD_ITALIC\n};\nconst getBeforeText = editor => {\n  const {\n    selection\n  } = editor;\n  if (selection == null) return {\n    beforeText: '',\n    range: null\n  };\n  const {\n    anchor,\n    focus\n  } = selection;\n  const range = {\n    anchor,\n    focus: {\n      path: focus.path,\n      offset: 0\n    }\n  };\n  const beforeText = Editor.string(editor, range) || '';\n  return {\n    beforeText,\n    range\n  };\n};\nconst withMarkDown = editor => {\n  const {\n    insertText\n  } = editor;\n  const newEditor = editor;\n  const KEY_TO_TYPE_FOR_SPACE = newEditor.editorType === COMMENT_EDITOR ? KEY_TO_TYPE_FOR_SPACE_COMMENT_EDITOR : KEY_TO_TYPE_FOR_SPACE_DEFAULT_EDITOR;\n\n  // When entering a space, convert markdown\n  newEditor.insertText = text => {\n    const {\n      selection\n    } = editor;\n    if (selection == null) return insertText(text);\n    if (Range.isExpanded(selection)) return insertText(text);\n    if (getSelectedNodeByType(editor, PARAGRAPH) == null) return insertText(text); // It must be in paragraph\n    if (text !== ' ') return insertText(text); // The value must be an input space\n\n    // Gets the text before the space\n    const {\n      beforeText,\n      range\n    } = getBeforeText(editor);\n    if (!beforeText || !range) return insertText(text);\n\n    // Based on the keyword, find the type of element you want to convert\n    const type = KEY_TO_TYPE_FOR_SPACE[beforeText.trim()];\n    const italicAndBoldType = KEY_TO_INLINE_TYPE_FOR_SPACE[beforeText.slice(-3)];\n    const boldType = KEY_TO_INLINE_TYPE_FOR_SPACE[beforeText.slice(-2)];\n    const italicType = KEY_TO_INLINE_TYPE_FOR_SPACE[beforeText.slice(-1)];\n    if (!type && !boldType && !italicType && !italicAndBoldType) return insertText(text);\n    if (italicAndBoldType === TEXT_STYLE_MAP.BOLD_ITALIC) {\n      const restStr = beforeText === null || beforeText === void 0 ? void 0 : beforeText.slice(0, beforeText.length - 3);\n      const startOffset = restStr === null || restStr === void 0 ? void 0 : restStr.lastIndexOf('***');\n      const endOffset = (beforeText === null || beforeText === void 0 ? void 0 : beforeText.lastIndexOf('***')) + 3;\n      if (startOffset !== -3) {\n        Transforms.delete(editor, {\n          at: {\n            anchor: {\n              path: range.focus.path,\n              offset: startOffset\n            },\n            focus: _objectSpread({}, selection.focus)\n          },\n          voids: true\n        });\n        const newText = beforeText.slice(startOffset + 3, endOffset - 3);\n        Editor.addMark(editor, TEXT_STYLE_MAP.BOLD, true);\n        Editor.addMark(editor, TEXT_STYLE_MAP.ITALIC, true);\n        return insertText(newText);\n      }\n    }\n    if (boldType === TEXT_STYLE_MAP.BOLD) {\n      const restStr = beforeText.slice(0, beforeText.length - 2);\n      const startOffset = restStr.lastIndexOf('**');\n      const endOffset = beforeText.lastIndexOf('**') + 2;\n      if (startOffset === -1) {\n        return insertText(text);\n      }\n      Transforms.delete(editor, {\n        at: {\n          anchor: {\n            path: range.focus.path,\n            offset: startOffset\n          },\n          focus: _objectSpread({}, selection.focus)\n        },\n        voids: true\n      });\n      const newType = boldType.toLowerCase();\n      const newText = beforeText.slice(startOffset + 2, endOffset - 2);\n      Editor.addMark(editor, newType, true);\n      return insertText(newText);\n    }\n\n    // demos\n    // 1 '*'\n    // 2 'acd * add *'\n    if (italicType === TEXT_STYLE_MAP.ITALIC) {\n      const restStr = beforeText === null || beforeText === void 0 ? void 0 : beforeText.slice(0, beforeText.length - 1);\n      const startOffset = restStr === null || restStr === void 0 ? void 0 : restStr.lastIndexOf('*');\n      const endOffset = (beforeText === null || beforeText === void 0 ? void 0 : beforeText.lastIndexOf('*')) + 1;\n      if (startOffset === -1 && restStr.length > 0) {\n        return insertText(text);\n      }\n      if (startOffset !== -1) {\n        Transforms.delete(editor, {\n          at: {\n            anchor: {\n              path: range.focus.path,\n              offset: startOffset\n            },\n            focus: _objectSpread({}, selection.focus)\n          },\n          voids: true\n        });\n        const newType = italicType.toLowerCase();\n        const newText = beforeText.slice(startOffset + 1, endOffset - 1);\n        Editor.addMark(editor, newType, true);\n        return insertText(newText);\n      }\n    }\n\n    // Delete element\n    Transforms.select(editor, range);\n    Transforms.delete(editor);\n    if (type === UNORDERED_LIST) {\n      toggleList(editor, type);\n      return;\n    }\n    if (type === BLOCKQUOTE) {\n      setBlockQuoteType(editor, false);\n      return;\n    }\n    Transforms.setNodes(editor, {\n      type\n    });\n  };\n  return newEditor;\n};\nexport default withMarkDown;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}