{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _defineProperty = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _slicedToArray = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removeTable = exports.removeRow = exports.removeColumn = exports.insertTableElement = exports.insertRow = exports.insertColumn = exports.changeColumnAlign = void 0;\nvar _slate = require(\"slate\");\nvar _constants = require(\"../../constants\");\nvar _helper = require(\"./helper\");\nvar _model = require(\"./model\");\nvar _core = require(\"../../core\");\nvar _constant = require(\"./constant\");\nvar _elementTypes = require(\"../../constants/element-types\");\n/**\n * @param {Object} editor\n * @param {INSERT_POSITION.AFTER | INSERT_POSITION.BEFORE} insertPosition by default is INSERT_POSITION.AFTER\n */\nvar insertRow = function insertRow(editor) {\n  var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.INSERT_POSITION.AFTER;\n  var _ref2 = (0, _helper.getTableFocusingInfos)(editor),\n    _ref2$tableEntry = _slicedToArray(_ref2.tableEntry, 2),\n    tablePath = _ref2$tableEntry[1],\n    _ref2$rowEntry = _slicedToArray(_ref2.rowEntry, 1),\n    rowNode = _ref2$rowEntry[0],\n    rowIndex = _ref2.rowIndex;\n  var getInsertPath = function getInsertPath(rowIndex) {\n    var _handlePosition;\n    var handlePosition = (_handlePosition = {}, _defineProperty(_handlePosition, _constants.INSERT_POSITION.BEFORE, function (rowIndex) {\n      return tablePath.concat(rowIndex);\n    }), _defineProperty(_handlePosition, _constants.INSERT_POSITION.AFTER, function (rowIndex) {\n      return tablePath.concat(rowIndex + 1);\n    }), _handlePosition);\n    return handlePosition[position](rowIndex);\n  };\n  var insertPath = getInsertPath(rowIndex);\n  var insertRowChildren = rowNode.children.map(function (_ref) {\n    var align = _ref.align;\n    return (0, _model.generateTableCell)({\n      align: align\n    });\n  });\n  var insertRow = (0, _model.generateTableRow)({\n    childrenOrText: insertRowChildren\n  });\n  _slate.Transforms.insertNodes(editor, insertRow, {\n    at: insertPath\n  });\n};\nexports.insertRow = insertRow;\nvar removeRow = function removeRow(editor) {\n  var isSelectMultipleTable = (0, _helper.isSelectingMultipleTables)(editor);\n  if (isSelectMultipleTable) return;\n  var selectInfo = (0, _helper.getSelectGrid)(editor);\n  var _ref3 = (0, _helper.getTableEntry)(editor),\n    _ref4 = _slicedToArray(_ref3, 1),\n    tableEntry = _ref4[0];\n  if (!tableEntry) return;\n  if (selectInfo) {\n    var startRowIndex = selectInfo.startRowIndex,\n      endRowIndex = selectInfo.endRowIndex;\n    var _tableEntry = _slicedToArray(tableEntry, 2),\n      table = _tableEntry[0],\n      _tablePath = _tableEntry[1];\n    var tableRowCount = table.children.length;\n\n    // Remove all rows\n    if (startRowIndex === 0 && endRowIndex === tableRowCount - 1) return removeTable(editor);\n    for (var index = endRowIndex; index >= startRowIndex; index--) {\n      var _rowPath = _tablePath.concat(index);\n      _slate.Transforms.removeNodes(editor, {\n        at: _rowPath\n      });\n    }\n    var _focusPoint = _slate.Editor.start(editor, tableEntry[1].concat(startRowIndex - 1 < 0 ? 0 : startRowIndex - 1));\n    (0, _core.focusEditor)(editor, _focusPoint);\n    return;\n  }\n  var _ref5 = (0, _helper.getTableFocusingInfos)(editor),\n    _ref5$tableEntry = _slicedToArray(_ref5.tableEntry, 2),\n    tableNode = _ref5$tableEntry[0],\n    tablePath = _ref5$tableEntry[1],\n    _ref5$rowEntry = _slicedToArray(_ref5.rowEntry, 2),\n    rowPath = _ref5$rowEntry[1],\n    rowIndex = _ref5.rowIndex;\n  var focusPoint = null;\n  var tableHeight = tableNode.children.length;\n  // If table has one more row, remove row, else remove table\n  if (tableHeight > 1) {\n    // If removing row is the last row, focus on the previous row\n    var isRemovingLastRow = rowIndex === tableHeight - 1;\n    focusPoint = isRemovingLastRow ? _slate.Editor.start(editor, tablePath.concat(rowIndex - 1)) : _slate.Editor.start(editor, rowPath);\n    _slate.Transforms.removeNodes(editor, {\n      at: rowPath\n    });\n    (0, _core.focusEditor)(editor, focusPoint);\n  } else {\n    return removeTable(editor);\n  }\n};\nexports.removeRow = removeRow;\nvar removeTable = function removeTable(editor) {\n  var _ref6 = (0, _helper.getTableEntry)(editor),\n    _ref7 = _slicedToArray(_ref6, 1),\n    tableNodeEntry = _ref7[0];\n  if (!tableNodeEntry) return;\n  var _tableNodeEntry = _slicedToArray(tableNodeEntry, 2),\n    table = _tableNodeEntry[0],\n    tablePath = _tableNodeEntry[1];\n  var isLast = (0, _core.isLastNode)(editor, table);\n  if (isLast) {\n    var paragraph = (0, _core.generateDefaultParagraph)();\n    _slate.Transforms.removeNodes(editor, {\n      at: tablePath\n    });\n    _slate.Transforms.insertNodes(editor, paragraph, {\n      at: tablePath\n    });\n    var _focusPoint2 = _slate.Editor.start(editor, tablePath);\n    (0, _core.focusEditor)(editor, _focusPoint2);\n    return;\n  }\n  var focusPoint = _slate.Editor.start(editor, tablePath[1]);\n  _slate.Transforms.removeNodes(editor, {\n    at: tablePath\n  });\n  (0, _core.focusEditor)(editor, focusPoint);\n};\n\n/**\n * @param {Object} editor\n * @param {INSERT_POSITION.AFTER | INSERT_POSITION.BEFORE} insertPosition by default is INSERT_POSITION.AFTER\n */\nexports.removeTable = removeTable;\nvar insertColumn = function insertColumn(editor) {\n  var insertPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.INSERT_POSITION.AFTER;\n  var _ref8 = (0, _helper.getTableFocusingInfos)(editor),\n    _ref8$tableEntry = _slicedToArray(_ref8.tableEntry, 2),\n    tableNode = _ref8$tableEntry[0],\n    tablePath = _ref8$tableEntry[1],\n    rowIndex = _ref8.rowIndex,\n    columnIndex = _ref8.columnIndex;\n  var getInsertPath = function getInsertPath(rowIndex, columnIndex) {\n    var _newCellPath;\n    var newCellPath = (_newCellPath = {}, _defineProperty(_newCellPath, _constants.INSERT_POSITION.BEFORE, function (rowIndex, columnIndex) {\n      return tablePath.concat(rowIndex, columnIndex);\n    }), _defineProperty(_newCellPath, _constants.INSERT_POSITION.AFTER, function (rowIndex, columnIndex) {\n      return tablePath.concat(rowIndex, columnIndex + 1);\n    }), _newCellPath);\n    return newCellPath[insertPosition](rowIndex, columnIndex);\n  };\n  tableNode.children.forEach(function (row, rowIndex) {\n    var insertPath = getInsertPath(rowIndex, columnIndex);\n    var newCell = (0, _model.generateTableCell)(rowIndex, columnIndex);\n    _slate.Transforms.insertNodes(editor, newCell, {\n      at: insertPath\n    });\n  });\n  var align = _toConsumableArray(tableNode.align);\n  var insertAlgin = insertPosition === _constants.INSERT_POSITION.BEFORE ? columnIndex : columnIndex + 1;\n  align.splice(insertAlgin, 0, _constants.TEXT_ALIGN.LEFT);\n  _slate.Transforms.setNodes(editor, {\n    align: align\n  }, {\n    at: tablePath\n  });\n  var focusPoint = _slate.Editor.start(editor, getInsertPath(rowIndex, columnIndex));\n  (0, _core.focusEditor)(editor, focusPoint);\n};\nexports.insertColumn = insertColumn;\nvar removeColumn = function removeColumn(editor) {\n  var isSelectMultipleTable = (0, _helper.isSelectingMultipleTables)(editor);\n  if (isSelectMultipleTable) return;\n  var selectInfos = (0, _helper.getSelectGrid)(editor);\n  var _ref9 = (0, _helper.getTableEntry)(editor),\n    _ref10 = _slicedToArray(_ref9, 1),\n    tableEntry = _ref10[0];\n  if (!tableEntry) return;\n  if (selectInfos) {\n    var startColIndex = selectInfos.startColIndex,\n      endColIndex = selectInfos.endColIndex;\n    var _tableEntry2 = _slicedToArray(tableEntry, 2),\n      table = _tableEntry2[0],\n      _tablePath2 = _tableEntry2[1];\n    var tableRowCount = table.children.length;\n    var tableColumnCount = table.children[0].children.length;\n\n    // Remove all columns\n    if (startColIndex === 0 && endColIndex === tableColumnCount - 1) return removeTable(editor);\n    for (var rowIndex = 0; rowIndex < tableRowCount; rowIndex++) {\n      for (var colIndex = endColIndex; colIndex >= startColIndex; colIndex--) {\n        var cellPath = _tablePath2.concat(rowIndex, colIndex);\n        _slate.Transforms.removeNodes(editor, {\n          at: cellPath\n        });\n      }\n    }\n    var _focusPoint3 = _slate.Editor.start(editor, _tablePath2.concat(0, startColIndex - 1 < 0 ? 0 : startColIndex - 1));\n    (0, _core.focusEditor)(editor, _focusPoint3);\n    return;\n  }\n  var _ref11 = (0, _helper.getTableFocusingInfos)(editor),\n    _ref11$tableEntry = _slicedToArray(_ref11.tableEntry, 2),\n    tableNode = _ref11$tableEntry[0],\n    tablePath = _ref11$tableEntry[1],\n    _ref11$rowEntry = _slicedToArray(_ref11.rowEntry, 2),\n    rowNode = _ref11$rowEntry[0],\n    rowPath = _ref11$rowEntry[1],\n    columnIndex = _ref11.columnIndex;\n  var tableWidth = rowNode.children.length;\n  var focusPoint = null;\n\n  // If table has one more column, remove column, else remove table\n  if (tableWidth > 1) {\n    // If removing column is the last column, focus on the previous column\n    var isRemovingLastColumn = columnIndex === tableWidth - 1;\n    tableNode.children.forEach(function (row, rowIndex) {\n      var removePath = tablePath.concat(rowIndex, columnIndex);\n      _slate.Transforms.removeNodes(editor, {\n        at: removePath\n      });\n    });\n\n    // Update columns\n    var align = _toConsumableArray(tableNode.align);\n    align.splice(columnIndex, 1);\n    _slate.Transforms.setNodes(editor, {\n      align: align\n    }, {\n      at: tablePath\n    });\n    focusPoint = isRemovingLastColumn ? _slate.Editor.start(editor, rowPath.concat(columnIndex - 1)) : _slate.Editor.start(editor, rowPath.concat(columnIndex));\n    (0, _core.focusEditor)(editor, focusPoint);\n  } else {\n    removeTable(editor);\n  }\n};\n\n/**\n * @param {Object} editor\n * @param {keyof TEXT_ALIGN} align Text align\n */\nexports.removeColumn = removeColumn;\nvar changeColumnAlign = function changeColumnAlign(editor, alignType) {\n  var _ref12 = (0, _helper.getTableFocusingInfos)(editor),\n    _ref12$tableEntry = _slicedToArray(_ref12.tableEntry, 2),\n    table = _ref12$tableEntry[0],\n    tablePath = _ref12$tableEntry[1],\n    columnIndex = _ref12.columnIndex;\n  var selectGrid = (0, _helper.getSelectGrid)(editor);\n  var align = _toConsumableArray(table.align);\n\n  // If select a range in table\n  if (selectGrid) {\n    var startColIndex = selectGrid.startColIndex,\n      endColIndex = selectGrid.endColIndex;\n    for (var _columnIndex = startColIndex; _columnIndex <= endColIndex; _columnIndex++) {\n      align.splice(_columnIndex, _columnIndex, alignType);\n    }\n  } else {\n    // If select a cell in table\n    align.splice(columnIndex, columnIndex, alignType);\n  }\n  _slate.Transforms.setNodes(editor, {\n    align: align\n  }, {\n    at: tablePath\n  });\n};\nexports.changeColumnAlign = changeColumnAlign;\nvar insertTableElement = function insertTableElement(editor, type) {\n  var position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _constant.TABLE_ELEMENT_POSITION.AFTER;\n  var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var _ref13 = (0, _helper.getTableEntry)(editor),\n    _ref14 = _slicedToArray(_ref13, 1),\n    tableEntry = _ref14[0];\n  if (!tableEntry) return;\n  var selectedInfo = (0, _helper.getSelectGrid)(editor);\n  if (!selectedInfo) {\n    var tableCellEntry = (0, _core.getSelectedNodeEntryByType)(editor, _elementTypes.TABLE_CELL);\n    var cellPath = tableCellEntry[1];\n    var rowPath = cellPath.slice(0, cellPath.length - 1);\n    selectedInfo = {\n      endRowIndex: rowPath.pop(),\n      endColIndex: cellPath.pop()\n    };\n  }\n  var _tableEntry3 = _slicedToArray(tableEntry, 2),\n    tableNode = _tableEntry3[0],\n    tablePath = _tableEntry3[1];\n  var tableRows = tableNode.children;\n  var tableRowsLength = tableRows.length;\n  var tableColumnLength = tableRows[0].children.length;\n  var _selectedInfo = selectedInfo,\n    endRowIndex = _selectedInfo.endRowIndex,\n    endColIndex = _selectedInfo.endColIndex;\n  if (type === _constant.TABLE_ELEMENT.ROW) {\n    if (tableRowsLength >= _constant.TABLE_MAX_ROWS) return;\n    var targetPath = position === _constant.TABLE_ELEMENT_POSITION.AFTER ? [].concat(_toConsumableArray(tablePath), [endRowIndex + 1]) : [].concat(_toConsumableArray(tablePath), [endRowIndex]);\n    var validCount = Math.min(_constant.TABLE_MAX_ROWS - tableRowsLength, count);\n    for (var i = 0; i < validCount; i++) {\n      var row = (0, _model.generateTableRow)({\n        columnNum: tableColumnLength\n      });\n      _slate.Transforms.insertNodes(editor, row, {\n        at: targetPath\n      });\n    }\n    setTimeout(function () {\n      var oldRowIndex = position === _constant.TABLE_ELEMENT_POSITION.AFTER ? endRowIndex : endRowIndex + validCount;\n      var focusPath = [].concat(_toConsumableArray(tablePath), [oldRowIndex, endColIndex]);\n      (0, _core.focusEditor)(editor, focusPath);\n      _slate.Transforms.collapse(editor, {\n        edge: 'end'\n      });\n    });\n    return;\n  }\n  if (type === _constant.TABLE_ELEMENT.COLUMN) {\n    if (tableColumnLength >= _constant.TABLE_MAX_COLUMNS) return;\n    var newCellIndex = position === _constant.TABLE_ELEMENT_POSITION.AFTER ? endColIndex + 1 : endColIndex;\n    var _validCount = Math.min(_constant.TABLE_MAX_COLUMNS - tableColumnLength, count);\n    for (var j = 0; j < _validCount; j++) {\n      for (var _i = 0; _i < tableRowsLength; _i++) {\n        var newCellPath = [].concat(_toConsumableArray(tablePath), [_i, newCellIndex]);\n        var newCell = (0, _model.generateTableCell)();\n        _slate.Transforms.insertNodes(editor, newCell, {\n          at: newCellPath\n        });\n      }\n    }\n    setTimeout(function () {\n      var oldCellIndex = position === _constant.TABLE_ELEMENT_POSITION.AFTER ? endColIndex : endColIndex + _validCount;\n      var focusPath = [].concat(_toConsumableArray(tablePath), [endRowIndex, oldCellIndex, 0]);\n      (0, _core.focusEditor)(editor, focusPath);\n      _slate.Transforms.collapse(editor, {\n        edge: 'end'\n      });\n    });\n    return;\n  }\n};\nexports.insertTableElement = insertTableElement;","map":{"version":3,"names":["_toConsumableArray","require","default","_defineProperty","_slicedToArray","Object","defineProperty","exports","value","removeTable","removeRow","removeColumn","insertTableElement","insertRow","insertColumn","changeColumnAlign","_slate","_constants","_helper","_model","_core","_constant","_elementTypes","editor","position","arguments","length","undefined","INSERT_POSITION","AFTER","_ref2","getTableFocusingInfos","_ref2$tableEntry","tableEntry","tablePath","_ref2$rowEntry","rowEntry","rowNode","rowIndex","getInsertPath","_handlePosition","handlePosition","BEFORE","concat","insertPath","insertRowChildren","children","map","_ref","align","generateTableCell","generateTableRow","childrenOrText","Transforms","insertNodes","at","isSelectMultipleTable","isSelectingMultipleTables","selectInfo","getSelectGrid","_ref3","getTableEntry","_ref4","startRowIndex","endRowIndex","_tableEntry","table","tableRowCount","index","rowPath","removeNodes","focusPoint","Editor","start","focusEditor","_ref5","_ref5$tableEntry","tableNode","_ref5$rowEntry","tableHeight","isRemovingLastRow","_ref6","_ref7","tableNodeEntry","_tableNodeEntry","isLast","isLastNode","paragraph","generateDefaultParagraph","insertPosition","_ref8","_ref8$tableEntry","columnIndex","_newCellPath","newCellPath","forEach","row","newCell","insertAlgin","splice","TEXT_ALIGN","LEFT","setNodes","selectInfos","_ref9","_ref10","startColIndex","endColIndex","_tableEntry2","tableColumnCount","colIndex","cellPath","_ref11","_ref11$tableEntry","_ref11$rowEntry","tableWidth","isRemovingLastColumn","removePath","alignType","_ref12","_ref12$tableEntry","selectGrid","type","TABLE_ELEMENT_POSITION","count","_ref13","_ref14","selectedInfo","tableCellEntry","getSelectedNodeEntryByType","TABLE_CELL","slice","pop","_tableEntry3","tableRows","tableRowsLength","tableColumnLength","_selectedInfo","TABLE_ELEMENT","ROW","TABLE_MAX_ROWS","targetPath","validCount","Math","min","i","columnNum","setTimeout","oldRowIndex","focusPath","collapse","edge","COLUMN","TABLE_MAX_COLUMNS","newCellIndex","j","oldCellIndex"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/seafile-editor/dist/extension/plugins/table/table-operations.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removeTable = exports.removeRow = exports.removeColumn = exports.insertTableElement = exports.insertRow = exports.insertColumn = exports.changeColumnAlign = void 0;\nvar _slate = require(\"slate\");\nvar _constants = require(\"../../constants\");\nvar _helper = require(\"./helper\");\nvar _model = require(\"./model\");\nvar _core = require(\"../../core\");\nvar _constant = require(\"./constant\");\nvar _elementTypes = require(\"../../constants/element-types\");\n/**\n * @param {Object} editor\n * @param {INSERT_POSITION.AFTER | INSERT_POSITION.BEFORE} insertPosition by default is INSERT_POSITION.AFTER\n */\nconst insertRow = function (editor) {\n  let position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.INSERT_POSITION.AFTER;\n  const {\n    tableEntry: [, tablePath],\n    rowEntry: [rowNode],\n    rowIndex\n  } = (0, _helper.getTableFocusingInfos)(editor);\n  const getInsertPath = rowIndex => {\n    const handlePosition = {\n      [_constants.INSERT_POSITION.BEFORE]: rowIndex => tablePath.concat(rowIndex),\n      [_constants.INSERT_POSITION.AFTER]: rowIndex => tablePath.concat(rowIndex + 1)\n    };\n    return handlePosition[position](rowIndex);\n  };\n  const insertPath = getInsertPath(rowIndex);\n  const insertRowChildren = rowNode.children.map(_ref => {\n    let {\n      align\n    } = _ref;\n    return (0, _model.generateTableCell)({\n      align\n    });\n  });\n  const insertRow = (0, _model.generateTableRow)({\n    childrenOrText: insertRowChildren\n  });\n  _slate.Transforms.insertNodes(editor, insertRow, {\n    at: insertPath\n  });\n};\nexports.insertRow = insertRow;\nconst removeRow = editor => {\n  const isSelectMultipleTable = (0, _helper.isSelectingMultipleTables)(editor);\n  if (isSelectMultipleTable) return;\n  const selectInfo = (0, _helper.getSelectGrid)(editor);\n  const [tableEntry] = (0, _helper.getTableEntry)(editor);\n  if (!tableEntry) return;\n  if (selectInfo) {\n    const {\n      startRowIndex,\n      endRowIndex\n    } = selectInfo;\n    const [table, tablePath] = tableEntry;\n    const tableRowCount = table.children.length;\n\n    // Remove all rows\n    if (startRowIndex === 0 && endRowIndex === tableRowCount - 1) return removeTable(editor);\n    for (let index = endRowIndex; index >= startRowIndex; index--) {\n      const rowPath = tablePath.concat(index);\n      _slate.Transforms.removeNodes(editor, {\n        at: rowPath\n      });\n    }\n    const focusPoint = _slate.Editor.start(editor, tableEntry[1].concat(startRowIndex - 1 < 0 ? 0 : startRowIndex - 1));\n    (0, _core.focusEditor)(editor, focusPoint);\n    return;\n  }\n  const {\n    tableEntry: [tableNode, tablePath],\n    rowEntry: [, rowPath],\n    rowIndex\n  } = (0, _helper.getTableFocusingInfos)(editor);\n  let focusPoint = null;\n  const tableHeight = tableNode.children.length;\n  // If table has one more row, remove row, else remove table\n  if (tableHeight > 1) {\n    // If removing row is the last row, focus on the previous row\n    const isRemovingLastRow = rowIndex === tableHeight - 1;\n    focusPoint = isRemovingLastRow ? _slate.Editor.start(editor, tablePath.concat(rowIndex - 1)) : _slate.Editor.start(editor, rowPath);\n    _slate.Transforms.removeNodes(editor, {\n      at: rowPath\n    });\n    (0, _core.focusEditor)(editor, focusPoint);\n  } else {\n    return removeTable(editor);\n  }\n};\nexports.removeRow = removeRow;\nconst removeTable = editor => {\n  const [tableNodeEntry] = (0, _helper.getTableEntry)(editor);\n  if (!tableNodeEntry) return;\n  const [table, tablePath] = tableNodeEntry;\n  const isLast = (0, _core.isLastNode)(editor, table);\n  if (isLast) {\n    const paragraph = (0, _core.generateDefaultParagraph)();\n    _slate.Transforms.removeNodes(editor, {\n      at: tablePath\n    });\n    _slate.Transforms.insertNodes(editor, paragraph, {\n      at: tablePath\n    });\n    const focusPoint = _slate.Editor.start(editor, tablePath);\n    (0, _core.focusEditor)(editor, focusPoint);\n    return;\n  }\n  const focusPoint = _slate.Editor.start(editor, tablePath[1]);\n  _slate.Transforms.removeNodes(editor, {\n    at: tablePath\n  });\n  (0, _core.focusEditor)(editor, focusPoint);\n};\n\n/**\n * @param {Object} editor\n * @param {INSERT_POSITION.AFTER | INSERT_POSITION.BEFORE} insertPosition by default is INSERT_POSITION.AFTER\n */\nexports.removeTable = removeTable;\nconst insertColumn = function (editor) {\n  let insertPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.INSERT_POSITION.AFTER;\n  const {\n    tableEntry: [tableNode, tablePath],\n    rowIndex,\n    columnIndex\n  } = (0, _helper.getTableFocusingInfos)(editor);\n  const getInsertPath = (rowIndex, columnIndex) => {\n    const newCellPath = {\n      [_constants.INSERT_POSITION.BEFORE]: (rowIndex, columnIndex) => tablePath.concat(rowIndex, columnIndex),\n      [_constants.INSERT_POSITION.AFTER]: (rowIndex, columnIndex) => tablePath.concat(rowIndex, columnIndex + 1)\n    };\n    return newCellPath[insertPosition](rowIndex, columnIndex);\n  };\n  tableNode.children.forEach((row, rowIndex) => {\n    const insertPath = getInsertPath(rowIndex, columnIndex);\n    const newCell = (0, _model.generateTableCell)(rowIndex, columnIndex);\n    _slate.Transforms.insertNodes(editor, newCell, {\n      at: insertPath\n    });\n  });\n  const align = [...tableNode.align];\n  const insertAlgin = insertPosition === _constants.INSERT_POSITION.BEFORE ? columnIndex : columnIndex + 1;\n  align.splice(insertAlgin, 0, _constants.TEXT_ALIGN.LEFT);\n  _slate.Transforms.setNodes(editor, {\n    align\n  }, {\n    at: tablePath\n  });\n  const focusPoint = _slate.Editor.start(editor, getInsertPath(rowIndex, columnIndex));\n  (0, _core.focusEditor)(editor, focusPoint);\n};\nexports.insertColumn = insertColumn;\nconst removeColumn = editor => {\n  const isSelectMultipleTable = (0, _helper.isSelectingMultipleTables)(editor);\n  if (isSelectMultipleTable) return;\n  const selectInfos = (0, _helper.getSelectGrid)(editor);\n  const [tableEntry] = (0, _helper.getTableEntry)(editor);\n  if (!tableEntry) return;\n  if (selectInfos) {\n    const {\n      startColIndex,\n      endColIndex\n    } = selectInfos;\n    const [table, tablePath] = tableEntry;\n    const tableRowCount = table.children.length;\n    const tableColumnCount = table.children[0].children.length;\n\n    // Remove all columns\n    if (startColIndex === 0 && endColIndex === tableColumnCount - 1) return removeTable(editor);\n    for (let rowIndex = 0; rowIndex < tableRowCount; rowIndex++) {\n      for (let colIndex = endColIndex; colIndex >= startColIndex; colIndex--) {\n        const cellPath = tablePath.concat(rowIndex, colIndex);\n        _slate.Transforms.removeNodes(editor, {\n          at: cellPath\n        });\n      }\n    }\n    const focusPoint = _slate.Editor.start(editor, tablePath.concat(0, startColIndex - 1 < 0 ? 0 : startColIndex - 1));\n    (0, _core.focusEditor)(editor, focusPoint);\n    return;\n  }\n  const {\n    tableEntry: [tableNode, tablePath],\n    rowEntry: [rowNode, rowPath],\n    columnIndex\n  } = (0, _helper.getTableFocusingInfos)(editor);\n  const tableWidth = rowNode.children.length;\n  let focusPoint = null;\n\n  // If table has one more column, remove column, else remove table\n  if (tableWidth > 1) {\n    // If removing column is the last column, focus on the previous column\n    const isRemovingLastColumn = columnIndex === tableWidth - 1;\n    tableNode.children.forEach((row, rowIndex) => {\n      const removePath = tablePath.concat(rowIndex, columnIndex);\n      _slate.Transforms.removeNodes(editor, {\n        at: removePath\n      });\n    });\n\n    // Update columns\n    const align = [...tableNode.align];\n    align.splice(columnIndex, 1);\n    _slate.Transforms.setNodes(editor, {\n      align\n    }, {\n      at: tablePath\n    });\n    focusPoint = isRemovingLastColumn ? _slate.Editor.start(editor, rowPath.concat(columnIndex - 1)) : _slate.Editor.start(editor, rowPath.concat(columnIndex));\n    (0, _core.focusEditor)(editor, focusPoint);\n  } else {\n    removeTable(editor);\n  }\n};\n\n/**\n * @param {Object} editor\n * @param {keyof TEXT_ALIGN} align Text align\n */\nexports.removeColumn = removeColumn;\nconst changeColumnAlign = (editor, alignType) => {\n  const {\n    tableEntry: [table, tablePath],\n    columnIndex\n  } = (0, _helper.getTableFocusingInfos)(editor);\n  const selectGrid = (0, _helper.getSelectGrid)(editor);\n  const align = [...table.align];\n\n  // If select a range in table\n  if (selectGrid) {\n    const {\n      startColIndex,\n      endColIndex\n    } = selectGrid;\n    for (let columnIndex = startColIndex; columnIndex <= endColIndex; columnIndex++) {\n      align.splice(columnIndex, columnIndex, alignType);\n    }\n  } else {\n    // If select a cell in table\n    align.splice(columnIndex, columnIndex, alignType);\n  }\n  _slate.Transforms.setNodes(editor, {\n    align\n  }, {\n    at: tablePath\n  });\n};\nexports.changeColumnAlign = changeColumnAlign;\nconst insertTableElement = function (editor, type) {\n  let position = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _constant.TABLE_ELEMENT_POSITION.AFTER;\n  let count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  const [tableEntry] = (0, _helper.getTableEntry)(editor);\n  if (!tableEntry) return;\n  let selectedInfo = (0, _helper.getSelectGrid)(editor);\n  if (!selectedInfo) {\n    const tableCellEntry = (0, _core.getSelectedNodeEntryByType)(editor, _elementTypes.TABLE_CELL);\n    const cellPath = tableCellEntry[1];\n    const rowPath = cellPath.slice(0, cellPath.length - 1);\n    selectedInfo = {\n      endRowIndex: rowPath.pop(),\n      endColIndex: cellPath.pop()\n    };\n  }\n  const [tableNode, tablePath] = tableEntry;\n  const tableRows = tableNode.children;\n  const tableRowsLength = tableRows.length;\n  const tableColumnLength = tableRows[0].children.length;\n  const {\n    endRowIndex,\n    endColIndex\n  } = selectedInfo;\n  if (type === _constant.TABLE_ELEMENT.ROW) {\n    if (tableRowsLength >= _constant.TABLE_MAX_ROWS) return;\n    const targetPath = position === _constant.TABLE_ELEMENT_POSITION.AFTER ? [...tablePath, endRowIndex + 1] : [...tablePath, endRowIndex];\n    const validCount = Math.min(_constant.TABLE_MAX_ROWS - tableRowsLength, count);\n    for (let i = 0; i < validCount; i++) {\n      const row = (0, _model.generateTableRow)({\n        columnNum: tableColumnLength\n      });\n      _slate.Transforms.insertNodes(editor, row, {\n        at: targetPath\n      });\n    }\n    setTimeout(() => {\n      const oldRowIndex = position === _constant.TABLE_ELEMENT_POSITION.AFTER ? endRowIndex : endRowIndex + validCount;\n      const focusPath = [...tablePath, oldRowIndex, endColIndex];\n      (0, _core.focusEditor)(editor, focusPath);\n      _slate.Transforms.collapse(editor, {\n        edge: 'end'\n      });\n    });\n    return;\n  }\n  if (type === _constant.TABLE_ELEMENT.COLUMN) {\n    if (tableColumnLength >= _constant.TABLE_MAX_COLUMNS) return;\n    const newCellIndex = position === _constant.TABLE_ELEMENT_POSITION.AFTER ? endColIndex + 1 : endColIndex;\n    const validCount = Math.min(_constant.TABLE_MAX_COLUMNS - tableColumnLength, count);\n    for (let j = 0; j < validCount; j++) {\n      for (let i = 0; i < tableRowsLength; i++) {\n        const newCellPath = [...tablePath, i, newCellIndex];\n        const newCell = (0, _model.generateTableCell)();\n        _slate.Transforms.insertNodes(editor, newCell, {\n          at: newCellPath\n        });\n      }\n    }\n    setTimeout(() => {\n      const oldCellIndex = position === _constant.TABLE_ELEMENT_POSITION.AFTER ? endColIndex : endColIndex + validCount;\n      const focusPath = [...tablePath, endRowIndex, oldCellIndex, 0];\n      (0, _core.focusEditor)(editor, focusPath);\n      _slate.Transforms.collapse(editor, {\n        edge: 'end'\n      });\n    });\n    return;\n  }\n};\nexports.insertTableElement = insertTableElement;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}