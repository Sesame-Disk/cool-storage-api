{"ast":null,"code":"/**\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Doctype} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n * @typedef {import('hast').Text} Text\n *\n * @typedef {import('parse5').DefaultTreeAdapterMap['document']} Parse5Document\n * @typedef {import('parse5').DefaultTreeAdapterMap['documentFragment']} Parse5Fragment\n * @typedef {import('parse5').DefaultTreeAdapterMap['element']} Parse5Element\n * @typedef {import('parse5').DefaultTreeAdapterMap['node']} Parse5Nodes\n * @typedef {import('parse5').DefaultTreeAdapterMap['documentType']} Parse5Doctype\n * @typedef {import('parse5').DefaultTreeAdapterMap['commentNode']} Parse5Comment\n * @typedef {import('parse5').DefaultTreeAdapterMap['textNode']} Parse5Text\n * @typedef {import('parse5').DefaultTreeAdapterMap['parentNode']} Parse5Parent\n * @typedef {import('parse5').Token.Attribute} Parse5Attribute\n *\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in (default: `'html'`).\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n *\n * @typedef {Exclude<Parse5Nodes, Parse5Document | Parse5Fragment>} Parse5Content\n *\n * @typedef {'html' | 'svg'} Space\n */\n\nimport { stringify as commas } from 'comma-separated-tokens';\nimport { ok as assert } from 'devlop';\nimport { find, html, svg } from 'property-information';\nimport { stringify as spaces } from 'space-separated-tokens';\nimport { webNamespaces } from 'web-namespaces';\nimport { zwitch } from 'zwitch';\n\n/** @type {Options} */\nvar emptyOptions = {};\nvar own = {}.hasOwnProperty;\nvar one = zwitch('type', {\n  handlers: {\n    root: root,\n    element: element,\n    text: text,\n    comment: comment,\n    doctype: doctype\n  }\n});\n\n/**\n * Transform a hast tree to a `parse5` AST.\n *\n * @param {Nodes} tree\n *   Tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Parse5Nodes}\n *   `parse5` node.\n */\nexport function toParse5(tree, options) {\n  var settings = options || emptyOptions;\n  var space = settings.space;\n  return one(tree, space === 'svg' ? svg : html);\n}\n\n/**\n * @param {Root} node\n *   Node (hast) to transform.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Parse5Document}\n *   Parse5 node.\n */\nfunction root(node, schema) {\n  /** @type {Parse5Document} */\n  var result = {\n    nodeName: '#document',\n    // @ts-expect-error: `parse5` uses enums, which are actually strings.\n    mode: (node.data || {}).quirksMode ? 'quirks' : 'no-quirks',\n    childNodes: []\n  };\n  result.childNodes = all(node.children, result, schema);\n  patch(node, result);\n  return result;\n}\n\n/**\n * @param {Root} node\n *   Node (hast) to transform.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Parse5Fragment}\n *   Parse5 node.\n */\nfunction fragment(node, schema) {\n  /** @type {Parse5Fragment} */\n  var result = {\n    nodeName: '#document-fragment',\n    childNodes: []\n  };\n  result.childNodes = all(node.children, result, schema);\n  patch(node, result);\n  return result;\n}\n\n/**\n * @param {Doctype} node\n *   Node (hast) to transform.\n * @returns {Parse5Doctype}\n *   Parse5 node.\n */\nfunction doctype(node) {\n  /** @type {Parse5Doctype} */\n  var result = {\n    nodeName: '#documentType',\n    name: 'html',\n    publicId: '',\n    systemId: '',\n    parentNode: null\n  };\n  patch(node, result);\n  return result;\n}\n\n/**\n * @param {Text} node\n *   Node (hast) to transform.\n * @returns {Parse5Text}\n *   Parse5 node.\n */\nfunction text(node) {\n  /** @type {Parse5Text} */\n  var result = {\n    nodeName: '#text',\n    value: node.value,\n    parentNode: null\n  };\n  patch(node, result);\n  return result;\n}\n\n/**\n * @param {Comment} node\n *   Node (hast) to transform.\n * @returns {Parse5Comment}\n *   Parse5 node.\n */\nfunction comment(node) {\n  /** @type {Parse5Comment} */\n  var result = {\n    nodeName: '#comment',\n    data: node.value,\n    parentNode: null\n  };\n  patch(node, result);\n  return result;\n}\n\n/**\n * @param {Element} node\n *   Node (hast) to transform.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Parse5Element}\n *   Parse5 node.\n */\nfunction element(node, schema) {\n  var parentSchema = schema;\n  var currentSchema = parentSchema;\n  if (node.type === 'element' && node.tagName.toLowerCase() === 'svg' && parentSchema.space === 'html') {\n    currentSchema = svg;\n  }\n\n  /** @type {Array<Parse5Attribute>} */\n  var attrs = [];\n  /** @type {string} */\n  var prop;\n  if (node.properties) {\n    for (prop in node.properties) {\n      if (prop !== 'children' && own.call(node.properties, prop)) {\n        var _result = createProperty(currentSchema, prop, node.properties[prop]);\n        if (_result) {\n          attrs.push(_result);\n        }\n      }\n    }\n  }\n  var space = currentSchema.space;\n  // `html` and `svg` both have a space.\n  assert(space);\n\n  /** @type {Parse5Element} */\n  var result = {\n    nodeName: node.tagName,\n    tagName: node.tagName,\n    attrs: attrs,\n    // @ts-expect-error: `parse5` types are wrong.\n    namespaceURI: webNamespaces[space],\n    childNodes: [],\n    parentNode: null\n  };\n  result.childNodes = all(node.children, result, currentSchema);\n  patch(node, result);\n  if (node.tagName === 'template' && node.content) {\n    // @ts-expect-error: `parse5` types are wrong.\n    result.content = fragment(node.content, currentSchema);\n  }\n  return result;\n}\n\n/**\n * Handle a property.\n *\n * @param {Schema} schema\n *   Current schema.\n * @param {string} prop\n *   Key.\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\n *   hast property value.\n * @returns {Parse5Attribute | undefined}\n *   Field for runtime, optional.\n */\nfunction createProperty(schema, prop, value) {\n  var info = find(schema, prop);\n\n  // Ignore nullish and `NaN` values.\n  if (value === false || value === null || value === undefined || typeof value === 'number' && Number.isNaN(value) || !value && info.boolean) {\n    return;\n  }\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value);\n  }\n\n  /** @type {Parse5Attribute} */\n  var attribute = {\n    name: info.attribute,\n    value: value === true ? '' : String(value)\n  };\n  if (info.space && info.space !== 'html' && info.space !== 'svg') {\n    var index = attribute.name.indexOf(':');\n    if (index < 0) {\n      attribute.prefix = '';\n    } else {\n      attribute.name = attribute.name.slice(index + 1);\n      attribute.prefix = info.attribute.slice(0, index);\n    }\n    attribute.namespace = webNamespaces[info.space];\n  }\n  return attribute;\n}\n\n/**\n * Transform all hast nodes.\n *\n * @param {Array<RootContent>} children\n *   List of children.\n * @param {Parse5Parent} parentNode\n *   `parse5` parent node.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Array<Parse5Content>}\n *   Transformed children.\n */\nfunction all(children, parentNode, schema) {\n  var index = -1;\n  /** @type {Array<Parse5Content>} */\n  var results = [];\n  if (children) {\n    while (++index < children.length) {\n      /** @type {Parse5Content} */\n      var child = one(children[index], schema);\n      child.parentNode = parentNode;\n      results.push(child);\n    }\n  }\n  return results;\n}\n\n/**\n * Add position info from `from` to `to`.\n *\n * @param {Nodes} from\n *   hast node.\n * @param {Parse5Nodes} to\n *   `parse5` node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(from, to) {\n  var position = from.position;\n  if (position && position.start && position.end) {\n    assert(typeof position.start.offset === 'number');\n    assert(typeof position.end.offset === 'number');\n    to.sourceCodeLocation = {\n      startLine: position.start.line,\n      startCol: position.start.column,\n      startOffset: position.start.offset,\n      endLine: position.end.line,\n      endCol: position.end.column,\n      endOffset: position.end.offset\n    };\n  }\n}","map":{"version":3,"names":["stringify","commas","ok","assert","find","html","svg","spaces","webNamespaces","zwitch","emptyOptions","own","hasOwnProperty","one","handlers","root","element","text","comment","doctype","toParse5","tree","options","settings","space","node","schema","result","nodeName","mode","data","quirksMode","childNodes","all","children","patch","fragment","name","publicId","systemId","parentNode","value","parentSchema","currentSchema","type","tagName","toLowerCase","attrs","prop","properties","call","createProperty","push","namespaceURI","content","info","undefined","Number","isNaN","boolean","Array","isArray","commaSeparated","attribute","String","index","indexOf","prefix","slice","namespace","results","length","child","from","to","position","start","end","offset","sourceCodeLocation","startLine","line","startCol","column","startOffset","endLine","endCol","endOffset"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/hast-util-to-parse5/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Doctype} Doctype\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n * @typedef {import('hast').Text} Text\n *\n * @typedef {import('parse5').DefaultTreeAdapterMap['document']} Parse5Document\n * @typedef {import('parse5').DefaultTreeAdapterMap['documentFragment']} Parse5Fragment\n * @typedef {import('parse5').DefaultTreeAdapterMap['element']} Parse5Element\n * @typedef {import('parse5').DefaultTreeAdapterMap['node']} Parse5Nodes\n * @typedef {import('parse5').DefaultTreeAdapterMap['documentType']} Parse5Doctype\n * @typedef {import('parse5').DefaultTreeAdapterMap['commentNode']} Parse5Comment\n * @typedef {import('parse5').DefaultTreeAdapterMap['textNode']} Parse5Text\n * @typedef {import('parse5').DefaultTreeAdapterMap['parentNode']} Parse5Parent\n * @typedef {import('parse5').Token.Attribute} Parse5Attribute\n *\n * @typedef {import('property-information').Schema} Schema\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in (default: `'html'`).\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n *\n * @typedef {Exclude<Parse5Nodes, Parse5Document | Parse5Fragment>} Parse5Content\n *\n * @typedef {'html' | 'svg'} Space\n */\n\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {ok as assert} from 'devlop'\nimport {find, html, svg} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport {webNamespaces} from 'web-namespaces'\nimport {zwitch} from 'zwitch'\n\n/** @type {Options} */\nconst emptyOptions = {}\n\nconst own = {}.hasOwnProperty\n\nconst one = zwitch('type', {handlers: {root, element, text, comment, doctype}})\n\n/**\n * Transform a hast tree to a `parse5` AST.\n *\n * @param {Nodes} tree\n *   Tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Parse5Nodes}\n *   `parse5` node.\n */\nexport function toParse5(tree, options) {\n  const settings = options || emptyOptions\n  const space = settings.space\n  return one(tree, space === 'svg' ? svg : html)\n}\n\n/**\n * @param {Root} node\n *   Node (hast) to transform.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Parse5Document}\n *   Parse5 node.\n */\nfunction root(node, schema) {\n  /** @type {Parse5Document} */\n  const result = {\n    nodeName: '#document',\n    // @ts-expect-error: `parse5` uses enums, which are actually strings.\n    mode: (node.data || {}).quirksMode ? 'quirks' : 'no-quirks',\n    childNodes: []\n  }\n  result.childNodes = all(node.children, result, schema)\n  patch(node, result)\n  return result\n}\n\n/**\n * @param {Root} node\n *   Node (hast) to transform.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Parse5Fragment}\n *   Parse5 node.\n */\nfunction fragment(node, schema) {\n  /** @type {Parse5Fragment} */\n  const result = {nodeName: '#document-fragment', childNodes: []}\n  result.childNodes = all(node.children, result, schema)\n  patch(node, result)\n  return result\n}\n\n/**\n * @param {Doctype} node\n *   Node (hast) to transform.\n * @returns {Parse5Doctype}\n *   Parse5 node.\n */\nfunction doctype(node) {\n  /** @type {Parse5Doctype} */\n  const result = {\n    nodeName: '#documentType',\n    name: 'html',\n    publicId: '',\n    systemId: '',\n    parentNode: null\n  }\n\n  patch(node, result)\n  return result\n}\n\n/**\n * @param {Text} node\n *   Node (hast) to transform.\n * @returns {Parse5Text}\n *   Parse5 node.\n */\nfunction text(node) {\n  /** @type {Parse5Text} */\n  const result = {\n    nodeName: '#text',\n    value: node.value,\n    parentNode: null\n  }\n  patch(node, result)\n  return result\n}\n\n/**\n * @param {Comment} node\n *   Node (hast) to transform.\n * @returns {Parse5Comment}\n *   Parse5 node.\n */\nfunction comment(node) {\n  /** @type {Parse5Comment} */\n  const result = {\n    nodeName: '#comment',\n    data: node.value,\n    parentNode: null\n  }\n\n  patch(node, result)\n\n  return result\n}\n\n/**\n * @param {Element} node\n *   Node (hast) to transform.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Parse5Element}\n *   Parse5 node.\n */\nfunction element(node, schema) {\n  const parentSchema = schema\n  let currentSchema = parentSchema\n\n  if (\n    node.type === 'element' &&\n    node.tagName.toLowerCase() === 'svg' &&\n    parentSchema.space === 'html'\n  ) {\n    currentSchema = svg\n  }\n\n  /** @type {Array<Parse5Attribute>} */\n  const attrs = []\n  /** @type {string} */\n  let prop\n\n  if (node.properties) {\n    for (prop in node.properties) {\n      if (prop !== 'children' && own.call(node.properties, prop)) {\n        const result = createProperty(\n          currentSchema,\n          prop,\n          node.properties[prop]\n        )\n\n        if (result) {\n          attrs.push(result)\n        }\n      }\n    }\n  }\n\n  const space = currentSchema.space\n  // `html` and `svg` both have a space.\n  assert(space)\n\n  /** @type {Parse5Element} */\n  const result = {\n    nodeName: node.tagName,\n    tagName: node.tagName,\n    attrs,\n    // @ts-expect-error: `parse5` types are wrong.\n    namespaceURI: webNamespaces[space],\n    childNodes: [],\n    parentNode: null\n  }\n  result.childNodes = all(node.children, result, currentSchema)\n  patch(node, result)\n\n  if (node.tagName === 'template' && node.content) {\n    // @ts-expect-error: `parse5` types are wrong.\n    result.content = fragment(node.content, currentSchema)\n  }\n\n  return result\n}\n\n/**\n * Handle a property.\n *\n * @param {Schema} schema\n *   Current schema.\n * @param {string} prop\n *   Key.\n * @param {Array<number | string> | boolean | number | string | null | undefined} value\n *   hast property value.\n * @returns {Parse5Attribute | undefined}\n *   Field for runtime, optional.\n */\nfunction createProperty(schema, prop, value) {\n  const info = find(schema, prop)\n\n  // Ignore nullish and `NaN` values.\n  if (\n    value === false ||\n    value === null ||\n    value === undefined ||\n    (typeof value === 'number' && Number.isNaN(value)) ||\n    (!value && info.boolean)\n  ) {\n    return\n  }\n\n  if (Array.isArray(value)) {\n    // Accept `array`.\n    // Most props are space-separated.\n    value = info.commaSeparated ? commas(value) : spaces(value)\n  }\n\n  /** @type {Parse5Attribute} */\n  const attribute = {\n    name: info.attribute,\n    value: value === true ? '' : String(value)\n  }\n\n  if (info.space && info.space !== 'html' && info.space !== 'svg') {\n    const index = attribute.name.indexOf(':')\n\n    if (index < 0) {\n      attribute.prefix = ''\n    } else {\n      attribute.name = attribute.name.slice(index + 1)\n      attribute.prefix = info.attribute.slice(0, index)\n    }\n\n    attribute.namespace = webNamespaces[info.space]\n  }\n\n  return attribute\n}\n\n/**\n * Transform all hast nodes.\n *\n * @param {Array<RootContent>} children\n *   List of children.\n * @param {Parse5Parent} parentNode\n *   `parse5` parent node.\n * @param {Schema} schema\n *   Current schema.\n * @returns {Array<Parse5Content>}\n *   Transformed children.\n */\nfunction all(children, parentNode, schema) {\n  let index = -1\n  /** @type {Array<Parse5Content>} */\n  const results = []\n\n  if (children) {\n    while (++index < children.length) {\n      /** @type {Parse5Content} */\n      const child = one(children[index], schema)\n\n      child.parentNode = parentNode\n\n      results.push(child)\n    }\n  }\n\n  return results\n}\n\n/**\n * Add position info from `from` to `to`.\n *\n * @param {Nodes} from\n *   hast node.\n * @param {Parse5Nodes} to\n *   `parse5` node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(from, to) {\n  const position = from.position\n\n  if (position && position.start && position.end) {\n    assert(typeof position.start.offset === 'number')\n    assert(typeof position.end.offset === 'number')\n\n    to.sourceCodeLocation = {\n      startLine: position.start.line,\n      startCol: position.start.column,\n      startOffset: position.start.offset,\n      endLine: position.end.line,\n      endCol: position.end.column,\n      endOffset: position.end.offset\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}