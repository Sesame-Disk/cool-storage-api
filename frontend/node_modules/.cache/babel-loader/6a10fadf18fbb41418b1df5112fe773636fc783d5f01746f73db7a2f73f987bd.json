{"ast":null,"code":"import _toConsumableArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport { Editor, Transforms, Element, Node } from '@seafile/slate';\nimport slugid from 'slugid';\nimport { BLOCKQUOTE, CHECK_LIST_ITEM, IMAGE, ORDERED_LIST, PARAGRAPH, UNORDERED_LIST, CODE_BLOCK, TABLE, CALL_OUT } from '../../constants';\nimport { getNodeType } from '../../core';\nexport var isMenuDisabled = function isMenuDisabled(editor, readonly) {\n  if (readonly) return true;\n  if (editor.selection == null) return true;\n  var _Editor$nodes = Editor.nodes(editor, {\n      match: function match(n) {\n        var type = getNodeType(n);\n\n        // Only available for p and blockquote\n        if (type === PARAGRAPH) return true;\n        if (type === BLOCKQUOTE) return true;\n        if (type === UNORDERED_LIST) return true;\n        if (type === ORDERED_LIST) return true;\n        if (type === CHECK_LIST_ITEM) return true;\n        if (type && type.startWith && type.startWith('header')) return true;\n        if (type === IMAGE) return true;\n        return false;\n      },\n      universal: true,\n      mode: 'highest' // Match top level\n    }),\n    _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n    nodeEntry = _Editor$nodes2[0];\n\n  // Match to p blockquote, do not disable\n  if (nodeEntry) {\n    return false;\n  }\n  // 未匹配到，则禁用\n  return true;\n};\nexport var getBlockQuoteType = function getBlockQuoteType(editor) {\n  var _Editor$nodes3 = Editor.nodes(editor, {\n      match: function match(n) {\n        return getNodeType(n) === BLOCKQUOTE;\n      },\n      universal: true\n    }),\n    _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1),\n    match = _Editor$nodes4[0];\n  if (!match) return PARAGRAPH;\n  var _match = _slicedToArray(match, 1),\n    n = _match[0];\n  return getNodeType(n);\n};\n\n// If cursor is in  callout, insert block quote in callout, otherwise wrap block quote directly\nexport var setBlockQuoteType = function setBlockQuoteType(editor, active) {\n  if (!active) {\n    var blockquoteNode = {\n      id: slugid.nice(),\n      type: BLOCKQUOTE\n    };\n    Transforms.wrapNodes(editor, blockquoteNode, {\n      mode: 'highest',\n      match: function match(n) {\n        if (n.type === CALL_OUT) return false;\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    });\n  } else {\n    Transforms.unwrapNodes(editor, {\n      mode: 'highest',\n      match: function match(n) {\n        if (n.type === CALL_OUT) return false;\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    });\n  }\n};\nexport var getFormattedElements = function getFormattedElements(data) {\n  var elements = [];\n  var arr = [];\n  data.forEach(function (item) {\n    if ([CODE_BLOCK, TABLE, BLOCKQUOTE].includes(item === null || item === void 0 ? void 0 : item.type)) {\n      // Insert quote block\n      if (arr.length !== 0) {\n        var blockquoteNode = {\n          id: slugid.nice(),\n          type: BLOCKQUOTE\n        };\n        blockquoteNode['children'] = arr;\n        elements.push(blockquoteNode);\n        arr = [];\n      }\n      // Merge quote block\n      var preElement = elements[elements.length - 1];\n      if ((preElement === null || preElement === void 0 ? void 0 : preElement.type) === BLOCKQUOTE && (item === null || item === void 0 ? void 0 : item.type) === BLOCKQUOTE) {\n        elements[elements.length - 1] = _objectSpread(_objectSpread({}, preElement), {}, {\n          children: [].concat(_toConsumableArray(preElement.children), _toConsumableArray(item.children))\n        });\n      } else {\n        elements.push(item);\n      }\n    } else {\n      arr.push(item);\n    }\n  });\n  return elements;\n};\nexport var getFormattedRestElements = function getFormattedRestElements(data) {\n  var restElements = data.slice(0);\n  data.forEach(function (item, index) {\n    if (Node.string(item).length === 0) {\n      restElements.splice(index, 1);\n    }\n\n    // Split quote block\n    if ((item === null || item === void 0 ? void 0 : item.type) === BLOCKQUOTE) {\n      restElements.splice.apply(restElements, [index, 1].concat(_toConsumableArray(item.children)));\n    }\n  });\n  return restElements;\n};","map":{"version":3,"names":["_objectSpread","Editor","Transforms","Element","Node","slugid","BLOCKQUOTE","CHECK_LIST_ITEM","IMAGE","ORDERED_LIST","PARAGRAPH","UNORDERED_LIST","CODE_BLOCK","TABLE","CALL_OUT","getNodeType","isMenuDisabled","editor","readonly","selection","_Editor$nodes","nodes","match","n","type","startWith","universal","mode","_Editor$nodes2","_slicedToArray","nodeEntry","getBlockQuoteType","_Editor$nodes3","_Editor$nodes4","_match","setBlockQuoteType","active","blockquoteNode","id","nice","wrapNodes","isElement","isBlock","unwrapNodes","getFormattedElements","data","elements","arr","forEach","item","includes","length","push","preElement","children","concat","_toConsumableArray","getFormattedRestElements","restElements","slice","index","string","splice","apply"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/plugins/blockquote/helpers.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport { Editor, Transforms, Element, Node } from '@seafile/slate';\nimport slugid from 'slugid';\nimport { BLOCKQUOTE, CHECK_LIST_ITEM, IMAGE, ORDERED_LIST, PARAGRAPH, UNORDERED_LIST, CODE_BLOCK, TABLE, CALL_OUT } from '../../constants';\nimport { getNodeType } from '../../core';\nexport const isMenuDisabled = (editor, readonly) => {\n  if (readonly) return true;\n  if (editor.selection == null) return true;\n  const [nodeEntry] = Editor.nodes(editor, {\n    match: n => {\n      const type = getNodeType(n);\n\n      // Only available for p and blockquote\n      if (type === PARAGRAPH) return true;\n      if (type === BLOCKQUOTE) return true;\n      if (type === UNORDERED_LIST) return true;\n      if (type === ORDERED_LIST) return true;\n      if (type === CHECK_LIST_ITEM) return true;\n      if (type && type.startWith && type.startWith('header')) return true;\n      if (type === IMAGE) return true;\n      return false;\n    },\n    universal: true,\n    mode: 'highest' // Match top level\n  });\n\n  // Match to p blockquote, do not disable\n  if (nodeEntry) {\n    return false;\n  }\n  // 未匹配到，则禁用\n  return true;\n};\nexport const getBlockQuoteType = editor => {\n  const [match] = Editor.nodes(editor, {\n    match: n => getNodeType(n) === BLOCKQUOTE,\n    universal: true\n  });\n  if (!match) return PARAGRAPH;\n  const [n] = match;\n  return getNodeType(n);\n};\n\n// If cursor is in  callout, insert block quote in callout, otherwise wrap block quote directly\nexport const setBlockQuoteType = (editor, active) => {\n  if (!active) {\n    const blockquoteNode = {\n      id: slugid.nice(),\n      type: BLOCKQUOTE\n    };\n    Transforms.wrapNodes(editor, blockquoteNode, {\n      mode: 'highest',\n      match: n => {\n        if (n.type === CALL_OUT) return false;\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    });\n  } else {\n    Transforms.unwrapNodes(editor, {\n      mode: 'highest',\n      match: n => {\n        if (n.type === CALL_OUT) return false;\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    });\n  }\n};\nexport const getFormattedElements = data => {\n  const elements = [];\n  let arr = [];\n  data.forEach(item => {\n    if ([CODE_BLOCK, TABLE, BLOCKQUOTE].includes(item === null || item === void 0 ? void 0 : item.type)) {\n      // Insert quote block\n      if (arr.length !== 0) {\n        const blockquoteNode = {\n          id: slugid.nice(),\n          type: BLOCKQUOTE\n        };\n        blockquoteNode['children'] = arr;\n        elements.push(blockquoteNode);\n        arr = [];\n      }\n      // Merge quote block\n      let preElement = elements[elements.length - 1];\n      if ((preElement === null || preElement === void 0 ? void 0 : preElement.type) === BLOCKQUOTE && (item === null || item === void 0 ? void 0 : item.type) === BLOCKQUOTE) {\n        elements[elements.length - 1] = _objectSpread(_objectSpread({}, preElement), {}, {\n          children: [...preElement.children, ...item.children]\n        });\n      } else {\n        elements.push(item);\n      }\n    } else {\n      arr.push(item);\n    }\n  });\n  return elements;\n};\nexport const getFormattedRestElements = data => {\n  const restElements = data.slice(0);\n  data.forEach((item, index) => {\n    if (Node.string(item).length === 0) {\n      restElements.splice(index, 1);\n    }\n\n    // Split quote block\n    if ((item === null || item === void 0 ? void 0 : item.type) === BLOCKQUOTE) {\n      restElements.splice(index, 1, ...item.children);\n    }\n  });\n  return restElements;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}