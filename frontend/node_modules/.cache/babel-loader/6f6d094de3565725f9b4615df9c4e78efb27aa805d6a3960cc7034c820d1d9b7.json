{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _slicedToArray = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _toArray = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/toArray.js\").default;\nvar _toConsumableArray = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _isHotkey = _interopRequireDefault(require(\"is-hotkey\"));\nvar _slate = require(\"slate\");\nvar _core = require(\"../../core\");\nvar _helpers = require(\"./helpers\");\nvar _elementTypes = require(\"../../constants/element-types\");\nvar withCodeBlock = function withCodeBlock(editor) {\n  var normalizeNode = editor.normalizeNode,\n    insertFragment = editor.insertFragment,\n    insertText = editor.insertText,\n    insertBreak = editor.insertBreak,\n    insertData = editor.insertData,\n    insertNode = editor.insertNode,\n    onHotKeyDown = editor.onHotKeyDown;\n  var newEditor = editor;\n  newEditor.insertData = function (data) {\n    if (data.types.includes('text/code-block') && !(0, _core.getSelectedNodeByType)(editor, _elementTypes.CODE_BLOCK)) {\n      var codeBlockNode = JSON.parse(data.getData('text/code-block'));\n      return insertNode(codeBlockNode);\n    }\n    insertData(data);\n  };\n  newEditor.insertFragment = function (data) {\n    // only selected code block content\n    if (data.length === 1 && data[0].type === _elementTypes.CODE_BLOCK && !(0, _core.getSelectedNodeByType)(editor, _elementTypes.CODE_BLOCK)) {\n      data.forEach(function (node, index) {\n        if (node.type === _elementTypes.CODE_BLOCK) {\n          var newBlock = node.children.map(function (line) {\n            var text = _slate.Node.string(line);\n            var children = (0, _core.generateElement)(_elementTypes.PARAGRAPH, {\n              childrenOrText: text\n            });\n            return children;\n          });\n          data.splice.apply(data, [index, 1].concat(_toConsumableArray(newBlock)));\n        }\n      });\n      return insertFragment(data);\n    } else {\n      if ((0, _core.getSelectedNodeByType)(editor, _elementTypes.CODE_BLOCK)) {\n        // Paste into code block\n\n        // Pasted data is code block split with code-line\n        data.forEach(function (node, index) {\n          if (node.type === _elementTypes.CODE_BLOCK) {\n            var codeLineArr = node.children.map(function (line) {\n              return line;\n            });\n            data.splice.apply(data, [index, 1].concat(_toConsumableArray(codeLineArr)));\n            // Paste the copied content in place in code_block\n          } else if (node.type === _elementTypes.CODE_LINE) {\n            data.splice(index, 1, node);\n          }\n        });\n        var insertCodeLines = data.map(function (node) {\n          var text = _slate.Node.string(node);\n          var codeLine = (0, _core.generateElement)(_elementTypes.CODE_LINE, {\n            childrenOrText: text\n          });\n          return codeLine;\n        });\n\n        // Current focus code-line string not empty\n        var string = _slate.Editor.string(newEditor, newEditor.selection.focus.path);\n        // Paste the copied content in place in code_block\n        if (insertCodeLines.length === 1 && _slate.Range.isExpanded(newEditor.selection)) {\n          var text = _slate.Node.string(insertCodeLines[0]);\n          insertText(text);\n          return;\n        }\n        if (string.length !== 0 && _slate.Range.isCollapsed(newEditor.selection)) {\n          var _insertCodeLines = _toArray(insertCodeLines),\n            node = _insertCodeLines[0],\n            restNode = _insertCodeLines.slice(1);\n          var _text = _slate.Node.string(node);\n          insertText(_text);\n          if (restNode.length !== 0) {\n            insertBreak();\n            insertFragment(restNode);\n          }\n          return;\n        }\n        return insertFragment(insertCodeLines);\n      } else {\n        // Paste into not a code block\n        return insertFragment(data);\n      }\n    }\n  };\n\n  // Rewrite normalizeNode\n  newEditor.normalizeNode = function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      node = _ref2[0],\n      path = _ref2[1];\n    var type = (0, _core.getNodeType)(node);\n    if (type === _elementTypes.CODE_LINE && path.length <= 1) {\n      _slate.Transforms.setNodes(newEditor, {\n        type: _elementTypes.PARAGRAPH\n      }, {\n        at: path\n      });\n      return;\n    }\n    if (type === _elementTypes.CODE_BLOCK) {\n      if (node.children.length === 0) {\n        _slate.Transforms.delete(newEditor, {\n          at: path\n        });\n        return;\n      }\n\n      // code-block is the last node in the editor and needs to be followed by a p node\n      var isLast = (0, _core.isLastNode)(newEditor, node);\n      if (isLast) {\n        var paragraph = (0, _core.generateEmptyElement)(_elementTypes.PARAGRAPH);\n        _slate.Transforms.insertNodes(newEditor, paragraph, {\n          at: [path[0] + 1]\n        });\n      }\n      var isFirst = (0, _core.isFirstNode)(newEditor, node);\n      if (isFirst) {\n        var _paragraph = (0, _core.generateEmptyElement)(_elementTypes.PARAGRAPH);\n        _slate.Transforms.insertNodes(newEditor, _paragraph, {\n          at: [path[0]]\n        });\n      }\n\n      // Here must be a code node below code-block\n      if ((0, _core.getNodeType)(node.children[0]) !== _elementTypes.CODE_LINE) {\n        _slate.Transforms.unwrapNodes(newEditor);\n        _slate.Transforms.setNodes(newEditor, {\n          type: _elementTypes.PARAGRAPH\n        }, {\n          mode: 'highest'\n        });\n      }\n      if (node.children.length > 1) {\n        node.children.forEach(function (child, index) {\n          if (child.type !== _elementTypes.CODE_LINE) {\n            _slate.Transforms.setNodes(newEditor, {\n              type: _elementTypes.CODE_LINE\n            }, {\n              at: [].concat(_toConsumableArray(path), [index])\n            });\n          }\n        });\n      }\n    }\n\n    // Perform default behavior\n    return normalizeNode([node, path]);\n  };\n  newEditor.onHotKeyDown = function (event) {\n    var wrapperCodeBlock = (0, _helpers.getCodeBlockNodeEntry)(newEditor);\n    if (!wrapperCodeBlock) return onHotKeyDown && onHotKeyDown(event);\n    if ((0, _isHotkey.default)('mod+enter', event)) {\n      event.preventDefault();\n      if (newEditor.selection && !_slate.Range.isExpanded(newEditor.selection)) {\n        var path = _slate.Editor.path(newEditor, newEditor.selection);\n        var newParagraphPath = [path[0] + 1];\n        var newParagraph = (0, _core.generateEmptyElement)(_elementTypes.PARAGRAPH);\n        _slate.Transforms.insertNodes(newEditor, newParagraph, {\n          at: newParagraphPath\n        });\n        _slate.Transforms.select(newEditor, newParagraphPath);\n      }\n      return true;\n    }\n    if ((0, _isHotkey.default)('tab', event)) {\n      event.preventDefault();\n      var nodeEntries = _slate.Editor.nodes(newEditor, {\n        mode: 'lowest',\n        match: function match(node) {\n          return node.type === _elementTypes.CODE_LINE;\n        }\n      });\n      var nodeEntryList = Array.from(nodeEntries);\n      for (var _i = 0, _nodeEntryList = nodeEntryList; _i < _nodeEntryList.length; _i++) {\n        var nodeEntry = _nodeEntryList[_i];\n        var _nodeEntry = _slicedToArray(nodeEntry, 2),\n          _path = _nodeEntry[1];\n        // Insert 4 spaces for easier remove space\n        _slate.Transforms.insertText(newEditor, ' '.repeat(4), {\n          at: {\n            path: [].concat(_toConsumableArray(_path), [0]),\n            offset: 0\n          }\n        });\n      }\n      var firstCodeLinePath = nodeEntryList.at(0)[1].concat(0);\n      var lastCodeLinePath = nodeEntryList.at(-1)[1].concat(0);\n      var newRange = _slate.Editor.range(newEditor, firstCodeLinePath, lastCodeLinePath);\n      nodeEntryList.length > 1 ? _slate.Transforms.select(newEditor, newRange) : _slate.Transforms.select(newEditor);\n      return true;\n    }\n    if ((0, _isHotkey.default)('shift+tab', event)) {\n      event.preventDefault();\n      // Match the beginning of the line space, delete up to 4 spaces at a time\n      var originSelection = newEditor.selection;\n      var matchBeginSpace = /^\\s*/;\n      var _nodeEntries = _slate.Editor.nodes(newEditor, {\n        mode: 'lowest',\n        match: function match(node) {\n          return node.type === _elementTypes.CODE_LINE;\n        }\n      });\n      var _nodeEntryList2 = Array.from(_nodeEntries);\n      var removedSpaceCount = 0;\n      for (var _i2 = 0, _nodeEntryList3 = _nodeEntryList2; _i2 < _nodeEntryList3.length; _i2++) {\n        var _nodeEntry2 = _nodeEntryList3[_i2];\n        var _nodeEntry3 = _slicedToArray(_nodeEntry2, 2),\n          node = _nodeEntry3[0],\n          _path2 = _nodeEntry3[1];\n        var spaceNum = _slate.Node.string(node).match(matchBeginSpace);\n        // skip empty line and no space begining line\n        if (!spaceNum || !spaceNum[0].length) continue;\n        var deleteNum = Math.min(spaceNum[0].length, 4);\n        removedSpaceCount += deleteNum;\n        for (var i = 0; i < deleteNum; i++) {\n          _slate.Transforms.select(newEditor, {\n            path: [].concat(_toConsumableArray(_path2), [0]),\n            offset: 0\n          });\n          _slate.Editor.deleteForward(newEditor, {\n            unit: 'character'\n          });\n        }\n      }\n      // Select multiple rows when operating more then one line\n      // Keep cursor location when operating one line\n      if (_nodeEntryList2.length > 1) {\n        var _firstCodeLinePath = _nodeEntryList2.at(0)[1].concat(0);\n        var _lastCodeLinePath = _nodeEntryList2.at(-1)[1].concat(0);\n        var selectLocation = _slate.Editor.range(newEditor, _firstCodeLinePath, _lastCodeLinePath);\n        _slate.Transforms.select(newEditor, selectLocation);\n      } else {\n        var anchor = originSelection.anchor,\n          focus = originSelection.focus;\n        var isCollapsed = _slate.Range.isCollapsed(originSelection);\n        if (isCollapsed) {\n          var _selectLocation = _objectSpread(_objectSpread({}, originSelection.focus), {}, {\n            offset: originSelection.focus.offset - removedSpaceCount\n          });\n          _slate.Transforms.select(newEditor, _selectLocation);\n        } else {\n          var _selectLocation2 = {\n            anchor: _objectSpread(_objectSpread({}, anchor), {}, {\n              offset: anchor.offset - removedSpaceCount\n            }),\n            focus: _objectSpread(_objectSpread({}, focus), {}, {\n              offset: focus.offset - removedSpaceCount\n            })\n          };\n          _slate.Transforms.select(newEditor, _selectLocation2);\n        }\n      }\n      return true;\n    }\n    if ((0, _isHotkey.default)('mod+a', event)) {\n      event.preventDefault();\n      var codeBlockEntry = _slate.Editor.nodes(newEditor, {\n        mode: 'highest',\n        match: function match(node) {\n          return node.type === _elementTypes.CODE_BLOCK;\n        }\n      });\n      if (!codeBlockEntry) return;\n      var codeBlockEntryList = Array.from.apply(Array, _toConsumableArray(codeBlockEntry));\n      _slate.Transforms.select(newEditor, codeBlockEntryList[1]);\n      return true;\n    }\n  };\n  return newEditor;\n};\nvar _default = exports.default = withCodeBlock;","map":{"version":3,"names":["_objectSpread","require","default","_slicedToArray","_toArray","_toConsumableArray","_interopRequireDefault","Object","defineProperty","exports","value","_isHotkey","_slate","_core","_helpers","_elementTypes","withCodeBlock","editor","normalizeNode","insertFragment","insertText","insertBreak","insertData","insertNode","onHotKeyDown","newEditor","data","types","includes","getSelectedNodeByType","CODE_BLOCK","codeBlockNode","JSON","parse","getData","length","type","forEach","node","index","newBlock","children","map","line","text","Node","string","generateElement","PARAGRAPH","childrenOrText","splice","apply","concat","codeLineArr","CODE_LINE","insertCodeLines","codeLine","Editor","selection","focus","path","Range","isExpanded","isCollapsed","_insertCodeLines","restNode","slice","_ref","_ref2","getNodeType","Transforms","setNodes","at","delete","isLast","isLastNode","paragraph","generateEmptyElement","insertNodes","isFirst","isFirstNode","unwrapNodes","mode","child","event","wrapperCodeBlock","getCodeBlockNodeEntry","preventDefault","newParagraphPath","newParagraph","select","nodeEntries","nodes","match","nodeEntryList","Array","from","_i","_nodeEntryList","nodeEntry","_nodeEntry","repeat","offset","firstCodeLinePath","lastCodeLinePath","newRange","range","originSelection","matchBeginSpace","removedSpaceCount","_i2","_nodeEntryList3","_nodeEntry3","spaceNum","deleteNum","Math","min","i","deleteForward","unit","selectLocation","anchor","codeBlockEntry","codeBlockEntryList","_default"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/seafile-editor/dist/extension/plugins/code-block/plugin.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _isHotkey = _interopRequireDefault(require(\"is-hotkey\"));\nvar _slate = require(\"slate\");\nvar _core = require(\"../../core\");\nvar _helpers = require(\"./helpers\");\nvar _elementTypes = require(\"../../constants/element-types\");\nconst withCodeBlock = editor => {\n  const {\n    normalizeNode,\n    insertFragment,\n    insertText,\n    insertBreak,\n    insertData,\n    insertNode,\n    onHotKeyDown\n  } = editor;\n  const newEditor = editor;\n  newEditor.insertData = data => {\n    if (data.types.includes('text/code-block') && !(0, _core.getSelectedNodeByType)(editor, _elementTypes.CODE_BLOCK)) {\n      const codeBlockNode = JSON.parse(data.getData('text/code-block'));\n      return insertNode(codeBlockNode);\n    }\n    insertData(data);\n  };\n  newEditor.insertFragment = data => {\n    // only selected code block content\n    if (data.length === 1 && data[0].type === _elementTypes.CODE_BLOCK && !(0, _core.getSelectedNodeByType)(editor, _elementTypes.CODE_BLOCK)) {\n      data.forEach((node, index) => {\n        if (node.type === _elementTypes.CODE_BLOCK) {\n          const newBlock = node.children.map(line => {\n            const text = _slate.Node.string(line);\n            const children = (0, _core.generateElement)(_elementTypes.PARAGRAPH, {\n              childrenOrText: text\n            });\n            return children;\n          });\n          data.splice(index, 1, ...newBlock);\n        }\n      });\n      return insertFragment(data);\n    } else {\n      if ((0, _core.getSelectedNodeByType)(editor, _elementTypes.CODE_BLOCK)) {\n        // Paste into code block\n\n        // Pasted data is code block split with code-line\n        data.forEach((node, index) => {\n          if (node.type === _elementTypes.CODE_BLOCK) {\n            const codeLineArr = node.children.map(line => line);\n            data.splice(index, 1, ...codeLineArr);\n            // Paste the copied content in place in code_block\n          } else if (node.type === _elementTypes.CODE_LINE) {\n            data.splice(index, 1, node);\n          }\n        });\n        const insertCodeLines = data.map(node => {\n          const text = _slate.Node.string(node);\n          const codeLine = (0, _core.generateElement)(_elementTypes.CODE_LINE, {\n            childrenOrText: text\n          });\n          return codeLine;\n        });\n\n        // Current focus code-line string not empty\n        const string = _slate.Editor.string(newEditor, newEditor.selection.focus.path);\n        // Paste the copied content in place in code_block\n        if (insertCodeLines.length === 1 && _slate.Range.isExpanded(newEditor.selection)) {\n          const text = _slate.Node.string(insertCodeLines[0]);\n          insertText(text);\n          return;\n        }\n        if (string.length !== 0 && _slate.Range.isCollapsed(newEditor.selection)) {\n          const [node, ...restNode] = insertCodeLines;\n          const text = _slate.Node.string(node);\n          insertText(text);\n          if (restNode.length !== 0) {\n            insertBreak();\n            insertFragment(restNode);\n          }\n          return;\n        }\n        return insertFragment(insertCodeLines);\n      } else {\n        // Paste into not a code block\n        return insertFragment(data);\n      }\n    }\n  };\n\n  // Rewrite normalizeNode\n  newEditor.normalizeNode = _ref => {\n    let [node, path] = _ref;\n    const type = (0, _core.getNodeType)(node);\n    if (type === _elementTypes.CODE_LINE && path.length <= 1) {\n      _slate.Transforms.setNodes(newEditor, {\n        type: _elementTypes.PARAGRAPH\n      }, {\n        at: path\n      });\n      return;\n    }\n    if (type === _elementTypes.CODE_BLOCK) {\n      if (node.children.length === 0) {\n        _slate.Transforms.delete(newEditor, {\n          at: path\n        });\n        return;\n      }\n\n      // code-block is the last node in the editor and needs to be followed by a p node\n      const isLast = (0, _core.isLastNode)(newEditor, node);\n      if (isLast) {\n        const paragraph = (0, _core.generateEmptyElement)(_elementTypes.PARAGRAPH);\n        _slate.Transforms.insertNodes(newEditor, paragraph, {\n          at: [path[0] + 1]\n        });\n      }\n      const isFirst = (0, _core.isFirstNode)(newEditor, node);\n      if (isFirst) {\n        const paragraph = (0, _core.generateEmptyElement)(_elementTypes.PARAGRAPH);\n        _slate.Transforms.insertNodes(newEditor, paragraph, {\n          at: [path[0]]\n        });\n      }\n\n      // Here must be a code node below code-block\n      if ((0, _core.getNodeType)(node.children[0]) !== _elementTypes.CODE_LINE) {\n        _slate.Transforms.unwrapNodes(newEditor);\n        _slate.Transforms.setNodes(newEditor, {\n          type: _elementTypes.PARAGRAPH\n        }, {\n          mode: 'highest'\n        });\n      }\n      if (node.children.length > 1) {\n        node.children.forEach((child, index) => {\n          if (child.type !== _elementTypes.CODE_LINE) {\n            _slate.Transforms.setNodes(newEditor, {\n              type: _elementTypes.CODE_LINE\n            }, {\n              at: [...path, index]\n            });\n          }\n        });\n      }\n    }\n\n    // Perform default behavior\n    return normalizeNode([node, path]);\n  };\n  newEditor.onHotKeyDown = event => {\n    const wrapperCodeBlock = (0, _helpers.getCodeBlockNodeEntry)(newEditor);\n    if (!wrapperCodeBlock) return onHotKeyDown && onHotKeyDown(event);\n    if ((0, _isHotkey.default)('mod+enter', event)) {\n      event.preventDefault();\n      if (newEditor.selection && !_slate.Range.isExpanded(newEditor.selection)) {\n        const path = _slate.Editor.path(newEditor, newEditor.selection);\n        const newParagraphPath = [path[0] + 1];\n        const newParagraph = (0, _core.generateEmptyElement)(_elementTypes.PARAGRAPH);\n        _slate.Transforms.insertNodes(newEditor, newParagraph, {\n          at: newParagraphPath\n        });\n        _slate.Transforms.select(newEditor, newParagraphPath);\n      }\n      return true;\n    }\n    if ((0, _isHotkey.default)('tab', event)) {\n      event.preventDefault();\n      const nodeEntries = _slate.Editor.nodes(newEditor, {\n        mode: 'lowest',\n        match: node => node.type === _elementTypes.CODE_LINE\n      });\n      const nodeEntryList = Array.from(nodeEntries);\n      for (const nodeEntry of nodeEntryList) {\n        const [, path] = nodeEntry;\n        // Insert 4 spaces for easier remove space\n        _slate.Transforms.insertText(newEditor, ' '.repeat(4), {\n          at: {\n            path: [...path, 0],\n            offset: 0\n          }\n        });\n      }\n      const firstCodeLinePath = nodeEntryList.at(0)[1].concat(0);\n      const lastCodeLinePath = nodeEntryList.at(-1)[1].concat(0);\n      const newRange = _slate.Editor.range(newEditor, firstCodeLinePath, lastCodeLinePath);\n      nodeEntryList.length > 1 ? _slate.Transforms.select(newEditor, newRange) : _slate.Transforms.select(newEditor);\n      return true;\n    }\n    if ((0, _isHotkey.default)('shift+tab', event)) {\n      event.preventDefault();\n      // Match the beginning of the line space, delete up to 4 spaces at a time\n      const originSelection = newEditor.selection;\n      const matchBeginSpace = /^\\s*/;\n      const nodeEntries = _slate.Editor.nodes(newEditor, {\n        mode: 'lowest',\n        match: node => node.type === _elementTypes.CODE_LINE\n      });\n      const nodeEntryList = Array.from(nodeEntries);\n      let removedSpaceCount = 0;\n      for (const nodeEntry of nodeEntryList) {\n        const [node, path] = nodeEntry;\n        const spaceNum = _slate.Node.string(node).match(matchBeginSpace);\n        // skip empty line and no space begining line\n        if (!spaceNum || !spaceNum[0].length) continue;\n        const deleteNum = Math.min(spaceNum[0].length, 4);\n        removedSpaceCount += deleteNum;\n        for (let i = 0; i < deleteNum; i++) {\n          _slate.Transforms.select(newEditor, {\n            path: [...path, 0],\n            offset: 0\n          });\n          _slate.Editor.deleteForward(newEditor, {\n            unit: 'character'\n          });\n        }\n      }\n      // Select multiple rows when operating more then one line\n      // Keep cursor location when operating one line\n      if (nodeEntryList.length > 1) {\n        const firstCodeLinePath = nodeEntryList.at(0)[1].concat(0);\n        const lastCodeLinePath = nodeEntryList.at(-1)[1].concat(0);\n        const selectLocation = _slate.Editor.range(newEditor, firstCodeLinePath, lastCodeLinePath);\n        _slate.Transforms.select(newEditor, selectLocation);\n      } else {\n        const {\n          anchor,\n          focus\n        } = originSelection;\n        const isCollapsed = _slate.Range.isCollapsed(originSelection);\n        if (isCollapsed) {\n          const selectLocation = {\n            ...originSelection.focus,\n            offset: originSelection.focus.offset - removedSpaceCount\n          };\n          _slate.Transforms.select(newEditor, selectLocation);\n        } else {\n          const selectLocation = {\n            anchor: {\n              ...anchor,\n              offset: anchor.offset - removedSpaceCount\n            },\n            focus: {\n              ...focus,\n              offset: focus.offset - removedSpaceCount\n            }\n          };\n          _slate.Transforms.select(newEditor, selectLocation);\n        }\n      }\n      return true;\n    }\n    if ((0, _isHotkey.default)('mod+a', event)) {\n      event.preventDefault();\n      const codeBlockEntry = _slate.Editor.nodes(newEditor, {\n        mode: 'highest',\n        match: node => node.type === _elementTypes.CODE_BLOCK\n      });\n      if (!codeBlockEntry) return;\n      const codeBlockEntryList = Array.from(...codeBlockEntry);\n      _slate.Transforms.select(newEditor, codeBlockEntryList[1]);\n      return true;\n    }\n  };\n  return newEditor;\n};\nvar _default = exports.default = withCodeBlock;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}