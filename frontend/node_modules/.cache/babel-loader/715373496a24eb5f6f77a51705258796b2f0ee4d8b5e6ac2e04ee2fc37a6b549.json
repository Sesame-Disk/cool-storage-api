{"ast":null,"code":"/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('vfile').Value} Value\n * @typedef {import('unist').Point} UnistPoint\n */\n\n/**\n *\n * @typedef PointLike\n *   unist point, allowed as input.\n * @property {number | null | undefined} [line]\n *   Line.\n * @property {number | null | undefined} [column]\n *   Column.\n * @property {number | null | undefined} [offset]\n *   Offset.\n *\n * @callback ToPoint\n *   Get the line/column based `Point` for `offset` in the bound indices.\n *\n *   Returns `undefined` when given out of bounds input.\n *\n *   Also implemented in Rust in [`wooorm/markdown-rs`][markdown-rs].\n *\n *   [markdown-rs]: https://github.com/wooorm/markdown-rs/blob/main/src/util/location.rs\n * @param {number | null | undefined} [offset]\n *   Something that should be an `offset.\n * @returns {UnistPoint | undefined}\n *   Point, if `offset` is valid and in-bounds input.\n *\n * @callback ToOffset\n *   Get the `offset` from a line/column based `Point` in the bound indices.\n * @param {PointLike | null | undefined} [point]\n *   Something that should be a `point.\n * @returns {number | undefined}\n *   Offset (`number`) or `undefined` for invalid or out of bounds input.\n *\n * @typedef Location\n *   Accessors for index.\n * @property {ToPoint} toPoint\n *   Get the line/column based `Point` for `offset` in the bound indices.\n * @property {ToOffset} toOffset\n *   Get the `offset` from a line/column based `Point` in the bound indices.\n */\n\nvar search = /\\r?\\n|\\r/g;\n\n/**\n * Create an index of the given document to translate between line/column and\n * offset based positional info.\n *\n * Also implemented in Rust in [`wooorm/markdown-rs`][markdown-rs].\n *\n * [markdown-rs]: https://github.com/wooorm/markdown-rs/blob/main/src/util/location.rs\n *\n * @param {VFile | Value} file\n *   File to index.\n * @returns {Location}\n *   Accessors for index.\n */\nexport function location(file) {\n  var value = String(file);\n  /**\n   * List, where each index is a line number (0-based), and each value is the\n   * byte index *after* where the line ends.\n   *\n   * @type {Array<number>}\n   */\n  var indices = [];\n  search.lastIndex = 0;\n  while (search.test(value)) {\n    indices.push(search.lastIndex);\n  }\n  indices.push(value.length + 1);\n  return {\n    toPoint: toPoint,\n    toOffset: toOffset\n  };\n\n  /** @type {ToPoint} */\n  function toPoint(offset) {\n    var index = -1;\n    if (typeof offset === 'number' && offset > -1 && offset < indices[indices.length - 1]) {\n      while (++index < indices.length) {\n        if (indices[index] > offset) {\n          return {\n            line: index + 1,\n            column: offset - (index > 0 ? indices[index - 1] : 0) + 1,\n            offset: offset\n          };\n        }\n      }\n    }\n  }\n\n  /** @type {ToOffset} */\n  function toOffset(point) {\n    var line = point && point.line;\n    var column = point && point.column;\n    if (typeof line === 'number' && typeof column === 'number' && !Number.isNaN(line) && !Number.isNaN(column) && line - 1 in indices) {\n      var offset = (indices[line - 2] || 0) + column - 1 || 0;\n      if (offset > -1 && offset < indices[indices.length - 1]) {\n        return offset;\n      }\n    }\n  }\n}","map":{"version":3,"names":["search","location","file","value","String","indices","lastIndex","test","push","length","toPoint","toOffset","offset","index","line","column","point","Number","isNaN"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/vfile-location/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('vfile').VFile} VFile\n * @typedef {import('vfile').Value} Value\n * @typedef {import('unist').Point} UnistPoint\n */\n\n/**\n *\n * @typedef PointLike\n *   unist point, allowed as input.\n * @property {number | null | undefined} [line]\n *   Line.\n * @property {number | null | undefined} [column]\n *   Column.\n * @property {number | null | undefined} [offset]\n *   Offset.\n *\n * @callback ToPoint\n *   Get the line/column based `Point` for `offset` in the bound indices.\n *\n *   Returns `undefined` when given out of bounds input.\n *\n *   Also implemented in Rust in [`wooorm/markdown-rs`][markdown-rs].\n *\n *   [markdown-rs]: https://github.com/wooorm/markdown-rs/blob/main/src/util/location.rs\n * @param {number | null | undefined} [offset]\n *   Something that should be an `offset.\n * @returns {UnistPoint | undefined}\n *   Point, if `offset` is valid and in-bounds input.\n *\n * @callback ToOffset\n *   Get the `offset` from a line/column based `Point` in the bound indices.\n * @param {PointLike | null | undefined} [point]\n *   Something that should be a `point.\n * @returns {number | undefined}\n *   Offset (`number`) or `undefined` for invalid or out of bounds input.\n *\n * @typedef Location\n *   Accessors for index.\n * @property {ToPoint} toPoint\n *   Get the line/column based `Point` for `offset` in the bound indices.\n * @property {ToOffset} toOffset\n *   Get the `offset` from a line/column based `Point` in the bound indices.\n */\n\nconst search = /\\r?\\n|\\r/g\n\n/**\n * Create an index of the given document to translate between line/column and\n * offset based positional info.\n *\n * Also implemented in Rust in [`wooorm/markdown-rs`][markdown-rs].\n *\n * [markdown-rs]: https://github.com/wooorm/markdown-rs/blob/main/src/util/location.rs\n *\n * @param {VFile | Value} file\n *   File to index.\n * @returns {Location}\n *   Accessors for index.\n */\nexport function location(file) {\n  const value = String(file)\n  /**\n   * List, where each index is a line number (0-based), and each value is the\n   * byte index *after* where the line ends.\n   *\n   * @type {Array<number>}\n   */\n  const indices = []\n\n  search.lastIndex = 0\n\n  while (search.test(value)) {\n    indices.push(search.lastIndex)\n  }\n\n  indices.push(value.length + 1)\n\n  return {toPoint, toOffset}\n\n  /** @type {ToPoint} */\n  function toPoint(offset) {\n    let index = -1\n\n    if (\n      typeof offset === 'number' &&\n      offset > -1 &&\n      offset < indices[indices.length - 1]\n    ) {\n      while (++index < indices.length) {\n        if (indices[index] > offset) {\n          return {\n            line: index + 1,\n            column: offset - (index > 0 ? indices[index - 1] : 0) + 1,\n            offset\n          }\n        }\n      }\n    }\n  }\n\n  /** @type {ToOffset} */\n  function toOffset(point) {\n    const line = point && point.line\n    const column = point && point.column\n\n    if (\n      typeof line === 'number' &&\n      typeof column === 'number' &&\n      !Number.isNaN(line) &&\n      !Number.isNaN(column) &&\n      line - 1 in indices\n    ) {\n      const offset = (indices[line - 2] || 0) + column - 1 || 0\n\n      if (offset > -1 && offset < indices[indices.length - 1]) {\n        return offset\n      }\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAMA,MAAM,GAAG,WAAW;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,QAAQA,CAACC,IAAI,EAAE;EAC7B,IAAMC,KAAK,GAAGC,MAAM,CAACF,IAAI,CAAC;EAC1B;AACF;AACA;AACA;AACA;AACA;EACE,IAAMG,OAAO,GAAG,EAAE;EAElBL,MAAM,CAACM,SAAS,GAAG,CAAC;EAEpB,OAAON,MAAM,CAACO,IAAI,CAACJ,KAAK,CAAC,EAAE;IACzBE,OAAO,CAACG,IAAI,CAACR,MAAM,CAACM,SAAS,CAAC;EAChC;EAEAD,OAAO,CAACG,IAAI,CAACL,KAAK,CAACM,MAAM,GAAG,CAAC,CAAC;EAE9B,OAAO;IAACC,OAAO,EAAPA,OAAO;IAAEC,QAAQ,EAARA;EAAQ,CAAC;;EAE1B;EACA,SAASD,OAAOA,CAACE,MAAM,EAAE;IACvB,IAAIC,KAAK,GAAG,CAAC,CAAC;IAEd,IACE,OAAOD,MAAM,KAAK,QAAQ,IAC1BA,MAAM,GAAG,CAAC,CAAC,IACXA,MAAM,GAAGP,OAAO,CAACA,OAAO,CAACI,MAAM,GAAG,CAAC,CAAC,EACpC;MACA,OAAO,EAAEI,KAAK,GAAGR,OAAO,CAACI,MAAM,EAAE;QAC/B,IAAIJ,OAAO,CAACQ,KAAK,CAAC,GAAGD,MAAM,EAAE;UAC3B,OAAO;YACLE,IAAI,EAAED,KAAK,GAAG,CAAC;YACfE,MAAM,EAAEH,MAAM,IAAIC,KAAK,GAAG,CAAC,GAAGR,OAAO,CAACQ,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;YACzDD,MAAM,EAANA;UACF,CAAC;QACH;MACF;IACF;EACF;;EAEA;EACA,SAASD,QAAQA,CAACK,KAAK,EAAE;IACvB,IAAMF,IAAI,GAAGE,KAAK,IAAIA,KAAK,CAACF,IAAI;IAChC,IAAMC,MAAM,GAAGC,KAAK,IAAIA,KAAK,CAACD,MAAM;IAEpC,IACE,OAAOD,IAAI,KAAK,QAAQ,IACxB,OAAOC,MAAM,KAAK,QAAQ,IAC1B,CAACE,MAAM,CAACC,KAAK,CAACJ,IAAI,CAAC,IACnB,CAACG,MAAM,CAACC,KAAK,CAACH,MAAM,CAAC,IACrBD,IAAI,GAAG,CAAC,IAAIT,OAAO,EACnB;MACA,IAAMO,MAAM,GAAG,CAACP,OAAO,CAACS,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,IAAIC,MAAM,GAAG,CAAC,IAAI,CAAC;MAEzD,IAAIH,MAAM,GAAG,CAAC,CAAC,IAAIA,MAAM,GAAGP,OAAO,CAACA,OAAO,CAACI,MAAM,GAAG,CAAC,CAAC,EAAE;QACvD,OAAOG,MAAM;MACf;IACF;EACF;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}