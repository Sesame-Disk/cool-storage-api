{"ast":null,"code":"import { simpleMode } from \"./simple-mode.js\";\nvar from = \"from\";\nvar fromRegex = new RegExp(\"^(\\\\s*)\\\\b(\" + from + \")\\\\b\", \"i\");\nvar shells = [\"run\", \"cmd\", \"entrypoint\", \"shell\"];\nvar shellsAsArrayRegex = new RegExp(\"^(\\\\s*)(\" + shells.join('|') + \")(\\\\s+\\\\[)\", \"i\");\nvar expose = \"expose\";\nvar exposeRegex = new RegExp(\"^(\\\\s*)(\" + expose + \")(\\\\s+)\", \"i\");\nvar others = [\"arg\", \"from\", \"maintainer\", \"label\", \"env\", \"add\", \"copy\", \"volume\", \"user\", \"workdir\", \"onbuild\", \"stopsignal\", \"healthcheck\", \"shell\"];\n\n// Collect all Dockerfile directives\nvar instructions = [from, expose].concat(shells).concat(others),\n  instructionRegex = \"(\" + instructions.join('|') + \")\",\n  instructionOnlyLine = new RegExp(\"^(\\\\s*)\" + instructionRegex + \"(\\\\s*)(#.*)?$\", \"i\"),\n  instructionWithArguments = new RegExp(\"^(\\\\s*)\" + instructionRegex + \"(\\\\s+)\", \"i\");\nexport var dockerFile = simpleMode({\n  start: [\n  // Block comment: This is a line starting with a comment\n  {\n    regex: /^\\s*#.*$/,\n    sol: true,\n    token: \"comment\"\n  }, {\n    regex: fromRegex,\n    token: [null, \"keyword\"],\n    sol: true,\n    next: \"from\"\n  },\n  // Highlight an instruction without any arguments (for convenience)\n  {\n    regex: instructionOnlyLine,\n    token: [null, \"keyword\", null, \"error\"],\n    sol: true\n  }, {\n    regex: shellsAsArrayRegex,\n    token: [null, \"keyword\", null],\n    sol: true,\n    next: \"array\"\n  }, {\n    regex: exposeRegex,\n    token: [null, \"keyword\", null],\n    sol: true,\n    next: \"expose\"\n  },\n  // Highlight an instruction followed by arguments\n  {\n    regex: instructionWithArguments,\n    token: [null, \"keyword\", null],\n    sol: true,\n    next: \"arguments\"\n  }, {\n    regex: /./,\n    token: null\n  }],\n  from: [{\n    regex: /\\s*$/,\n    token: null,\n    next: \"start\"\n  }, {\n    // Line comment without instruction arguments is an error\n    regex: /(\\s*)(#.*)$/,\n    token: [null, \"error\"],\n    next: \"start\"\n  }, {\n    regex: /(\\s*\\S+\\s+)(as)/i,\n    token: [null, \"keyword\"],\n    next: \"start\"\n  },\n  // Fail safe return to start\n  {\n    token: null,\n    next: \"start\"\n  }],\n  single: [{\n    regex: /(?:[^\\\\']|\\\\.)/,\n    token: \"string\"\n  }, {\n    regex: /'/,\n    token: \"string\",\n    pop: true\n  }],\n  double: [{\n    regex: /(?:[^\\\\\"]|\\\\.)/,\n    token: \"string\"\n  }, {\n    regex: /\"/,\n    token: \"string\",\n    pop: true\n  }],\n  array: [{\n    regex: /\\]/,\n    token: null,\n    next: \"start\"\n  }, {\n    regex: /\"(?:[^\\\\\"]|\\\\.)*\"?/,\n    token: \"string\"\n  }],\n  expose: [{\n    regex: /\\d+$/,\n    token: \"number\",\n    next: \"start\"\n  }, {\n    regex: /[^\\d]+$/,\n    token: null,\n    next: \"start\"\n  }, {\n    regex: /\\d+/,\n    token: \"number\"\n  }, {\n    regex: /[^\\d]+/,\n    token: null\n  },\n  // Fail safe return to start\n  {\n    token: null,\n    next: \"start\"\n  }],\n  arguments: [{\n    regex: /^\\s*#.*$/,\n    sol: true,\n    token: \"comment\"\n  }, {\n    regex: /\"(?:[^\\\\\"]|\\\\.)*\"?$/,\n    token: \"string\",\n    next: \"start\"\n  }, {\n    regex: /\"/,\n    token: \"string\",\n    push: \"double\"\n  }, {\n    regex: /'(?:[^\\\\']|\\\\.)*'?$/,\n    token: \"string\",\n    next: \"start\"\n  }, {\n    regex: /'/,\n    token: \"string\",\n    push: \"single\"\n  }, {\n    regex: /[^#\"']+[\\\\`]$/,\n    token: null\n  }, {\n    regex: /[^#\"']+$/,\n    token: null,\n    next: \"start\"\n  }, {\n    regex: /[^#\"']+/,\n    token: null\n  },\n  // Fail safe return to start\n  {\n    token: null,\n    next: \"start\"\n  }],\n  languageData: {\n    commentTokens: {\n      line: \"#\"\n    }\n  }\n});","map":{"version":3,"names":["simpleMode","from","fromRegex","RegExp","shells","shellsAsArrayRegex","join","expose","exposeRegex","others","instructions","concat","instructionRegex","instructionOnlyLine","instructionWithArguments","dockerFile","start","regex","sol","token","next","single","pop","double","array","arguments","push","languageData","commentTokens","line"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@codemirror/legacy-modes/mode/dockerfile.js"],"sourcesContent":["import {simpleMode} from \"./simple-mode.js\"\n\nvar from = \"from\";\nvar fromRegex = new RegExp(\"^(\\\\s*)\\\\b(\" + from + \")\\\\b\", \"i\");\n\nvar shells = [\"run\", \"cmd\", \"entrypoint\", \"shell\"];\nvar shellsAsArrayRegex = new RegExp(\"^(\\\\s*)(\" + shells.join('|') + \")(\\\\s+\\\\[)\", \"i\");\n\nvar expose = \"expose\";\nvar exposeRegex = new RegExp(\"^(\\\\s*)(\" + expose + \")(\\\\s+)\", \"i\");\n\nvar others = [\n  \"arg\", \"from\", \"maintainer\", \"label\", \"env\",\n  \"add\", \"copy\", \"volume\", \"user\",\n  \"workdir\", \"onbuild\", \"stopsignal\", \"healthcheck\", \"shell\"\n];\n\n// Collect all Dockerfile directives\nvar instructions = [from, expose].concat(shells).concat(others),\n    instructionRegex = \"(\" + instructions.join('|') + \")\",\n    instructionOnlyLine = new RegExp(\"^(\\\\s*)\" + instructionRegex + \"(\\\\s*)(#.*)?$\", \"i\"),\n    instructionWithArguments = new RegExp(\"^(\\\\s*)\" + instructionRegex + \"(\\\\s+)\", \"i\");\n\nexport const dockerFile = simpleMode({\n  start: [\n    // Block comment: This is a line starting with a comment\n    {\n      regex: /^\\s*#.*$/,\n      sol: true,\n      token: \"comment\"\n    },\n    {\n      regex: fromRegex,\n      token: [null, \"keyword\"],\n      sol: true,\n      next: \"from\"\n    },\n    // Highlight an instruction without any arguments (for convenience)\n    {\n      regex: instructionOnlyLine,\n      token: [null, \"keyword\", null, \"error\"],\n      sol: true\n    },\n    {\n      regex: shellsAsArrayRegex,\n      token: [null, \"keyword\", null],\n      sol: true,\n      next: \"array\"\n    },\n    {\n      regex: exposeRegex,\n      token: [null, \"keyword\", null],\n      sol: true,\n      next: \"expose\"\n    },\n    // Highlight an instruction followed by arguments\n    {\n      regex: instructionWithArguments,\n      token: [null, \"keyword\", null],\n      sol: true,\n      next: \"arguments\"\n    },\n    {\n      regex: /./,\n      token: null\n    }\n  ],\n  from: [\n    {\n      regex: /\\s*$/,\n      token: null,\n      next: \"start\"\n    },\n    {\n      // Line comment without instruction arguments is an error\n      regex: /(\\s*)(#.*)$/,\n      token: [null, \"error\"],\n      next: \"start\"\n    },\n    {\n      regex: /(\\s*\\S+\\s+)(as)/i,\n      token: [null, \"keyword\"],\n      next: \"start\"\n    },\n    // Fail safe return to start\n    {\n      token: null,\n      next: \"start\"\n    }\n  ],\n  single: [\n    {\n      regex: /(?:[^\\\\']|\\\\.)/,\n      token: \"string\"\n    },\n    {\n      regex: /'/,\n      token: \"string\",\n      pop: true\n    }\n  ],\n  double: [\n    {\n      regex: /(?:[^\\\\\"]|\\\\.)/,\n      token: \"string\"\n    },\n    {\n      regex: /\"/,\n      token: \"string\",\n      pop: true\n    }\n  ],\n  array: [\n    {\n      regex: /\\]/,\n      token: null,\n      next: \"start\"\n    },\n    {\n      regex: /\"(?:[^\\\\\"]|\\\\.)*\"?/,\n      token: \"string\"\n    }\n  ],\n  expose: [\n    {\n      regex: /\\d+$/,\n      token: \"number\",\n      next: \"start\"\n    },\n    {\n      regex: /[^\\d]+$/,\n      token: null,\n      next: \"start\"\n    },\n    {\n      regex: /\\d+/,\n      token: \"number\"\n    },\n    {\n      regex: /[^\\d]+/,\n      token: null\n    },\n    // Fail safe return to start\n    {\n      token: null,\n      next: \"start\"\n    }\n  ],\n  arguments: [\n    {\n      regex: /^\\s*#.*$/,\n      sol: true,\n      token: \"comment\"\n    },\n    {\n      regex: /\"(?:[^\\\\\"]|\\\\.)*\"?$/,\n      token: \"string\",\n      next: \"start\"\n    },\n    {\n      regex: /\"/,\n      token: \"string\",\n      push: \"double\"\n    },\n    {\n      regex: /'(?:[^\\\\']|\\\\.)*'?$/,\n      token: \"string\",\n      next: \"start\"\n    },\n    {\n      regex: /'/,\n      token: \"string\",\n      push: \"single\"\n    },\n    {\n      regex: /[^#\"']+[\\\\`]$/,\n      token: null\n    },\n    {\n      regex: /[^#\"']+$/,\n      token: null,\n      next: \"start\"\n    },\n    {\n      regex: /[^#\"']+/,\n      token: null\n    },\n    // Fail safe return to start\n    {\n      token: null,\n      next: \"start\"\n    }\n  ],\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n});\n\n"],"mappings":"AAAA,SAAQA,UAAU,QAAO,kBAAkB;AAE3C,IAAIC,IAAI,GAAG,MAAM;AACjB,IAAIC,SAAS,GAAG,IAAIC,MAAM,CAAC,aAAa,GAAGF,IAAI,GAAG,MAAM,EAAE,GAAG,CAAC;AAE9D,IAAIG,MAAM,GAAG,CAAC,KAAK,EAAE,KAAK,EAAE,YAAY,EAAE,OAAO,CAAC;AAClD,IAAIC,kBAAkB,GAAG,IAAIF,MAAM,CAAC,UAAU,GAAGC,MAAM,CAACE,IAAI,CAAC,GAAG,CAAC,GAAG,YAAY,EAAE,GAAG,CAAC;AAEtF,IAAIC,MAAM,GAAG,QAAQ;AACrB,IAAIC,WAAW,GAAG,IAAIL,MAAM,CAAC,UAAU,GAAGI,MAAM,GAAG,SAAS,EAAE,GAAG,CAAC;AAElE,IAAIE,MAAM,GAAG,CACX,KAAK,EAAE,MAAM,EAAE,YAAY,EAAE,OAAO,EAAE,KAAK,EAC3C,KAAK,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,EAC/B,SAAS,EAAE,SAAS,EAAE,YAAY,EAAE,aAAa,EAAE,OAAO,CAC3D;;AAED;AACA,IAAIC,YAAY,GAAG,CAACT,IAAI,EAAEM,MAAM,CAAC,CAACI,MAAM,CAACP,MAAM,CAAC,CAACO,MAAM,CAACF,MAAM,CAAC;EAC3DG,gBAAgB,GAAG,GAAG,GAAGF,YAAY,CAACJ,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG;EACrDO,mBAAmB,GAAG,IAAIV,MAAM,CAAC,SAAS,GAAGS,gBAAgB,GAAG,eAAe,EAAE,GAAG,CAAC;EACrFE,wBAAwB,GAAG,IAAIX,MAAM,CAAC,SAAS,GAAGS,gBAAgB,GAAG,QAAQ,EAAE,GAAG,CAAC;AAEvF,OAAO,IAAMG,UAAU,GAAGf,UAAU,CAAC;EACnCgB,KAAK,EAAE;EACL;EACA;IACEC,KAAK,EAAE,UAAU;IACjBC,GAAG,EAAE,IAAI;IACTC,KAAK,EAAE;EACT,CAAC,EACD;IACEF,KAAK,EAAEf,SAAS;IAChBiB,KAAK,EAAE,CAAC,IAAI,EAAE,SAAS,CAAC;IACxBD,GAAG,EAAE,IAAI;IACTE,IAAI,EAAE;EACR,CAAC;EACD;EACA;IACEH,KAAK,EAAEJ,mBAAmB;IAC1BM,KAAK,EAAE,CAAC,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,OAAO,CAAC;IACvCD,GAAG,EAAE;EACP,CAAC,EACD;IACED,KAAK,EAAEZ,kBAAkB;IACzBc,KAAK,EAAE,CAAC,IAAI,EAAE,SAAS,EAAE,IAAI,CAAC;IAC9BD,GAAG,EAAE,IAAI;IACTE,IAAI,EAAE;EACR,CAAC,EACD;IACEH,KAAK,EAAET,WAAW;IAClBW,KAAK,EAAE,CAAC,IAAI,EAAE,SAAS,EAAE,IAAI,CAAC;IAC9BD,GAAG,EAAE,IAAI;IACTE,IAAI,EAAE;EACR,CAAC;EACD;EACA;IACEH,KAAK,EAAEH,wBAAwB;IAC/BK,KAAK,EAAE,CAAC,IAAI,EAAE,SAAS,EAAE,IAAI,CAAC;IAC9BD,GAAG,EAAE,IAAI;IACTE,IAAI,EAAE;EACR,CAAC,EACD;IACEH,KAAK,EAAE,GAAG;IACVE,KAAK,EAAE;EACT,CAAC,CACF;EACDlB,IAAI,EAAE,CACJ;IACEgB,KAAK,EAAE,MAAM;IACbE,KAAK,EAAE,IAAI;IACXC,IAAI,EAAE;EACR,CAAC,EACD;IACE;IACAH,KAAK,EAAE,aAAa;IACpBE,KAAK,EAAE,CAAC,IAAI,EAAE,OAAO,CAAC;IACtBC,IAAI,EAAE;EACR,CAAC,EACD;IACEH,KAAK,EAAE,kBAAkB;IACzBE,KAAK,EAAE,CAAC,IAAI,EAAE,SAAS,CAAC;IACxBC,IAAI,EAAE;EACR,CAAC;EACD;EACA;IACED,KAAK,EAAE,IAAI;IACXC,IAAI,EAAE;EACR,CAAC,CACF;EACDC,MAAM,EAAE,CACN;IACEJ,KAAK,EAAE,gBAAgB;IACvBE,KAAK,EAAE;EACT,CAAC,EACD;IACEF,KAAK,EAAE,GAAG;IACVE,KAAK,EAAE,QAAQ;IACfG,GAAG,EAAE;EACP,CAAC,CACF;EACDC,MAAM,EAAE,CACN;IACEN,KAAK,EAAE,gBAAgB;IACvBE,KAAK,EAAE;EACT,CAAC,EACD;IACEF,KAAK,EAAE,GAAG;IACVE,KAAK,EAAE,QAAQ;IACfG,GAAG,EAAE;EACP,CAAC,CACF;EACDE,KAAK,EAAE,CACL;IACEP,KAAK,EAAE,IAAI;IACXE,KAAK,EAAE,IAAI;IACXC,IAAI,EAAE;EACR,CAAC,EACD;IACEH,KAAK,EAAE,oBAAoB;IAC3BE,KAAK,EAAE;EACT,CAAC,CACF;EACDZ,MAAM,EAAE,CACN;IACEU,KAAK,EAAE,MAAM;IACbE,KAAK,EAAE,QAAQ;IACfC,IAAI,EAAE;EACR,CAAC,EACD;IACEH,KAAK,EAAE,SAAS;IAChBE,KAAK,EAAE,IAAI;IACXC,IAAI,EAAE;EACR,CAAC,EACD;IACEH,KAAK,EAAE,KAAK;IACZE,KAAK,EAAE;EACT,CAAC,EACD;IACEF,KAAK,EAAE,QAAQ;IACfE,KAAK,EAAE;EACT,CAAC;EACD;EACA;IACEA,KAAK,EAAE,IAAI;IACXC,IAAI,EAAE;EACR,CAAC,CACF;EACDK,SAAS,EAAE,CACT;IACER,KAAK,EAAE,UAAU;IACjBC,GAAG,EAAE,IAAI;IACTC,KAAK,EAAE;EACT,CAAC,EACD;IACEF,KAAK,EAAE,qBAAqB;IAC5BE,KAAK,EAAE,QAAQ;IACfC,IAAI,EAAE;EACR,CAAC,EACD;IACEH,KAAK,EAAE,GAAG;IACVE,KAAK,EAAE,QAAQ;IACfO,IAAI,EAAE;EACR,CAAC,EACD;IACET,KAAK,EAAE,qBAAqB;IAC5BE,KAAK,EAAE,QAAQ;IACfC,IAAI,EAAE;EACR,CAAC,EACD;IACEH,KAAK,EAAE,GAAG;IACVE,KAAK,EAAE,QAAQ;IACfO,IAAI,EAAE;EACR,CAAC,EACD;IACET,KAAK,EAAE,eAAe;IACtBE,KAAK,EAAE;EACT,CAAC,EACD;IACEF,KAAK,EAAE,UAAU;IACjBE,KAAK,EAAE,IAAI;IACXC,IAAI,EAAE;EACR,CAAC,EACD;IACEH,KAAK,EAAE,SAAS;IAChBE,KAAK,EAAE;EACT,CAAC;EACD;EACA;IACEA,KAAK,EAAE,IAAI;IACXC,IAAI,EAAE;EACR,CAAC,CACF;EACDO,YAAY,EAAE;IACZC,aAAa,EAAE;MAACC,IAAI,EAAE;IAAG;EAC3B;AACF,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}