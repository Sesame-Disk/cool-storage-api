{"ast":null,"code":"// Tokenizer\n\nfunction kw(type) {\n  return {\n    type: type,\n    style: \"keyword\"\n  };\n}\nvar A = kw(\"keyword a\"),\n  B = kw(\"keyword b\"),\n  C = kw(\"keyword c\");\nvar operator = kw(\"operator\"),\n  atom = {\n    type: \"atom\",\n    style: \"atom\"\n  },\n  attribute = {\n    type: \"attribute\",\n    style: \"attribute\"\n  };\nvar type = kw(\"typedef\");\nvar keywords = {\n  \"if\": A,\n  \"while\": A,\n  \"else\": B,\n  \"do\": B,\n  \"try\": B,\n  \"return\": C,\n  \"break\": C,\n  \"continue\": C,\n  \"new\": C,\n  \"throw\": C,\n  \"var\": kw(\"var\"),\n  \"inline\": attribute,\n  \"static\": attribute,\n  \"using\": kw(\"import\"),\n  \"public\": attribute,\n  \"private\": attribute,\n  \"cast\": kw(\"cast\"),\n  \"import\": kw(\"import\"),\n  \"macro\": kw(\"macro\"),\n  \"function\": kw(\"function\"),\n  \"catch\": kw(\"catch\"),\n  \"untyped\": kw(\"untyped\"),\n  \"callback\": kw(\"cb\"),\n  \"for\": kw(\"for\"),\n  \"switch\": kw(\"switch\"),\n  \"case\": kw(\"case\"),\n  \"default\": kw(\"default\"),\n  \"in\": operator,\n  \"never\": kw(\"property_access\"),\n  \"trace\": kw(\"trace\"),\n  \"class\": type,\n  \"abstract\": type,\n  \"enum\": type,\n  \"interface\": type,\n  \"typedef\": type,\n  \"extends\": type,\n  \"implements\": type,\n  \"dynamic\": type,\n  \"true\": atom,\n  \"false\": atom,\n  \"null\": atom\n};\nvar isOperatorChar = /[+\\-*&%=<>!?|]/;\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\nfunction toUnescaped(stream, end) {\n  var escaped = false,\n    next;\n  while ((next = stream.next()) != null) {\n    if (next == end && !escaped) return true;\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\n\n// Used as scratch variables to communicate multiple values without\n// consing up tons of objects.\nvar type, content;\nfunction ret(tp, style, cont) {\n  type = tp;\n  content = cont;\n  return style;\n}\nfunction haxeTokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == '\"' || ch == \"'\") {\n    return chain(stream, state, haxeTokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    return ret(ch);\n  } else if (ch == \"0\" && stream.eat(/x/i)) {\n    stream.eatWhile(/[\\da-f]/i);\n    return ret(\"number\", \"number\");\n  } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n    stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n    return ret(\"number\", \"number\");\n  } else if (state.reAllowed && ch == \"~\" && stream.eat(/\\//)) {\n    toUnescaped(stream, \"/\");\n    stream.eatWhile(/[gimsu]/);\n    return ret(\"regexp\", \"string.special\");\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      return chain(stream, state, haxeTokenComment);\n    } else if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return ret(\"comment\", \"comment\");\n    } else {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n  } else if (ch == \"#\") {\n    stream.skipToEnd();\n    return ret(\"conditional\", \"meta\");\n  } else if (ch == \"@\") {\n    stream.eat(/:/);\n    stream.eatWhile(/[\\w_]/);\n    return ret(\"metadata\", \"meta\");\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return ret(\"operator\", null, stream.current());\n  } else {\n    var word;\n    if (/[A-Z]/.test(ch)) {\n      stream.eatWhile(/[\\w_<>]/);\n      word = stream.current();\n      return ret(\"type\", \"type\", word);\n    } else {\n      stream.eatWhile(/[\\w_]/);\n      var word = stream.current(),\n        known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return known && state.kwAllowed ? ret(known.type, known.style, word) : ret(\"variable\", \"variable\", word);\n    }\n  }\n}\nfunction haxeTokenString(quote) {\n  return function (stream, state) {\n    if (toUnescaped(stream, quote)) state.tokenize = haxeTokenBase;\n    return ret(\"string\", \"string\");\n  };\n}\nfunction haxeTokenComment(stream, state) {\n  var maybeEnd = false,\n    ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = haxeTokenBase;\n      break;\n    }\n    maybeEnd = ch == \"*\";\n  }\n  return ret(\"comment\", \"comment\");\n}\n\n// Parser\n\nvar atomicTypes = {\n  \"atom\": true,\n  \"number\": true,\n  \"variable\": true,\n  \"string\": true,\n  \"regexp\": true\n};\nfunction HaxeLexical(indented, column, type, align, prev, info) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.prev = prev;\n  this.info = info;\n  if (align != null) this.align = align;\n}\nfunction inScope(state, varname) {\n  for (var v = state.localVars; v; v = v.next) if (v.name == varname) return true;\n}\nfunction parseHaxe(state, style, type, content, stream) {\n  var cc = state.cc;\n  // Communicate our context to the combinators.\n  // (Less wasteful than consing up a hundred closures on every call.)\n  cx.state = state;\n  cx.stream = stream;\n  cx.marked = null, cx.cc = cc;\n  if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = true;\n  while (true) {\n    var combinator = cc.length ? cc.pop() : statement;\n    if (combinator(type, content)) {\n      while (cc.length && cc[cc.length - 1].lex) cc.pop()();\n      if (cx.marked) return cx.marked;\n      if (type == \"variable\" && inScope(state, content)) return \"variableName.local\";\n      if (type == \"variable\" && imported(state, content)) return \"variableName.special\";\n      return style;\n    }\n  }\n}\nfunction imported(state, typename) {\n  if (/[a-z]/.test(typename.charAt(0))) return false;\n  var len = state.importedtypes.length;\n  for (var i = 0; i < len; i++) if (state.importedtypes[i] == typename) return true;\n}\nfunction registerimport(importname) {\n  var state = cx.state;\n  for (var t = state.importedtypes; t; t = t.next) if (t.name == importname) return;\n  state.importedtypes = {\n    name: importname,\n    next: state.importedtypes\n  };\n}\n// Combinator utils\n\nvar cx = {\n  state: null,\n  column: null,\n  marked: null,\n  cc: null\n};\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n}\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\nfunction inList(name, list) {\n  for (var v = list; v; v = v.next) if (v.name == name) return true;\n  return false;\n}\nfunction register(varname) {\n  var state = cx.state;\n  if (state.context) {\n    cx.marked = \"def\";\n    if (inList(varname, state.localVars)) return;\n    state.localVars = {\n      name: varname,\n      next: state.localVars\n    };\n  } else if (state.globalVars) {\n    if (inList(varname, state.globalVars)) return;\n    state.globalVars = {\n      name: varname,\n      next: state.globalVars\n    };\n  }\n}\n\n// Combinators\n\nvar defaultVars = {\n  name: \"this\",\n  next: null\n};\nfunction pushcontext() {\n  if (!cx.state.context) cx.state.localVars = defaultVars;\n  cx.state.context = {\n    prev: cx.state.context,\n    vars: cx.state.localVars\n  };\n}\nfunction popcontext() {\n  cx.state.localVars = cx.state.context.vars;\n  cx.state.context = cx.state.context.prev;\n}\npopcontext.lex = true;\nfunction pushlex(type, info) {\n  var result = function result() {\n    var state = cx.state;\n    state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n  };\n  result.lex = true;\n  return result;\n}\nfunction poplex() {\n  var state = cx.state;\n  if (state.lexical.prev) {\n    if (state.lexical.type == \")\") state.indented = state.lexical.indented;\n    state.lexical = state.lexical.prev;\n  }\n}\npoplex.lex = true;\nfunction expect(wanted) {\n  function f(type) {\n    if (type == wanted) return cont();else if (wanted == \";\") return pass();else return cont(f);\n  }\n  return f;\n}\nfunction statement(type) {\n  if (type == \"@\") return cont(metadef);\n  if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n  if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n  if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n  if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n  if (type == \";\") return cont();\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"), poplex, statement, poplex);\n  if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n  if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"), block, poplex, poplex);\n  if (type == \"case\") return cont(expression, expect(\":\"));\n  if (type == \"default\") return cont(expect(\":\"));\n  if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"), statement, poplex, popcontext);\n  if (type == \"import\") return cont(importdef, expect(\";\"));\n  if (type == \"typedef\") return cont(typedef);\n  return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n}\nfunction expression(type) {\n  if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n  if (type == \"type\") return cont(maybeoperator);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"keyword c\") return cont(maybeexpression);\n  if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n  if (type == \"operator\") return cont(expression);\n  if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n  return cont();\n}\nfunction maybeexpression(type) {\n  if (type.match(/[;\\}\\)\\],]/)) return pass();\n  return pass(expression);\n}\nfunction maybeoperator(type, value) {\n  if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n  if (type == \"operator\" || type == \":\") return cont(expression);\n  if (type == \";\") return;\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n  if (type == \".\") return cont(property, maybeoperator);\n  if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n}\nfunction maybeattribute(type) {\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"var\") return cont(vardef1);\n}\nfunction metadef(type) {\n  if (type == \":\") return cont(metadef);\n  if (type == \"variable\") return cont(metadef);\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n}\nfunction metaargs(type) {\n  if (type == \"variable\") return cont();\n}\nfunction importdef(type, value) {\n  if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n    registerimport(value);\n    return cont();\n  } else if (type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n}\nfunction typedef(type, value) {\n  if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n    registerimport(value);\n    return cont();\n  } else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) {\n    return cont();\n  }\n}\nfunction maybelabel(type) {\n  if (type == \":\") return cont(poplex, statement);\n  return pass(maybeoperator, expect(\";\"), poplex);\n}\nfunction property(type) {\n  if (type == \"variable\") {\n    cx.marked = \"property\";\n    return cont();\n  }\n}\nfunction objprop(type) {\n  if (type == \"variable\") cx.marked = \"property\";\n  if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n}\nfunction commasep(what, end) {\n  function proceed(type) {\n    if (type == \",\") return cont(what, proceed);\n    if (type == end) return cont();\n    return cont(expect(end));\n  }\n  return function (type) {\n    if (type == end) return cont();else return pass(what, proceed);\n  };\n}\nfunction block(type) {\n  if (type == \"}\") return cont();\n  return pass(statement, block);\n}\nfunction vardef1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(typeuse, vardef2);\n  }\n  return cont();\n}\nfunction vardef2(type, value) {\n  if (value == \"=\") return cont(expression, vardef2);\n  if (type == \",\") return cont(vardef1);\n}\nfunction forspec1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(forin, expression);\n  } else {\n    return pass();\n  }\n}\nfunction forin(_type, value) {\n  if (value == \"in\") return cont();\n}\nfunction functiondef(type, value) {\n  //function names starting with upper-case letters are recognised as types, so cludging them together here.\n  if (type == \"variable\" || type == \"type\") {\n    register(value);\n    return cont(functiondef);\n  }\n  if (value == \"new\") return cont(functiondef);\n  if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n}\nfunction typeuse(type) {\n  if (type == \":\") return cont(typestring);\n}\nfunction typestring(type) {\n  if (type == \"type\") return cont();\n  if (type == \"variable\") return cont();\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n}\nfunction typeprop(type) {\n  if (type == \"variable\") return cont(typeuse);\n}\nfunction funarg(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(typeuse);\n  }\n}\n\n// Interface\nexport var haxe = {\n  name: \"haxe\",\n  startState: function startState(indentUnit) {\n    var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n    var state = {\n      tokenize: haxeTokenBase,\n      reAllowed: true,\n      kwAllowed: true,\n      cc: [],\n      lexical: new HaxeLexical(-indentUnit, 0, \"block\", false),\n      importedtypes: defaulttypes,\n      context: null,\n      indented: 0\n    };\n    return state;\n  },\n  token: function token(stream, state) {\n    if (stream.sol()) {\n      if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = false;\n      state.indented = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    if (type == \"comment\") return style;\n    state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n    state.kwAllowed = type != '.';\n    return parseHaxe(state, style, type, content, stream);\n  },\n  indent: function indent(state, textAfter, cx) {\n    if (state.tokenize != haxeTokenBase) return 0;\n    var firstChar = textAfter && textAfter.charAt(0),\n      lexical = state.lexical;\n    if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n    var type = lexical.type,\n      closing = firstChar == type;\n    if (type == \"vardef\") return lexical.indented + 4;else if (type == \"form\" && firstChar == \"{\") return lexical.indented;else if (type == \"stat\" || type == \"form\") return lexical.indented + cx.unit;else if (lexical.info == \"switch\" && !closing) return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : cx.unit);\n  },\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    }\n  }\n};\nexport var hxml = {\n  name: \"hxml\",\n  startState: function startState() {\n    return {\n      define: false,\n      inString: false\n    };\n  },\n  token: function token(stream, state) {\n    var ch = stream.peek();\n    var sol = stream.sol();\n\n    ///* comments */\n    if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n    if (sol && ch == \"-\") {\n      var style = \"variable-2\";\n      stream.eat(/-/);\n      if (stream.peek() == \"-\") {\n        stream.eat(/-/);\n        style = \"keyword a\";\n      }\n      if (stream.peek() == \"D\") {\n        stream.eat(/[D]/);\n        style = \"keyword c\";\n        state.define = true;\n      }\n      stream.eatWhile(/[A-Z]/i);\n      return style;\n    }\n    var ch = stream.peek();\n    if (state.inString == false && ch == \"'\") {\n      state.inString = true;\n      stream.next();\n    }\n    if (state.inString == true) {\n      if (stream.skipTo(\"'\")) {} else {\n        stream.skipToEnd();\n      }\n      if (stream.peek() == \"'\") {\n        stream.next();\n        state.inString = false;\n      }\n      return \"string\";\n    }\n    stream.next();\n    return null;\n  },\n  languageData: {\n    commentTokens: {\n      line: \"#\"\n    }\n  }\n};","map":{"version":3,"names":["kw","type","style","A","B","C","operator","atom","attribute","keywords","isOperatorChar","chain","stream","state","f","tokenize","toUnescaped","end","escaped","next","content","ret","tp","cont","haxeTokenBase","ch","haxeTokenString","test","eat","eatWhile","match","reAllowed","haxeTokenComment","skipToEnd","current","word","known","propertyIsEnumerable","kwAllowed","quote","maybeEnd","atomicTypes","HaxeLexical","indented","column","align","prev","info","inScope","varname","v","localVars","name","parseHaxe","cc","cx","marked","lexical","hasOwnProperty","combinator","length","pop","statement","lex","imported","typename","charAt","len","importedtypes","i","registerimport","importname","t","pass","arguments","push","apply","inList","list","register","context","globalVars","defaultVars","pushcontext","vars","popcontext","pushlex","result","poplex","expect","wanted","metadef","vardef1","expression","block","maybeattribute","functiondef","forspec1","maybelabel","funarg","importdef","typedef","maybeoperator","maybeexpression","commasep","objprop","value","property","metaargs","what","proceed","typeuse","vardef2","forin","_type","typestring","typeprop","haxe","startState","indentUnit","defaulttypes","token","sol","indentation","eatSpace","indent","textAfter","firstChar","closing","unit","languageData","indentOnInput","commentTokens","line","open","close","hxml","define","inString","peek","skipTo"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@codemirror/legacy-modes/mode/haxe.js"],"sourcesContent":["// Tokenizer\n\nfunction kw(type) {return {type: type, style: \"keyword\"};}\nvar A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\nvar operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"}, attribute = {type:\"attribute\", style: \"attribute\"};\nvar type = kw(\"typedef\");\nvar keywords = {\n  \"if\": A, \"while\": A, \"else\": B, \"do\": B, \"try\": B,\n  \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"throw\": C,\n  \"var\": kw(\"var\"), \"inline\":attribute, \"static\": attribute, \"using\":kw(\"import\"),\n  \"public\": attribute, \"private\": attribute, \"cast\": kw(\"cast\"), \"import\": kw(\"import\"), \"macro\": kw(\"macro\"),\n  \"function\": kw(\"function\"), \"catch\": kw(\"catch\"), \"untyped\": kw(\"untyped\"), \"callback\": kw(\"cb\"),\n  \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n  \"in\": operator, \"never\": kw(\"property_access\"), \"trace\":kw(\"trace\"),\n  \"class\": type, \"abstract\":type, \"enum\":type, \"interface\":type, \"typedef\":type, \"extends\":type, \"implements\":type, \"dynamic\":type,\n  \"true\": atom, \"false\": atom, \"null\": atom\n};\n\nvar isOperatorChar = /[+\\-*&%=<>!?|]/;\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\nfunction toUnescaped(stream, end) {\n  var escaped = false, next;\n  while ((next = stream.next()) != null) {\n    if (next == end && !escaped)\n      return true;\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\n\n// Used as scratch variables to communicate multiple values without\n// consing up tons of objects.\nvar type, content;\nfunction ret(tp, style, cont) {\n  type = tp; content = cont;\n  return style;\n}\n\nfunction haxeTokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == '\"' || ch == \"'\") {\n    return chain(stream, state, haxeTokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    return ret(ch);\n  } else if (ch == \"0\" && stream.eat(/x/i)) {\n    stream.eatWhile(/[\\da-f]/i);\n    return ret(\"number\", \"number\");\n  } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n    stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n    return ret(\"number\", \"number\");\n  } else if (state.reAllowed && (ch == \"~\" && stream.eat(/\\//))) {\n    toUnescaped(stream, \"/\");\n    stream.eatWhile(/[gimsu]/);\n    return ret(\"regexp\", \"string.special\");\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      return chain(stream, state, haxeTokenComment);\n    } else if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return ret(\"comment\", \"comment\");\n    } else {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n  } else if (ch == \"#\") {\n    stream.skipToEnd();\n    return ret(\"conditional\", \"meta\");\n  } else if (ch == \"@\") {\n    stream.eat(/:/);\n    stream.eatWhile(/[\\w_]/);\n    return ret (\"metadata\", \"meta\");\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return ret(\"operator\", null, stream.current());\n  } else {\n    var word;\n    if(/[A-Z]/.test(ch)) {\n      stream.eatWhile(/[\\w_<>]/);\n      word = stream.current();\n      return ret(\"type\", \"type\", word);\n    } else {\n      stream.eatWhile(/[\\w_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\n        ret(\"variable\", \"variable\", word);\n    }\n  }\n}\n\nfunction haxeTokenString(quote) {\n  return function(stream, state) {\n    if (toUnescaped(stream, quote))\n      state.tokenize = haxeTokenBase;\n    return ret(\"string\", \"string\");\n  };\n}\n\nfunction haxeTokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = haxeTokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return ret(\"comment\", \"comment\");\n}\n\n// Parser\n\nvar atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\n\nfunction HaxeLexical(indented, column, type, align, prev, info) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.prev = prev;\n  this.info = info;\n  if (align != null) this.align = align;\n}\n\nfunction inScope(state, varname) {\n  for (var v = state.localVars; v; v = v.next)\n    if (v.name == varname) return true;\n}\n\nfunction parseHaxe(state, style, type, content, stream) {\n  var cc = state.cc;\n  // Communicate our context to the combinators.\n  // (Less wasteful than consing up a hundred closures on every call.)\n  cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n  if (!state.lexical.hasOwnProperty(\"align\"))\n    state.lexical.align = true;\n\n  while(true) {\n    var combinator = cc.length ? cc.pop() : statement;\n    if (combinator(type, content)) {\n      while(cc.length && cc[cc.length - 1].lex)\n        cc.pop()();\n      if (cx.marked) return cx.marked;\n      if (type == \"variable\" && inScope(state, content)) return \"variableName.local\";\n      if (type == \"variable\" && imported(state, content)) return \"variableName.special\";\n      return style;\n    }\n  }\n}\n\nfunction imported(state, typename) {\n  if (/[a-z]/.test(typename.charAt(0)))\n    return false;\n  var len = state.importedtypes.length;\n  for (var i = 0; i<len; i++)\n    if(state.importedtypes[i]==typename) return true;\n}\n\nfunction registerimport(importname) {\n  var state = cx.state;\n  for (var t = state.importedtypes; t; t = t.next)\n    if(t.name == importname) return;\n  state.importedtypes = { name: importname, next: state.importedtypes };\n}\n// Combinator utils\n\nvar cx = {state: null, column: null, marked: null, cc: null};\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n}\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\nfunction inList(name, list) {\n  for (var v = list; v; v = v.next)\n    if (v.name == name) return true;\n  return false;\n}\nfunction register(varname) {\n  var state = cx.state;\n  if (state.context) {\n    cx.marked = \"def\";\n    if (inList(varname, state.localVars)) return;\n    state.localVars = {name: varname, next: state.localVars};\n  } else if (state.globalVars) {\n    if (inList(varname, state.globalVars)) return;\n    state.globalVars = {name: varname, next: state.globalVars};\n  }\n}\n\n// Combinators\n\nvar defaultVars = {name: \"this\", next: null};\nfunction pushcontext() {\n  if (!cx.state.context) cx.state.localVars = defaultVars;\n  cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n}\nfunction popcontext() {\n  cx.state.localVars = cx.state.context.vars;\n  cx.state.context = cx.state.context.prev;\n}\npopcontext.lex = true;\nfunction pushlex(type, info) {\n  var result = function() {\n    var state = cx.state;\n    state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n  };\n  result.lex = true;\n  return result;\n}\nfunction poplex() {\n  var state = cx.state;\n  if (state.lexical.prev) {\n    if (state.lexical.type == \")\")\n      state.indented = state.lexical.indented;\n    state.lexical = state.lexical.prev;\n  }\n}\npoplex.lex = true;\n\nfunction expect(wanted) {\n  function f(type) {\n    if (type == wanted) return cont();\n    else if (wanted == \";\") return pass();\n    else return cont(f);\n  }\n  return f;\n}\n\nfunction statement(type) {\n  if (type == \"@\") return cont(metadef);\n  if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n  if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n  if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n  if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n  if (type == \";\") return cont();\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                 poplex, statement, poplex);\n  if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n  if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                    block, poplex, poplex);\n  if (type == \"case\") return cont(expression, expect(\":\"));\n  if (type == \"default\") return cont(expect(\":\"));\n  if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                   statement, poplex, popcontext);\n  if (type == \"import\") return cont(importdef, expect(\";\"));\n  if (type == \"typedef\") return cont(typedef);\n  return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n}\nfunction expression(type) {\n  if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n  if (type == \"type\" ) return cont(maybeoperator);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"keyword c\") return cont(maybeexpression);\n  if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n  if (type == \"operator\") return cont(expression);\n  if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n  return cont();\n}\nfunction maybeexpression(type) {\n  if (type.match(/[;\\}\\)\\],]/)) return pass();\n  return pass(expression);\n}\n\nfunction maybeoperator(type, value) {\n  if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n  if (type == \"operator\" || type == \":\") return cont(expression);\n  if (type == \";\") return;\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n  if (type == \".\") return cont(property, maybeoperator);\n  if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n}\n\nfunction maybeattribute(type) {\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"var\") return cont(vardef1);\n}\n\nfunction metadef(type) {\n  if(type == \":\") return cont(metadef);\n  if(type == \"variable\") return cont(metadef);\n  if(type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n}\nfunction metaargs(type) {\n  if(type == \"variable\") return cont();\n}\n\nfunction importdef (type, value) {\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if(type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n}\n\nfunction typedef (type, value)\n{\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) { return cont(); }\n}\n\nfunction maybelabel(type) {\n  if (type == \":\") return cont(poplex, statement);\n  return pass(maybeoperator, expect(\";\"), poplex);\n}\nfunction property(type) {\n  if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n}\nfunction objprop(type) {\n  if (type == \"variable\") cx.marked = \"property\";\n  if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n}\nfunction commasep(what, end) {\n  function proceed(type) {\n    if (type == \",\") return cont(what, proceed);\n    if (type == end) return cont();\n    return cont(expect(end));\n  }\n  return function(type) {\n    if (type == end) return cont();\n    else return pass(what, proceed);\n  };\n}\nfunction block(type) {\n  if (type == \"}\") return cont();\n  return pass(statement, block);\n}\nfunction vardef1(type, value) {\n  if (type == \"variable\"){register(value); return cont(typeuse, vardef2);}\n  return cont();\n}\nfunction vardef2(type, value) {\n  if (value == \"=\") return cont(expression, vardef2);\n  if (type == \",\") return cont(vardef1);\n}\nfunction forspec1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(forin, expression)\n  } else {\n    return pass()\n  }\n}\nfunction forin(_type, value) {\n  if (value == \"in\") return cont();\n}\nfunction functiondef(type, value) {\n  //function names starting with upper-case letters are recognised as types, so cludging them together here.\n  if (type == \"variable\" || type == \"type\") {register(value); return cont(functiondef);}\n  if (value == \"new\") return cont(functiondef);\n  if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n}\nfunction typeuse(type) {\n  if(type == \":\") return cont(typestring);\n}\nfunction typestring(type) {\n  if(type == \"type\") return cont();\n  if(type == \"variable\") return cont();\n  if(type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n}\nfunction typeprop(type) {\n  if(type == \"variable\") return cont(typeuse);\n}\nfunction funarg(type, value) {\n  if (type == \"variable\") {register(value); return cont(typeuse);}\n}\n\n// Interface\nexport const haxe = {\n  name: \"haxe\",\n  startState: function(indentUnit) {\n    var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n    var state = {\n      tokenize: haxeTokenBase,\n      reAllowed: true,\n      kwAllowed: true,\n      cc: [],\n      lexical: new HaxeLexical(-indentUnit, 0, \"block\", false),\n      importedtypes: defaulttypes,\n      context: null,\n      indented: 0\n    };\n    return state;\n  },\n\n  token: function(stream, state) {\n    if (stream.sol()) {\n      if (!state.lexical.hasOwnProperty(\"align\"))\n        state.lexical.align = false;\n      state.indented = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    if (type == \"comment\") return style;\n    state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n    state.kwAllowed = type != '.';\n    return parseHaxe(state, style, type, content, stream);\n  },\n\n  indent: function(state, textAfter, cx) {\n    if (state.tokenize != haxeTokenBase) return 0;\n    var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n    if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n    var type = lexical.type, closing = firstChar == type;\n    if (type == \"vardef\") return lexical.indented + 4;\n    else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n    else if (type == \"stat\" || type == \"form\") return lexical.indented + cx.unit;\n    else if (lexical.info == \"switch\" && !closing)\n      return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);\n    else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n    else return lexical.indented + (closing ? 0 : cx.unit);\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\n  }\n};\n\nexport const hxml = {\n  name: \"hxml\",\n  startState: function () {\n    return {\n      define: false,\n      inString: false\n    };\n  },\n  token: function (stream, state) {\n    var ch = stream.peek();\n    var sol = stream.sol();\n\n    ///* comments */\n    if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n    if (sol && ch == \"-\") {\n      var style = \"variable-2\";\n\n      stream.eat(/-/);\n\n      if (stream.peek() == \"-\") {\n        stream.eat(/-/);\n        style = \"keyword a\";\n      }\n\n      if (stream.peek() == \"D\") {\n        stream.eat(/[D]/);\n        style = \"keyword c\";\n        state.define = true;\n      }\n\n      stream.eatWhile(/[A-Z]/i);\n      return style;\n    }\n\n    var ch = stream.peek();\n\n    if (state.inString == false && ch == \"'\") {\n      state.inString = true;\n      stream.next();\n    }\n\n    if (state.inString == true) {\n      if (stream.skipTo(\"'\")) {\n\n      } else {\n        stream.skipToEnd();\n      }\n\n      if (stream.peek() == \"'\") {\n        stream.next();\n        state.inString = false;\n      }\n\n      return \"string\";\n    }\n\n    stream.next();\n    return null;\n  },\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}