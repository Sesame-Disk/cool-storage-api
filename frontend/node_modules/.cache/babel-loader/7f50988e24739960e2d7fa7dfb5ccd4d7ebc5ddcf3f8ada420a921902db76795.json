{"ast":null,"code":"/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementData} ElementData\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n *\n * @typedef {import('parse5').DefaultTreeAdapterMap} DefaultTreeAdapterMap\n * @typedef {import('parse5').Token.ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Token.Location} P5Location\n *\n * @typedef {import('property-information').Schema} Schema\n *\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n *\n * @typedef {import('vfile').VFile} VFile\n */\n\n/**\n * @typedef {DefaultTreeAdapterMap['document']} P5Document\n * @typedef {DefaultTreeAdapterMap['documentFragment']} P5DocumentFragment\n * @typedef {DefaultTreeAdapterMap['documentType']} P5DocumentType\n * @typedef {DefaultTreeAdapterMap['commentNode']} P5Comment\n * @typedef {DefaultTreeAdapterMap['textNode']} P5Text\n * @typedef {DefaultTreeAdapterMap['element']} P5Element\n * @typedef {DefaultTreeAdapterMap['node']} P5Node\n * @typedef {DefaultTreeAdapterMap['template']} P5Template\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in (default: `'html'`).\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {VFile | null | undefined} [file]\n *   File used to add positional info to nodes (optional).\n *\n *   If given, the file should represent the original HTML source.\n * @property {boolean | null | undefined} [verbose=false]\n *   Whether to add extra positional info about starting tags, closing tags,\n *   and attributes to elements (default: `false`).\n *\n *   > ðŸ‘‰ **Note**: only used when `file` is given.\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {VFile | undefined} file\n *   Corresponding file.\n * @property {boolean} location\n *   Whether location info was found.\n * @property {Schema} schema\n *   Current schema.\n * @property {boolean | undefined} verbose\n *   Add extra positional info.\n */\n\nimport { ok as assert } from 'devlop';\nimport { h, s } from 'hastscript';\nimport { find, html, svg } from 'property-information';\nimport { location } from 'vfile-location';\nimport { webNamespaces } from 'web-namespaces';\nvar own = {}.hasOwnProperty;\n/** @type {unknown} */\n// type-coverage:ignore-next-line\nvar proto = Object.prototype;\n\n/**\n * Transform a `parse5` AST to hast.\n *\n * @param {P5Node} tree\n *   `parse5` tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Nodes}\n *   hast tree.\n */\nexport function fromParse5(tree, options) {\n  var settings = options || {};\n  return one({\n    file: settings.file || undefined,\n    location: false,\n    schema: settings.space === 'svg' ? svg : html,\n    verbose: settings.verbose || false\n  }, tree);\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} node\n *   p5 node.\n * @returns {Nodes}\n *   hast node.\n */\nfunction one(state, node) {\n  /** @type {Nodes} */\n  var result;\n  switch (node.nodeName) {\n    case '#comment':\n      {\n        var reference = /** @type {P5Comment} */node;\n        result = {\n          type: 'comment',\n          value: reference.data\n        };\n        patch(state, reference, result);\n        return result;\n      }\n    case '#document':\n    case '#document-fragment':\n      {\n        var _reference = /** @type {P5Document | P5DocumentFragment} */node;\n        var quirksMode = 'mode' in _reference ? _reference.mode === 'quirks' || _reference.mode === 'limited-quirks' : false;\n        result = {\n          type: 'root',\n          children: all(state, node.childNodes),\n          data: {\n            quirksMode: quirksMode\n          }\n        };\n        if (state.file && state.location) {\n          var doc = String(state.file);\n          var loc = location(doc);\n          var start = loc.toPoint(0);\n          var end = loc.toPoint(doc.length);\n          // Always defined as we give valid input.\n          assert(start, 'expected `start`');\n          assert(end, 'expected `end`');\n          result.position = {\n            start: start,\n            end: end\n          };\n        }\n        return result;\n      }\n    case '#documentType':\n      {\n        var _reference2 = /** @type {P5DocumentType} */node;\n        result = {\n          type: 'doctype'\n        };\n        patch(state, _reference2, result);\n        return result;\n      }\n    case '#text':\n      {\n        var _reference3 = /** @type {P5Text} */node;\n        result = {\n          type: 'text',\n          value: _reference3.value\n        };\n        patch(state, _reference3, result);\n        return result;\n      }\n\n    // Element.\n    default:\n      {\n        var _reference4 = /** @type {P5Element} */node;\n        result = element(state, _reference4);\n        return result;\n      }\n  }\n}\n\n/**\n * Transform children.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Array<P5Node>} nodes\n *   Nodes.\n * @returns {Array<RootContent>}\n *   hast nodes.\n */\nfunction all(state, nodes) {\n  var index = -1;\n  /** @type {Array<RootContent>} */\n  var results = [];\n  while (++index < nodes.length) {\n    // Assume no roots in `nodes`.\n    var result = /** @type {RootContent} */one(state, nodes[index]);\n    results.push(result);\n  }\n  return results;\n}\n\n/**\n * Transform an element.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Element} node\n *   `parse5` node to transform.\n * @returns {Element}\n *   hast node.\n */\nfunction element(state, node) {\n  var schema = state.schema;\n  state.schema = node.namespaceURI === webNamespaces.svg ? svg : html;\n\n  // Props.\n  var index = -1;\n  /** @type {Record<string, string>} */\n  var props = {};\n  while (++index < node.attrs.length) {\n    var attribute = node.attrs[index];\n    var name = (attribute.prefix ? attribute.prefix + ':' : '') + attribute.name;\n    if (!own.call(proto, name)) {\n      props[name] = attribute.value;\n    }\n  }\n\n  // Build.\n  var fn = state.schema.space === 'svg' ? s : h;\n  var result = fn(node.tagName, props, all(state, node.childNodes));\n  patch(state, node, result);\n\n  // Switch content.\n  if (result.tagName === 'template') {\n    var reference = /** @type {P5Template} */node;\n    var pos = reference.sourceCodeLocation;\n    var startTag = pos && pos.startTag && position(pos.startTag);\n    var endTag = pos && pos.endTag && position(pos.endTag);\n\n    // Root in, root out.\n    var content = /** @type {Root} */one(state, reference.content);\n    if (startTag && endTag && state.file) {\n      content.position = {\n        start: startTag.end,\n        end: endTag.start\n      };\n    }\n    result.content = content;\n  }\n  state.schema = schema;\n  return result;\n}\n\n/**\n * Patch positional info from `from` onto `to`.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} from\n *   p5 node.\n * @param {Nodes} to\n *   hast node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(state, from, to) {\n  if ('sourceCodeLocation' in from && from.sourceCodeLocation && state.file) {\n    var _position = createLocation(state, to, from.sourceCodeLocation);\n    if (_position) {\n      state.location = true;\n      to.position = _position;\n    }\n  }\n}\n\n/**\n * Create clean positional information.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Nodes} node\n *   hast node.\n * @param {P5ElementLocation} location\n *   p5 location info.\n * @returns {Position | undefined}\n *   Position, or nothing.\n */\nfunction createLocation(state, node, location) {\n  var result = position(location);\n  if (node.type === 'element') {\n    var tail = node.children[node.children.length - 1];\n\n    // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n    if (result && !location.endTag && tail && tail.position && tail.position.end) {\n      result.end = Object.assign({}, tail.position.end);\n    }\n    if (state.verbose) {\n      /** @type {Record<string, Position | undefined>} */\n      var props = {};\n      /** @type {string} */\n      var key;\n      if (location.attrs) {\n        for (key in location.attrs) {\n          if (own.call(location.attrs, key)) {\n            props[find(state.schema, key).property] = position(location.attrs[key]);\n          }\n        }\n      }\n      assert(location.startTag, 'a start tag should exist');\n      var opening = position(location.startTag);\n      var closing = location.endTag ? position(location.endTag) : undefined;\n      /** @type {ElementData['position']} */\n      var data = {\n        opening: opening\n      };\n      if (closing) data.closing = closing;\n      data.properties = props;\n      node.data = {\n        position: data\n      };\n    }\n  }\n  return result;\n}\n\n/**\n * Turn a p5 location into a position.\n *\n * @param {P5Location} loc\n *   Location.\n * @returns {Position | undefined}\n *   Position or nothing.\n */\nfunction position(loc) {\n  var start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  });\n  var end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  });\n\n  // @ts-expect-error: we do use `undefined` for points if one or the other\n  // exists.\n  return start || end ? {\n    start: start,\n    end: end\n  } : undefined;\n}\n\n/**\n * Filter out invalid points.\n *\n * @param {Point} point\n *   Point with potentially `undefined` values.\n * @returns {Point | undefined}\n *   Point or nothing.\n */\nfunction point(point) {\n  return point.line && point.column ? point : undefined;\n}","map":{"version":3,"names":["ok","assert","h","s","find","html","svg","location","webNamespaces","own","hasOwnProperty","proto","Object","prototype","fromParse5","tree","options","settings","one","file","undefined","schema","space","verbose","state","node","result","nodeName","reference","type","value","data","patch","quirksMode","mode","children","all","childNodes","doc","String","loc","start","toPoint","end","length","position","element","nodes","index","results","push","namespaceURI","props","attrs","attribute","name","prefix","call","fn","tagName","pos","sourceCodeLocation","startTag","endTag","content","from","to","createLocation","tail","assign","key","property","opening","closing","properties","point","line","startLine","column","startCol","offset","startOffset","endLine","endCol","endOffset"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/hast-util-from-parse5/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementData} ElementData\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').RootContent} RootContent\n *\n * @typedef {import('parse5').DefaultTreeAdapterMap} DefaultTreeAdapterMap\n * @typedef {import('parse5').Token.ElementLocation} P5ElementLocation\n * @typedef {import('parse5').Token.Location} P5Location\n *\n * @typedef {import('property-information').Schema} Schema\n *\n * @typedef {import('unist').Point} Point\n * @typedef {import('unist').Position} Position\n *\n * @typedef {import('vfile').VFile} VFile\n */\n\n/**\n * @typedef {DefaultTreeAdapterMap['document']} P5Document\n * @typedef {DefaultTreeAdapterMap['documentFragment']} P5DocumentFragment\n * @typedef {DefaultTreeAdapterMap['documentType']} P5DocumentType\n * @typedef {DefaultTreeAdapterMap['commentNode']} P5Comment\n * @typedef {DefaultTreeAdapterMap['textNode']} P5Text\n * @typedef {DefaultTreeAdapterMap['element']} P5Element\n * @typedef {DefaultTreeAdapterMap['node']} P5Node\n * @typedef {DefaultTreeAdapterMap['template']} P5Template\n */\n\n/**\n * @typedef Options\n *   Configuration.\n * @property {Space | null | undefined} [space='html']\n *   Which space the document is in (default: `'html'`).\n *\n *   When an `<svg>` element is found in the HTML space, this package already\n *   automatically switches to and from the SVG space when entering and exiting\n *   it.\n * @property {VFile | null | undefined} [file]\n *   File used to add positional info to nodes (optional).\n *\n *   If given, the file should represent the original HTML source.\n * @property {boolean | null | undefined} [verbose=false]\n *   Whether to add extra positional info about starting tags, closing tags,\n *   and attributes to elements (default: `false`).\n *\n *   > ðŸ‘‰ **Note**: only used when `file` is given.\n *\n * @typedef {'html' | 'svg'} Space\n *   Namespace.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {VFile | undefined} file\n *   Corresponding file.\n * @property {boolean} location\n *   Whether location info was found.\n * @property {Schema} schema\n *   Current schema.\n * @property {boolean | undefined} verbose\n *   Add extra positional info.\n */\n\nimport {ok as assert} from 'devlop'\nimport {h, s} from 'hastscript'\nimport {find, html, svg} from 'property-information'\nimport {location} from 'vfile-location'\nimport {webNamespaces} from 'web-namespaces'\n\nconst own = {}.hasOwnProperty\n/** @type {unknown} */\n// type-coverage:ignore-next-line\nconst proto = Object.prototype\n\n/**\n * Transform a `parse5` AST to hast.\n *\n * @param {P5Node} tree\n *   `parse5` tree to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {Nodes}\n *   hast tree.\n */\nexport function fromParse5(tree, options) {\n  const settings = options || {}\n\n  return one(\n    {\n      file: settings.file || undefined,\n      location: false,\n      schema: settings.space === 'svg' ? svg : html,\n      verbose: settings.verbose || false\n    },\n    tree\n  )\n}\n\n/**\n * Transform a node.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} node\n *   p5 node.\n * @returns {Nodes}\n *   hast node.\n */\nfunction one(state, node) {\n  /** @type {Nodes} */\n  let result\n\n  switch (node.nodeName) {\n    case '#comment': {\n      const reference = /** @type {P5Comment} */ (node)\n      result = {type: 'comment', value: reference.data}\n      patch(state, reference, result)\n      return result\n    }\n\n    case '#document':\n    case '#document-fragment': {\n      const reference = /** @type {P5Document | P5DocumentFragment} */ (node)\n      const quirksMode =\n        'mode' in reference\n          ? reference.mode === 'quirks' || reference.mode === 'limited-quirks'\n          : false\n\n      result = {\n        type: 'root',\n        children: all(state, node.childNodes),\n        data: {quirksMode}\n      }\n\n      if (state.file && state.location) {\n        const doc = String(state.file)\n        const loc = location(doc)\n        const start = loc.toPoint(0)\n        const end = loc.toPoint(doc.length)\n        // Always defined as we give valid input.\n        assert(start, 'expected `start`')\n        assert(end, 'expected `end`')\n        result.position = {start, end}\n      }\n\n      return result\n    }\n\n    case '#documentType': {\n      const reference = /** @type {P5DocumentType} */ (node)\n      result = {type: 'doctype'}\n      patch(state, reference, result)\n      return result\n    }\n\n    case '#text': {\n      const reference = /** @type {P5Text} */ (node)\n      result = {type: 'text', value: reference.value}\n      patch(state, reference, result)\n      return result\n    }\n\n    // Element.\n    default: {\n      const reference = /** @type {P5Element} */ (node)\n      result = element(state, reference)\n      return result\n    }\n  }\n}\n\n/**\n * Transform children.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Array<P5Node>} nodes\n *   Nodes.\n * @returns {Array<RootContent>}\n *   hast nodes.\n */\nfunction all(state, nodes) {\n  let index = -1\n  /** @type {Array<RootContent>} */\n  const results = []\n\n  while (++index < nodes.length) {\n    // Assume no roots in `nodes`.\n    const result = /** @type {RootContent} */ (one(state, nodes[index]))\n    results.push(result)\n  }\n\n  return results\n}\n\n/**\n * Transform an element.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Element} node\n *   `parse5` node to transform.\n * @returns {Element}\n *   hast node.\n */\nfunction element(state, node) {\n  const schema = state.schema\n\n  state.schema = node.namespaceURI === webNamespaces.svg ? svg : html\n\n  // Props.\n  let index = -1\n  /** @type {Record<string, string>} */\n  const props = {}\n\n  while (++index < node.attrs.length) {\n    const attribute = node.attrs[index]\n    const name =\n      (attribute.prefix ? attribute.prefix + ':' : '') + attribute.name\n    if (!own.call(proto, name)) {\n      props[name] = attribute.value\n    }\n  }\n\n  // Build.\n  const fn = state.schema.space === 'svg' ? s : h\n  const result = fn(node.tagName, props, all(state, node.childNodes))\n  patch(state, node, result)\n\n  // Switch content.\n  if (result.tagName === 'template') {\n    const reference = /** @type {P5Template} */ (node)\n    const pos = reference.sourceCodeLocation\n    const startTag = pos && pos.startTag && position(pos.startTag)\n    const endTag = pos && pos.endTag && position(pos.endTag)\n\n    // Root in, root out.\n    const content = /** @type {Root} */ (one(state, reference.content))\n\n    if (startTag && endTag && state.file) {\n      content.position = {start: startTag.end, end: endTag.start}\n    }\n\n    result.content = content\n  }\n\n  state.schema = schema\n\n  return result\n}\n\n/**\n * Patch positional info from `from` onto `to`.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {P5Node} from\n *   p5 node.\n * @param {Nodes} to\n *   hast node.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(state, from, to) {\n  if ('sourceCodeLocation' in from && from.sourceCodeLocation && state.file) {\n    const position = createLocation(state, to, from.sourceCodeLocation)\n\n    if (position) {\n      state.location = true\n      to.position = position\n    }\n  }\n}\n\n/**\n * Create clean positional information.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Nodes} node\n *   hast node.\n * @param {P5ElementLocation} location\n *   p5 location info.\n * @returns {Position | undefined}\n *   Position, or nothing.\n */\nfunction createLocation(state, node, location) {\n  const result = position(location)\n\n  if (node.type === 'element') {\n    const tail = node.children[node.children.length - 1]\n\n    // Bug for unclosed with children.\n    // See: <https://github.com/inikulin/parse5/issues/109>.\n    if (\n      result &&\n      !location.endTag &&\n      tail &&\n      tail.position &&\n      tail.position.end\n    ) {\n      result.end = Object.assign({}, tail.position.end)\n    }\n\n    if (state.verbose) {\n      /** @type {Record<string, Position | undefined>} */\n      const props = {}\n      /** @type {string} */\n      let key\n\n      if (location.attrs) {\n        for (key in location.attrs) {\n          if (own.call(location.attrs, key)) {\n            props[find(state.schema, key).property] = position(\n              location.attrs[key]\n            )\n          }\n        }\n      }\n\n      assert(location.startTag, 'a start tag should exist')\n      const opening = position(location.startTag)\n      const closing = location.endTag ? position(location.endTag) : undefined\n      /** @type {ElementData['position']} */\n      const data = {opening}\n      if (closing) data.closing = closing\n      data.properties = props\n\n      node.data = {position: data}\n    }\n  }\n\n  return result\n}\n\n/**\n * Turn a p5 location into a position.\n *\n * @param {P5Location} loc\n *   Location.\n * @returns {Position | undefined}\n *   Position or nothing.\n */\nfunction position(loc) {\n  const start = point({\n    line: loc.startLine,\n    column: loc.startCol,\n    offset: loc.startOffset\n  })\n  const end = point({\n    line: loc.endLine,\n    column: loc.endCol,\n    offset: loc.endOffset\n  })\n\n  // @ts-expect-error: we do use `undefined` for points if one or the other\n  // exists.\n  return start || end ? {start, end} : undefined\n}\n\n/**\n * Filter out invalid points.\n *\n * @param {Point} point\n *   Point with potentially `undefined` values.\n * @returns {Point | undefined}\n *   Point or nothing.\n */\nfunction point(point) {\n  return point.line && point.column ? point : undefined\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}