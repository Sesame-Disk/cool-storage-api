{"ast":null,"code":"// Tokenizer\nvar textwords = {};\nvar keywords = {\n  \"allTags\": true,\n  \"closeAll\": true,\n  \"list\": true,\n  \"newJournal\": true,\n  \"newTiddler\": true,\n  \"permaview\": true,\n  \"saveChanges\": true,\n  \"search\": true,\n  \"slider\": true,\n  \"tabs\": true,\n  \"tag\": true,\n  \"tagging\": true,\n  \"tags\": true,\n  \"tiddler\": true,\n  \"timeline\": true,\n  \"today\": true,\n  \"version\": true,\n  \"option\": true,\n  \"with\": true,\n  \"filter\": true\n};\nvar isSpaceName = /[\\w_\\-]/i,\n  reHR = /^\\-\\-\\-\\-+$/,\n  // <hr>\n  reWikiCommentStart = /^\\/\\*\\*\\*$/,\n  // /***\n  reWikiCommentStop = /^\\*\\*\\*\\/$/,\n  // ***/\n  reBlockQuote = /^<<<$/,\n  reJsCodeStart = /^\\/\\/\\{\\{\\{$/,\n  // //{{{ js block start\n  reJsCodeStop = /^\\/\\/\\}\\}\\}$/,\n  // //}}} js stop\n  reXmlCodeStart = /^<!--\\{\\{\\{-->$/,\n  // xml block start\n  reXmlCodeStop = /^<!--\\}\\}\\}-->$/,\n  // xml stop\n\n  reCodeBlockStart = /^\\{\\{\\{$/,\n  // {{{ TW text div block start\n  reCodeBlockStop = /^\\}\\}\\}$/,\n  // }}} TW text stop\n\n  reUntilCodeStop = /.*?\\}\\}\\}/;\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\nfunction tokenBase(stream, state) {\n  var sol = stream.sol(),\n    ch = stream.peek();\n  state.block = false; // indicates the start of a code block.\n\n  // check start of  blocks\n  if (sol && /[<\\/\\*{}\\-]/.test(ch)) {\n    if (stream.match(reCodeBlockStart)) {\n      state.block = true;\n      return chain(stream, state, twTokenCode);\n    }\n    if (stream.match(reBlockQuote)) return 'quote';\n    if (stream.match(reWikiCommentStart) || stream.match(reWikiCommentStop)) return 'comment';\n    if (stream.match(reJsCodeStart) || stream.match(reJsCodeStop) || stream.match(reXmlCodeStart) || stream.match(reXmlCodeStop)) return 'comment';\n    if (stream.match(reHR)) return 'contentSeparator';\n  }\n  stream.next();\n  if (sol && /[\\/\\*!#;:>|]/.test(ch)) {\n    if (ch == \"!\") {\n      // tw header\n      stream.skipToEnd();\n      return \"header\";\n    }\n    if (ch == \"*\") {\n      // tw list\n      stream.eatWhile('*');\n      return \"comment\";\n    }\n    if (ch == \"#\") {\n      // tw numbered list\n      stream.eatWhile('#');\n      return \"comment\";\n    }\n    if (ch == \";\") {\n      // definition list, term\n      stream.eatWhile(';');\n      return \"comment\";\n    }\n    if (ch == \":\") {\n      // definition list, description\n      stream.eatWhile(':');\n      return \"comment\";\n    }\n    if (ch == \">\") {\n      // single line quote\n      stream.eatWhile(\">\");\n      return \"quote\";\n    }\n    if (ch == '|') return 'header';\n  }\n  if (ch == '{' && stream.match('{{')) return chain(stream, state, twTokenCode);\n\n  // rudimentary html:// file:// link matching. TW knows much more ...\n  if (/[hf]/i.test(ch) && /[ti]/i.test(stream.peek()) && stream.match(/\\b(ttps?|tp|ile):\\/\\/[\\-A-Z0-9+&@#\\/%?=~_|$!:,.;]*[A-Z0-9+&@#\\/%=~_|$]/i)) return \"link\";\n\n  // just a little string indicator, don't want to have the whole string covered\n  if (ch == '\"') return 'string';\n  if (ch == '~')\n    // _no_ CamelCase indicator should be bold\n    return 'brace';\n  if (/[\\[\\]]/.test(ch) && stream.match(ch))\n    // check for [[..]]\n    return 'brace';\n  if (ch == \"@\") {\n    // check for space link. TODO fix @@...@@ highlighting\n    stream.eatWhile(isSpaceName);\n    return \"link\";\n  }\n  if (/\\d/.test(ch)) {\n    // numbers\n    stream.eatWhile(/\\d/);\n    return \"number\";\n  }\n  if (ch == \"/\") {\n    // tw invisible comment\n    if (stream.eat(\"%\")) {\n      return chain(stream, state, twTokenComment);\n    } else if (stream.eat(\"/\")) {\n      //\n      return chain(stream, state, twTokenEm);\n    }\n  }\n  if (ch == \"_\" && stream.eat(\"_\"))\n    // tw underline\n    return chain(stream, state, twTokenUnderline);\n\n  // strikethrough and mdash handling\n  if (ch == \"-\" && stream.eat(\"-\")) {\n    // if strikethrough looks ugly, change CSS.\n    if (stream.peek() != ' ') return chain(stream, state, twTokenStrike);\n    // mdash\n    if (stream.peek() == ' ') return 'brace';\n  }\n  if (ch == \"'\" && stream.eat(\"'\"))\n    // tw bold\n    return chain(stream, state, twTokenStrong);\n  if (ch == \"<\" && stream.eat(\"<\"))\n    // tw macro\n    return chain(stream, state, twTokenMacro);\n\n  // core macro handling\n  stream.eatWhile(/[\\w\\$_]/);\n  return textwords.propertyIsEnumerable(stream.current()) ? \"keyword\" : null;\n}\n\n// tw invisible comment\nfunction twTokenComment(stream, state) {\n  var maybeEnd = false,\n    ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = ch == \"%\";\n  }\n  return \"comment\";\n}\n\n// tw strong / bold\nfunction twTokenStrong(stream, state) {\n  var maybeEnd = false,\n    ch;\n  while (ch = stream.next()) {\n    if (ch == \"'\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = ch == \"'\";\n  }\n  return \"strong\";\n}\n\n// tw code\nfunction twTokenCode(stream, state) {\n  var sb = state.block;\n  if (sb && stream.current()) {\n    return \"comment\";\n  }\n  if (!sb && stream.match(reUntilCodeStop)) {\n    state.tokenize = tokenBase;\n    return \"comment\";\n  }\n  if (sb && stream.sol() && stream.match(reCodeBlockStop)) {\n    state.tokenize = tokenBase;\n    return \"comment\";\n  }\n  stream.next();\n  return \"comment\";\n}\n\n// tw em / italic\nfunction twTokenEm(stream, state) {\n  var maybeEnd = false,\n    ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = ch == \"/\";\n  }\n  return \"emphasis\";\n}\n\n// tw underlined text\nfunction twTokenUnderline(stream, state) {\n  var maybeEnd = false,\n    ch;\n  while (ch = stream.next()) {\n    if (ch == \"_\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = ch == \"_\";\n  }\n  return \"link\";\n}\n\n// tw strike through text looks ugly\n// change CSS if needed\nfunction twTokenStrike(stream, state) {\n  var maybeEnd = false,\n    ch;\n  while (ch = stream.next()) {\n    if (ch == \"-\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = ch == \"-\";\n  }\n  return \"deleted\";\n}\n\n// macro\nfunction twTokenMacro(stream, state) {\n  if (stream.current() == '<<') {\n    return 'meta';\n  }\n  var ch = stream.next();\n  if (!ch) {\n    state.tokenize = tokenBase;\n    return null;\n  }\n  if (ch == \">\") {\n    if (stream.peek() == '>') {\n      stream.next();\n      state.tokenize = tokenBase;\n      return \"meta\";\n    }\n  }\n  stream.eatWhile(/[\\w\\$_]/);\n  return keywords.propertyIsEnumerable(stream.current()) ? \"keyword\" : null;\n}\n\n// Interface\nexport var tiddlyWiki = {\n  name: \"tiddlywiki\",\n  startState: function startState() {\n    return {\n      tokenize: tokenBase\n    };\n  },\n  token: function token(stream, state) {\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    return style;\n  }\n};","map":{"version":3,"names":["textwords","keywords","isSpaceName","reHR","reWikiCommentStart","reWikiCommentStop","reBlockQuote","reJsCodeStart","reJsCodeStop","reXmlCodeStart","reXmlCodeStop","reCodeBlockStart","reCodeBlockStop","reUntilCodeStop","chain","stream","state","f","tokenize","tokenBase","sol","ch","peek","block","test","match","twTokenCode","next","skipToEnd","eatWhile","eat","twTokenComment","twTokenEm","twTokenUnderline","twTokenStrike","twTokenStrong","twTokenMacro","propertyIsEnumerable","current","maybeEnd","sb","tiddlyWiki","name","startState","token","eatSpace","style"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@codemirror/legacy-modes/mode/tiddlywiki.js"],"sourcesContent":["// Tokenizer\nvar textwords = {};\n\nvar keywords = {\n  \"allTags\": true, \"closeAll\": true, \"list\": true,\n  \"newJournal\": true, \"newTiddler\": true,\n  \"permaview\": true, \"saveChanges\": true,\n  \"search\": true, \"slider\": true, \"tabs\": true,\n  \"tag\": true, \"tagging\": true, \"tags\": true,\n  \"tiddler\": true, \"timeline\": true,\n  \"today\": true, \"version\": true, \"option\": true,\n  \"with\": true, \"filter\": true\n};\n\nvar isSpaceName = /[\\w_\\-]/i,\n    reHR = /^\\-\\-\\-\\-+$/,                                 // <hr>\n    reWikiCommentStart = /^\\/\\*\\*\\*$/,            // /***\n    reWikiCommentStop = /^\\*\\*\\*\\/$/,             // ***/\n    reBlockQuote = /^<<<$/,\n\n    reJsCodeStart = /^\\/\\/\\{\\{\\{$/,                       // //{{{ js block start\n    reJsCodeStop = /^\\/\\/\\}\\}\\}$/,                        // //}}} js stop\n    reXmlCodeStart = /^<!--\\{\\{\\{-->$/,           // xml block start\n    reXmlCodeStop = /^<!--\\}\\}\\}-->$/,            // xml stop\n\n    reCodeBlockStart = /^\\{\\{\\{$/,                        // {{{ TW text div block start\n    reCodeBlockStop = /^\\}\\}\\}$/,                 // }}} TW text stop\n\n    reUntilCodeStop = /.*?\\}\\}\\}/;\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\nfunction tokenBase(stream, state) {\n  var sol = stream.sol(), ch = stream.peek();\n\n  state.block = false;        // indicates the start of a code block.\n\n  // check start of  blocks\n  if (sol && /[<\\/\\*{}\\-]/.test(ch)) {\n    if (stream.match(reCodeBlockStart)) {\n      state.block = true;\n      return chain(stream, state, twTokenCode);\n    }\n    if (stream.match(reBlockQuote))\n      return 'quote';\n    if (stream.match(reWikiCommentStart) || stream.match(reWikiCommentStop))\n      return 'comment';\n    if (stream.match(reJsCodeStart) || stream.match(reJsCodeStop) || stream.match(reXmlCodeStart) || stream.match(reXmlCodeStop))\n      return 'comment';\n    if (stream.match(reHR))\n      return 'contentSeparator';\n  }\n\n  stream.next();\n  if (sol && /[\\/\\*!#;:>|]/.test(ch)) {\n    if (ch == \"!\") { // tw header\n      stream.skipToEnd();\n      return \"header\";\n    }\n    if (ch == \"*\") { // tw list\n      stream.eatWhile('*');\n      return \"comment\";\n    }\n    if (ch == \"#\") { // tw numbered list\n      stream.eatWhile('#');\n      return \"comment\";\n    }\n    if (ch == \";\") { // definition list, term\n      stream.eatWhile(';');\n      return \"comment\";\n    }\n    if (ch == \":\") { // definition list, description\n      stream.eatWhile(':');\n      return \"comment\";\n    }\n    if (ch == \">\") { // single line quote\n      stream.eatWhile(\">\");\n      return \"quote\";\n    }\n    if (ch == '|')\n      return 'header';\n  }\n\n  if (ch == '{' && stream.match('{{'))\n    return chain(stream, state, twTokenCode);\n\n  // rudimentary html:// file:// link matching. TW knows much more ...\n  if (/[hf]/i.test(ch) &&\n      /[ti]/i.test(stream.peek()) &&\n      stream.match(/\\b(ttps?|tp|ile):\\/\\/[\\-A-Z0-9+&@#\\/%?=~_|$!:,.;]*[A-Z0-9+&@#\\/%=~_|$]/i))\n    return \"link\";\n\n  // just a little string indicator, don't want to have the whole string covered\n  if (ch == '\"')\n    return 'string';\n\n  if (ch == '~')    // _no_ CamelCase indicator should be bold\n    return 'brace';\n\n  if (/[\\[\\]]/.test(ch) && stream.match(ch)) // check for [[..]]\n    return 'brace';\n\n  if (ch == \"@\") {    // check for space link. TODO fix @@...@@ highlighting\n    stream.eatWhile(isSpaceName);\n    return \"link\";\n  }\n\n  if (/\\d/.test(ch)) {        // numbers\n    stream.eatWhile(/\\d/);\n    return \"number\";\n  }\n\n  if (ch == \"/\") { // tw invisible comment\n    if (stream.eat(\"%\")) {\n      return chain(stream, state, twTokenComment);\n    } else if (stream.eat(\"/\")) { //\n      return chain(stream, state, twTokenEm);\n    }\n  }\n\n  if (ch == \"_\" && stream.eat(\"_\")) // tw underline\n    return chain(stream, state, twTokenUnderline);\n\n  // strikethrough and mdash handling\n  if (ch == \"-\" && stream.eat(\"-\")) {\n    // if strikethrough looks ugly, change CSS.\n    if (stream.peek() != ' ')\n      return chain(stream, state, twTokenStrike);\n    // mdash\n    if (stream.peek() == ' ')\n      return 'brace';\n  }\n\n  if (ch == \"'\" && stream.eat(\"'\")) // tw bold\n    return chain(stream, state, twTokenStrong);\n\n  if (ch == \"<\" && stream.eat(\"<\")) // tw macro\n    return chain(stream, state, twTokenMacro);\n\n  // core macro handling\n  stream.eatWhile(/[\\w\\$_]/);\n  return textwords.propertyIsEnumerable(stream.current()) ? \"keyword\" : null\n}\n\n// tw invisible comment\nfunction twTokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"%\");\n  }\n  return \"comment\";\n}\n\n// tw strong / bold\nfunction twTokenStrong(stream, state) {\n  var maybeEnd = false,\n      ch;\n  while (ch = stream.next()) {\n    if (ch == \"'\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"'\");\n  }\n  return \"strong\";\n}\n\n// tw code\nfunction twTokenCode(stream, state) {\n  var sb = state.block;\n\n  if (sb && stream.current()) {\n    return \"comment\";\n  }\n\n  if (!sb && stream.match(reUntilCodeStop)) {\n    state.tokenize = tokenBase;\n    return \"comment\";\n  }\n\n  if (sb && stream.sol() && stream.match(reCodeBlockStop)) {\n    state.tokenize = tokenBase;\n    return \"comment\";\n  }\n\n  stream.next();\n  return \"comment\";\n}\n\n// tw em / italic\nfunction twTokenEm(stream, state) {\n  var maybeEnd = false,\n      ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"/\");\n  }\n  return \"emphasis\";\n}\n\n// tw underlined text\nfunction twTokenUnderline(stream, state) {\n  var maybeEnd = false,\n      ch;\n  while (ch = stream.next()) {\n    if (ch == \"_\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"_\");\n  }\n  return \"link\";\n}\n\n// tw strike through text looks ugly\n// change CSS if needed\nfunction twTokenStrike(stream, state) {\n  var maybeEnd = false, ch;\n\n  while (ch = stream.next()) {\n    if (ch == \"-\" && maybeEnd) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"-\");\n  }\n  return \"deleted\";\n}\n\n// macro\nfunction twTokenMacro(stream, state) {\n  if (stream.current() == '<<') {\n    return 'meta';\n  }\n\n  var ch = stream.next();\n  if (!ch) {\n    state.tokenize = tokenBase;\n    return null;\n  }\n  if (ch == \">\") {\n    if (stream.peek() == '>') {\n      stream.next();\n      state.tokenize = tokenBase;\n      return \"meta\";\n    }\n  }\n\n  stream.eatWhile(/[\\w\\$_]/);\n  return keywords.propertyIsEnumerable(stream.current()) ? \"keyword\" : null\n}\n\n// Interface\nexport const tiddlyWiki = {\n  name: \"tiddlywiki\",\n\n  startState: function () {\n    return {tokenize: tokenBase};\n  },\n\n  token: function (stream, state) {\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    return style;\n  }\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}