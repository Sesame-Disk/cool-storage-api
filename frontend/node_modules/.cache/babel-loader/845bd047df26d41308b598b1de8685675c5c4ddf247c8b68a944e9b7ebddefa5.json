{"ast":null,"code":"import _defineProperty2 from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _inherits from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _toConsumableArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createClass from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport getDirection from 'direction';\nimport debounce from 'lodash/debounce';\nimport throttle from 'lodash/throttle';\nimport React, { createContext, useContext, useLayoutEffect, useEffect, Component, useRef, useState, useCallback, memo, forwardRef, useMemo, useReducer } from 'react';\nimport scrollIntoView from 'scroll-into-view-if-needed';\nimport { Editor, Scrubber, Transforms, Range, Element as Element$1, Path, Point, Node, Text as Text$1 } from '@seafile/slate';\nimport { isKeyHotkey } from 'is-hotkey';\nimport { ResizeObserver } from '@juggle/resize-observer';\nimport ReactDOM from 'react-dom';\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\n/**\r\n * An auto-incrementing identifier for keys.\r\n */\nvar n = 0;\n/**\r\n * A class that keeps track of a key string. We use a full class here because we\r\n * want to be able to use them as keys in `WeakMap` objects.\r\n */\nvar Key = /*#__PURE__*/_createClass(function Key() {\n  _classCallCheck(this, Key);\n  this.id = \"\".concat(n++);\n});\n/**\r\n * Two weak maps that allow us rebuild a path given a node. They are populated\r\n * at render time such that after a render occurs we can always backtrack.\r\n */\nvar NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\r\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\r\n * are used to resolve DOM event-related logic into Slate actions.\r\n */\n\nvar EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\n/**\r\n * Weak maps for storing editor-related state.\r\n */\n\nvar IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\r\n * Weak map for associating the context `onChange` context with the plugin.\r\n */\n\nvar EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\r\n * Weak maps for saving pending state on composition stage.\r\n */\n\nvar EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\r\n * Android input handling specific weak-maps\r\n */\n\nvar EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\r\n * Symbols.\r\n */\n\nvar PLACEHOLDER_SYMBOL = Symbol('placeholder');\nvar MARK_PLACEHOLDER_SYMBOL = Symbol('mark-placeholder');\n\n/**\r\n * Types.\r\n */\nvar DOMText = globalThis.Text;\n/**\r\n * Returns the host window of a DOM node\r\n */\n\nvar getDefaultView = function getDefaultView(value) {\n  return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\r\n * Check if a DOM node is a comment node.\r\n */\n\nvar isDOMComment = function isDOMComment(value) {\n  return isDOMNode(value) && value.nodeType === 8;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */\n\nvar isDOMElement = function isDOMElement(value) {\n  return isDOMNode(value) && value.nodeType === 1;\n};\n/**\r\n * Check if a value is a DOM node.\r\n */\n\nvar isDOMNode = function isDOMNode(value) {\n  var window = getDefaultView(value);\n  return !!window && value instanceof window.Node;\n};\n/**\r\n * Check if a value is a DOM selection.\r\n */\n\nvar isDOMSelection = function isDOMSelection(value) {\n  var window = value && value.anchorNode && getDefaultView(value.anchorNode);\n  return !!window && value instanceof window.Selection;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */\n\nvar isDOMText = function isDOMText(value) {\n  return isDOMNode(value) && value.nodeType === 3;\n};\n/**\r\n * Checks whether a paste event is a plaintext-only event.\r\n */\n\nvar isPlainTextOnlyPaste = function isPlainTextOnlyPaste(event) {\n  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;\n};\n/**\r\n * Normalize a DOM point so that it always refers to a text node.\r\n */\n\nvar normalizeDOMPoint = function normalizeDOMPoint(domPoint) {\n  var _domPoint = _slicedToArray(domPoint, 2),\n    node = _domPoint[0],\n    offset = _domPoint[1]; // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n\n  if (isDOMElement(node) && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var index = isLast ? offset - 1 : offset;\n    // If the editable child found is in front of input offset, we instead seek to its end\n    var _getEditableChildAndI = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward');\n    var _getEditableChildAndI2 = _slicedToArray(_getEditableChildAndI, 2);\n    node = _getEditableChildAndI2[0];\n    index = _getEditableChildAndI2[1];\n    isLast = index < offset; // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n\n    while (isDOMElement(node) && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward');\n    } // Determine the new offset inside the text node.\n\n    offset = isLast && node.textContent != null ? node.textContent.length : 0;\n  } // Return the node and offset.\n\n  return [node, offset];\n};\n/**\r\n * Determines wether the active element is nested within a shadowRoot\r\n */\n\nvar hasShadowRoot = function hasShadowRoot(node) {\n  var parent = node && node.parentNode;\n  while (parent) {\n    if (parent.toString() === '[object ShadowRoot]') {\n      return true;\n    }\n    parent = parent.parentNode;\n  }\n  return false;\n};\n/**\r\n * Get the nearest editable child and index at `index` in a `parent`, preferring\r\n * `direction`.\r\n */\n\nvar getEditableChildAndIndex = function getEditableChildAndIndex(parent, index, direction) {\n  var childNodes = parent.childNodes;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false; // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n\n  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) {\n      break;\n    }\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n    child = childNodes[i];\n    index = i;\n    i += direction === 'forward' ? 1 : -1;\n  }\n  return [child, index];\n};\n/**\r\n * Get the nearest editable child at `index` in a `parent`, preferring\r\n * `direction`.\r\n */\n\nvar getEditableChild = function getEditableChild(parent, index, direction) {\n  var _getEditableChildAndI3 = getEditableChildAndIndex(parent, index, direction),\n    _getEditableChildAndI4 = _slicedToArray(_getEditableChildAndI3, 1),\n    child = _getEditableChildAndI4[0];\n  return child;\n};\n/**\r\n * Get a plaintext representation of the content of a node, accounting for block\r\n * elements which get a newline appended.\r\n *\r\n * The domNode must be attached to the DOM.\r\n */\n\nvar getPlainText = function getPlainText(domNode) {\n  var text = '';\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n  if (isDOMElement(domNode)) {\n    for (var _i = 0, _Array$from = Array.from(domNode.childNodes); _i < _Array$from.length; _i++) {\n      var childNode = _Array$from[_i];\n      text += getPlainText(childNode);\n    }\n    var display = getComputedStyle(domNode).getPropertyValue('display');\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n';\n    }\n  }\n  return text;\n};\n/**\r\n * Get x-slate-fragment attribute from data-slate-fragment\r\n */\n\nvar catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = function getSlateFragmentAttribute(dataTransfer) {\n  var htmlData = dataTransfer.getData('text/html');\n  var _ref3 = htmlData.match(catchSlateFragment) || [],\n    _ref4 = _slicedToArray(_ref3, 2),\n    fragment = _ref4[1];\n  return fragment;\n};\n/**\r\n * Check whether a mutation originates from a editable element inside the editor.\r\n */\n\nvar isTrackedMutation = function isTrackedMutation(editor, mutation, batch) {\n  var target = mutation.target;\n  if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n    return false;\n  }\n  var _ReactEditor$getWindo = ReactEditor.getWindow(editor),\n    document = _ReactEditor$getWindo.document;\n  if (document.contains(target)) {\n    return ReactEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  }\n  var parentMutation = batch.find(function (_ref) {\n    var addedNodes = _ref.addedNodes,\n      removedNodes = _ref.removedNodes;\n    var _iterator = _createForOfIteratorHelper(addedNodes),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var node = _step.value;\n        if (node === target || node.contains(target)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var _iterator2 = _createForOfIteratorHelper(removedNodes),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _node = _step2.value;\n        if (_node === target || _node.contains(target)) {\n          return true;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  });\n  if (!parentMutation || parentMutation === mutation) {\n    return false;\n  } // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n\n  return isTrackedMutation(editor, parentMutation, batch);\n};\nvar IS_REACT_VERSION_17_OR_ABOVE = parseInt(React.version.split('.')[0], 10) >= 17;\nvar IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nvar IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_SAFARI = typeof navigator !== 'undefined' && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent); // \"modern\" Edge was released at 79.x\n\nvar IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent); // Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\n\nvar IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent);\nvar IS_ANDROID_CHROME_LEGACY = IS_ANDROID && typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-5]?\\d)(?:\\.)/i.test(navigator.userAgent); // Firefox did not support `beforeInput` until `v87`.\n\nvar IS_FIREFOX_LEGACY = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent); // UC mobile browser\n\nvar IS_UC_MOBILE = typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent); // Wechat browser\n\nvar IS_WECHATBROWSER = typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent); // Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\n\nvar CAN_USE_DOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined'); // COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\n\nvar HAS_BEFORE_INPUT_SUPPORT = (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) && !IS_EDGE_LEGACY &&\n// globalThis is undefined in older browsers\ntypeof globalThis !== 'undefined' && globalThis.InputEvent &&\n// @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === 'function';\nvar ReactEditor = {\n  /**\r\n   * Check if the user is currently composing inside the editor.\r\n   */\n  isComposing: function isComposing(editor) {\n    return !!IS_COMPOSING.get(editor);\n  },\n  /**\r\n   * Return the host window of the current editor.\r\n   */\n  getWindow: function getWindow(editor) {\n    var window = EDITOR_TO_WINDOW.get(editor);\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor');\n    }\n    return window;\n  },\n  /**\r\n   * Find a key for a Slate node.\r\n   */\n  findKey: function findKey(editor, node) {\n    var key = NODE_TO_KEY.get(node);\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n    return key;\n  },\n  /**\r\n   * Find the path of Slate node.\r\n   */\n  findPath: function findPath(editor, node) {\n    var path = [];\n    var child = node;\n    while (true) {\n      var parent = NODE_TO_PARENT.get(child);\n      if (parent == null) {\n        if (Editor.isEditor(child)) {\n          return path;\n        } else {\n          break;\n        }\n      }\n      var i = NODE_TO_INDEX.get(child);\n      if (i == null) {\n        break;\n      }\n      path.unshift(i);\n      child = parent;\n    }\n    throw new Error(\"Unable to find the path for Slate node: \".concat(Scrubber.stringify(node)));\n  },\n  /**\r\n   * Find the DOM node that implements DocumentOrShadowRoot for the editor.\r\n   */\n  findDocumentOrShadowRoot: function findDocumentOrShadowRoot(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n    if ((root instanceof Document || root instanceof ShadowRoot) && root.getSelection != null) {\n      return root;\n    }\n    return el.ownerDocument;\n  },\n  /**\r\n   * Check if the editor is focused.\r\n   */\n  isFocused: function isFocused(editor) {\n    return !!IS_FOCUSED.get(editor);\n  },\n  /**\r\n   * Check if the editor is in read-only mode.\r\n   */\n  isReadOnly: function isReadOnly(editor) {\n    return !!IS_READ_ONLY.get(editor);\n  },\n  /**\r\n   * Blur the editor.\r\n   */\n  blur: function blur(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, false);\n    if (root.activeElement === el) {\n      el.blur();\n    }\n  },\n  /**\r\n   * Focus the editor.\r\n   */\n  focus: function focus(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, true);\n    if (root.activeElement !== el) {\n      el.focus({\n        preventScroll: true\n      });\n    }\n  },\n  /**\r\n   * Deselect the editor.\r\n   */\n  deselect: function deselect(editor) {\n    var selection = editor.selection;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = root.getSelection();\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges();\n    }\n    if (selection) {\n      Transforms.deselect(editor);\n    }\n  },\n  /**\r\n   * Check if a DOM node is within the editor.\r\n   */\n  hasDOMNode: function hasDOMNode(editor, target) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$editable = options.editable,\n      editable = _options$editable === void 0 ? false : _options$editable;\n    var editorEl = ReactEditor.toDOMNode(editor, editor);\n    var targetEl; // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n\n    try {\n      targetEl = isDOMElement(target) ? target : target.parentElement;\n    } catch (err) {\n      if (!err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err;\n      }\n    }\n    if (!targetEl) {\n      return false;\n    }\n    return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === 'boolean' &&\n    // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n    targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute('data-slate-zero-width'));\n  },\n  /**\r\n   * Insert data from a `DataTransfer` into the editor.\r\n   */\n  insertData: function insertData(editor, data) {\n    editor.insertData(data);\n  },\n  /**\r\n   * Insert fragment data from a `DataTransfer` into the editor.\r\n   */\n  insertFragmentData: function insertFragmentData(editor, data) {\n    return editor.insertFragmentData(data);\n  },\n  /**\r\n   * Insert text data from a `DataTransfer` into the editor.\r\n   */\n  insertTextData: function insertTextData(editor, data) {\n    return editor.insertTextData(data);\n  },\n  /**\r\n   * Sets data from the currently selected fragment on a `DataTransfer`.\r\n   */\n  setFragmentData: function setFragmentData(editor, data, originEvent) {\n    editor.setFragmentData(data, originEvent);\n  },\n  /**\r\n   * Find the native DOM element from a Slate node.\r\n   */\n  toDOMNode: function toDOMNode(editor, node) {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    var domNode = Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node));\n    if (!domNode) {\n      throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(Scrubber.stringify(node)));\n    }\n    return domNode;\n  },\n  /**\r\n   * Find a native DOM selection point from a Slate point.\r\n   */\n  toDOMPoint: function toDOMPoint(editor, point) {\n    var _Editor$node = Editor.node(editor, point.path),\n      _Editor$node2 = _slicedToArray(_Editor$node, 1),\n      node = _Editor$node2[0];\n    var el = ReactEditor.toDOMNode(editor, node);\n    var domPoint; // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n\n    if (Editor.void(editor, {\n      at: point\n    })) {\n      point = {\n        path: point.path,\n        offset: 0\n      };\n    } // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n\n    var selector = \"[data-slate-string], [data-slate-zero-width]\";\n    var texts = Array.from(el.querySelectorAll(selector));\n    var start = 0;\n    for (var i = 0; i < texts.length; i++) {\n      var text = texts[i];\n      var domNode = text.childNodes[0];\n      if (domNode == null || domNode.textContent == null) {\n        continue;\n      }\n      var length = domNode.textContent.length;\n      var attr = text.getAttribute('data-slate-length');\n      var trueLength = attr == null ? length : parseInt(attr, 10);\n      var end = start + trueLength; // Prefer putting the selection inside the mark placeholder to ensure\n      // composed text is displayed with the correct marks.\n\n      var nextText = texts[i + 1];\n      if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute('data-slate-mark-placeholder')) {\n        var _nextText$textContent;\n        var domText = nextText.childNodes[0];\n        domPoint = [\n        // COMPAT: If we don't explicity set the dom point to be on the actual\n        // dom text element, chrome will put the selection behind the actual dom\n        // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n        // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n        // which will cause issues when scrolling to it.\n        domText instanceof DOMText ? domText : nextText, (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith(\"\\uFEFF\") ? 1 : 0];\n        break;\n      }\n      if (point.offset <= end) {\n        var offset = Math.min(length, Math.max(0, point.offset - start));\n        domPoint = [domNode, offset];\n        break;\n      }\n      start = end;\n    }\n    if (!domPoint) {\n      throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(Scrubber.stringify(point)));\n    }\n    return domPoint;\n  },\n  /**\r\n   * Find a native DOM range from a Slate `range`.\r\n   *\r\n   * Notice: the returned range will always be ordinal regardless of the direction of Slate `range` due to DOM API limit.\r\n   *\r\n   * there is no way to create a reverse DOM Range using Range.setStart/setEnd\r\n   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.\r\n   */\n  toDOMRange: function toDOMRange(editor, range) {\n    var anchor = range.anchor,\n      focus = range.focus;\n    var isBackward = Range.isBackward(range);\n    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);\n    var domFocus = Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);\n    var window = ReactEditor.getWindow(editor);\n    var domRange = window.document.createRange();\n    var _ref5 = isBackward ? domFocus : domAnchor,\n      _ref6 = _slicedToArray(_ref5, 2),\n      startNode = _ref6[0],\n      startOffset = _ref6[1];\n    var _ref7 = isBackward ? domAnchor : domFocus,\n      _ref8 = _slicedToArray(_ref7, 2),\n      endNode = _ref8[0],\n      endOffset = _ref8[1]; // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n\n    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');\n    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n    return domRange;\n  },\n  /**\r\n   * Find a Slate node from a native DOM `element`.\r\n   */\n  toSlateNode: function toSlateNode(editor, domNode) {\n    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(\"[data-slate-node]\");\n    }\n    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n    if (!node) {\n      throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n    }\n    return node;\n  },\n  /**\r\n   * Get the target range from a DOM `event`.\r\n   */\n  findEventRange: function findEventRange(editor, event) {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent;\n    }\n    var _event2 = event,\n      x = _event2.clientX,\n      y = _event2.clientY,\n      target = _event2.target;\n    if (x == null || y == null) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n    var node = ReactEditor.toSlateNode(editor, event.target);\n    var path = ReactEditor.findPath(editor, node); // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n\n    if (Element$1.isElement(node) && Editor.isVoid(editor, node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n      var edge = Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end'\n      });\n      var point = isPrev ? Editor.before(editor, edge) : Editor.after(editor, edge);\n      if (point) {\n        var _range = Editor.range(editor, point);\n        return _range;\n      }\n    } // Else resolve a range from the caret position where the drop occured.\n\n    var domRange;\n    var _ReactEditor$getWindo2 = ReactEditor.getWindow(editor),\n      document = _ReactEditor$getWindo2.document; // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y);\n    } else {\n      var position = document.caretPositionFromPoint(x, y);\n      if (position) {\n        domRange = document.createRange();\n        domRange.setStart(position.offsetNode, position.offset);\n        domRange.setEnd(position.offsetNode, position.offset);\n      }\n    }\n    if (!domRange) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    } // Resolve a Slate range from the DOM range.\n\n    var range = ReactEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      suppressThrow: false\n    });\n    return range;\n  },\n  /**\r\n   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.\r\n   */\n  toSlatePoint: function toSlatePoint(editor, domPoint, options) {\n    var exactMatch = options.exactMatch,\n      suppressThrow = options.suppressThrow;\n    var _ref9 = exactMatch ? domPoint : normalizeDOMPoint(domPoint),\n      _ref10 = _slicedToArray(_ref9, 2),\n      nearestNode = _ref10[0],\n      nearestOffset = _ref10[1];\n    var parentNode = nearestNode.parentNode;\n    var textNode = null;\n    var offset = 0;\n    if (parentNode) {\n      var _domNode$textContent, _domNode$textContent2;\n      var editorEl = ReactEditor.toDOMNode(editor, editor);\n      var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]'); // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n\n      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n      var leafNode = parentNode.closest('[data-slate-leaf]');\n      var domNode = null; // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n        if (textNode) {\n          var window = ReactEditor.getWindow(editor);\n          var range = window.document.createRange();\n          range.setStart(textNode, 0);\n          range.setEnd(nearestNode, nearestOffset);\n          var contents = range.cloneContents();\n          var removals = [].concat(_toConsumableArray(Array.prototype.slice.call(contents.querySelectorAll('[data-slate-zero-width]'))), _toConsumableArray(Array.prototype.slice.call(contents.querySelectorAll('[contenteditable=false]'))));\n          removals.forEach(function (el) {\n            // COMPAT: While composing at the start of a text node, some keyboards put\n            // the text content inside the zero width space.\n            if (IS_ANDROID && !exactMatch && el.hasAttribute('data-slate-zero-width') && el.textContent.length > 0 && el.textContext !== \"\\uFEFF\") {\n              if (el.textContent.startsWith(\"\\uFEFF\")) {\n                el.textContent = el.textContent.slice(1);\n              }\n              return;\n            }\n            el.parentNode.removeChild(el);\n          }); // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-react\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n\n          offset = contents.textContent.length;\n          domNode = textNode;\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent and taking the\n        // first one that isn't inside a nested editor.\n        var leafNodes = voidNode.querySelectorAll('[data-slate-leaf]');\n        for (var index = 0; index < leafNodes.length; index++) {\n          var current = leafNodes[index];\n          if (ReactEditor.hasDOMNode(editor, current)) {\n            leafNode = current;\n            break;\n          }\n        } // COMPAT: In read-only editors the leaf is not rendered.\n\n        if (!leafNode) {\n          offset = 1;\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          offset = domNode.textContent.length;\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(function (el) {\n            offset -= el.textContent.length;\n          });\n        }\n      }\n      if (domNode && offset === domNode.textContent.length &&\n      // COMPAT: Android IMEs might remove the zero width space while composing,\n      // and we don't add it for line-breaks.\n      IS_ANDROID && domNode.getAttribute('data-slate-zero-width') === 'z' && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith(\"\\uFEFF\") && (parentNode.hasAttribute('data-slate-zero-width') || IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith('\\n\\n'))) {\n        offset--;\n      }\n    }\n    if (IS_ANDROID && !textNode && !exactMatch) {\n      var node = parentNode.hasAttribute('data-slate-node') ? parentNode : parentNode.closest('[data-slate-node]');\n      if (node && ReactEditor.hasDOMNode(editor, node, {\n        editable: true\n      })) {\n        var _slateNode = ReactEditor.toSlateNode(editor, node);\n        var _Editor$start = Editor.start(editor, ReactEditor.findPath(editor, _slateNode)),\n          _path = _Editor$start.path,\n          _offset = _Editor$start.offset;\n        if (!node.querySelector('[data-slate-leaf]')) {\n          _offset = nearestOffset;\n        }\n        return {\n          path: _path,\n          offset: _offset\n        };\n      }\n    }\n    if (!textNode) {\n      if (suppressThrow) {\n        return null;\n      }\n      throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n    } // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n\n    var slateNode = ReactEditor.toSlateNode(editor, textNode);\n    var path = ReactEditor.findPath(editor, slateNode);\n    return {\n      path: path,\n      offset: offset\n    };\n  },\n  /**\r\n   * Find a Slate range from a DOM range or selection.\r\n   */\n  toSlateRange: function toSlateRange(editor, domRange, options) {\n    var exactMatch = options.exactMatch,\n      suppressThrow = options.suppressThrow;\n    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n    var anchorNode;\n    var anchorOffset;\n    var focusNode;\n    var focusOffset;\n    var isCollapsed;\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        anchorNode = domRange.anchorNode;\n        anchorOffset = domRange.anchorOffset;\n        focusNode = domRange.focusNode;\n        focusOffset = domRange.focusOffset; // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n\n        if (IS_CHROME && hasShadowRoot(anchorNode)) {\n          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n        } else {\n          isCollapsed = domRange.isCollapsed;\n        }\n      } else {\n        anchorNode = domRange.startContainer;\n        anchorOffset = domRange.startOffset;\n        focusNode = domRange.endContainer;\n        focusOffset = domRange.endOffset;\n        isCollapsed = domRange.collapsed;\n      }\n    }\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n    } // COMPAT: Triple-clicking a word in chrome will sometimes place the focus\n    // inside a `contenteditable=\"false\"` DOM node following the word, which\n    // will cause `toSlatePoint` to throw an error. (2023/03/07)\n\n    if ('getAttribute' in focusNode && focusNode.getAttribute('contenteditable') === 'false') {\n      var _anchorNode$textConte;\n      focusNode = anchorNode;\n      focusOffset = ((_anchorNode$textConte = anchorNode.textContent) === null || _anchorNode$textConte === void 0 ? void 0 : _anchorNode$textConte.length) || 0;\n    }\n    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {\n      exactMatch: exactMatch,\n      suppressThrow: suppressThrow\n    });\n    if (!anchor) {\n      return null;\n    }\n    var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset], {\n      exactMatch: exactMatch,\n      suppressThrow: suppressThrow\n    });\n    if (!focus) {\n      return null;\n    }\n    /**\r\n     * suppose we have this document:\r\n     *\r\n     * { type: 'paragraph',\r\n     *   children: [\r\n     *     { text: 'foo ' },\r\n     *     { text: 'bar' },\r\n     *     { text: ' baz' }\r\n     *   ]\r\n     * }\r\n     *\r\n     * a double click on \"bar\" on chrome will create this range:\r\n     *\r\n     * anchor -> [0,1] offset 0\r\n     * focus  -> [0,1] offset 3\r\n     *\r\n     * while on firefox will create this range:\r\n     *\r\n     * anchor -> [0,0] offset 4\r\n     * focus  -> [0,2] offset 0\r\n     *\r\n     * let's try to fix it...\r\n     */\n\n    if (IS_FIREFOX && !isCollapsed && anchorNode !== focusNode) {\n      var isEnd = Editor.isEnd(editor, anchor, anchor.path);\n      var isStart = Editor.isStart(editor, focus, focus.path);\n      if (isEnd) {\n        var after = Editor.after(editor, anchor); // Editor.after() might return undefined\n\n        anchor = after || anchor;\n      }\n      if (isStart) {\n        var before = Editor.before(editor, focus);\n        focus = before || focus;\n      }\n    }\n    var range = {\n      anchor: anchor,\n      focus: focus\n    }; // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n\n    if (Range.isExpanded(range) && Range.isForward(range) && isDOMElement(focusNode) && Editor.void(editor, {\n      at: range.focus,\n      mode: 'highest'\n    })) {\n      range = Editor.unhangRange(editor, range, {\n        voids: true\n      });\n    }\n    return range;\n  },\n  hasRange: function hasRange(editor, range) {\n    var anchor = range.anchor,\n      focus = range.focus;\n    return Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus.path);\n  },\n  /**\r\n   * Check if the target is in the editor.\r\n   */\n  hasTarget: function hasTarget(editor, target) {\n    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);\n  },\n  /**\r\n   * Check if the target is editable and in the editor.\r\n   */\n  hasEditableTarget: function hasEditableTarget(editor, target) {\n    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  },\n  /**\r\n   * Check if the target can be selectable\r\n   */\n  hasSelectableTarget: function hasSelectableTarget(editor, target) {\n    return ReactEditor.hasEditableTarget(editor, target) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, target);\n  },\n  /**\r\n   * Check if the target is inside void and in an non-readonly editor.\r\n   */\n  isTargetInsideNonReadonlyVoid: function isTargetInsideNonReadonlyVoid(editor, target) {\n    if (IS_READ_ONLY.get(editor)) return false;\n    var slateNode = ReactEditor.hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);\n    return Element$1.isElement(slateNode) && Editor.isVoid(editor, slateNode);\n  },\n  /**\r\n   * Experimental and android specific: Flush all pending diffs and cancel composition at the next possible time.\r\n   */\n  androidScheduleFlush: function androidScheduleFlush(editor) {\n    var _EDITOR_TO_SCHEDULE_F;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n  },\n  /**\r\n   * Experimental and android specific: Get pending diffs\r\n   */\n  androidPendingDiffs: function androidPendingDiffs(editor) {\n    return EDITOR_TO_PENDING_DIFFS.get(editor);\n  }\n};\n\n/**\r\n * A React context for sharing the `decorate` prop of the editable.\r\n */\n\nvar DecorateContext = /*#__PURE__*/createContext(function () {\n  return [];\n});\n/**\r\n * Get the current `decorate` prop of the editable.\r\n */\n\nvar useDecorate = function useDecorate() {\n  return useContext(DecorateContext);\n};\n\n/**\r\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\r\n */\n\nvar useIsomorphicLayoutEffect = CAN_USE_DOM ? useLayoutEffect : useEffect;\n\n/**\r\n * A React context for sharing the `readOnly` state of the editor.\r\n */\n\nvar ReadOnlyContext = /*#__PURE__*/createContext(false);\n/**\r\n * Get the current `readOnly` state of the editor.\r\n */\n\nvar useReadOnly = function useReadOnly() {\n  return useContext(ReadOnlyContext);\n};\nvar SlateContext = /*#__PURE__*/createContext(null);\n/**\r\n * Get the current editor object from the React context.\r\n */\n\nvar useSlate = function useSlate() {\n  var context = useContext(SlateContext);\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n  var editor = context.editor;\n  return editor;\n};\nvar useSlateWithV = function useSlateWithV() {\n  var context = useContext(SlateContext);\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n  return context;\n};\nvar TRIPLE_CLICK = 3;\n\n/**\r\n * Hotkey mappings for each platform.\r\n */\n\nvar HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z'\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t'\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z']\n};\n/**\r\n * Create a platform-aware hotkey checker.\r\n */\n\nvar create = function create(key) {\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && isKeyHotkey(generic);\n  var isApple = apple && isKeyHotkey(apple);\n  var isWindows = windows && isKeyHotkey(windows);\n  return function (event) {\n    if (isGeneric && isGeneric(event)) return true;\n    if (IS_APPLE && isApple && isApple(event)) return true;\n    if (!IS_APPLE && isWindows && isWindows(event)) return true;\n    return false;\n  };\n};\n/**\r\n * Hotkeys.\r\n */\n\nvar Hotkeys = {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo')\n};\n\n/**\r\n * A React context for sharing the editor object.\r\n */\n\nvar EditorContext = /*#__PURE__*/createContext(null);\n/**\r\n * Get the current editor object from the React context.\r\n */\n\nvar useSlateStatic = function useSlateStatic() {\n  var editor = useContext(EditorContext);\n  if (!editor) {\n    throw new Error(\"The `useSlateStatic` hook must be used inside the <Slate> component's context.\");\n  }\n  return editor;\n};\nvar createRestoreDomManager = function createRestoreDomManager(editor, receivedUserInput) {\n  var bufferedMutations = [];\n  var clear = function clear() {\n    bufferedMutations = [];\n  };\n  var registerMutations = function registerMutations(mutations) {\n    var _bufferedMutations;\n    if (!receivedUserInput.current) {\n      return;\n    }\n    var trackedMutations = mutations.filter(function (mutation) {\n      return isTrackedMutation(editor, mutation, mutations);\n    });\n    (_bufferedMutations = bufferedMutations).push.apply(_bufferedMutations, _toConsumableArray(trackedMutations));\n  };\n  function restoreDOM() {\n    if (bufferedMutations.length > 0) {\n      bufferedMutations.reverse().forEach(function (mutation) {\n        if (mutation.type === 'characterData') {\n          // We don't want to restore the DOM for characterData mutations\n          // because this interrupts the composition.\n          return;\n        }\n        mutation.removedNodes.forEach(function (node) {\n          mutation.target.insertBefore(node, mutation.nextSibling);\n        });\n        mutation.addedNodes.forEach(function (node) {\n          mutation.target.removeChild(node);\n        });\n      }); // Clear buffered mutations to ensure we don't undo them twice\n\n      clear();\n    }\n  }\n  return {\n    registerMutations: registerMutations,\n    restoreDOM: restoreDOM,\n    clear: clear\n  };\n};\nvar MUTATION_OBSERVER_CONFIG$1 = {\n  subtree: true,\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true\n}; // We have to use a class component here since we rely on `getSnapshotBeforeUpdate` which has no FC equivalent\n// to run code synchronously immediately before react commits the component update to the DOM.\nvar RestoreDOMComponent = /*#__PURE__*/function (_Component) {\n  _inherits(RestoreDOMComponent, _Component);\n  var _super = _createSuper(RestoreDOMComponent);\n  function RestoreDOMComponent() {\n    var _this;\n    _classCallCheck(this, RestoreDOMComponent);\n    _this = _super.apply(this, arguments);\n    _this.context = null;\n    _this.manager = null;\n    _this.mutationObserver = null;\n    return _this;\n  }\n  _createClass(RestoreDOMComponent, [{\n    key: \"observe\",\n    value: function observe() {\n      var _this$mutationObserve;\n      var node = this.props.node;\n      if (!node.current) {\n        throw new Error('Failed to attach MutationObserver, `node` is undefined');\n      }\n      (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.observe(node.current, MUTATION_OBSERVER_CONFIG$1);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var receivedUserInput = this.props.receivedUserInput;\n      var editor = this.context;\n      this.manager = createRestoreDomManager(editor, receivedUserInput);\n      this.mutationObserver = new MutationObserver(this.manager.registerMutations);\n      this.observe();\n    }\n  }, {\n    key: \"getSnapshotBeforeUpdate\",\n    value: function getSnapshotBeforeUpdate() {\n      var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;\n      var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();\n      if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {\n        var _this$manager;\n        (_this$manager = this.manager) === null || _this$manager === void 0 ? void 0 : _this$manager.registerMutations(pendingMutations);\n      }\n      (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 ? void 0 : _this$mutationObserve3.disconnect();\n      (_this$manager2 = this.manager) === null || _this$manager2 === void 0 ? void 0 : _this$manager2.restoreDOM();\n      return null;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var _this$manager3;\n      (_this$manager3 = this.manager) === null || _this$manager3 === void 0 ? void 0 : _this$manager3.clear();\n      this.observe();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var _this$mutationObserve4;\n      (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 ? void 0 : _this$mutationObserve4.disconnect();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.props.children;\n    }\n  }]);\n  return RestoreDOMComponent;\n}(Component);\nRestoreDOMComponent.contextType = EditorContext;\nvar RestoreDOM = IS_ANDROID ? RestoreDOMComponent : function (_ref) {\n  var children = _ref.children;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n};\n\n/**\r\n * Check whether a text diff was applied in a way we can perform the pending action on /\r\n * recover the pending selection.\r\n */\n\nfunction verifyDiffState(editor, textDiff) {\n  var path = textDiff.path,\n    diff = textDiff.diff;\n  if (!Editor.hasPath(editor, path)) {\n    return false;\n  }\n  var node = Node.get(editor, path);\n  if (!Text$1.isText(node)) {\n    return false;\n  }\n  if (diff.start !== node.text.length || diff.text.length === 0) {\n    return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n  }\n  var nextPath = Path.next(path);\n  if (!Editor.hasPath(editor, nextPath)) {\n    return false;\n  }\n  var nextNode = Node.get(editor, nextPath);\n  return Text$1.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\nfunction applyStringDiff(text) {\n  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    diffs[_key - 1] = arguments[_key];\n  }\n  return diffs.reduce(function (text, diff) {\n    return text.slice(0, diff.start) + diff.text + text.slice(diff.end);\n  }, text);\n}\nfunction longestCommonPrefixLength(str, another) {\n  var length = Math.min(str.length, another.length);\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(i) !== another.charAt(i)) {\n      return i;\n    }\n  }\n  return length;\n}\nfunction longestCommonSuffixLength(str, another, max) {\n  var length = Math.min(str.length, another.length, max);\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n      return i;\n    }\n  }\n  return length;\n}\n/**\r\n * Remove redundant changes from the diff so that it spans the minimal possible range\r\n */\n\nfunction normalizeStringDiff(targetText, diff) {\n  var start = diff.start,\n    end = diff.end,\n    text = diff.text;\n  var removedText = targetText.slice(start, end);\n  var prefixLength = longestCommonPrefixLength(removedText, text);\n  var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n  var suffixLength = longestCommonSuffixLength(removedText, text, max);\n  var normalized = {\n    start: start + prefixLength,\n    end: end - suffixLength,\n    text: text.slice(prefixLength, text.length - suffixLength)\n  };\n  if (normalized.start === normalized.end && normalized.text.length === 0) {\n    return null;\n  }\n  return normalized;\n}\n/**\r\n * Return a string diff that is equivalent to applying b after a spanning the range of\r\n * both changes\r\n */\n\nfunction mergeStringDiffs(targetText, a, b) {\n  var start = Math.min(a.start, b.start);\n  var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n  var applied = applyStringDiff(targetText, a, b);\n  var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n  var text = applied.slice(start, sliceEnd);\n  var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n  return normalizeStringDiff(targetText, {\n    start: start,\n    end: end,\n    text: text\n  });\n}\n/**\r\n * Get the slate range the text diff spans.\r\n */\n\nfunction targetRange(textDiff) {\n  var path = textDiff.path,\n    diff = textDiff.diff;\n  return {\n    anchor: {\n      path: path,\n      offset: diff.start\n    },\n    focus: {\n      path: path,\n      offset: diff.end\n    }\n  };\n}\n/**\r\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\r\n * the pending diffs. Since the pending diffs might have been inserted with different\r\n * marks we have to 'walk' the offset from the starting position to ensure we still\r\n * have a valid point inside the document\r\n */\n\nfunction normalizePoint(editor, point) {\n  var path = point.path,\n    offset = point.offset;\n  if (!Editor.hasPath(editor, path)) {\n    return null;\n  }\n  var leaf = Node.get(editor, path);\n  if (!Text$1.isText(leaf)) {\n    return null;\n  }\n  var parentBlock = Editor.above(editor, {\n    match: function match(n) {\n      return Element$1.isElement(n) && Editor.isBlock(editor, n);\n    },\n    at: path\n  });\n  if (!parentBlock) {\n    return null;\n  }\n  while (offset > leaf.text.length) {\n    var entry = Editor.next(editor, {\n      at: path,\n      match: Text$1.isText\n    });\n    if (!entry || !Path.isDescendant(entry[1], parentBlock[1])) {\n      return null;\n    }\n    offset -= leaf.text.length;\n    leaf = entry[0];\n    path = entry[1];\n  }\n  return {\n    path: path,\n    offset: offset\n  };\n}\n/**\r\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\r\n */\n\nfunction normalizeRange(editor, range) {\n  var anchor = normalizePoint(editor, range.anchor);\n  if (!anchor) {\n    return null;\n  }\n  if (Range.isCollapsed(range)) {\n    return {\n      anchor: anchor,\n      focus: anchor\n    };\n  }\n  var focus = normalizePoint(editor, range.focus);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor: anchor,\n    focus: focus\n  };\n}\nfunction transformPendingPoint(editor, point, op) {\n  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(function (_ref) {\n    var path = _ref.path;\n    return Path.equals(path, point.path);\n  });\n  if (!textDiff || point.offset <= textDiff.diff.start) {\n    return Point.transform(point, op, {\n      affinity: 'backward'\n    });\n  }\n  var diff = textDiff.diff; // Point references location inside the diff => transform the point based on the location\n  // the diff will be applied to and add the offset inside the diff.\n\n  if (point.offset <= diff.start + diff.text.length) {\n    var _anchor = {\n      path: point.path,\n      offset: diff.start\n    };\n    var _transformed = Point.transform(_anchor, op, {\n      affinity: 'backward'\n    });\n    if (!_transformed) {\n      return null;\n    }\n    return {\n      path: _transformed.path,\n      offset: _transformed.offset + point.offset - diff.start\n    };\n  } // Point references location after the diff\n\n  var anchor = {\n    path: point.path,\n    offset: point.offset - diff.text.length + diff.end - diff.start\n  };\n  var transformed = Point.transform(anchor, op, {\n    affinity: 'backward'\n  });\n  if (!transformed) {\n    return null;\n  }\n  if (op.type === 'split_node' && Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n    return transformed;\n  }\n  return {\n    path: transformed.path,\n    offset: transformed.offset + diff.text.length - diff.end + diff.start\n  };\n}\nfunction transformPendingRange(editor, range, op) {\n  var anchor = transformPendingPoint(editor, range.anchor, op);\n  if (!anchor) {\n    return null;\n  }\n  if (Range.isCollapsed(range)) {\n    return {\n      anchor: anchor,\n      focus: anchor\n    };\n  }\n  var focus = transformPendingPoint(editor, range.focus, op);\n  if (!focus) {\n    return null;\n  }\n  return {\n    anchor: anchor,\n    focus: focus\n  };\n}\nfunction transformTextDiff(textDiff, op) {\n  var path = textDiff.path,\n    diff = textDiff.diff,\n    id = textDiff.id;\n  switch (op.type) {\n    case 'insert_text':\n      {\n        if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n        if (op.offset <= diff.start) {\n          return {\n            diff: {\n              start: op.text.length + diff.start,\n              end: op.text.length + diff.end,\n              text: diff.text\n            },\n            id: id,\n            path: path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end + op.text.length,\n            text: diff.text\n          },\n          id: id,\n          path: path\n        };\n      }\n    case 'remove_text':\n      {\n        if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n        if (op.offset + op.text.length <= diff.start) {\n          return {\n            diff: {\n              start: diff.start - op.text.length,\n              end: diff.end - op.text.length,\n              text: diff.text\n            },\n            id: id,\n            path: path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end - op.text.length,\n            text: diff.text\n          },\n          id: id,\n          path: path\n        };\n      }\n    case 'split_node':\n      {\n        if (!Path.equals(op.path, path) || op.position >= diff.end) {\n          return {\n            diff: diff,\n            id: id,\n            path: Path.transform(path, op, {\n              affinity: 'backward'\n            })\n          };\n        }\n        if (op.position > diff.start) {\n          return {\n            diff: {\n              start: diff.start,\n              end: Math.min(op.position, diff.end),\n              text: diff.text\n            },\n            id: id,\n            path: path\n          };\n        }\n        return {\n          diff: {\n            start: diff.start - op.position,\n            end: diff.end - op.position,\n            text: diff.text\n          },\n          id: id,\n          path: Path.transform(path, op, {\n            affinity: 'forward'\n          })\n        };\n      }\n    case 'merge_node':\n      {\n        if (!Path.equals(op.path, path)) {\n          return {\n            diff: diff,\n            id: id,\n            path: Path.transform(path, op)\n          };\n        }\n        return {\n          diff: {\n            start: diff.start + op.position,\n            end: diff.end + op.position,\n            text: diff.text\n          },\n          id: id,\n          path: Path.transform(path, op)\n        };\n      }\n  }\n  var newPath = Path.transform(path, op);\n  if (!newPath) {\n    return null;\n  }\n  return {\n    diff: diff,\n    path: newPath,\n    id: id\n  };\n}\nfunction ownKeys$4(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$4(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys$4(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$4(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n// When using keyboard English association function, conpositionEnd triggered too fast, resulting in after `insertText` still maintain association state.\n\nvar RESOLVE_DELAY = 25; // Time with no user interaction before the current user action is considered as done.\n\nvar FLUSH_DELAY = 200; // Replace with `const debug = console.log` to debug\n\nvar debug = function debug() {}; // Type guard to check if a value is a DataTransfer\n\nvar isDataTransfer = function isDataTransfer(value) {\n  return (value === null || value === void 0 ? void 0 : value.constructor.name) === 'DataTransfer';\n};\nfunction createAndroidInputManager(_ref) {\n  var editor = _ref.editor,\n    scheduleOnDOMSelectionChange = _ref.scheduleOnDOMSelectionChange,\n    onDOMSelectionChange = _ref.onDOMSelectionChange;\n  var flushing = false;\n  var compositionEndTimeoutId = null;\n  var flushTimeoutId = null;\n  var actionTimeoutId = null;\n  var idCounter = 0;\n  var insertPositionHint = false;\n  var applyPendingSelection = function applyPendingSelection() {\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);\n    EDITOR_TO_PENDING_SELECTION.delete(editor);\n    if (pendingSelection) {\n      var selection = editor.selection;\n      var normalized = normalizeRange(editor, pendingSelection);\n      if (normalized && (!selection || !Range.equals(normalized, selection))) {\n        Transforms.select(editor, normalized);\n      }\n    }\n  };\n  var performAction = function performAction() {\n    var action = EDITOR_TO_PENDING_ACTION.get(editor);\n    EDITOR_TO_PENDING_ACTION.delete(editor);\n    if (!action) {\n      return;\n    }\n    if (action.at) {\n      var target = Point.isPoint(action.at) ? normalizePoint(editor, action.at) : normalizeRange(editor, action.at);\n      if (!target) {\n        return;\n      }\n      var _targetRange = Editor.range(editor, target);\n      if (!editor.selection || !Range.equals(editor.selection, _targetRange)) {\n        Transforms.select(editor, target);\n      }\n    }\n    action.run();\n  };\n  var flush = function flush() {\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n    if (actionTimeoutId) {\n      clearTimeout(actionTimeoutId);\n      actionTimeoutId = null;\n    }\n    if (!hasPendingDiffs() && !hasPendingAction()) {\n      applyPendingSelection();\n      return;\n    }\n    if (!flushing) {\n      flushing = true;\n      setTimeout(function () {\n        return flushing = false;\n      });\n    }\n    if (hasPendingAction()) {\n      flushing = 'action';\n    }\n    var selectionRef = editor.selection && Editor.rangeRef(editor, editor.selection, {\n      affinity: 'forward'\n    });\n    EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n    debug('flush', EDITOR_TO_PENDING_ACTION.get(editor), EDITOR_TO_PENDING_DIFFS.get(editor));\n    var scheduleSelectionChange = hasPendingDiffs();\n    var diff;\n    while (diff = (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI === void 0 ? void 0 : _EDITOR_TO_PENDING_DI[0]) {\n      var _EDITOR_TO_PENDING_DI, _EDITOR_TO_PENDING_DI2;\n      var pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n      if (pendingMarks !== undefined) {\n        EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n        editor.marks = pendingMarks;\n      }\n      if (pendingMarks && insertPositionHint === false) {\n        insertPositionHint = null;\n      }\n      var range = targetRange(diff);\n      if (!editor.selection || !Range.equals(editor.selection, range)) {\n        Transforms.select(editor, range);\n      }\n      if (diff.diff.text) {\n        Editor.insertText(editor, diff.diff.text);\n      } else {\n        Editor.deleteFragment(editor);\n      } // Remove diff only after we have applied it to account for it when transforming\n      // pending ranges.\n\n      EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2.filter(function (_ref2) {\n        var id = _ref2.id;\n        return id !== diff.id;\n      }));\n      if (!verifyDiffState(editor, diff)) {\n        scheduleSelectionChange = false;\n        EDITOR_TO_PENDING_ACTION.delete(editor);\n        EDITOR_TO_USER_MARKS.delete(editor);\n        flushing = 'action'; // Ensure we don't restore the pending user (dom) selection\n        // since the document and dom state do not match.\n\n        EDITOR_TO_PENDING_SELECTION.delete(editor);\n        scheduleOnDOMSelectionChange.cancel();\n        onDOMSelectionChange.cancel();\n        selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n      }\n    }\n    var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n    if (selection && !EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !Range.equals(selection, editor.selection))) {\n      Transforms.select(editor, selection);\n    }\n    if (hasPendingAction()) {\n      performAction();\n      return;\n    } // COMPAT: The selectionChange event is fired after the action is performed,\n    // so we have to manually schedule it to ensure we don't 'throw away' the selection\n    // while rendering if we have pending changes.\n\n    if (scheduleSelectionChange) {\n      scheduleOnDOMSelectionChange();\n    }\n    scheduleOnDOMSelectionChange.flush();\n    onDOMSelectionChange.flush();\n    applyPendingSelection();\n    var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n    EDITOR_TO_USER_MARKS.delete(editor);\n    if (userMarks !== undefined) {\n      editor.marks = userMarks;\n      editor.onChange();\n    }\n  };\n  var handleCompositionEnd = function handleCompositionEnd(_event) {\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n    }\n    compositionEndTimeoutId = setTimeout(function () {\n      IS_COMPOSING.set(editor, false);\n      flush();\n    }, RESOLVE_DELAY);\n  };\n  var handleCompositionStart = function handleCompositionStart(_event) {\n    IS_COMPOSING.set(editor, true);\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n      compositionEndTimeoutId = null;\n    }\n  };\n  var updatePlaceholderVisibility = function updatePlaceholderVisibility() {\n    var forceHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);\n    if (!placeholderElement) {\n      return;\n    }\n    if (hasPendingDiffs() || forceHide) {\n      placeholderElement.style.display = 'none';\n      return;\n    }\n    placeholderElement.style.removeProperty('display');\n  };\n  var storeDiff = function storeDiff(path, diff) {\n    var _EDITOR_TO_PENDING_DI3;\n    var pendingDiffs = (_EDITOR_TO_PENDING_DI3 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI3 !== void 0 ? _EDITOR_TO_PENDING_DI3 : [];\n    EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);\n    var target = Node.leaf(editor, path);\n    var idx = pendingDiffs.findIndex(function (change) {\n      return Path.equals(change.path, path);\n    });\n    if (idx < 0) {\n      var normalized = normalizeStringDiff(target.text, diff);\n      if (normalized) {\n        pendingDiffs.push({\n          path: path,\n          diff: diff,\n          id: idCounter++\n        });\n      }\n      updatePlaceholderVisibility();\n      return;\n    }\n    var merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff);\n    if (!merged) {\n      pendingDiffs.splice(idx, 1);\n      updatePlaceholderVisibility();\n      return;\n    }\n    pendingDiffs[idx] = _objectSpread$4(_objectSpread$4({}, pendingDiffs[idx]), {}, {\n      diff: merged\n    });\n  };\n  var scheduleAction = function scheduleAction(run) {\n    var _ref11 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      at = _ref11.at;\n    insertPositionHint = false;\n    EDITOR_TO_PENDING_SELECTION.delete(editor);\n    scheduleOnDOMSelectionChange.cancel();\n    onDOMSelectionChange.cancel();\n    if (hasPendingAction()) {\n      flush();\n    }\n    EDITOR_TO_PENDING_ACTION.set(editor, {\n      at: at,\n      run: run\n    }); // COMPAT: When deleting before a non-contenteditable element chrome only fires a beforeinput,\n    // (no input) and doesn't perform any dom mutations. Without a flush timeout we would never flush\n    // in this case and thus never actually perform the action.\n\n    actionTimeoutId = setTimeout(flush);\n  };\n  var handleDOMBeforeInput = function handleDOMBeforeInput(event) {\n    var _targetRange2;\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n    var type = event.inputType;\n    var targetRange = null;\n    var data = event.dataTransfer || event.data || undefined;\n    if (insertPositionHint !== false && type !== 'insertText' && type !== 'insertCompositionText') {\n      insertPositionHint = false;\n    }\n    var _event$getTargetRange = event.getTargetRanges(),\n      _event$getTargetRange2 = _slicedToArray(_event$getTargetRange, 1),\n      nativeTargetRange = _event$getTargetRange2[0];\n    if (nativeTargetRange) {\n      targetRange = ReactEditor.toSlateRange(editor, nativeTargetRange, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    } // COMPAT: SelectionChange event is fired after the action is performed, so we\n    // have to manually get the selection here to ensure it's up-to-date.\n\n    var window = ReactEditor.getWindow(editor);\n    var domSelection = window.getSelection();\n    if (!targetRange && domSelection) {\n      nativeTargetRange = domSelection;\n      targetRange = ReactEditor.toSlateRange(editor, domSelection, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    }\n    targetRange = (_targetRange2 = targetRange) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;\n    if (!targetRange) {\n      return;\n    } // By default, the input manager tries to store text diffs so that we can\n    // defer flushing them at a later point in time. We don't want to flush\n    // for every input event as this can be expensive. However, there are some\n    // scenarios where we cannot safely store the text diff and must instead\n    // schedule an action to let Slate normalize the editor state.\n\n    var canStoreDiff = true;\n    if (type.startsWith('delete')) {\n      if (Range.isExpanded(targetRange)) {\n        var _Range$edges = Range.edges(targetRange),\n          _Range$edges2 = _slicedToArray(_Range$edges, 2),\n          _start = _Range$edges2[0],\n          _end = _Range$edges2[1];\n        var _leaf = Node.leaf(editor, _start.path);\n        if (_leaf.text.length === _start.offset && _end.offset === 0) {\n          var next = Editor.next(editor, {\n            at: _start.path,\n            match: Text$1.isText\n          });\n          if (next && Path.equals(next[1], _end.path)) {\n            targetRange = {\n              anchor: _end,\n              focus: _end\n            };\n          }\n        }\n      }\n      var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n      var _Range$edges3 = Range.edges(targetRange),\n        _Range$edges4 = _slicedToArray(_Range$edges3, 2),\n        start = _Range$edges4[0],\n        end = _Range$edges4[1];\n      var _Editor$leaf = Editor.leaf(editor, start.path),\n        _Editor$leaf2 = _slicedToArray(_Editor$leaf, 2),\n        leaf = _Editor$leaf2[0],\n        path = _Editor$leaf2[1];\n      var diff = {\n        text: '',\n        start: start.offset,\n        end: end.offset\n      };\n      var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n      var relevantPendingDiffs = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(function (change) {\n        return Path.equals(change.path, path);\n      });\n      var diffs = relevantPendingDiffs ? [relevantPendingDiffs.diff, diff] : [diff];\n      var text = applyStringDiff.apply(void 0, [leaf.text].concat(diffs));\n      if (text.length === 0) {\n        // Text leaf will be removed, so we need to schedule an\n        // action to remove it so that Slate can normalize instead\n        // of storing as a diff\n        canStoreDiff = false;\n      }\n      if (Range.isExpanded(targetRange)) {\n        if (canStoreDiff && Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n          var point = {\n            path: targetRange.anchor.path,\n            offset: start.offset\n          };\n          var range = Editor.range(editor, point, point);\n          handleUserSelect(range);\n          return storeDiff(targetRange.anchor.path, {\n            text: '',\n            end: end.offset,\n            start: start.offset\n          });\n        }\n        return scheduleAction(function () {\n          return Editor.deleteFragment(editor, {\n            direction: direction\n          });\n        }, {\n          at: targetRange\n        });\n      }\n    }\n    switch (type) {\n      case 'deleteByComposition':\n      case 'deleteByCut':\n      case 'deleteByDrag':\n        {\n          return scheduleAction(function () {\n            return Editor.deleteFragment(editor);\n          }, {\n            at: targetRange\n          });\n        }\n      case 'deleteContent':\n      case 'deleteContentForward':\n        {\n          var _targetRange3 = targetRange,\n            anchor = _targetRange3.anchor;\n          if (canStoreDiff && Range.isCollapsed(targetRange)) {\n            var targetNode = Node.leaf(editor, anchor.path);\n            if (anchor.offset < targetNode.text.length) {\n              return storeDiff(anchor.path, {\n                text: '',\n                start: anchor.offset,\n                end: anchor.offset + 1\n              });\n            }\n          }\n          return scheduleAction(function () {\n            return Editor.deleteForward(editor);\n          }, {\n            at: targetRange\n          });\n        }\n      case 'deleteContentBackward':\n        {\n          var _nativeTargetRange;\n          var _targetRange4 = targetRange,\n            _anchor = _targetRange4.anchor; // If we have a mismatch between the native and slate selection being collapsed\n          // we are most likely deleting a zero-width placeholder and thus should perform it\n          // as an action to ensure correct behavior (mostly happens with mark placeholders)\n\n          var nativeCollapsed = isDOMSelection(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);\n          if (canStoreDiff && nativeCollapsed && Range.isCollapsed(targetRange) && _anchor.offset > 0) {\n            return storeDiff(_anchor.path, {\n              text: '',\n              start: _anchor.offset - 1,\n              end: _anchor.offset\n            });\n          }\n          return scheduleAction(function () {\n            return Editor.deleteBackward(editor);\n          }, {\n            at: targetRange\n          });\n        }\n      case 'deleteEntireSoftLine':\n        {\n          return scheduleAction(function () {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n      case 'deleteHardLineBackward':\n        {\n          return scheduleAction(function () {\n            return Editor.deleteBackward(editor, {\n              unit: 'block'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n      case 'deleteSoftLineBackward':\n        {\n          return scheduleAction(function () {\n            return Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n      case 'deleteHardLineForward':\n        {\n          return scheduleAction(function () {\n            return Editor.deleteForward(editor, {\n              unit: 'block'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n      case 'deleteSoftLineForward':\n        {\n          return scheduleAction(function () {\n            return Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n      case 'deleteWordBackward':\n        {\n          return scheduleAction(function () {\n            return Editor.deleteBackward(editor, {\n              unit: 'word'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n      case 'deleteWordForward':\n        {\n          return scheduleAction(function () {\n            return Editor.deleteForward(editor, {\n              unit: 'word'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n      case 'insertLineBreak':\n        {\n          return scheduleAction(function () {\n            return Editor.insertSoftBreak(editor);\n          }, {\n            at: targetRange\n          });\n        }\n      case 'insertParagraph':\n        {\n          return scheduleAction(function () {\n            return Editor.insertBreak(editor);\n          }, {\n            at: targetRange\n          });\n        }\n      case 'insertCompositionText':\n      case 'deleteCompositionText':\n      case 'insertFromComposition':\n      case 'insertFromDrop':\n      case 'insertFromPaste':\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText':\n        {\n          if (isDataTransfer(data)) {\n            return scheduleAction(function () {\n              return ReactEditor.insertData(editor, data);\n            }, {\n              at: targetRange\n            });\n          }\n          var _text = data !== null && data !== void 0 ? data : ''; // COMPAT: If we are writing inside a placeholder, the ime inserts the text inside\n          // the placeholder itself and thus includes the zero-width space inside edit events.\n\n          if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {\n            _text = _text.replace(\"\\uFEFF\", '');\n          } // Pastes from the Android clipboard will generate `insertText` events.\n          // If the copied text contains any newlines, Android will append an\n          // extra newline to the end of the copied text.\n\n          if (type === 'insertText' && /.*\\n.*\\n$/.test(_text)) {\n            _text = _text.slice(0, -1);\n          } // If the text includes a newline, split it at newlines and paste each component\n          // string, with soft breaks in between each.\n\n          if (_text.includes('\\n')) {\n            return scheduleAction(function () {\n              var parts = _text.split('\\n');\n              parts.forEach(function (line, i) {\n                if (line) {\n                  Editor.insertText(editor, line);\n                }\n                if (i !== parts.length - 1) {\n                  Editor.insertSoftBreak(editor);\n                }\n              });\n            }, {\n              at: targetRange\n            });\n          }\n          if (Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n            var _Range$edges5 = Range.edges(targetRange),\n              _Range$edges6 = _slicedToArray(_Range$edges5, 2),\n              _start2 = _Range$edges6[0],\n              _end2 = _Range$edges6[1];\n            var _diff = {\n              start: _start2.offset,\n              end: _end2.offset,\n              text: _text\n            }; // COMPAT: Swiftkey has a weird bug where the target range of the 2nd word\n            // inserted after a mark placeholder is inserted with an anchor offset off by 1.\n            // So writing 'some text' will result in 'some ttext'. Luckily all 'normal' insert\n            // text events are fired with the correct target ranges, only the final 'insertComposition'\n            // isn't, so we can adjust the target range start offset if we are confident this is the\n            // swiftkey insert causing the issue.\n\n            if (_text && insertPositionHint && type === 'insertCompositionText') {\n              var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\\S|$/);\n              var diffPosition = _diff.start + _diff.text.search(/\\S|$/);\n              if (diffPosition === hintPosition + 1 && _diff.end === insertPositionHint.start + insertPositionHint.text.length) {\n                _diff.start -= 1;\n                insertPositionHint = null;\n                scheduleFlush();\n              } else {\n                insertPositionHint = false;\n              }\n            } else if (type === 'insertText') {\n              if (insertPositionHint === null) {\n                insertPositionHint = _diff;\n              } else if (insertPositionHint && Range.isCollapsed(targetRange) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {\n                insertPositionHint = _objectSpread$4(_objectSpread$4({}, insertPositionHint), {}, {\n                  text: insertPositionHint.text + _text\n                });\n              } else {\n                insertPositionHint = false;\n              }\n            } else {\n              insertPositionHint = false;\n            }\n            if (canStoreDiff) {\n              storeDiff(_start2.path, _diff);\n              return;\n            }\n          }\n          return scheduleAction(function () {\n            return Editor.insertText(editor, _text);\n          }, {\n            at: targetRange\n          });\n        }\n    }\n  };\n  var hasPendingAction = function hasPendingAction() {\n    return !!EDITOR_TO_PENDING_ACTION.get(editor);\n  };\n  var hasPendingDiffs = function hasPendingDiffs() {\n    var _EDITOR_TO_PENDING_DI4;\n    return !!((_EDITOR_TO_PENDING_DI4 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 && _EDITOR_TO_PENDING_DI4.length);\n  };\n  var hasPendingChanges = function hasPendingChanges() {\n    return hasPendingAction() || hasPendingDiffs();\n  };\n  var isFlushing = function isFlushing() {\n    return flushing;\n  };\n  var handleUserSelect = function handleUserSelect(range) {\n    EDITOR_TO_PENDING_SELECTION.set(editor, range);\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n    var selection = editor.selection;\n    if (!range) {\n      return;\n    }\n    var pathChanged = !selection || !Path.equals(selection.anchor.path, range.anchor.path);\n    var parentPathChanged = !selection || !Path.equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));\n    if (pathChanged && insertPositionHint || parentPathChanged) {\n      insertPositionHint = false;\n    }\n    if (pathChanged || hasPendingDiffs()) {\n      flushTimeoutId = setTimeout(flush, FLUSH_DELAY);\n    }\n  };\n  var handleInput = function handleInput() {\n    if (hasPendingAction() || !hasPendingDiffs()) {\n      flush();\n    }\n  };\n  var handleKeyDown = function handleKeyDown(_) {\n    // COMPAT: Swiftkey closes the keyboard when typing inside a empty node\n    // directly next to a non-contenteditable element (= the placeholder).\n    // The only event fired soon enough for us to allow hiding the placeholder\n    // without swiftkey picking it up is the keydown event, so we have to hide it\n    // here. See https://github.com/ianstormtaylor/slate/pull/4988#issuecomment-1201050535\n    if (!hasPendingDiffs()) {\n      updatePlaceholderVisibility(true);\n      setTimeout(updatePlaceholderVisibility);\n    }\n  };\n  var scheduleFlush = function scheduleFlush() {\n    if (!hasPendingAction()) {\n      actionTimeoutId = setTimeout(flush);\n    }\n  };\n  var handleDomMutations = function handleDomMutations(mutations) {\n    if (hasPendingDiffs() || hasPendingAction()) {\n      return;\n    }\n    if (mutations.some(function (mutation) {\n      return isTrackedMutation(editor, mutation, mutations);\n    })) {\n      var _EDITOR_TO_FORCE_REND;\n\n      // Cause a re-render to restore the dom state if we encounter tracked mutations without\n      // a corresponding pending action.\n      (_EDITOR_TO_FORCE_REND = EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 ? void 0 : _EDITOR_TO_FORCE_REND();\n    }\n  };\n  return {\n    flush: flush,\n    scheduleFlush: scheduleFlush,\n    hasPendingDiffs: hasPendingDiffs,\n    hasPendingAction: hasPendingAction,\n    hasPendingChanges: hasPendingChanges,\n    isFlushing: isFlushing,\n    handleUserSelect: handleUserSelect,\n    handleCompositionEnd: handleCompositionEnd,\n    handleCompositionStart: handleCompositionStart,\n    handleDOMBeforeInput: handleDOMBeforeInput,\n    handleKeyDown: handleKeyDown,\n    handleDomMutations: handleDomMutations,\n    handleInput: handleInput\n  };\n}\nfunction useIsMounted() {\n  var isMountedRef = useRef(false);\n  useEffect(function () {\n    isMountedRef.current = true;\n    return function () {\n      isMountedRef.current = false;\n    };\n  }, []);\n  return isMountedRef.current;\n}\nfunction useMutationObserver(node, callback, options) {\n  var _useState = useState(function () {\n      return new MutationObserver(callback);\n    }),\n    _useState2 = _slicedToArray(_useState, 1),\n    mutationObserver = _useState2[0];\n  useIsomorphicLayoutEffect(function () {\n    // Discard mutations caused during render phase. This works due to react calling\n    // useLayoutEffect synchronously after the render phase before the next tick.\n    mutationObserver.takeRecords();\n  });\n  useEffect(function () {\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined');\n    }\n    mutationObserver.observe(node.current, options);\n    return function () {\n      return mutationObserver.disconnect();\n    };\n  }, [mutationObserver, node, options]);\n}\nvar _excluded$3 = [\"node\"];\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys$3(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$3(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar MUTATION_OBSERVER_CONFIG = {\n  subtree: true,\n  childList: true,\n  characterData: true\n};\nvar useAndroidInputManager = !IS_ANDROID ? function () {\n  return null;\n} : function (_ref) {\n  var node = _ref.node,\n    options = _objectWithoutProperties(_ref, _excluded$3);\n  if (!IS_ANDROID) {\n    return null;\n  }\n  var editor = useSlateStatic();\n  var isMounted = useIsMounted();\n  var _useState3 = useState(function () {\n      return createAndroidInputManager(_objectSpread$3({\n        editor: editor\n      }, options));\n    }),\n    _useState4 = _slicedToArray(_useState3, 1),\n    inputManager = _useState4[0];\n  useMutationObserver(node, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG);\n  EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);\n  if (isMounted) {\n    inputManager.flush();\n  }\n  return inputManager;\n};\nfunction useTrackUserInput() {\n  var editor = useSlateStatic();\n  var receivedUserInput = useRef(false);\n  var animationFrameIdRef = useRef(0);\n  var onUserInput = useCallback(function () {\n    if (receivedUserInput.current) {\n      return;\n    }\n    receivedUserInput.current = true;\n    var window = ReactEditor.getWindow(editor);\n    window.cancelAnimationFrame(animationFrameIdRef.current);\n    animationFrameIdRef.current = window.requestAnimationFrame(function () {\n      receivedUserInput.current = false;\n    });\n  }, [editor]);\n  useEffect(function () {\n    return function () {\n      return cancelAnimationFrame(animationFrameIdRef.current);\n    };\n  }, []);\n  return {\n    receivedUserInput: receivedUserInput,\n    onUserInput: onUserInput\n  };\n}\nvar _excluded$2 = [\"anchor\", \"focus\"],\n  _excluded2$1 = [\"anchor\", \"focus\"];\nvar shallowCompare = function shallowCompare(obj1, obj2) {\n  return Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every(function (key) {\n    return obj2.hasOwnProperty(key) && obj1[key] === obj2[key];\n  });\n};\nvar isDecorationFlagsEqual = function isDecorationFlagsEqual(range, other) {\n  var rangeOwnProps = _objectWithoutProperties(range, _excluded$2);\n  var otherOwnProps = _objectWithoutProperties(other, _excluded2$1);\n  return range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] && shallowCompare(rangeOwnProps, otherOwnProps);\n};\n/**\r\n * Check if a list of decorator ranges are equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */\n\nvar isElementDecorationsEqual = function isElementDecorationsEqual(list, another) {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n    if (!Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\r\n * Check if a list of decorator ranges are equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */\n\nvar isTextDecorationsEqual = function isTextDecorationsEqual(list, another) {\n  if (list.length !== another.length) {\n    return false;\n  }\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i]; // compare only offsets because paths doesn't matter for text\n\n    if (range.anchor.offset !== other.anchor.offset || range.focus.offset !== other.focus.offset || !isDecorationFlagsEqual(range, other)) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\r\n * Leaf content strings.\r\n */\n\nvar String = function String(props) {\n  var isLast = props.isLast,\n    leaf = props.leaf,\n    parent = props.parent,\n    text = props.text;\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, text);\n  var parentPath = Path.parent(path);\n  var isMarkPlaceholder = leaf[MARK_PLACEHOLDER_SYMBOL] === true; // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n\n  if (editor.isVoid(parent)) {\n    return /*#__PURE__*/React.createElement(ZeroWidthString, {\n      length: Node.string(parent).length\n    });\n  } // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n\n  if (leaf.text === '' && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && Editor.string(editor, parentPath) === '') {\n    return /*#__PURE__*/React.createElement(ZeroWidthString, {\n      isLineBreak: true,\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  } // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n\n  if (leaf.text === '') {\n    return /*#__PURE__*/React.createElement(ZeroWidthString, {\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  } // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return /*#__PURE__*/React.createElement(TextString, {\n      isTrailing: true,\n      text: leaf.text\n    });\n  }\n  return /*#__PURE__*/React.createElement(TextString, {\n    text: leaf.text\n  });\n};\n/**\r\n * Leaf strings with text in them.\r\n */\n\nvar TextString = function TextString(props) {\n  var text = props.text,\n    _props$isTrailing = props.isTrailing,\n    isTrailing = _props$isTrailing === void 0 ? false : _props$isTrailing;\n  var ref = useRef(null);\n  var getTextContent = function getTextContent() {\n    return \"\".concat(text !== null && text !== void 0 ? text : '').concat(isTrailing ? '\\n' : '');\n  };\n  var _useState5 = useState(getTextContent),\n    _useState6 = _slicedToArray(_useState5, 1),\n    initialText = _useState6[0]; // This is the actual text rendering boundary where we interface with the DOM\n  // The text is not rendered as part of the virtual DOM, as since we handle basic character insertions natively,\n  // updating the DOM is not a one way dataflow anymore. What we need here is not reconciliation and diffing\n  // with previous version of the virtual DOM, but rather diffing with the actual DOM element, and replace the DOM <span> content\n  // exactly if and only if its current content does not match our current virtual DOM.\n  // Otherwise the DOM TextNode would always be replaced by React as the user types, which interferes with native text features,\n  // eg makes native spellcheck opt out from checking the text node.\n  // useLayoutEffect: updating our span before browser paint\n\n  useIsomorphicLayoutEffect(function () {\n    // null coalescing text to make sure we're not outputing \"null\" as a string in the extreme case it is nullish at runtime\n    var textWithTrailing = getTextContent();\n    if (ref.current && ref.current.textContent !== textWithTrailing) {\n      ref.current.textContent = textWithTrailing;\n    } // intentionally not specifying dependencies, so that this effect runs on every render\n    // as this effectively replaces \"specifying the text in the virtual DOM under the <span> below\" on each render\n  }); // We intentionally render a memoized <span> that only receives the initial text content when the component is mounted.\n  // We defer to the layout effect above to update the `textContent` of the span element when needed.\n\n  return /*#__PURE__*/React.createElement(MemoizedText$1, {\n    ref: ref\n  }, initialText);\n};\nvar MemoizedText$1 = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"data-slate-string\": true,\n    ref: ref\n  }, props.children);\n}));\n/**\r\n * Leaf strings without text, render as zero-width strings.\r\n */\n\nvar ZeroWidthString = function ZeroWidthString(props) {\n  var _props$length = props.length,\n    length = _props$length === void 0 ? 0 : _props$length,\n    _props$isLineBreak = props.isLineBreak,\n    isLineBreak = _props$isLineBreak === void 0 ? false : _props$isLineBreak,\n    _props$isMarkPlacehol = props.isMarkPlaceholder,\n    isMarkPlaceholder = _props$isMarkPlacehol === void 0 ? false : _props$isMarkPlacehol;\n  var attributes = {\n    'data-slate-zero-width': isLineBreak ? 'n' : 'z',\n    'data-slate-length': length\n  };\n  if (isMarkPlaceholder) {\n    attributes['data-slate-mark-placeholder'] = true;\n  }\n  return /*#__PURE__*/React.createElement(\"span\", Object.assign({}, attributes), !IS_ANDROID || !isLineBreak ? \"\\uFEFF\" : null, isLineBreak ? /*#__PURE__*/React.createElement(\"br\", null) : null);\n};\nfunction disconnectPlaceholderResizeObserver(placeholderResizeObserver, releaseObserver) {\n  if (placeholderResizeObserver.current) {\n    placeholderResizeObserver.current.disconnect();\n    if (releaseObserver) {\n      placeholderResizeObserver.current = null;\n    }\n  }\n}\nfunction clearTimeoutRef(timeoutRef) {\n  if (timeoutRef.current) {\n    clearTimeout(timeoutRef.current);\n    timeoutRef.current = null;\n  }\n}\n/**\r\n * Individual leaves in a text node with unique formatting.\r\n */\n\nvar Leaf = function Leaf(props) {\n  var leaf = props.leaf,\n    isLast = props.isLast,\n    text = props.text,\n    parent = props.parent,\n    renderPlaceholder = props.renderPlaceholder,\n    _props$renderLeaf = props.renderLeaf,\n    renderLeaf = _props$renderLeaf === void 0 ? function (props) {\n      return /*#__PURE__*/React.createElement(DefaultLeaf, Object.assign({}, props));\n    } : _props$renderLeaf;\n  var editor = useSlateStatic();\n  var placeholderResizeObserver = useRef(null);\n  var placeholderRef = useRef(null);\n  var _useState7 = useState(false),\n    _useState8 = _slicedToArray(_useState7, 2),\n    showPlaceholder = _useState8[0],\n    setShowPlaceholder = _useState8[1];\n  var showPlaceholderTimeoutRef = useRef(null);\n  var callbackPlaceholderRef = useCallback(function (placeholderEl) {\n    disconnectPlaceholderResizeObserver(placeholderResizeObserver, placeholderEl == null);\n    if (placeholderEl == null) {\n      var _leaf$onPlaceholderRe;\n      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n      (_leaf$onPlaceholderRe = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe === void 0 ? void 0 : _leaf$onPlaceholderRe.call(leaf, null);\n    } else {\n      EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);\n      if (!placeholderResizeObserver.current) {\n        // Create a new observer and observe the placeholder element.\n        var ResizeObserver$1 = window.ResizeObserver || ResizeObserver;\n        placeholderResizeObserver.current = new ResizeObserver$1(function () {\n          var _leaf$onPlaceholderRe2;\n          (_leaf$onPlaceholderRe2 = leaf.onPlaceholderResize) === null || _leaf$onPlaceholderRe2 === void 0 ? void 0 : _leaf$onPlaceholderRe2.call(leaf, placeholderEl);\n        });\n      }\n      placeholderResizeObserver.current.observe(placeholderEl);\n      placeholderRef.current = placeholderEl;\n    }\n  }, [placeholderRef, leaf, editor]);\n  var children = /*#__PURE__*/React.createElement(String, {\n    isLast: isLast,\n    leaf: leaf,\n    parent: parent,\n    text: text\n  });\n  var leafIsPlaceholder = leaf[PLACEHOLDER_SYMBOL];\n  useEffect(function () {\n    if (leafIsPlaceholder) {\n      if (!showPlaceholderTimeoutRef.current) {\n        // Delay the placeholder so it will not render in a selection\n        showPlaceholderTimeoutRef.current = setTimeout(function () {\n          setShowPlaceholder(true);\n          showPlaceholderTimeoutRef.current = null;\n        }, 300);\n      }\n    } else {\n      clearTimeoutRef(showPlaceholderTimeoutRef);\n      setShowPlaceholder(false);\n    }\n    return function () {\n      return clearTimeoutRef(showPlaceholderTimeoutRef);\n    };\n  }, [leafIsPlaceholder, setShowPlaceholder]);\n  if (leafIsPlaceholder && showPlaceholder) {\n    var placeholderProps = {\n      children: leaf.placeholder,\n      attributes: {\n        'data-slate-placeholder': true,\n        style: {\n          position: 'absolute',\n          pointerEvents: 'none',\n          width: '100%',\n          maxWidth: '100%',\n          display: 'block',\n          opacity: '0.333',\n          userSelect: 'none',\n          textDecoration: 'none'\n        },\n        contentEditable: false,\n        ref: callbackPlaceholderRef\n      }\n    };\n    children = /*#__PURE__*/React.createElement(React.Fragment, null, renderPlaceholder(placeholderProps), children);\n  } // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n\n  var attributes = {\n    'data-slate-leaf': true\n  };\n  return renderLeaf({\n    attributes: attributes,\n    children: children,\n    leaf: leaf,\n    text: text\n  });\n};\nvar MemoizedLeaf = /*#__PURE__*/React.memo(Leaf, function (prev, next) {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && Text$1.equals(next.leaf, prev.leaf) && next.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL];\n});\nvar DefaultLeaf = function DefaultLeaf(props) {\n  var attributes = props.attributes,\n    children = props.children;\n  return /*#__PURE__*/React.createElement(\"span\", Object.assign({}, attributes), children);\n};\n\n/**\r\n * Text.\r\n */\n\nvar Text = function Text(props) {\n  var decorations = props.decorations,\n    isLast = props.isLast,\n    parent = props.parent,\n    renderPlaceholder = props.renderPlaceholder,\n    renderLeaf = props.renderLeaf,\n    text = props.text;\n  var editor = useSlateStatic();\n  var ref = useRef(null);\n  var leaves = Text$1.decorations(text, decorations);\n  var key = ReactEditor.findKey(editor, text);\n  var children = [];\n  for (var i = 0; i < leaves.length; i++) {\n    var leaf = leaves[i];\n    children.push( /*#__PURE__*/React.createElement(MemoizedLeaf, {\n      isLast: isLast && i === leaves.length - 1,\n      key: \"\".concat(key.id, \"-\").concat(i),\n      renderPlaceholder: renderPlaceholder,\n      leaf: leaf,\n      text: text,\n      parent: parent,\n      renderLeaf: renderLeaf\n    }));\n  } // Update element-related weak maps with the DOM element ref.\n\n  var callbackRef = useCallback(function (span) {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    if (span) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, span);\n      NODE_TO_ELEMENT.set(text, span);\n      ELEMENT_TO_NODE.set(span, text);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(text);\n      if (ref.current) {\n        ELEMENT_TO_NODE.delete(ref.current);\n      }\n    }\n    ref.current = span;\n  }, [ref, editor, key, text]);\n  return /*#__PURE__*/React.createElement(\"span\", {\n    \"data-slate-node\": \"text\",\n    ref: callbackRef\n  }, children);\n};\nvar MemoizedText = /*#__PURE__*/React.memo(Text, function (prev, next) {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && isTextDecorationsEqual(next.decorations, prev.decorations);\n});\n\n/**\r\n * A React context for sharing the `selected` state of an element.\r\n */\n\nvar SelectedContext = /*#__PURE__*/createContext(false);\n/**\r\n * Get the current `selected` state of an element.\r\n */\n\nvar useSelected = function useSelected() {\n  return useContext(SelectedContext);\n};\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys$2(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$2(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nvar hasCursors = function hasCursors(cursors, node) {\n  var _node2 = _slicedToArray(node, 2),\n    path = _node2[1];\n  if (!cursors) return false;\n  return cursors.some(function (cursor) {\n    if (Range.includes(cursor, path)) return true;\n    return false;\n  });\n};\nvar decorateCursors = function decorateCursors(cursors, nodeEntry) {\n  if (!cursors) return [];\n  var ranges = [];\n  var _nodeEntry = _slicedToArray(nodeEntry, 2),\n    node = _nodeEntry[0],\n    path = _nodeEntry[1];\n  if (Text$1.isText(node) && cursors !== null && cursors !== void 0 && cursors.length) {\n    cursors.forEach(function (cursor) {\n      if (Range.includes(cursor, path)) {\n        var focus = cursor.focus,\n          anchor = cursor.anchor;\n        var isFocusNode = Path.equals(focus.path, path);\n        var isAnchorNode = Path.equals(anchor.path, path);\n        ranges.push(_objectSpread$2(_objectSpread$2({}, cursor), {}, {\n          isCaret: isFocusNode,\n          anchor: {\n            path: path,\n            offset: isAnchorNode ? anchor.offset : node.text.length\n          },\n          focus: {\n            path: path,\n            offset: isFocusNode ? focus.offset : 0\n          }\n        }));\n      }\n    });\n  }\n  return ranges;\n};\n\n/**\r\n * Children.\r\n */\n\nvar useChildren = function useChildren(props) {\n  var decorations = props.decorations,\n    node = props.node,\n    renderElement = props.renderElement,\n    renderPlaceholder = props.renderPlaceholder,\n    renderLeaf = props.renderLeaf,\n    selection = props.selection,\n    cursors = props.cursors;\n  var decorate = useDecorate();\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, node);\n  var children = [];\n  var isLeafBlock = Element$1.isElement(node) && !editor.isInline(node) && Editor.hasInlines(editor, node);\n  for (var i = 0; i < node.children.length; i++) {\n    var p = path.concat(i);\n    var n = node.children[i];\n    var key = ReactEditor.findKey(editor, n);\n    var range = Editor.range(editor, p);\n    var sel = selection && Range.intersection(range, selection);\n    var ds = decorate([n, p]);\n    var _iterator3 = _createForOfIteratorHelper(decorations),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var dec = _step3.value;\n        var d = Range.intersection(dec, range);\n        if (d) {\n          ds.push(d);\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n    if (Element$1.isElement(n)) {\n      // cursors\n      var hasCursor = hasCursors(cursors, [n, p]);\n      var childCursors = hasCursor ? cursors : null;\n      children.push( /*#__PURE__*/React.createElement(SelectedContext.Provider, {\n        key: \"provider-\".concat(key.id),\n        value: !!sel\n      }, /*#__PURE__*/React.createElement(MemoizedElement, {\n        decorations: ds,\n        element: n,\n        key: key.id,\n        renderElement: renderElement,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        selection: sel,\n        cursors: childCursors\n      })));\n    } else {\n      if (cursors) {\n        var _ds;\n        var ranges = decorateCursors(cursors, [n, p]);\n        (_ds = ds).push.apply(_ds, _toConsumableArray(ranges));\n      }\n      children.push( /*#__PURE__*/React.createElement(MemoizedText, {\n        decorations: ds,\n        key: key.id,\n        isLast: isLeafBlock && i === node.children.length - 1,\n        parent: node,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        text: n\n      }));\n    }\n    NODE_TO_INDEX.set(n, i);\n    NODE_TO_PARENT.set(n, node);\n  }\n  return children;\n};\n\n/**\r\n * Element.\r\n */\n\nvar Element = function Element(props) {\n  var decorations = props.decorations,\n    element = props.element,\n    _props$renderElement = props.renderElement,\n    renderElement = _props$renderElement === void 0 ? function (p) {\n      return /*#__PURE__*/React.createElement(DefaultElement, Object.assign({}, p));\n    } : _props$renderElement,\n    renderPlaceholder = props.renderPlaceholder,\n    renderLeaf = props.renderLeaf,\n    selection = props.selection,\n    cursors = props.cursors,\n    isComposing = props.isComposing;\n  var editor = useSlateStatic();\n  var readOnly = useReadOnly();\n  var isInline = editor.isInline(element);\n  var key = ReactEditor.findKey(editor, element);\n  var ref = useCallback(function (ref) {\n    // Update element-related weak maps with the DOM element ref.\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    if (ref) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref);\n      NODE_TO_ELEMENT.set(element, ref);\n      ELEMENT_TO_NODE.set(ref, element);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(element);\n    }\n  }, [editor, key, element]);\n  var children = useChildren({\n    decorations: decorations,\n    node: element,\n    renderElement: renderElement,\n    renderPlaceholder: renderPlaceholder,\n    renderLeaf: renderLeaf,\n    selection: selection,\n    cursors: cursors\n  }); // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n\n  var attributes = {\n    'data-slate-node': 'element',\n    ref: ref\n  };\n  if (isInline) {\n    attributes['data-slate-inline'] = true;\n  } // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n\n  if (!isInline && Editor.hasInlines(editor, element)) {\n    var text = Node.string(element);\n    var dir = getDirection(text);\n    if (dir === 'rtl') {\n      attributes.dir = dir;\n    }\n  } // If it's a void node, wrap the children in extra void-specific elements.\n\n  if (Editor.isVoid(editor, element)) {\n    attributes['data-slate-void'] = true;\n    if (!readOnly && isInline) {\n      attributes.contentEditable = false;\n    }\n    var Tag = isInline ? 'span' : 'div';\n    var _Node$texts = Node.texts(element),\n      _Node$texts2 = _slicedToArray(_Node$texts, 1),\n      _Node$texts2$ = _slicedToArray(_Node$texts2[0], 1),\n      _text = _Node$texts2$[0];\n    children = /*#__PURE__*/React.createElement(Tag, {\n      \"data-slate-spacer\": true,\n      style: {\n        height: '0',\n        color: 'transparent',\n        outline: 'none',\n        position: 'absolute'\n      }\n    }, /*#__PURE__*/React.createElement(MemoizedText, {\n      renderPlaceholder: renderPlaceholder,\n      decorations: [],\n      isLast: false,\n      parent: element,\n      text: _text\n    }));\n    NODE_TO_INDEX.set(_text, 0);\n    NODE_TO_PARENT.set(_text, element);\n  }\n  return renderElement({\n    attributes: attributes,\n    children: children,\n    element: element,\n    isComposing: isComposing\n  });\n};\nvar MemoizedElement = /*#__PURE__*/React.memo(Element, function (prev, next) {\n  return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && prev.renderPlaceholder === next.renderPlaceholder && isElementDecorationsEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && Range.equals(prev.selection, next.selection)) && prev.cursors === next.cursors && prev.isComposing === next.isComposing;\n});\n/**\r\n * The default element renderer.\r\n */\n\nvar DefaultElement = function DefaultElement(props) {\n  var attributes = props.attributes,\n    children = props.children,\n    element = props.element;\n  var editor = useSlateStatic();\n  var Tag = editor.isInline(element) ? 'span' : 'div';\n  return /*#__PURE__*/React.createElement(Tag, Object.assign({}, attributes, {\n    style: {\n      position: 'relative'\n    }\n  }), children);\n};\n\n/**\r\n * Children.\r\n */\n\nvar Children = function Children(props) {\n  var decorations = props.decorations,\n    node = props.node,\n    renderElement = props.renderElement,\n    renderPlaceholder = props.renderPlaceholder,\n    renderLeaf = props.renderLeaf,\n    selection = props.selection,\n    cursors = props.cursors,\n    composingNode = props.composingNode;\n  var decorate = useDecorate();\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, node);\n  var children = [];\n  for (var i = 0; i < node.children.length; i++) {\n    var p = path.concat(i);\n    var n = node.children[i];\n    var key = ReactEditor.findKey(editor, n);\n    var range = Editor.range(editor, p);\n    var sel = selection && Range.intersection(range, selection); // decorate\n\n    var ds = decorate([n, p]);\n    var _iterator4 = _createForOfIteratorHelper(decorations),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var dec = _step4.value;\n        var d = Range.intersection(dec, range);\n        if (d) {\n          ds.push(d);\n        }\n      } // cursors\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    var hasCursor = hasCursors(cursors, [n, p]);\n    var childCursors = hasCursor ? cursors : null; // placeholder\n\n    var isComposing = (composingNode === null || composingNode === void 0 ? void 0 : composingNode.id) === n.id;\n    children.push( /*#__PURE__*/React.createElement(SelectedContext.Provider, {\n      key: \"provider-\".concat(key.id),\n      value: !!sel\n    }, /*#__PURE__*/React.createElement(MemoizedElement, {\n      decorations: ds,\n      element: n,\n      key: key.id,\n      renderElement: renderElement,\n      renderPlaceholder: renderPlaceholder,\n      renderLeaf: renderLeaf,\n      selection: sel,\n      cursors: childCursors,\n      isComposing: isComposing\n    })));\n    NODE_TO_INDEX.set(n, i);\n    NODE_TO_PARENT.set(n, node);\n  }\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n};\nvar _excluded$1 = [\"autoFocus\", \"decorate\", \"onDOMBeforeInput\", \"placeholder\", \"readOnly\", \"renderElement\", \"renderLeaf\", \"renderPlaceholder\", \"scrollSelectionIntoView\", \"style\", \"as\", \"disableDefaultStyles\", \"cursors\"],\n  _excluded2 = [\"text\"];\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys$1(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$1(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n/**\r\n * Editable.\r\n */\n\nvar Editable = function Editable(props) {\n  var defaultRenderPlaceholder = useCallback(function (props) {\n    return /*#__PURE__*/React.createElement(DefaultPlaceholder, Object.assign({}, props));\n  }, []);\n  var autoFocus = props.autoFocus,\n    _props$decorate = props.decorate,\n    decorate = _props$decorate === void 0 ? defaultDecorate : _props$decorate,\n    propsOnDOMBeforeInput = props.onDOMBeforeInput,\n    placeholder = props.placeholder,\n    _props$readOnly = props.readOnly,\n    readOnly = _props$readOnly === void 0 ? false : _props$readOnly,\n    renderElement = props.renderElement,\n    renderLeaf = props.renderLeaf,\n    _props$renderPlacehol = props.renderPlaceholder,\n    renderPlaceholder = _props$renderPlacehol === void 0 ? defaultRenderPlaceholder : _props$renderPlacehol,\n    _props$scrollSelectio = props.scrollSelectionIntoView,\n    scrollSelectionIntoView = _props$scrollSelectio === void 0 ? defaultScrollSelectionIntoView : _props$scrollSelectio,\n    _props$style = props.style,\n    userStyle = _props$style === void 0 ? {} : _props$style,\n    _props$as = props.as,\n    Component = _props$as === void 0 ? 'div' : _props$as,\n    _props$disableDefault = props.disableDefaultStyles,\n    disableDefaultStyles = _props$disableDefault === void 0 ? false : _props$disableDefault,\n    cursors = props.cursors,\n    attributes = _objectWithoutProperties(props, _excluded$1);\n  var editor = useSlate(); // Rerender editor when composition status changed\n\n  var _useState9 = useState(false),\n    _useState10 = _slicedToArray(_useState9, 2),\n    isComposing = _useState10[0],\n    setIsComposing = _useState10[1];\n  var ref = useRef(null);\n  var deferredOperations = useRef([]);\n  var _useState11 = useState(),\n    _useState12 = _slicedToArray(_useState11, 2),\n    placeholderHeight = _useState12[0],\n    setPlaceholderHeight = _useState12[1];\n  var _useTrackUserInput = useTrackUserInput(),\n    onUserInput = _useTrackUserInput.onUserInput,\n    receivedUserInput = _useTrackUserInput.receivedUserInput;\n  var composingNode = useMemo(function () {\n    if (!isComposing) return null;\n    var block = Editor.above(editor, {\n      mode: 'highest',\n      match: function match(n) {\n        return Element$1.isElement(n) && Editor.isBlock(editor, n);\n      }\n    });\n    return block ? block[0] : null;\n  }, [editor, isComposing]);\n  var _useReducer = useReducer(function (s) {\n      return s + 1;\n    }, 0),\n    _useReducer2 = _slicedToArray(_useReducer, 2),\n    forceRender = _useReducer2[1];\n  EDITOR_TO_FORCE_RENDER.set(editor, forceRender); // Update internal state on each render.\n\n  IS_READ_ONLY.set(editor, readOnly); // Keep track of some state for the event handler logic.\n\n  var state = useMemo(function () {\n    return {\n      isDraggingInternally: false,\n      isUpdatingSelection: false,\n      latestElement: null,\n      hasMarkPlaceholder: false\n    };\n  }, []); // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n  // needs to be manually focused.\n\n  useEffect(function () {\n    if (ref.current && autoFocus) {\n      ref.current.focus();\n    }\n  }, [autoFocus]);\n  /**\r\n   * The AndroidInputManager object has a cyclical dependency on onDOMSelectionChange\r\n   *\r\n   * It is defined as a reference to simplify hook dependencies and clarify that\r\n   * it needs to be initialized.\r\n   */\n\n  var androidInputManagerRef = useRef(); // Listen on the native `selectionchange` event to be able to update any time\n  // the selection changes. This is required because React's `onSelect` is leaky\n  // and non-standard so it doesn't fire until after a selection has been\n  // released. This causes issues in situations where another change happens\n  // while a selection is being dragged.\n\n  var onDOMSelectionChange = useMemo(function () {\n    return throttle(function () {\n      var androidInputManager = androidInputManagerRef.current;\n      if ((IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        var activeElement = root.activeElement;\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var domSelection = root.getSelection();\n        if (activeElement === el) {\n          state.latestElement = activeElement;\n          IS_FOCUSED.set(editor, true);\n        } else {\n          IS_FOCUSED.delete(editor);\n        }\n        if (!domSelection) {\n          return Transforms.deselect(editor);\n        }\n        var anchorNode = domSelection.anchorNode,\n          focusNode = domSelection.focusNode;\n        var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);\n        var focusNodeSelectable = ReactEditor.hasEditableTarget(editor, focusNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, focusNode);\n        if (anchorNodeSelectable && focusNodeSelectable) {\n          var range = ReactEditor.toSlateRange(editor, domSelection, {\n            exactMatch: false,\n            suppressThrow: true\n          });\n          if (range) {\n            if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {\n              Transforms.select(editor, range);\n            } else {\n              androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleUserSelect(range);\n            }\n          }\n        } // Deselect the editor if the dom selection is not selectable in readonly mode\n\n        if (readOnly && (!anchorNodeSelectable || !focusNodeSelectable)) {\n          Transforms.deselect(editor);\n        }\n      }\n    }, 100);\n  }, [editor, readOnly, state]);\n  var scheduleOnDOMSelectionChange = useMemo(function () {\n    return debounce(onDOMSelectionChange, 0);\n  }, [onDOMSelectionChange]);\n  androidInputManagerRef.current = useAndroidInputManager({\n    node: ref,\n    onDOMSelectionChange: onDOMSelectionChange,\n    scheduleOnDOMSelectionChange: scheduleOnDOMSelectionChange\n  });\n  useIsomorphicLayoutEffect(function () {\n    var _androidInputManagerR, _androidInputManagerR2;\n\n    // Update element-related weak maps with the DOM element ref.\n    var window;\n    if (ref.current && (window = getDefaultView(ref.current))) {\n      EDITOR_TO_WINDOW.set(editor, window);\n      EDITOR_TO_ELEMENT.set(editor, ref.current);\n      NODE_TO_ELEMENT.set(editor, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, editor);\n    } else {\n      NODE_TO_ELEMENT.delete(editor);\n    } // Make sure the DOM selection state is in sync.\n\n    var selection = editor.selection;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = root.getSelection();\n    if (!domSelection || !ReactEditor.isFocused(editor) || (_androidInputManagerR = androidInputManagerRef.current) !== null && _androidInputManagerR !== void 0 && _androidInputManagerR.hasPendingAction()) {\n      return;\n    }\n    var setDomSelection = function setDomSelection(forceChange) {\n      var hasDomSelection = domSelection.type !== 'None'; // If the DOM selection is properly unset, we're done.\n\n      if (!selection && !hasDomSelection) {\n        return;\n      } // verify that the dom selection is in the editor\n\n      var editorElement = EDITOR_TO_ELEMENT.get(editor);\n      var hasDomSelectionInEditor = false;\n      if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {\n        hasDomSelectionInEditor = true;\n      } // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n\n      if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {\n        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: true,\n          // domSelection is not necessarily a valid Slate range\n          // (e.g. when clicking on contentEditable:false element)\n          suppressThrow: true\n        });\n        if (slateRange && Range.equals(slateRange, selection)) {\n          var _anchorNode$parentEle;\n          if (!state.hasMarkPlaceholder) {\n            return;\n          } // Ensure selection is inside the mark placeholder\n\n          var anchorNode = domSelection.anchorNode;\n          if (anchorNode !== null && anchorNode !== void 0 && (_anchorNode$parentEle = anchorNode.parentElement) !== null && _anchorNode$parentEle !== void 0 && _anchorNode$parentEle.hasAttribute('data-slate-mark-placeholder')) {\n            return;\n          }\n        }\n      } // when <Editable/> is being controlled through external value\n      // then its children might just change - DOM responds to it on its own\n      // but Slate's value is not being updated through any operation\n      // and thus it doesn't transform selection on its own\n\n      if (selection && !ReactEditor.hasRange(editor, selection)) {\n        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n        return;\n      } // Otherwise the DOM selection is out of sync, so update it.\n\n      state.isUpdatingSelection = true;\n      var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);\n      if (newDomRange) {\n        if (Range.isBackward(selection)) {\n          domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);\n        } else {\n          domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);\n        }\n        scrollSelectionIntoView(editor, newDomRange);\n      } else {\n        domSelection.removeAllRanges();\n      }\n      return newDomRange;\n    };\n    var newDomRange = setDomSelection();\n    var ensureSelection = ((_androidInputManagerR2 = androidInputManagerRef.current) === null || _androidInputManagerR2 === void 0 ? void 0 : _androidInputManagerR2.isFlushing()) === 'action';\n    if (!IS_ANDROID || !ensureSelection) {\n      setTimeout(function () {\n        // COMPAT: In Firefox, it's not enough to create a range, you also need\n        // to focus the contenteditable element too. (2016/11/16)\n        if (newDomRange && IS_FIREFOX) {\n          var el = ReactEditor.toDOMNode(editor, editor);\n          el.focus();\n        }\n        state.isUpdatingSelection = false;\n      });\n      return;\n    }\n    var timeoutId = null;\n    var animationFrameId = requestAnimationFrame(function () {\n      if (ensureSelection) {\n        var ensureDomSelection = function ensureDomSelection(forceChange) {\n          try {\n            var el = ReactEditor.toDOMNode(editor, editor);\n            el.focus();\n            setDomSelection(forceChange);\n          } catch (e) {// Ignore, dom and state might be out of sync\n          }\n        }; // Compat: Android IMEs try to force their selection by manually re-applying it even after we set it.\n        // This essentially would make setting the slate selection during an update meaningless, so we force it\n        // again here. We can't only do it in the setTimeout after the animation frame since that would cause a\n        // visible flicker.\n\n        ensureDomSelection();\n        timeoutId = setTimeout(function () {\n          // COMPAT: While setting the selection in an animation frame visually correctly sets the selection,\n          // it doesn't update GBoards spellchecker state. We have to manually trigger a selection change after\n          // the animation frame to ensure it displays the correct state.\n          ensureDomSelection(true);\n          state.isUpdatingSelection = false;\n        });\n      }\n    });\n    return function () {\n      cancelAnimationFrame(animationFrameId);\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  }); // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n  // is required because React's `beforeinput` is fake and never really attaches\n  // to the real event sadly. (2019/11/01)\n  // https://github.com/facebook/react/issues/11211\n\n  var onDOMBeforeInput = useCallback(function (event) {\n    onUserInput();\n    if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {\n      var _EDITOR_TO_USER_SELEC;\n\n      // COMPAT: BeforeInput events aren't cancelable on android, so we have to handle them differently using the android input manager.\n      if (androidInputManagerRef.current) {\n        return androidInputManagerRef.current.handleDOMBeforeInput(event);\n      } // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before\n      // triggering a `beforeinput` expecting the change to be applied to the immediately before\n      // set selection.\n\n      scheduleOnDOMSelectionChange.flush();\n      onDOMSelectionChange.flush();\n      var selection = editor.selection;\n      var type = event.inputType;\n      var data = event.dataTransfer || event.data || undefined;\n      var isCompositionChange = type === 'insertCompositionText' || type === 'deleteCompositionText'; // COMPAT: use composition change events as a hint to where we should insert\n      // composition text if we aren't composing to work around https://github.com/ianstormtaylor/slate/issues/5038\n\n      if (isCompositionChange && ReactEditor.isComposing(editor)) {\n        return;\n      }\n      var native = false;\n      if (type === 'insertText' && selection && Range.isCollapsed(selection) &&\n      // Only use native character insertion for single characters a-z or space for now.\n      // Long-press events (hold a + press 4 = ) to choose a special character otherwise\n      // causes duplicate inserts.\n      event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) &&\n      // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405\n      // When there is an inline element, e.g. a link, and you select\n      // right after it (the start of the next node).\n      selection.anchor.offset !== 0) {\n        var _node$parentElement, _window$getComputedSt;\n        native = true; // Skip native if there are marks, as\n        // `insertText` will insert a node, not just text.\n\n        if (editor.marks) {\n          native = false;\n        } // Chrome also has issues correctly editing the end of anchor elements: https://bugs.chromium.org/p/chromium/issues/detail?id=1259100\n        // Therefore we don't allow native events to insert text at the end of anchor nodes.\n\n        var anchor = selection.anchor;\n        var _ReactEditor$toDOMPoi = ReactEditor.toDOMPoint(editor, anchor),\n          _ReactEditor$toDOMPoi2 = _slicedToArray(_ReactEditor$toDOMPoi, 2),\n          node = _ReactEditor$toDOMPoi2[0],\n          offset = _ReactEditor$toDOMPoi2[1];\n        var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest('a');\n        var window = ReactEditor.getWindow(editor);\n        if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {\n          var _lastText$textContent;\n\n          // Find the last text node inside the anchor.\n          var lastText = window === null || window === void 0 ? void 0 : window.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();\n          if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {\n            native = false;\n          }\n        } // Chrome has issues with the presence of tab characters inside elements with whiteSpace = 'pre'\n        // causing abnormal insert behavior: https://bugs.chromium.org/p/chromium/issues/detail?id=1219139\n\n        if (native && node.parentElement && (window === null || window === void 0 ? void 0 : (_window$getComputedSt = window.getComputedStyle(node.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === 'pre') {\n          var block = Editor.above(editor, {\n            at: anchor.path,\n            match: function match(n) {\n              return Element$1.isElement(n) && Editor.isBlock(editor, n);\n            }\n          });\n          if (block && Node.string(block[0]).includes('\\t')) {\n            native = false;\n          }\n        }\n      } // COMPAT: For the deleting forward/backward input types we don't want\n      // to change the selection because it is the range that will be deleted,\n      // and those commands determine that for themselves.\n\n      if (!type.startsWith('delete') || type.startsWith('deleteBy')) {\n        var _event$getTargetRange3 = event.getTargetRanges(),\n          _event$getTargetRange4 = _slicedToArray(_event$getTargetRange3, 1),\n          targetRange = _event$getTargetRange4[0];\n        if (targetRange) {\n          var range = ReactEditor.toSlateRange(editor, targetRange, {\n            exactMatch: false,\n            suppressThrow: false\n          });\n          if (!selection || !Range.equals(selection, range)) {\n            native = false;\n            var selectionRef = !isCompositionChange && editor.selection && Editor.rangeRef(editor, editor.selection);\n            Transforms.select(editor, range);\n            if (selectionRef) {\n              EDITOR_TO_USER_SELECTION.set(editor, selectionRef);\n            }\n          }\n        }\n      } // Composition change types occur while a user is composing text and can't be\n      // cancelled. Let them through and wait for the composition to end.\n\n      if (isCompositionChange) {\n        return;\n      }\n      if (!native) {\n        event.preventDefault();\n      } // COMPAT: If the selection is expanded, even if the command seems like\n      // a delete forward/backward command it should delete the selection.\n\n      if (selection && Range.isExpanded(selection) && type.startsWith('delete')) {\n        var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n        Editor.deleteFragment(editor, {\n          direction: direction\n        });\n        return;\n      }\n      switch (type) {\n        case 'deleteByComposition':\n        case 'deleteByCut':\n        case 'deleteByDrag':\n          {\n            Editor.deleteFragment(editor);\n            break;\n          }\n        case 'deleteContent':\n        case 'deleteContentForward':\n          {\n            Editor.deleteForward(editor);\n            break;\n          }\n        case 'deleteContentBackward':\n          {\n            Editor.deleteBackward(editor);\n            break;\n          }\n        case 'deleteEntireSoftLine':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n        case 'deleteHardLineBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n        case 'deleteSoftLineBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n        case 'deleteHardLineForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n        case 'deleteSoftLineForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n        case 'deleteWordBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n        case 'deleteWordForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n        case 'insertLineBreak':\n          Editor.insertSoftBreak(editor);\n          break;\n        case 'insertParagraph':\n          {\n            Editor.insertBreak(editor);\n            break;\n          }\n        case 'insertFromComposition':\n        case 'insertFromDrop':\n        case 'insertFromPaste':\n        case 'insertFromYank':\n        case 'insertReplacementText':\n        case 'insertText':\n          {\n            if (type === 'insertFromComposition') {\n              // COMPAT: in Safari, `compositionend` is dispatched after the\n              // `beforeinput` for \"insertFromComposition\". But if we wait for it\n              // then we will abort because we're still composing and the selection\n              // won't be updated properly.\n              // https://www.w3.org/TR/input-events-2/\n              if (ReactEditor.isComposing(editor)) {\n                setIsComposing(false);\n                IS_COMPOSING.set(editor, false);\n              }\n            } // use a weak comparison instead of 'instanceof' to allow\n            // programmatic access of paste events coming from external windows\n            // like cypress where cy.window does not work realibly\n\n            if ((data === null || data === void 0 ? void 0 : data.constructor.name) === 'DataTransfer') {\n              ReactEditor.insertData(editor, data);\n            } else if (typeof data === 'string') {\n              // Only insertText operations use the native functionality, for now.\n              // Potentially expand to single character deletes, as well.\n              if (native) {\n                deferredOperations.current.push(function () {\n                  return Editor.insertText(editor, data);\n                });\n              } else {\n                Editor.insertText(editor, data);\n              }\n            }\n            break;\n          }\n      } // Restore the actual user section if nothing manually set it.\n\n      var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n      EDITOR_TO_USER_SELECTION.delete(editor);\n      if (toRestore && (!editor.selection || !Range.equals(editor.selection, toRestore))) {\n        Transforms.select(editor, toRestore);\n      }\n    }\n  }, [editor, onDOMSelectionChange, onUserInput, propsOnDOMBeforeInput, readOnly, scheduleOnDOMSelectionChange]);\n  var callbackRef = useCallback(function (node) {\n    if (node == null) {\n      onDOMSelectionChange.cancel();\n      scheduleOnDOMSelectionChange.cancel();\n      EDITOR_TO_ELEMENT.delete(editor);\n      NODE_TO_ELEMENT.delete(editor);\n      if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        ref.current.removeEventListener('beforeinput', onDOMBeforeInput);\n      }\n    } else {\n      // Attach a native DOM event handler for `beforeinput` events, because React's\n      // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n      // real `beforeinput` events sadly... (2019/11/04)\n      // https://github.com/facebook/react/issues/11211\n      if (HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        node.addEventListener('beforeinput', onDOMBeforeInput);\n      }\n    }\n    ref.current = node;\n  }, [onDOMSelectionChange, scheduleOnDOMSelectionChange, editor, onDOMBeforeInput]); // Attach a native DOM event handler for `selectionchange`, because React's\n  // built-in `onSelect` handler doesn't fire for all selection changes. It's a\n  // leaky polyfill that only fires on keypresses or clicks. Instead, we want to\n  // fire for any change to the selection inside the editor. (2019/11/04)\n  // https://github.com/facebook/react/issues/5785\n\n  useIsomorphicLayoutEffect(function () {\n    var window = ReactEditor.getWindow(editor);\n    window.document.addEventListener('selectionchange', scheduleOnDOMSelectionChange);\n    return function () {\n      window.document.removeEventListener('selectionchange', scheduleOnDOMSelectionChange);\n    };\n  }, [scheduleOnDOMSelectionChange]);\n  var decorations = decorate([editor, []]);\n  var showPlaceholder = placeholder && editor.children.length === 1 && Array.from(Node.texts(editor)).length === 1 && Node.string(editor) === '' && !isComposing;\n  var placeHolderResizeHandler = useCallback(function (placeholderEl) {\n    if (placeholderEl && showPlaceholder) {\n      var _placeholderEl$getBou;\n      setPlaceholderHeight((_placeholderEl$getBou = placeholderEl.getBoundingClientRect()) === null || _placeholderEl$getBou === void 0 ? void 0 : _placeholderEl$getBou.height);\n    } else {\n      setPlaceholderHeight(undefined);\n    }\n  }, [showPlaceholder]);\n  if (showPlaceholder) {\n    var _decorations$push;\n    var start = Editor.start(editor, []);\n    decorations.push((_decorations$push = {}, _defineProperty2(_decorations$push, PLACEHOLDER_SYMBOL, true), _defineProperty2(_decorations$push, \"placeholder\", placeholder), _defineProperty2(_decorations$push, \"onPlaceholderResize\", placeHolderResizeHandler), _defineProperty2(_decorations$push, \"anchor\", start), _defineProperty2(_decorations$push, \"focus\", start), _decorations$push));\n  }\n  var marks = editor.marks;\n  state.hasMarkPlaceholder = false;\n  if (editor.selection && Range.isCollapsed(editor.selection) && marks) {\n    var anchor = editor.selection.anchor;\n    var leaf = Node.leaf(editor, anchor.path);\n    var rest = _objectWithoutProperties(leaf, _excluded2); // While marks isn't a 'complete' text, we can still use loose Text.equals\n    // here which only compares marks anyway.\n\n    if (!Text$1.equals(leaf, marks, {\n      loose: true\n    })) {\n      state.hasMarkPlaceholder = true;\n      var unset = Object.fromEntries(Object.keys(rest).map(function (mark) {\n        return [mark, null];\n      }));\n      decorations.push(_objectSpread$1(_objectSpread$1(_objectSpread$1(_defineProperty2({}, MARK_PLACEHOLDER_SYMBOL, true), unset), marks), {}, {\n        anchor: anchor,\n        focus: anchor\n      }));\n    }\n  } // Update EDITOR_TO_MARK_PLACEHOLDER_MARKS in setTimeout useEffect to ensure we don't set it\n  // before we receive the composition end event.\n\n  useEffect(function () {\n    setTimeout(function () {\n      var selection = editor.selection;\n      if (selection) {\n        var _anchor = selection.anchor;\n        var _text = Node.leaf(editor, _anchor.path); // While marks isn't a 'complete' text, we can still use loose Text.equals\n        // here which only compares marks anyway.\n\n        if (marks && !Text$1.equals(_text, marks, {\n          loose: true\n        })) {\n          EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks);\n          return;\n        }\n      }\n      EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n    });\n  });\n  return /*#__PURE__*/React.createElement(ReadOnlyContext.Provider, {\n    value: readOnly\n  }, /*#__PURE__*/React.createElement(DecorateContext.Provider, {\n    value: decorate\n  }, /*#__PURE__*/React.createElement(RestoreDOM, {\n    node: ref,\n    receivedUserInput: receivedUserInput\n  }, /*#__PURE__*/React.createElement(Component, Object.assign({\n    role: readOnly ? undefined : 'textbox',\n    \"aria-multiline\": readOnly ? undefined : true\n  }, attributes, {\n    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n    // have to use hacks to make these replacement-based features work.\n    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop\n    // mismatch warning app moves to browser. Pass-through consumer props when\n    // not CAN_USE_DOM (SSR) and default to falsy value\n    spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,\n    autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : 'false',\n    autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : 'false',\n    \"data-slate-editor\": true,\n    \"data-slate-node\": \"value\",\n    // explicitly set this\n    contentEditable: !readOnly,\n    // in some cases, a decoration needs access to the range / selection to decorate a text node,\n    // then you will select the whole text node when you select part the of text\n    // this magic zIndex=\"-1\" will fix it\n    zindex: -1,\n    suppressContentEditableWarning: true,\n    ref: callbackRef,\n    style: _objectSpread$1(_objectSpread$1({}, disableDefaultStyles ? {} : _objectSpread$1({\n      // Allow positioning relative to the editable element.\n      position: 'relative',\n      // Prevent the default outline styles.\n      outline: 'none',\n      // Preserve adjacent whitespace and new lines.\n      whiteSpace: 'pre-wrap',\n      // Allow words to break if they are too long.\n      wordWrap: 'break-word'\n    }, placeholderHeight ? {\n      minHeight: placeholderHeight\n    } : {})), userStyle),\n    onBeforeInput: useCallback(function (event) {\n      // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n      // fall back to React's leaky polyfill instead just for it. It\n      // only works for the `insertText` input type.\n      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {\n        event.preventDefault();\n        if (!ReactEditor.isComposing(editor)) {\n          var _text2 = event.data;\n          Editor.insertText(editor, _text2);\n        }\n      }\n    }, [attributes.onBeforeInput, editor, readOnly]),\n    onInput: useCallback(function (event) {\n      if (isEventHandled(event, attributes.onInput)) {\n        return;\n      }\n      if (androidInputManagerRef.current) {\n        androidInputManagerRef.current.handleInput();\n        return;\n      } // Flush native operations, as native events will have propogated\n      // and we can correctly compare DOM text values in components\n      // to stop rendering, so that browser functions like autocorrect\n      // and spellcheck work as expected.\n      var _iterator5 = _createForOfIteratorHelper(deferredOperations.current),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var op = _step5.value;\n          op();\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      deferredOperations.current = [];\n    }, [attributes.onInput]),\n    onBlur: useCallback(function (event) {\n      if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {\n        return;\n      } // COMPAT: If the current `activeElement` is still the previous\n      // one, this is due to the window being blurred when the tab\n      // itself becomes unfocused, so we want to abort early to allow to\n      // editor to stay focused when the tab becomes focused again.\n\n      var root = ReactEditor.findDocumentOrShadowRoot(editor);\n      if (state.latestElement === root.activeElement) {\n        return;\n      }\n      var relatedTarget = event.relatedTarget;\n      var el = ReactEditor.toDOMNode(editor, editor); // COMPAT: The event should be ignored if the focus is returning\n      // to the editor from an embedded editable element (eg. an <input>\n      // element inside a void node).\n\n      if (relatedTarget === el) {\n        return;\n      } // COMPAT: The event should be ignored if the focus is moving from\n      // the editor to inside a void node's spacer element.\n\n      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute('data-slate-spacer')) {\n        return;\n      } // COMPAT: The event should be ignored if the focus is moving to a\n      // non- editable section of an element that isn't a void node (eg.\n      // a list item of the check list example).\n\n      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {\n        var node = ReactEditor.toSlateNode(editor, relatedTarget);\n        if (Element$1.isElement(node) && !editor.isVoid(node)) {\n          return;\n        }\n      } // COMPAT: Safari doesn't always remove the selection even if the content-\n      // editable element no longer has focus. Refer to:\n      // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web\n\n      if (IS_SAFARI) {\n        var domSelection = root.getSelection();\n        domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges();\n      }\n      IS_FOCUSED.delete(editor);\n    }, [readOnly, state.isUpdatingSelection, state.latestElement, editor, attributes.onBlur]),\n    onClick: useCallback(function (event) {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node); // At this time, the Slate document may be arbitrarily different,\n        // because onClick handlers can change the document before we get here.\n        // Therefore we must check that this path actually exists,\n        // and that it still refers to the same node.\n\n        if (!Editor.hasPath(editor, path) || Node.get(editor, path) !== node) {\n          return;\n        }\n        if (event.detail === TRIPLE_CLICK && path.length >= 1) {\n          var blockPath = path;\n          if (!(Element$1.isElement(node) && Editor.isBlock(editor, node))) {\n            var _block$;\n            var block = Editor.above(editor, {\n              match: function match(n) {\n                return Element$1.isElement(n) && Editor.isBlock(editor, n);\n              },\n              at: path\n            });\n            blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);\n          }\n          var range = Editor.range(editor, blockPath);\n          Transforms.select(editor, range);\n          return;\n        }\n        if (readOnly) {\n          return;\n        }\n        var _start = Editor.start(editor, path);\n        var end = Editor.end(editor, path);\n        var startVoid = Editor.void(editor, {\n          at: _start\n        });\n        var endVoid = Editor.void(editor, {\n          at: end\n        });\n        if (startVoid && endVoid && Path.equals(startVoid[1], endVoid[1])) {\n          var _range = Editor.range(editor, _start);\n          Transforms.select(editor, _range);\n        }\n      }\n    }, [editor, attributes.onClick, readOnly]),\n    onCompositionEnd: useCallback(function (event) {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        var _androidInputManagerR3;\n        if (ReactEditor.isComposing(editor)) {\n          setIsComposing(false);\n          IS_COMPOSING.set(editor, false);\n        }\n        (_androidInputManagerR3 = androidInputManagerRef.current) === null || _androidInputManagerR3 === void 0 ? void 0 : _androidInputManagerR3.handleCompositionEnd(event);\n        if (isEventHandled(event, attributes.onCompositionEnd) || IS_ANDROID) {\n          return;\n        } // COMPAT: In Chrome, `beforeinput` events for compositions\n        // aren't correct and never fire the \"insertFromComposition\"\n        // type that we need. So instead, insert whenever a composition\n        // ends since it will already have been committed to the DOM.\n\n        if (!IS_SAFARI && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {\n          var placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n          EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor); // Ensure we insert text with the marks the user was actually seeing\n\n          if (placeholderMarks !== undefined) {\n            EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n            editor.marks = placeholderMarks;\n          }\n          Editor.insertText(editor, event.data);\n          var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n          EDITOR_TO_USER_MARKS.delete(editor);\n          if (userMarks !== undefined) {\n            editor.marks = userMarks;\n          }\n        }\n      }\n    }, [attributes.onCompositionEnd, editor]),\n    onCompositionUpdate: useCallback(function (event) {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {\n        if (!ReactEditor.isComposing(editor)) {\n          setIsComposing(true);\n          IS_COMPOSING.set(editor, true);\n        }\n      }\n    }, [attributes.onCompositionUpdate, editor]),\n    onCompositionStart: useCallback(function (event) {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        var _androidInputManagerR4;\n        (_androidInputManagerR4 = androidInputManagerRef.current) === null || _androidInputManagerR4 === void 0 ? void 0 : _androidInputManagerR4.handleCompositionStart(event);\n        if (isEventHandled(event, attributes.onCompositionStart) || IS_ANDROID) {\n          return;\n        }\n        setIsComposing(true);\n        var selection = editor.selection;\n        if (selection) {\n          if (Range.isExpanded(selection)) {\n            Editor.deleteFragment(editor);\n            return;\n          }\n          var inline = Editor.above(editor, {\n            match: function match(n) {\n              return Element$1.isElement(n) && Editor.isInline(editor, n);\n            },\n            mode: 'highest'\n          });\n          if (inline) {\n            var _inline = _slicedToArray(inline, 2),\n              inlinePath = _inline[1];\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              var point = Editor.after(editor, inlinePath);\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point\n              });\n            }\n          }\n        }\n      }\n    }, [attributes.onCompositionStart, editor]),\n    onCopy: useCallback(function (event) {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy) && !isDOMEventTargetInput(event)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'copy');\n      }\n    }, [attributes.onCopy, editor]),\n    onCut: useCallback(function (event) {\n      if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut) && !isDOMEventTargetInput(event)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'cut');\n        var selection = editor.selection;\n        if (selection) {\n          if (Range.isExpanded(selection)) {\n            Editor.deleteFragment(editor);\n          } else {\n            var node = Node.parent(editor, selection.anchor.path);\n            if (Editor.isVoid(editor, node)) {\n              Transforms.delete(editor);\n            }\n          }\n        }\n      }\n    }, [readOnly, editor, attributes.onCut]),\n    onDragOver: useCallback(function (event) {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {\n        // Only when the target is void, call `preventDefault` to signal\n        // that drops are allowed. Editable content is droppable by\n        // default, and calling `preventDefault` hides the cursor.\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        if (Element$1.isElement(node) && Editor.isVoid(editor, node)) {\n          event.preventDefault();\n        }\n      }\n    }, [attributes.onDragOver, editor]),\n    onDragStart: useCallback(function (event) {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n        var voidMatch = Element$1.isElement(node) && Editor.isVoid(editor, node) || Editor.void(editor, {\n          at: path,\n          voids: true\n        }); // If starting a drag on a void node, make sure it is selected\n        // so that it shows up in the selection's fragment.\n\n        if (voidMatch) {\n          var range = Editor.range(editor, path);\n          Transforms.select(editor, range);\n        }\n        state.isDraggingInternally = true;\n        ReactEditor.setFragmentData(editor, event.dataTransfer, 'drag');\n      }\n    }, [readOnly, editor, attributes.onDragStart, state]),\n    onDrop: useCallback(function (event) {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {\n        event.preventDefault(); // Keep a reference to the dragged range before updating selection\n\n        var draggedRange = editor.selection; // Find the range where the drop happened\n\n        var range = ReactEditor.findEventRange(editor, event);\n        var data = event.dataTransfer;\n        Transforms.select(editor, range);\n        if (state.isDraggingInternally) {\n          if (draggedRange && !Range.equals(draggedRange, range) && !Editor.void(editor, {\n            at: range,\n            voids: true\n          })) {\n            Transforms.delete(editor, {\n              at: draggedRange\n            });\n          }\n        }\n        ReactEditor.insertData(editor, data); // When dragging from another source into the editor, it's possible\n        // that the current editor does not have focus.\n\n        if (!ReactEditor.isFocused(editor)) {\n          ReactEditor.focus(editor);\n        }\n      }\n      state.isDraggingInternally = false;\n    }, [readOnly, editor, attributes.onDrop, state]),\n    onDragEnd: useCallback(function (event) {\n      if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {\n        attributes.onDragEnd(event);\n      } // When dropping on a different droppable element than the current editor,\n      // `onDrop` is not called. So we need to clean up in `onDragEnd` instead.\n      // Note: `onDragEnd` is only called when `onDrop` is not called\n\n      state.isDraggingInternally = false;\n    }, [readOnly, state, attributes, editor]),\n    onFocus: useCallback(function (event) {\n      if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        state.latestElement = root.activeElement; // COMPAT: If the editor has nested editable elements, the focus\n        // can go to them. In Firefox, this must be prevented because it\n        // results in issues with keyboard navigation. (2017/03/30)\n\n        if (IS_FIREFOX && event.target !== el) {\n          el.focus();\n          return;\n        }\n        IS_FOCUSED.set(editor, true);\n      }\n    }, [readOnly, state, editor, attributes.onFocus]),\n    onKeyDown: useCallback(function (event) {\n      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {\n        var _androidInputManagerR5;\n        (_androidInputManagerR5 = androidInputManagerRef.current) === null || _androidInputManagerR5 === void 0 ? void 0 : _androidInputManagerR5.handleKeyDown(event);\n        var nativeEvent = event.nativeEvent; // COMPAT: The composition end event isn't fired reliably in all browsers,\n        // so we sometimes might end up stuck in a composition state even though we\n        // aren't composing any more.\n\n        if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {\n          IS_COMPOSING.set(editor, false);\n          setIsComposing(false);\n        }\n        if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {\n          return;\n        }\n        var selection = editor.selection;\n        var element = editor.children[selection !== null ? selection.focus.path[0] : 0];\n        var isRTL = getDirection(Node.string(element)) === 'rtl'; // COMPAT: Since we prevent the default behavior on\n        // `beforeinput` events, the browser doesn't think there's ever\n        // any history stack to undo or redo, so we have to manage these\n        // hotkeys ourselves. (2019/11/06)\n\n        if (Hotkeys.isRedo(nativeEvent)) {\n          event.preventDefault();\n          var maybeHistoryEditor = editor;\n          if (typeof maybeHistoryEditor.redo === 'function') {\n            maybeHistoryEditor.redo();\n          }\n          return;\n        }\n        if (Hotkeys.isUndo(nativeEvent)) {\n          event.preventDefault();\n          var _maybeHistoryEditor = editor;\n          if (typeof _maybeHistoryEditor.undo === 'function') {\n            _maybeHistoryEditor.undo();\n          }\n          return;\n        } // COMPAT: Certain browsers don't handle the selection updates\n        // properly. In Chrome, the selection isn't properly extended.\n        // And in Firefox, the selection isn't properly collapsed.\n        // (2017/10/17)\n\n        if (Hotkeys.isMoveLineBackward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            reverse: true\n          });\n          return;\n        }\n        if (Hotkeys.isMoveLineForward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line'\n          });\n          return;\n        }\n        if (Hotkeys.isExtendLineBackward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus',\n            reverse: true\n          });\n          return;\n        }\n        if (Hotkeys.isExtendLineForward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus'\n          });\n          return;\n        } // COMPAT: If a void node is selected, or a zero-width text node\n        // adjacent to an inline is selected, we need to handle these\n        // hotkeys manually because browsers won't be able to skip over\n        // the void node with the zero-width space not being an empty\n        // string.\n\n        if (Hotkeys.isMoveBackward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && Range.isCollapsed(selection)) {\n            Transforms.move(editor, {\n              reverse: !isRTL\n            });\n          } else {\n            Transforms.collapse(editor, {\n              edge: 'start'\n            });\n          }\n          return;\n        }\n        if (Hotkeys.isMoveForward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && Range.isCollapsed(selection)) {\n            Transforms.move(editor, {\n              reverse: isRTL\n            });\n          } else {\n            Transforms.collapse(editor, {\n              edge: 'end'\n            });\n          }\n          return;\n        }\n        if (Hotkeys.isMoveWordBackward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && Range.isExpanded(selection)) {\n            Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n          Transforms.move(editor, {\n            unit: 'word',\n            reverse: !isRTL\n          });\n          return;\n        }\n        if (Hotkeys.isMoveWordForward(nativeEvent)) {\n          event.preventDefault();\n          if (selection && Range.isExpanded(selection)) {\n            Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n          Transforms.move(editor, {\n            unit: 'word',\n            reverse: isRTL\n          });\n          return;\n        } // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to guessing at the input intention for hotkeys.\n        // COMPAT: In iOS, some of these hotkeys are handled in the\n\n        if (!HAS_BEFORE_INPUT_SUPPORT) {\n          // We don't have a core behavior for these, but they change the\n          // DOM if we don't prevent them, so we have to.\n          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {\n            event.preventDefault();\n            return;\n          }\n          if (Hotkeys.isSoftBreak(nativeEvent)) {\n            event.preventDefault();\n            Editor.insertSoftBreak(editor);\n            return;\n          }\n          if (Hotkeys.isSplitBlock(nativeEvent)) {\n            event.preventDefault();\n            Editor.insertBreak(editor);\n            return;\n          }\n          if (Hotkeys.isDeleteBackward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor);\n            }\n            return;\n          }\n          if (Hotkeys.isDeleteForward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor);\n            }\n            return;\n          }\n          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor, {\n                unit: 'line'\n              });\n            }\n            return;\n          }\n          if (Hotkeys.isDeleteLineForward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor, {\n                unit: 'line'\n              });\n            }\n            return;\n          }\n          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor, {\n                unit: 'word'\n              });\n            }\n            return;\n          }\n          if (Hotkeys.isDeleteWordForward(nativeEvent)) {\n            event.preventDefault();\n            if (selection && Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor, {\n                unit: 'word'\n              });\n            }\n            return;\n          }\n        } else {\n          if (IS_CHROME || IS_SAFARI) {\n            // COMPAT: Chrome and Safari support `beforeinput` event but do not fire\n            // an event when deleting backwards in a selected void inline node\n            if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && Range.isCollapsed(selection)) {\n              var currentNode = Node.parent(editor, selection.anchor.path);\n              if (Element$1.isElement(currentNode) && Editor.isVoid(editor, currentNode) && (Editor.isInline(editor, currentNode) || Editor.isBlock(editor, currentNode))) {\n                event.preventDefault();\n                Editor.deleteBackward(editor, {\n                  unit: 'block'\n                });\n                return;\n              }\n            }\n          }\n        }\n      }\n    }, [readOnly, editor, attributes.onKeyDown]),\n    onPaste: useCallback(function (event) {\n      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to React's `onPaste` here instead.\n        // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events\n        // when \"paste without formatting\" is used, so fallback. (2020/02/20)\n        // COMPAT: Safari InputEvents generated by pasting won't include\n        // application/x-slate-fragment items, so use the\n        // ClipboardEvent here. (2023/03/15)\n        if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent) || IS_SAFARI) {\n          event.preventDefault();\n          ReactEditor.insertData(editor, event.clipboardData);\n        }\n      }\n    }, [readOnly, editor, attributes.onPaste])\n  }), /*#__PURE__*/React.createElement(Children, {\n    decorations: decorations,\n    node: editor,\n    renderElement: renderElement,\n    renderPlaceholder: renderPlaceholder,\n    renderLeaf: renderLeaf,\n    selection: editor.selection,\n    cursors: cursors,\n    composingNode: composingNode\n  })))));\n};\n/**\r\n * The default placeholder element\r\n */\n\nvar DefaultPlaceholder = function DefaultPlaceholder(_ref) {\n  var attributes = _ref.attributes,\n    children = _ref.children;\n  return /*#__PURE__*/(\n    // COMPAT: Artificially add a line-break to the end on the placeholder element\n    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter\n    React.createElement(\"span\", Object.assign({}, attributes), children, IS_ANDROID && /*#__PURE__*/React.createElement(\"br\", null))\n  );\n};\n/**\r\n * A default memoized decorate function.\r\n */\n\nvar defaultDecorate = function defaultDecorate() {\n  return [];\n};\n/**\r\n * A default implement to scroll dom range into view.\r\n */\n\nvar defaultScrollSelectionIntoView = function defaultScrollSelectionIntoView(editor, domRange) {\n  // This was affecting the selection of multiple blocks and dragging behavior,\n  // so enabled only if the selection has been collapsed.\n  if (domRange.getBoundingClientRect && (!editor.selection || editor.selection && Range.isCollapsed(editor.selection))) {\n    var leafEl = domRange.startContainer.parentElement;\n    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);\n    scrollIntoView(leafEl, {\n      scrollMode: 'if-needed'\n    }); // @ts-expect-error an unorthodox delete D:\n\n    delete leafEl.getBoundingClientRect;\n  }\n};\n/**\r\n * Check if an event is overrided by a handler.\r\n */\n\nvar isEventHandled = function isEventHandled(event, handler) {\n  if (!handler) {\n    return false;\n  } // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n\n  var shouldTreatEventAsHandled = handler(event);\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n  return event.isDefaultPrevented() || event.isPropagationStopped();\n};\n/**\r\n * Check if the event's target is an input element\r\n */\n\nvar isDOMEventTargetInput = function isDOMEventTargetInput(event) {\n  return isDOMNode(event.target) && (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement);\n};\n/**\r\n * Check if a DOM event is overrided by a handler.\r\n */\n\nvar isDOMEventHandled = function isDOMEventHandled(event, handler) {\n  if (!handler) {\n    return false;\n  } // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n\n  var shouldTreatEventAsHandled = handler(event);\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n  return event.defaultPrevented;\n};\n\n/**\r\n * A React context for sharing the `focused` state of the editor.\r\n */\n\nvar FocusedContext = /*#__PURE__*/createContext(false);\n/**\r\n * Get the current `focused` state of the editor.\r\n */\n\nvar useFocused = function useFocused() {\n  return useContext(FocusedContext);\n};\nfunction isError(error) {\n  return error instanceof Error;\n}\n/**\r\n * A React context for sharing the editor selector context in a way to control rerenders\r\n */\n\nvar SlateSelectorContext = /*#__PURE__*/createContext({});\nvar refEquality = function refEquality(a, b) {\n  return a === b;\n};\n/**\r\n * use redux style selectors to prevent rerendering on every keystroke.\r\n * Bear in mind rerendering can only prevented if the returned value is a value type or for reference types (e.g. objects and arrays) add a custom equality function.\r\n *\r\n * Example:\r\n * ```\r\n *  const isSelectionActive = useSlateSelector(editor => Boolean(editor.selection));\r\n * ```\r\n */\n\nfunction useSlateSelector(selector) {\n  var equalityFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : refEquality;\n  var _useReducer3 = useReducer(function (s) {\n      return s + 1;\n    }, 0),\n    _useReducer4 = _slicedToArray(_useReducer3, 2),\n    forceRender = _useReducer4[1];\n  var context = useContext(SlateSelectorContext);\n  if (!context) {\n    throw new Error(\"The `useSlateSelector` hook must be used inside the <Slate> component's context.\");\n  }\n  var getSlate = context.getSlate,\n    addEventListener = context.addEventListener;\n  var latestSubscriptionCallbackError = useRef();\n  var latestSelector = useRef(function () {\n    return null;\n  });\n  var latestSelectedState = useRef(null);\n  var selectedState;\n  try {\n    if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n      selectedState = selector(getSlate());\n    } else {\n      selectedState = latestSelectedState.current;\n    }\n  } catch (err) {\n    if (latestSubscriptionCallbackError.current && isError(err)) {\n      err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n    }\n    throw err;\n  }\n  useIsomorphicLayoutEffect(function () {\n    latestSelector.current = selector;\n    latestSelectedState.current = selectedState;\n    latestSubscriptionCallbackError.current = undefined;\n  });\n  useIsomorphicLayoutEffect(function () {\n    function checkForUpdates() {\n      try {\n        var newSelectedState = latestSelector.current(getSlate());\n        if (equalityFn(newSelectedState, latestSelectedState.current)) {\n          return;\n        }\n        latestSelectedState.current = newSelectedState;\n      } catch (err) {\n        // we ignore all errors here, since when the component\n        // is re-rendered, the selectors are called again, and\n        // will throw again, if neither props nor store state\n        // changed\n        latestSubscriptionCallbackError.current = err;\n      }\n      forceRender();\n    }\n    var unsubscribe = addEventListener(checkForUpdates);\n    checkForUpdates();\n    return function () {\n      return unsubscribe();\n    };\n  },\n  // don't rerender on equalityFn change since we want to be able to define it inline\n  [addEventListener, getSlate]);\n  return selectedState;\n}\n/**\r\n * Create selector context with editor updating on every editor change\r\n */\n\nfunction useSelectorContext(editor) {\n  var eventListeners = useRef([]).current;\n  var slateRef = useRef({\n    editor: editor\n  }).current;\n  var onChange = useCallback(function (editor) {\n    slateRef.editor = editor;\n    eventListeners.forEach(function (listener) {\n      return listener(editor);\n    });\n  }, [eventListeners, slateRef]);\n  var selectorContext = useMemo(function () {\n    return {\n      getSlate: function getSlate() {\n        return slateRef.editor;\n      },\n      addEventListener: function addEventListener(callback) {\n        eventListeners.push(callback);\n        return function () {\n          eventListeners.splice(eventListeners.indexOf(callback), 1);\n        };\n      }\n    };\n  }, [eventListeners, slateRef]);\n  return {\n    selectorContext: selectorContext,\n    onChange: onChange\n  };\n}\nvar _excluded = [\"editor\", \"children\", \"onChange\", \"value\"];\n/**\r\n * A wrapper around the provider to handle `onChange` events, because the editor\r\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\r\n */\n\nvar Slate = function Slate(props) {\n  var editor = props.editor,\n    children = props.children,\n    onChange = props.onChange,\n    value = props.value,\n    rest = _objectWithoutProperties(props, _excluded);\n  var unmountRef = useRef(false);\n  var _React$useState = React.useState(function () {\n      if (!Node.isNodeList(value)) {\n        throw new Error(\"[Slate] value is invalid! Expected a list of elements but got: \".concat(Scrubber.stringify(value)));\n      }\n      if (!Editor.isEditor(editor)) {\n        throw new Error(\"[Slate] editor is invalid! You passed: \".concat(Scrubber.stringify(editor)));\n      }\n      editor.children = value;\n      Object.assign(editor, rest);\n      return {\n        v: 0,\n        editor: editor\n      };\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    context = _React$useState2[0],\n    setContext = _React$useState2[1];\n  var _useSelectorContext = useSelectorContext(editor),\n    selectorContext = _useSelectorContext.selectorContext,\n    handleSelectorChange = _useSelectorContext.onChange;\n  var onContextChange = useCallback(function () {\n    if (onChange) {\n      onChange(editor.children);\n    }\n    setContext(function (prevContext) {\n      return {\n        v: prevContext.v + 1,\n        editor: editor\n      };\n    });\n    handleSelectorChange(editor);\n  }, [editor, handleSelectorChange, onChange]);\n  useEffect(function () {\n    EDITOR_TO_ON_CHANGE.set(editor, onContextChange);\n    return function () {\n      EDITOR_TO_ON_CHANGE.set(editor, function () {});\n      unmountRef.current = true;\n    };\n  }, [editor, onContextChange]);\n  var _useState13 = useState(ReactEditor.isFocused(editor)),\n    _useState14 = _slicedToArray(_useState13, 2),\n    isFocused = _useState14[0],\n    setIsFocused = _useState14[1];\n  useEffect(function () {\n    setIsFocused(ReactEditor.isFocused(editor));\n  }, [editor]);\n  useIsomorphicLayoutEffect(function () {\n    var fn = function fn() {\n      return setIsFocused(ReactEditor.isFocused(editor));\n    };\n    if (IS_REACT_VERSION_17_OR_ABOVE) {\n      // In React >= 17 onFocus and onBlur listen to the focusin and focusout events during the bubbling phase.\n      // Therefore in order for <Editable />'s handlers to run first, which is necessary for ReactEditor.isFocused(editor)\n      // to return the correct value, we have to listen to the focusin and focusout events without useCapture here.\n      document.addEventListener('focusin', fn);\n      document.addEventListener('focusout', fn);\n      return function () {\n        document.removeEventListener('focusin', fn);\n        document.removeEventListener('focusout', fn);\n      };\n    } else {\n      document.addEventListener('focus', fn, true);\n      document.addEventListener('blur', fn, true);\n      return function () {\n        document.removeEventListener('focus', fn, true);\n        document.removeEventListener('blur', fn, true);\n      };\n    }\n  }, []);\n  return /*#__PURE__*/React.createElement(SlateSelectorContext.Provider, {\n    value: selectorContext\n  }, /*#__PURE__*/React.createElement(SlateContext.Provider, {\n    value: context\n  }, /*#__PURE__*/React.createElement(EditorContext.Provider, {\n    value: context.editor\n  }, /*#__PURE__*/React.createElement(FocusedContext.Provider, {\n    value: isFocused\n  }, children))));\n};\n\n/**\r\n * Get the current editor object from the React context.\r\n * @deprecated Use useSlateStatic instead.\r\n */\n\nvar useEditor = function useEditor() {\n  var editor = useContext(EditorContext);\n  if (!editor) {\n    throw new Error(\"The `useEditor` hook must be used inside the <Slate> component's context.\");\n  }\n  return editor;\n};\n\n/**\r\n * Get the current slate selection.\r\n * Only triggers a rerender when the selection actually changes\r\n */\n\nvar useSlateSelection = function useSlateSelection() {\n  return useSlateSelector(function (editor) {\n    return editor.selection;\n  }, isSelectionEqual);\n};\nvar isSelectionEqual = function isSelectionEqual(a, b) {\n  if (!a && !b) return true;\n  if (!a || !b) return false;\n  return Range.equals(a, b);\n};\n\n/**\r\n * Utilities for single-line deletion\r\n */\n\nvar doRectsIntersect = function doRectsIntersect(rect, compareRect) {\n  var middle = (compareRect.top + compareRect.bottom) / 2;\n  return rect.top <= middle && rect.bottom >= middle;\n};\nvar areRangesSameLine = function areRangesSameLine(editor, range1, range2) {\n  var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();\n  var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\r\n * A helper utility that returns the end portion of a `Range`\r\n * which is located on a single line.\r\n *\r\n * @param {Editor} editor The editor object to compare against\r\n * @param {Range} parentRange The parent range to compare against\r\n * @returns {Range} A valid portion of the parentRange which is one a single line\r\n */\n\nvar findCurrentLineRange = function findCurrentLineRange(editor, parentRange) {\n  var parentRangeBoundary = Editor.range(editor, Range.end(parentRange));\n  var positions = Array.from(Editor.positions(editor, {\n    at: parentRange\n  }));\n  var left = 0;\n  var right = positions.length;\n  var middle = Math.floor(right / 2);\n  if (areRangesSameLine(editor, Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return Editor.range(editor, positions[left], parentRangeBoundary);\n  }\n  if (positions.length < 2) {\n    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n  }\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle;\n    } else {\n      left = middle;\n    }\n    middle = Math.floor((left + right) / 2);\n  }\n  return Editor.range(editor, positions[right], parentRangeBoundary);\n};\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\n/**\r\n * `withReact` adds React and DOM specific behaviors to the editor.\r\n *\r\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\r\n * this plugin.\r\n *\r\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\r\n */\n\nvar withReact = function withReact(editor) {\n  var clipboardFormatKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x-slate-fragment';\n  var e = editor;\n  var apply = e.apply,\n    onChange = e.onChange,\n    deleteBackward = e.deleteBackward,\n    addMark = e.addMark,\n    removeMark = e.removeMark; // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n  e.addMark = function (key, value) {\n    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n    EDITOR_TO_USER_MARKS.delete(e);\n    addMark(key, value);\n  };\n  e.removeMark = function (key) {\n    var _EDITOR_TO_PENDING_DI2;\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n    EDITOR_TO_USER_MARKS.delete(e);\n    removeMark(key);\n  };\n  e.deleteBackward = function (unit) {\n    if (unit !== 'line') {\n      return deleteBackward(unit);\n    }\n    if (e.selection && Range.isCollapsed(e.selection)) {\n      var parentBlockEntry = Editor.above(e, {\n        match: function match(n) {\n          return Element$1.isElement(n) && Editor.isBlock(e, n);\n        },\n        at: e.selection\n      });\n      if (parentBlockEntry) {\n        var _parentBlockEntry = _slicedToArray(parentBlockEntry, 2),\n          parentBlockPath = _parentBlockEntry[1];\n        var parentElementRange = Editor.range(e, parentBlockPath, e.selection.anchor);\n        var currentLineRange = findCurrentLineRange(e, parentElementRange);\n        if (!Range.isCollapsed(currentLineRange)) {\n          Transforms.delete(e, {\n            at: currentLineRange\n          });\n        }\n      }\n    }\n  }; // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n\n  e.apply = function (op) {\n    var matches = [];\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n      var transformed = pendingDiffs.map(function (textDiff) {\n        return transformTextDiff(textDiff, op);\n      }).filter(Boolean);\n      EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n    }\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n    if (pendingSelection) {\n      EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n    }\n    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n      var at = Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n      EDITOR_TO_PENDING_ACTION.set(e, at ? _objectSpread(_objectSpread({}, pendingAction), {}, {\n        at: at\n      }) : null);\n    }\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node':\n        {\n          matches.push.apply(matches, _toConsumableArray(getMatches(e, op.path)));\n          break;\n        }\n      case 'set_selection':\n        {\n          var _EDITOR_TO_USER_SELEC;\n\n          // Selection was manually set, don't restore the user selection after the change.\n          (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n          EDITOR_TO_USER_SELECTION.delete(e);\n          break;\n        }\n      case 'insert_node':\n      case 'remove_node':\n        {\n          matches.push.apply(matches, _toConsumableArray(getMatches(e, Path.parent(op.path))));\n          break;\n        }\n      case 'merge_node':\n        {\n          var prevPath = Path.previous(op.path);\n          matches.push.apply(matches, _toConsumableArray(getMatches(e, prevPath)));\n          break;\n        }\n      case 'move_node':\n        {\n          var commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath));\n          matches.push.apply(matches, _toConsumableArray(getMatches(e, commonPath)));\n          break;\n        }\n    }\n    apply(op);\n    for (var _i2 = 0, _matches = matches; _i2 < _matches.length; _i2++) {\n      var _matches$_i = _slicedToArray(_matches[_i2], 2),\n        path = _matches$_i[0],\n        key = _matches$_i[1];\n      var _Editor$node3 = Editor.node(e, path),\n        _Editor$node4 = _slicedToArray(_Editor$node3, 1),\n        node = _Editor$node4[0];\n      NODE_TO_KEY.set(node, key);\n    }\n  };\n  e.setFragmentData = function (data) {\n    var selection = e.selection;\n    if (!selection) {\n      return;\n    }\n    var _Range$edges7 = Range.edges(selection),\n      _Range$edges8 = _slicedToArray(_Range$edges7, 2),\n      start = _Range$edges8[0],\n      end = _Range$edges8[1];\n    var startVoid = Editor.void(e, {\n      at: start.path\n    });\n    var endVoid = Editor.void(e, {\n      at: end.path\n    });\n    if (Range.isCollapsed(selection) && !startVoid) {\n      return;\n    } // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n\n    var domRange = ReactEditor.toDOMRange(e, selection);\n    var contents = domRange.cloneContents();\n    var attach = contents.childNodes[0]; // Make sure attach is non-empty, since empty nodes will not get copied.\n\n    contents.childNodes.forEach(function (node) {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node;\n      }\n    }); // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n\n    if (endVoid) {\n      var _endVoid = _slicedToArray(endVoid, 1),\n        voidNode = _endVoid[0];\n      var r = domRange.cloneRange();\n      var domNode = ReactEditor.toDOMNode(e, voidNode);\n      r.setEndAfter(domNode);\n      contents = r.cloneContents();\n    } // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]');\n    } // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(function (zw) {\n      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';\n      zw.textContent = isNewline ? '\\n' : '';\n    }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n\n    if (isDOMText(attach)) {\n      var span = attach.ownerDocument.createElement('span'); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n\n      span.style.whiteSpace = 'pre';\n      span.appendChild(attach);\n      contents.appendChild(span);\n      attach = span;\n    }\n    var fragment = e.getFragment();\n    var string = JSON.stringify(fragment);\n    var encoded = window.btoa(encodeURIComponent(string));\n    attach.setAttribute('data-slate-fragment', encoded);\n    data.setData(\"application/\".concat(clipboardFormatKey), encoded); // Add the content to a <div> so that we can get its inner HTML.\n\n    var div = contents.ownerDocument.createElement('div');\n    div.appendChild(contents);\n    div.setAttribute('hidden', 'true');\n    contents.ownerDocument.body.appendChild(div);\n    data.setData('text/html', div.innerHTML);\n    data.setData('text/plain', getPlainText(div));\n    contents.ownerDocument.body.removeChild(div);\n    return data;\n  };\n  e.insertData = function (data) {\n    if (!e.insertFragmentData(data)) {\n      e.insertTextData(data);\n    }\n  };\n  e.insertFragmentData = function (data) {\n    /**\r\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\r\n     */\n    var fragment = data.getData(\"application/\".concat(clipboardFormatKey)) || getSlateFragmentAttribute(data);\n    if (fragment) {\n      var decoded = decodeURIComponent(window.atob(fragment));\n      var parsed = JSON.parse(decoded);\n      e.insertFragment(parsed);\n      return true;\n    }\n    return false;\n  };\n  e.insertTextData = function (data) {\n    var text = data.getData('text/plain');\n    if (text) {\n      var lines = text.split(/\\r\\n|\\r|\\n/);\n      var split = false;\n      var _iterator6 = _createForOfIteratorHelper(lines),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var line = _step6.value;\n          if (split) {\n            Transforms.splitNodes(e, {\n              always: true\n            });\n          }\n          e.insertText(line);\n          split = true;\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      return true;\n    }\n    return false;\n  };\n  e.onChange = function (options) {\n    // COMPAT: React doesn't batch `setState` hook calls, which means that the\n    // children and selection can get out of sync for one render pass. So we\n    // have to use this unstable API to ensure it batches them. (2019/12/03)\n    // https://github.com/facebook/react/issues/14259#issuecomment-439702367\n    ReactDOM.unstable_batchedUpdates(function () {\n      var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n      if (onContextChange) {\n        onContextChange();\n      }\n      onChange(options);\n    });\n  };\n  return e;\n};\nvar getMatches = function getMatches(e, path) {\n  var matches = [];\n  var _iterator7 = _createForOfIteratorHelper(Editor.levels(e, {\n      at: path\n    })),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var _step7$value = _slicedToArray(_step7.value, 2),\n        n = _step7$value[0],\n        p = _step7$value[1];\n      var key = ReactEditor.findKey(e, n);\n      matches.push([p, key]);\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  return matches;\n};\nexport { DefaultElement, DefaultLeaf, DefaultPlaceholder, Editable, ReactEditor, Slate, useEditor, useFocused, useReadOnly, useSelected, useSlate, useSlateSelection, useSlateSelector, useSlateStatic, useSlateWithV, withReact };","map":{"version":3,"names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_objectWithoutPropertiesLoose","source","excluded","target","sourceKeys","keys","i","length","indexOf","_objectWithoutProperties","getOwnPropertySymbols","sourceSymbolKeys","prototype","propertyIsEnumerable","call","n","Key","_createClass","_classCallCheck","id","concat","NODE_TO_INDEX","WeakMap","NODE_TO_PARENT","EDITOR_TO_WINDOW","EDITOR_TO_ELEMENT","EDITOR_TO_PLACEHOLDER_ELEMENT","ELEMENT_TO_NODE","NODE_TO_ELEMENT","NODE_TO_KEY","EDITOR_TO_KEY_TO_ELEMENT","IS_READ_ONLY","IS_FOCUSED","IS_COMPOSING","EDITOR_TO_USER_SELECTION","EDITOR_TO_ON_CHANGE","EDITOR_TO_SCHEDULE_FLUSH","EDITOR_TO_PENDING_INSERTION_MARKS","EDITOR_TO_USER_MARKS","EDITOR_TO_PENDING_DIFFS","EDITOR_TO_PENDING_ACTION","EDITOR_TO_PENDING_SELECTION","EDITOR_TO_FORCE_RENDER","PLACEHOLDER_SYMBOL","Symbol","MARK_PLACEHOLDER_SYMBOL","DOMText","globalThis","Text","getDefaultView","ownerDocument","defaultView","isDOMComment","isDOMNode","nodeType","isDOMElement","window","Node","isDOMSelection","anchorNode","Selection","isDOMText","isPlainTextOnlyPaste","event","clipboardData","getData","types","normalizeDOMPoint","domPoint","_domPoint","_slicedToArray","node","offset","childNodes","isLast","index","_getEditableChildAndI","getEditableChildAndIndex","_getEditableChildAndI2","getEditableChild","textContent","hasShadowRoot","parent","parentNode","toString","direction","child","triedForward","triedBackward","getAttribute","_getEditableChildAndI3","_getEditableChildAndI4","getPlainText","domNode","text","nodeValue","_i","_Array$from","Array","from","childNode","display","getComputedStyle","getPropertyValue","tagName","catchSlateFragment","getSlateFragmentAttribute","dataTransfer","htmlData","_ref3","match","_ref4","fragment","isTrackedMutation","editor","mutation","batch","matches","_ReactEditor$getWindo","ReactEditor","getWindow","document","contains","hasDOMNode","editable","parentMutation","find","_ref","addedNodes","removedNodes","_iterator","_createForOfIteratorHelper","_step","s","done","err","e","f","_iterator2","_step2","_node","IS_REACT_VERSION_17_OR_ABOVE","parseInt","React","version","split","IS_IOS","navigator","test","userAgent","MSStream","IS_APPLE","IS_ANDROID","IS_FIREFOX","IS_SAFARI","IS_EDGE_LEGACY","IS_CHROME","IS_CHROME_LEGACY","IS_ANDROID_CHROME_LEGACY","IS_FIREFOX_LEGACY","IS_UC_MOBILE","IS_WECHATBROWSER","CAN_USE_DOM","createElement","HAS_BEFORE_INPUT_SUPPORT","InputEvent","getTargetRanges","isComposing","get","Error","findKey","set","findPath","path","Editor","isEditor","unshift","Scrubber","stringify","findDocumentOrShadowRoot","el","toDOMNode","root","getRootNode","Document","ShadowRoot","getSelection","isFocused","isReadOnly","blur","activeElement","focus","preventScroll","deselect","selection","domSelection","rangeCount","removeAllRanges","Transforms","options","arguments","undefined","_options$editable","editorEl","targetEl","parentElement","message","includes","closest","isContentEditable","insertData","data","insertFragmentData","insertTextData","setFragmentData","originEvent","KEY_TO_ELEMENT","toDOMPoint","point","_Editor$node","_Editor$node2","void","at","selector","texts","querySelectorAll","start","attr","trueLength","end","nextText","hasAttribute","_nextText$textContent","domText","startsWith","Math","min","max","toDOMRange","range","anchor","isBackward","Range","domAnchor","domFocus","isCollapsed","domRange","createRange","_ref5","_ref6","startNode","startOffset","_ref7","_ref8","endNode","endOffset","startEl","isStartAtZeroWidth","endEl","isEndAtZeroWidth","setStart","setEnd","toSlateNode","domEl","findEventRange","nativeEvent","_event2","x","clientX","y","clientY","Element$1","isElement","isVoid","rect","getBoundingClientRect","isPrev","isInline","left","width","top","height","edge","before","after","_range","_ReactEditor$getWindo2","caretRangeFromPoint","position","caretPositionFromPoint","offsetNode","toSlateRange","exactMatch","suppressThrow","toSlatePoint","_ref9","_ref10","nearestNode","nearestOffset","textNode","_domNode$textContent","_domNode$textContent2","potentialVoidNode","voidNode","leafNode","contents","cloneContents","removals","_toConsumableArray","slice","forEach","textContext","removeChild","leafNodes","current","endsWith","_slateNode","_Editor$start","_path","_offset","querySelector","slateNode","startContainer","anchorOffset","focusNode","focusOffset","endContainer","collapsed","_anchorNode$textConte","isEnd","isStart","isExpanded","isForward","mode","unhangRange","voids","hasRange","hasPath","hasTarget","hasEditableTarget","hasSelectableTarget","isTargetInsideNonReadonlyVoid","androidScheduleFlush","_EDITOR_TO_SCHEDULE_F","androidPendingDiffs","DecorateContext","createContext","useDecorate","useContext","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","ReadOnlyContext","useReadOnly","SlateContext","useSlate","context","useSlateWithV","TRIPLE_CLICK","HOTKEYS","bold","compose","moveBackward","moveForward","moveWordBackward","moveWordForward","deleteBackward","deleteForward","extendBackward","extendForward","italic","insertSoftBreak","splitBlock","undo","APPLE_HOTKEYS","moveLineBackward","moveLineForward","deleteLineBackward","deleteLineForward","deleteWordBackward","deleteWordForward","extendLineBackward","extendLineForward","redo","transposeCharacter","WINDOWS_HOTKEYS","create","generic","apple","windows","isGeneric","isKeyHotkey","isApple","isWindows","Hotkeys","isBold","isCompose","isMoveBackward","isMoveForward","isDeleteBackward","isDeleteForward","isDeleteLineBackward","isDeleteLineForward","isDeleteWordBackward","isDeleteWordForward","isExtendBackward","isExtendForward","isExtendLineBackward","isExtendLineForward","isItalic","isMoveLineBackward","isMoveLineForward","isMoveWordBackward","isMoveWordForward","isRedo","isSoftBreak","isSplitBlock","isTransposeCharacter","isUndo","EditorContext","useSlateStatic","createRestoreDomManager","receivedUserInput","bufferedMutations","clear","registerMutations","mutations","_bufferedMutations","trackedMutations","filter","push","apply","restoreDOM","reverse","type","insertBefore","nextSibling","MUTATION_OBSERVER_CONFIG$1","subtree","childList","characterData","characterDataOldValue","RestoreDOMComponent","_Component","_inherits","_super","_createSuper","_this","manager","mutationObserver","observe","props","_this$mutationObserve","componentDidMount","MutationObserver","getSnapshotBeforeUpdate","pendingMutations","_this$mutationObserve2","takeRecords","_this$manager","_this$mutationObserve3","disconnect","_this$manager2","componentDidUpdate","_this$manager3","componentWillUnmount","_this$mutationObserve4","render","children","Component","contextType","RestoreDOM","Fragment","verifyDiffState","textDiff","diff","Text$1","isText","nextPath","Path","next","nextNode","applyStringDiff","diffs","_len","_key","reduce","longestCommonPrefixLength","str","another","charAt","longestCommonSuffixLength","normalizeStringDiff","targetText","removedText","prefixLength","suffixLength","normalized","mergeStringDiffs","a","b","overlap","applied","sliceEnd","targetRange","normalizePoint","leaf","parentBlock","above","isBlock","entry","isDescendant","normalizeRange","transformPendingPoint","op","pendingDiffs","equals","Point","transform","affinity","_anchor","_transformed","transformed","transformPendingRange","transformTextDiff","newPath","RESOLVE_DELAY","FLUSH_DELAY","debug","isDataTransfer","constructor","name","createAndroidInputManager","scheduleOnDOMSelectionChange","onDOMSelectionChange","flushing","compositionEndTimeoutId","flushTimeoutId","actionTimeoutId","idCounter","insertPositionHint","applyPendingSelection","pendingSelection","delete","select","performAction","action","isPoint","_targetRange","run","flush","clearTimeout","hasPendingDiffs","hasPendingAction","setTimeout","selectionRef","rangeRef","marks","scheduleSelectionChange","_EDITOR_TO_PENDING_DI","_EDITOR_TO_PENDING_DI2","pendingMarks","insertText","deleteFragment","_ref2","cancel","unref","userMarks","onChange","handleCompositionEnd","_event","handleCompositionStart","updatePlaceholderVisibility","forceHide","placeholderElement","style","removeProperty","storeDiff","_EDITOR_TO_PENDING_DI3","idx","findIndex","change","merged","splice","_objectSpread$4","scheduleAction","_ref11","handleDOMBeforeInput","inputType","_event$getTargetRange","_event$getTargetRange2","nativeTargetRange","_targetRange2","canStoreDiff","_Range$edges","edges","_Range$edges2","_start","_end","_leaf","_Range$edges3","_Range$edges4","_Editor$leaf","_Editor$leaf2","relevantPendingDiffs","handleUserSelect","_targetRange3","targetNode","_nativeTargetRange","_targetRange4","nativeCollapsed","unit","insertBreak","_text","replace","parts","line","_Range$edges5","_Range$edges6","_start2","_end2","_diff","hintPosition","search","diffPosition","scheduleFlush","_EDITOR_TO_PENDING_DI4","hasPendingChanges","isFlushing","pathChanged","parentPathChanged","handleInput","handleKeyDown","_","handleDomMutations","some","_EDITOR_TO_FORCE_REND","useIsMounted","isMountedRef","useRef","useMutationObserver","callback","_useState","useState","_useState2","MUTATION_OBSERVER_CONFIG","useAndroidInputManager","_excluded$3","isMounted","_useState3","_objectSpread$3","_useState4","inputManager","useTrackUserInput","animationFrameIdRef","onUserInput","useCallback","cancelAnimationFrame","requestAnimationFrame","shallowCompare","obj1","obj2","every","hasOwnProperty","isDecorationFlagsEqual","other","rangeOwnProps","_excluded$2","otherOwnProps","_excluded2$1","isElementDecorationsEqual","list","isTextDecorationsEqual","String","parentPath","isMarkPlaceholder","ZeroWidthString","string","isLineBreak","TextString","isTrailing","_props$isTrailing","ref","getTextContent","_useState5","_useState6","initialText","textWithTrailing","MemoizedText$1","memo","forwardRef","_props$length","_props$isLineBreak","_props$isMarkPlacehol","attributes","assign","disconnectPlaceholderResizeObserver","placeholderResizeObserver","releaseObserver","clearTimeoutRef","timeoutRef","Leaf","renderPlaceholder","_props$renderLeaf","renderLeaf","DefaultLeaf","placeholderRef","_useState7","_useState8","showPlaceholder","setShowPlaceholder","showPlaceholderTimeoutRef","callbackPlaceholderRef","placeholderEl","_leaf$onPlaceholderRe","onPlaceholderResize","ResizeObserver$1","ResizeObserver","_leaf$onPlaceholderRe2","leafIsPlaceholder","placeholderProps","placeholder","pointerEvents","maxWidth","opacity","userSelect","textDecoration","contentEditable","MemoizedLeaf","prev","decorations","leaves","callbackRef","span","MemoizedText","SelectedContext","useSelected","hasCursors","cursors","_node2","cursor","decorateCursors","nodeEntry","ranges","_nodeEntry","isFocusNode","isAnchorNode","_objectSpread$2","isCaret","useChildren","renderElement","decorate","isLeafBlock","hasInlines","p","sel","intersection","ds","_iterator3","_step3","dec","d","hasCursor","childCursors","Provider","MemoizedElement","element","_ds","Element","_props$renderElement","DefaultElement","readOnly","dir","getDirection","Tag","_Node$texts","_Node$texts2","_Node$texts2$","color","outline","Children","composingNode","_iterator4","_step4","Editable","defaultRenderPlaceholder","DefaultPlaceholder","autoFocus","_props$decorate","defaultDecorate","propsOnDOMBeforeInput","onDOMBeforeInput","_props$readOnly","_props$renderPlacehol","_props$scrollSelectio","scrollSelectionIntoView","defaultScrollSelectionIntoView","_props$style","userStyle","_props$as","as","_props$disableDefault","disableDefaultStyles","_excluded$1","_useState9","_useState10","setIsComposing","deferredOperations","_useState11","_useState12","placeholderHeight","setPlaceholderHeight","_useTrackUserInput","useMemo","block","_useReducer","useReducer","_useReducer2","forceRender","state","isDraggingInternally","isUpdatingSelection","latestElement","hasMarkPlaceholder","androidInputManagerRef","throttle","androidInputManager","anchorNodeSelectable","focusNodeSelectable","debounce","_androidInputManagerR","setDomSelection","forceChange","hasDomSelection","editorElement","hasDomSelectionInEditor","slateRange","_anchorNode$parentEle","newDomRange","setBaseAndExtent","ensureSelection","_androidInputManagerR2","timeoutId","animationFrameId","ensureDomSelection","isDOMEventHandled","_EDITOR_TO_USER_SELEC","isCompositionChange","native","_node$parentElement","_window$getComputedSt","_ReactEditor$toDOMPoi","_ReactEditor$toDOMPoi2","_lastText$textContent","lastText","createTreeWalker","NodeFilter","SHOW_TEXT","lastChild","whiteSpace","_event$getTargetRange3","_event$getTargetRange4","preventDefault","toRestore","removeEventListener","addEventListener","placeHolderResizeHandler","_placeholderEl$getBou","_decorations$push","_defineProperty2","rest","_excluded2","loose","unset","fromEntries","map","mark","_objectSpread$1","role","spellCheck","autoCorrect","autoCapitalize","zindex","suppressContentEditableWarning","wordWrap","minHeight","onBeforeInput","isEventHandled","_text2","onInput","_iterator5","_step5","onBlur","relatedTarget","onClick","detail","blockPath","_block$","startVoid","endVoid","onCompositionEnd","_androidInputManagerR3","placeholderMarks","onCompositionUpdate","onCompositionStart","_androidInputManagerR4","inline","_inline","inlinePath","setSelection","onCopy","isDOMEventTargetInput","onCut","onDragOver","onDragStart","voidMatch","onDrop","draggedRange","onDragEnd","onFocus","onKeyDown","_androidInputManagerR5","isRTL","maybeHistoryEditor","_maybeHistoryEditor","move","collapse","currentNode","onPaste","leafEl","bind","scrollIntoView","scrollMode","handler","shouldTreatEventAsHandled","isDefaultPrevented","isPropagationStopped","HTMLInputElement","HTMLTextAreaElement","defaultPrevented","FocusedContext","useFocused","isError","error","SlateSelectorContext","refEquality","useSlateSelector","equalityFn","_useReducer3","_useReducer4","getSlate","latestSubscriptionCallbackError","latestSelector","latestSelectedState","selectedState","stack","checkForUpdates","newSelectedState","unsubscribe","useSelectorContext","eventListeners","slateRef","listener","selectorContext","Slate","_excluded","unmountRef","_React$useState","isNodeList","v","_React$useState2","setContext","_useSelectorContext","handleSelectorChange","onContextChange","prevContext","_useState13","_useState14","setIsFocused","fn","useEditor","useSlateSelection","isSelectionEqual","doRectsIntersect","compareRect","middle","bottom","areRangesSameLine","range1","range2","rect1","rect2","findCurrentLineRange","parentRange","parentRangeBoundary","positions","right","floor","withReact","clipboardFormatKey","addMark","removeMark","parentBlockEntry","_parentBlockEntry","parentBlockPath","parentElementRange","currentLineRange","Boolean","pendingAction","_objectSpread","getMatches","prevPath","previous","commonPath","common","_i2","_matches","_matches$_i","_Editor$node3","_Editor$node4","_Range$edges7","_Range$edges8","attach","trim","_endVoid","r","cloneRange","setEndAfter","zw","isNewline","appendChild","getFragment","JSON","encoded","btoa","encodeURIComponent","setAttribute","setData","div","body","innerHTML","decoded","decodeURIComponent","atob","parsed","parse","insertFragment","lines","_iterator6","_step6","splitNodes","always","ReactDOM","unstable_batchedUpdates","_iterator7","levels","_step7","_step7$value"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/.yarn/cache/@babel-runtime-npm-7.15.3-6333c71362-2f0b8d2d4e.zip/node_modules/@babel/runtime/helpers/esm/defineProperty.js","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/.yarn/cache/@babel-runtime-npm-7.15.3-6333c71362-2f0b8d2d4e.zip/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/.yarn/cache/@babel-runtime-npm-7.15.3-6333c71362-2f0b8d2d4e.zip/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/utils/key.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/utils/weak-maps.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/utils/dom.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/utils/environment.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/plugin/react-editor.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/hooks/use-decorate.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/hooks/use-isomorphic-layout-effect.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/hooks/use-read-only.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/hooks/use-slate.tsx","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/utils/constants.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/utils/hotkeys.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/hooks/use-slate-static.tsx","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/components/restore-dom/restore-dom-manager.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/components/restore-dom/restore-dom.tsx","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/utils/diff-text.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/hooks/android-input-manager/android-input-manager.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/hooks/use-is-mounted.tsx","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/hooks/use-mutation-observer.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/hooks/android-input-manager/use-android-input-manager.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/hooks/use-track-user-input.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/utils/range-list.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/components/string.tsx","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/components/leaf.tsx","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/components/text.tsx","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/hooks/use-selected.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/utils/cusors.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/hooks/use-children.tsx","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/components/element.tsx","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/components/children.tsx","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/components/editable.tsx","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/hooks/use-focused.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/hooks/use-slate-selector.tsx","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/components/slate.tsx","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/hooks/use-editor.tsx","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/hooks/use-slate-selection.tsx","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/utils/lines.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-react/src/plugin/with-react.ts"],"sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","/**\n * An auto-incrementing identifier for keys.\n */\n\nlet n = 0\n\n/**\n * A class that keeps track of a key string. We use a full class here because we\n * want to be able to use them as keys in `WeakMap` objects.\n */\n\nexport class Key {\n  id: string\n\n  constructor() {\n    this.id = `${n++}`\n  }\n}\n","import { Ancestor, Editor, Node, Range, RangeRef, Text } from '@seafile/slate'\nimport { Action } from '../hooks/android-input-manager/android-input-manager'\nimport { TextDiff } from './diff-text'\nimport { Key } from './key'\n\n/**\n * Two weak maps that allow us rebuild a path given a node. They are populated\n * at render time such that after a render occurs we can always backtrack.\n */\n\nexport const NODE_TO_INDEX: WeakMap<Node, number> = new WeakMap()\nexport const NODE_TO_PARENT: WeakMap<Node, Ancestor> = new WeakMap()\n\n/**\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\n * are used to resolve DOM event-related logic into Slate actions.\n */\nexport const EDITOR_TO_WINDOW: WeakMap<Editor, Window> = new WeakMap()\nexport const EDITOR_TO_ELEMENT: WeakMap<Editor, HTMLElement> = new WeakMap()\nexport const EDITOR_TO_PLACEHOLDER: WeakMap<Editor, string> = new WeakMap()\nexport const EDITOR_TO_PLACEHOLDER_ELEMENT: WeakMap<\n  Editor,\n  HTMLElement\n> = new WeakMap()\nexport const ELEMENT_TO_NODE: WeakMap<HTMLElement, Node> = new WeakMap()\nexport const NODE_TO_ELEMENT: WeakMap<Node, HTMLElement> = new WeakMap()\nexport const NODE_TO_KEY: WeakMap<Node, Key> = new WeakMap()\nexport const EDITOR_TO_KEY_TO_ELEMENT: WeakMap<\n  Editor,\n  WeakMap<Key, HTMLElement>\n> = new WeakMap()\n\n/**\n * Weak maps for storing editor-related state.\n */\n\nexport const IS_READ_ONLY: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_FOCUSED: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_COMPOSING: WeakMap<Editor, boolean> = new WeakMap()\n\nexport const EDITOR_TO_USER_SELECTION: WeakMap<\n  Editor,\n  RangeRef | null\n> = new WeakMap()\n\n/**\n * Weak map for associating the context `onChange` context with the plugin.\n */\n\nexport const EDITOR_TO_ON_CHANGE = new WeakMap<Editor, () => void>()\n\n/**\n * Weak maps for saving pending state on composition stage.\n */\n\nexport const EDITOR_TO_SCHEDULE_FLUSH: WeakMap<\n  Editor,\n  () => void\n> = new WeakMap()\n\nexport const EDITOR_TO_PENDING_INSERTION_MARKS: WeakMap<\n  Editor,\n  Partial<Text> | null\n> = new WeakMap()\n\nexport const EDITOR_TO_USER_MARKS: WeakMap<\n  Editor,\n  Partial<Text> | null\n> = new WeakMap()\n\n/**\n * Android input handling specific weak-maps\n */\n\nexport const EDITOR_TO_PENDING_DIFFS: WeakMap<\n  Editor,\n  TextDiff[]\n> = new WeakMap()\n\nexport const EDITOR_TO_PENDING_ACTION: WeakMap<\n  Editor,\n  Action | null\n> = new WeakMap()\n\nexport const EDITOR_TO_PENDING_SELECTION: WeakMap<\n  Editor,\n  Range | null\n> = new WeakMap()\n\nexport const EDITOR_TO_FORCE_RENDER: WeakMap<Editor, () => void> = new WeakMap()\n\n/**\n * Symbols.\n */\n\nexport const PLACEHOLDER_SYMBOL = (Symbol('placeholder') as unknown) as string\nexport const MARK_PLACEHOLDER_SYMBOL = (Symbol(\n  'mark-placeholder'\n) as unknown) as string\n","/**\n * Types.\n */\n\n// COMPAT: This is required to prevent TypeScript aliases from doing some very\n// weird things for Slate's types with the same name as globals. (2019/11/27)\n// https://github.com/microsoft/TypeScript/issues/35002\nimport DOMNode = globalThis.Node\nimport DOMComment = globalThis.Comment\nimport DOMElement = globalThis.Element\nimport DOMText = globalThis.Text\nimport DOMRange = globalThis.Range\nimport DOMSelection = globalThis.Selection\nimport DOMStaticRange = globalThis.StaticRange\nimport { ReactEditor } from '../plugin/react-editor'\n\nexport {\n  DOMNode,\n  DOMComment,\n  DOMElement,\n  DOMText,\n  DOMRange,\n  DOMSelection,\n  DOMStaticRange,\n}\n\ndeclare global {\n  interface Window {\n    Selection: typeof Selection['constructor']\n    DataTransfer: typeof DataTransfer['constructor']\n    Node: typeof Node['constructor']\n  }\n}\n\nexport type DOMPoint = [Node, number]\n\n/**\n * Returns the host window of a DOM node\n */\n\nexport const getDefaultView = (value: any): Window | null => {\n  return (\n    (value && value.ownerDocument && value.ownerDocument.defaultView) || null\n  )\n}\n\n/**\n * Check if a DOM node is a comment node.\n */\n\nexport const isDOMComment = (value: any): value is DOMComment => {\n  return isDOMNode(value) && value.nodeType === 8\n}\n\n/**\n * Check if a DOM node is an element node.\n */\n\nexport const isDOMElement = (value: any): value is DOMElement => {\n  return isDOMNode(value) && value.nodeType === 1\n}\n\n/**\n * Check if a value is a DOM node.\n */\n\nexport const isDOMNode = (value: any): value is DOMNode => {\n  const window = getDefaultView(value)\n  return !!window && value instanceof window.Node\n}\n\n/**\n * Check if a value is a DOM selection.\n */\n\nexport const isDOMSelection = (value: any): value is DOMSelection => {\n  const window = value && value.anchorNode && getDefaultView(value.anchorNode)\n  return !!window && value instanceof window.Selection\n}\n\n/**\n * Check if a DOM node is an element node.\n */\n\nexport const isDOMText = (value: any): value is DOMText => {\n  return isDOMNode(value) && value.nodeType === 3\n}\n\n/**\n * Checks whether a paste event is a plaintext-only event.\n */\n\nexport const isPlainTextOnlyPaste = (event: ClipboardEvent) => {\n  return (\n    event.clipboardData &&\n    event.clipboardData.getData('text/plain') !== '' &&\n    event.clipboardData.types.length === 1\n  )\n}\n\n/**\n * Normalize a DOM point so that it always refers to a text node.\n */\n\nexport const normalizeDOMPoint = (domPoint: DOMPoint): DOMPoint => {\n  let [node, offset] = domPoint\n\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (isDOMElement(node) && node.childNodes.length) {\n    let isLast = offset === node.childNodes.length\n    let index = isLast ? offset - 1 : offset\n    ;[node, index] = getEditableChildAndIndex(\n      node,\n      index,\n      isLast ? 'backward' : 'forward'\n    )\n    // If the editable child found is in front of input offset, we instead seek to its end\n    isLast = index < offset\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (isDOMElement(node) && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward')\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast && node.textContent != null ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return [node, offset]\n}\n\n/**\n * Determines wether the active element is nested within a shadowRoot\n */\n\nexport const hasShadowRoot = (node: Node | null) => {\n  let parent = node && node.parentNode\n  while (parent) {\n    if (parent.toString() === '[object ShadowRoot]') {\n      return true\n    }\n    parent = parent.parentNode\n  }\n  return false\n}\n\n/**\n * Get the nearest editable child and index at `index` in a `parent`, preferring\n * `direction`.\n */\n\nexport const getEditableChildAndIndex = (\n  parent: DOMElement,\n  index: number,\n  direction: 'forward' | 'backward'\n): [DOMNode, number] => {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (\n    isDOMComment(child) ||\n    (isDOMElement(child) && child.childNodes.length === 0) ||\n    (isDOMElement(child) && child.getAttribute('contenteditable') === 'false')\n  ) {\n    if (triedForward && triedBackward) {\n      break\n    }\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    index = i\n    i += direction === 'forward' ? 1 : -1\n  }\n\n  return [child, index]\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n */\n\nexport const getEditableChild = (\n  parent: DOMElement,\n  index: number,\n  direction: 'forward' | 'backward'\n): DOMNode => {\n  const [child] = getEditableChildAndIndex(parent, index, direction)\n  return child\n}\n\n/**\n * Get a plaintext representation of the content of a node, accounting for block\n * elements which get a newline appended.\n *\n * The domNode must be attached to the DOM.\n */\n\nexport const getPlainText = (domNode: DOMNode) => {\n  let text = ''\n\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue\n  }\n\n  if (isDOMElement(domNode)) {\n    for (const childNode of Array.from(domNode.childNodes)) {\n      text += getPlainText(childNode)\n    }\n\n    const display = getComputedStyle(domNode).getPropertyValue('display')\n\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n'\n    }\n  }\n\n  return text\n}\n\n/**\n * Get x-slate-fragment attribute from data-slate-fragment\n */\nconst catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m\nexport const getSlateFragmentAttribute = (\n  dataTransfer: DataTransfer\n): string | void => {\n  const htmlData = dataTransfer.getData('text/html')\n  const [, fragment] = htmlData.match(catchSlateFragment) || []\n  return fragment\n}\n\n/**\n * Get the x-slate-fragment attribute that exist in text/html data\n * and append it to the DataTransfer object\n */\nexport const getClipboardData = (\n  dataTransfer: DataTransfer,\n  clipboardFormatKey = 'x-slate-fragment'\n): DataTransfer => {\n  if (!dataTransfer.getData(`application/${clipboardFormatKey}`)) {\n    const fragment = getSlateFragmentAttribute(dataTransfer)\n    if (fragment) {\n      const clipboardData = new DataTransfer()\n      dataTransfer.types.forEach(type => {\n        clipboardData.setData(type, dataTransfer.getData(type))\n      })\n      clipboardData.setData(`application/${clipboardFormatKey}`, fragment)\n      return clipboardData\n    }\n  }\n  return dataTransfer\n}\n\n/**\n * Check whether a mutation originates from a editable element inside the editor.\n */\n\nexport const isTrackedMutation = (\n  editor: ReactEditor,\n  mutation: MutationRecord,\n  batch: MutationRecord[]\n): boolean => {\n  const { target } = mutation\n  if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n    return false\n  }\n\n  const { document } = ReactEditor.getWindow(editor)\n  if (document.contains(target)) {\n    return ReactEditor.hasDOMNode(editor, target, { editable: true })\n  }\n\n  const parentMutation = batch.find(({ addedNodes, removedNodes }) => {\n    for (const node of addedNodes) {\n      if (node === target || node.contains(target)) {\n        return true\n      }\n    }\n\n    for (const node of removedNodes) {\n      if (node === target || node.contains(target)) {\n        return true\n      }\n    }\n  })\n\n  if (!parentMutation || parentMutation === mutation) {\n    return false\n  }\n\n  // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n  return isTrackedMutation(editor, parentMutation, batch)\n}\n","import React from 'react'\n\nexport const IS_REACT_VERSION_17_OR_ABOVE =\n  parseInt(React.version.split('.')[0], 10) >= 17\n\nexport const IS_IOS =\n  typeof navigator !== 'undefined' &&\n  typeof window !== 'undefined' &&\n  /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n  !window.MSStream\n\nexport const IS_APPLE =\n  typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent)\n\nexport const IS_ANDROID =\n  typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent)\n\nexport const IS_FIREFOX =\n  typeof navigator !== 'undefined' &&\n  /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent)\n\nexport const IS_SAFARI =\n  typeof navigator !== 'undefined' &&\n  /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent)\n\n// \"modern\" Edge was released at 79.x\nexport const IS_EDGE_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent)\n\nexport const IS_CHROME =\n  typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent)\n\n// Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nexport const IS_CHROME_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent)\n\nexport const IS_ANDROID_CHROME_LEGACY =\n  IS_ANDROID &&\n  typeof navigator !== 'undefined' &&\n  /Chrome?\\/(?:[0-5]?\\d)(?:\\.)/i.test(navigator.userAgent)\n\n// Firefox did not support `beforeInput` until `v87`.\nexport const IS_FIREFOX_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(\n    navigator.userAgent\n  )\n\n// UC mobile browser\nexport const IS_UC_MOBILE =\n  typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent)\n\n// Wechat browser\nexport const IS_WECHATBROWSER =\n  typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent)\n\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nexport const CAN_USE_DOM = !!(\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined'\n)\n\n// COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nexport const HAS_BEFORE_INPUT_SUPPORT =\n  (!IS_CHROME_LEGACY || !IS_ANDROID_CHROME_LEGACY) &&\n  !IS_EDGE_LEGACY &&\n  // globalThis is undefined in older browsers\n  typeof globalThis !== 'undefined' &&\n  globalThis.InputEvent &&\n  // @ts-ignore The `getTargetRanges` property isn't recognized.\n  typeof globalThis.InputEvent.prototype.getTargetRanges === 'function'\n","import {\n  BaseEditor,\n  Editor,\n  Node,\n  Path,\n  Point,\n  Range,\n  Scrubber,\n  Transforms,\n  Element,\n} from '@seafile/slate'\n\nimport { Key } from '../utils/key'\nimport {\n  EDITOR_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  IS_FOCUSED,\n  IS_READ_ONLY,\n  NODE_TO_INDEX,\n  NODE_TO_KEY,\n  NODE_TO_PARENT,\n  EDITOR_TO_WINDOW,\n  EDITOR_TO_KEY_TO_ELEMENT,\n  IS_COMPOSING,\n  EDITOR_TO_SCHEDULE_FLUSH,\n  EDITOR_TO_PENDING_DIFFS,\n} from '../utils/weak-maps'\nimport {\n  DOMElement,\n  DOMNode,\n  DOMPoint,\n  DOMRange,\n  DOMSelection,\n  DOMStaticRange,\n  isDOMElement,\n  isDOMSelection,\n  isDOMNode,\n  normalizeDOMPoint,\n  hasShadowRoot,\n  DOMText,\n} from '../utils/dom'\nimport { IS_CHROME, IS_FIREFOX, IS_ANDROID } from '../utils/environment'\n\n/**\n * A React and DOM-specific version of the `Editor` interface.\n */\n\nexport interface ReactEditor extends BaseEditor {\n  insertData: (data: DataTransfer) => void\n  insertFragmentData: (data: DataTransfer) => boolean\n  insertTextData: (data: DataTransfer) => boolean\n  setFragmentData: (\n    data: DataTransfer,\n    originEvent?: 'drag' | 'copy' | 'cut'\n  ) => void\n  hasRange: (editor: ReactEditor, range: Range) => boolean\n  hasTarget: (\n    editor: ReactEditor,\n    target: EventTarget | null\n  ) => target is DOMNode\n  hasEditableTarget: (\n    editor: ReactEditor,\n    target: EventTarget | null\n  ) => target is DOMNode\n  hasSelectableTarget: (\n    editor: ReactEditor,\n    target: EventTarget | null\n  ) => boolean\n  isTargetInsideNonReadonlyVoid: (\n    editor: ReactEditor,\n    target: EventTarget | null\n  ) => boolean\n}\n\n// eslint-disable-next-line no-redeclare\nexport const ReactEditor = {\n  /**\n   * Check if the user is currently composing inside the editor.\n   */\n\n  isComposing(editor: ReactEditor): boolean {\n    return !!IS_COMPOSING.get(editor)\n  },\n\n  /**\n   * Return the host window of the current editor.\n   */\n\n  getWindow(editor: ReactEditor): Window {\n    const window = EDITOR_TO_WINDOW.get(editor)\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor')\n    }\n    return window\n  },\n\n  /**\n   * Find a key for a Slate node.\n   */\n\n  findKey(editor: ReactEditor, node: Node): Key {\n    let key = NODE_TO_KEY.get(node)\n\n    if (!key) {\n      key = new Key()\n      NODE_TO_KEY.set(node, key)\n    }\n\n    return key\n  },\n\n  /**\n   * Find the path of Slate node.\n   */\n\n  findPath(editor: ReactEditor, node: Node): Path {\n    const path: Path = []\n    let child = node\n\n    while (true) {\n      const parent = NODE_TO_PARENT.get(child)\n\n      if (parent == null) {\n        if (Editor.isEditor(child)) {\n          return path\n        } else {\n          break\n        }\n      }\n\n      const i = NODE_TO_INDEX.get(child)\n\n      if (i == null) {\n        break\n      }\n\n      path.unshift(i)\n      child = parent\n    }\n\n    throw new Error(\n      `Unable to find the path for Slate node: ${Scrubber.stringify(node)}`\n    )\n  },\n\n  /**\n   * Find the DOM node that implements DocumentOrShadowRoot for the editor.\n   */\n\n  findDocumentOrShadowRoot(editor: ReactEditor): Document | ShadowRoot {\n    const el = ReactEditor.toDOMNode(editor, editor)\n    const root = el.getRootNode()\n\n    if (\n      (root instanceof Document || root instanceof ShadowRoot) &&\n      root.getSelection != null\n    ) {\n      return root\n    }\n\n    return el.ownerDocument\n  },\n\n  /**\n   * Check if the editor is focused.\n   */\n\n  isFocused(editor: ReactEditor): boolean {\n    return !!IS_FOCUSED.get(editor)\n  },\n\n  /**\n   * Check if the editor is in read-only mode.\n   */\n\n  isReadOnly(editor: ReactEditor): boolean {\n    return !!IS_READ_ONLY.get(editor)\n  },\n\n  /**\n   * Blur the editor.\n   */\n\n  blur(editor: ReactEditor): void {\n    const el = ReactEditor.toDOMNode(editor, editor)\n    const root = ReactEditor.findDocumentOrShadowRoot(editor)\n    IS_FOCUSED.set(editor, false)\n\n    if (root.activeElement === el) {\n      el.blur()\n    }\n  },\n\n  /**\n   * Focus the editor.\n   */\n\n  focus(editor: ReactEditor): void {\n    const el = ReactEditor.toDOMNode(editor, editor)\n    const root = ReactEditor.findDocumentOrShadowRoot(editor)\n    IS_FOCUSED.set(editor, true)\n\n    if (root.activeElement !== el) {\n      el.focus({ preventScroll: true })\n    }\n  },\n\n  /**\n   * Deselect the editor.\n   */\n\n  deselect(editor: ReactEditor): void {\n    const { selection } = editor\n    const root = ReactEditor.findDocumentOrShadowRoot(editor)\n    const domSelection = root.getSelection()\n\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges()\n    }\n\n    if (selection) {\n      Transforms.deselect(editor)\n    }\n  },\n\n  /**\n   * Check if a DOM node is within the editor.\n   */\n\n  hasDOMNode(\n    editor: ReactEditor,\n    target: DOMNode,\n    options: { editable?: boolean } = {}\n  ): boolean {\n    const { editable = false } = options\n    const editorEl = ReactEditor.toDOMNode(editor, editor)\n    let targetEl\n\n    // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n    try {\n      targetEl = (isDOMElement(target)\n        ? target\n        : target.parentElement) as HTMLElement\n    } catch (err) {\n      if (\n        !err.message.includes('Permission denied to access property \"nodeType\"')\n      ) {\n        throw err\n      }\n    }\n\n    if (!targetEl) {\n      return false\n    }\n\n    return (\n      targetEl.closest(`[data-slate-editor]`) === editorEl &&\n      (!editable || targetEl.isContentEditable\n        ? true\n        : (typeof targetEl.isContentEditable === 'boolean' && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n            // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n            targetEl.closest('[contenteditable=\"false\"]') === editorEl) ||\n          !!targetEl.getAttribute('data-slate-zero-width'))\n    )\n  },\n\n  /**\n   * Insert data from a `DataTransfer` into the editor.\n   */\n\n  insertData(editor: ReactEditor, data: DataTransfer): void {\n    editor.insertData(data)\n  },\n\n  /**\n   * Insert fragment data from a `DataTransfer` into the editor.\n   */\n\n  insertFragmentData(editor: ReactEditor, data: DataTransfer): boolean {\n    return editor.insertFragmentData(data)\n  },\n\n  /**\n   * Insert text data from a `DataTransfer` into the editor.\n   */\n\n  insertTextData(editor: ReactEditor, data: DataTransfer): boolean {\n    return editor.insertTextData(data)\n  },\n\n  /**\n   * Sets data from the currently selected fragment on a `DataTransfer`.\n   */\n\n  setFragmentData(\n    editor: ReactEditor,\n    data: DataTransfer,\n    originEvent?: 'drag' | 'copy' | 'cut'\n  ): void {\n    editor.setFragmentData(data, originEvent)\n  },\n\n  /**\n   * Find the native DOM element from a Slate node.\n   */\n\n  toDOMNode(editor: ReactEditor, node: Node): HTMLElement {\n    const KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor)\n    const domNode = Editor.isEditor(node)\n      ? EDITOR_TO_ELEMENT.get(editor)\n      : KEY_TO_ELEMENT?.get(ReactEditor.findKey(editor, node))\n\n    if (!domNode) {\n      throw new Error(\n        `Cannot resolve a DOM node from Slate node: ${Scrubber.stringify(node)}`\n      )\n    }\n\n    return domNode\n  },\n\n  /**\n   * Find a native DOM selection point from a Slate point.\n   */\n\n  toDOMPoint(editor: ReactEditor, point: Point): DOMPoint {\n    const [node] = Editor.node(editor, point.path)\n    const el = ReactEditor.toDOMNode(editor, node)\n    let domPoint: DOMPoint | undefined\n\n    // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n    if (Editor.void(editor, { at: point })) {\n      point = { path: point.path, offset: 0 }\n    }\n\n    // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n    const selector = `[data-slate-string], [data-slate-zero-width]`\n    const texts = Array.from(el.querySelectorAll(selector))\n    let start = 0\n\n    for (let i = 0; i < texts.length; i++) {\n      const text = texts[i]\n      const domNode = text.childNodes[0] as HTMLElement\n\n      if (domNode == null || domNode.textContent == null) {\n        continue\n      }\n\n      const { length } = domNode.textContent\n      const attr = text.getAttribute('data-slate-length')\n      const trueLength = attr == null ? length : parseInt(attr, 10)\n      const end = start + trueLength\n\n      // Prefer putting the selection inside the mark placeholder to ensure\n      // composed text is displayed with the correct marks.\n      const nextText = texts[i + 1]\n      if (\n        point.offset === end &&\n        nextText?.hasAttribute('data-slate-mark-placeholder')\n      ) {\n        const domText = nextText.childNodes[0]\n\n        domPoint = [\n          // COMPAT: If we don't explicity set the dom point to be on the actual\n          // dom text element, chrome will put the selection behind the actual dom\n          // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n          // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n          // which will cause issues when scrolling to it.\n          domText instanceof DOMText ? domText : nextText,\n          nextText.textContent?.startsWith('\\uFEFF') ? 1 : 0,\n        ]\n        break\n      }\n\n      if (point.offset <= end) {\n        const offset = Math.min(length, Math.max(0, point.offset - start))\n        domPoint = [domNode, offset]\n        break\n      }\n\n      start = end\n    }\n\n    if (!domPoint) {\n      throw new Error(\n        `Cannot resolve a DOM point from Slate point: ${Scrubber.stringify(\n          point\n        )}`\n      )\n    }\n\n    return domPoint\n  },\n\n  /**\n   * Find a native DOM range from a Slate `range`.\n   *\n   * Notice: the returned range will always be ordinal regardless of the direction of Slate `range` due to DOM API limit.\n   *\n   * there is no way to create a reverse DOM Range using Range.setStart/setEnd\n   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.\n   */\n\n  toDOMRange(editor: ReactEditor, range: Range): DOMRange {\n    const { anchor, focus } = range\n    const isBackward = Range.isBackward(range)\n    const domAnchor = ReactEditor.toDOMPoint(editor, anchor)\n    const domFocus = Range.isCollapsed(range)\n      ? domAnchor\n      : ReactEditor.toDOMPoint(editor, focus)\n\n    const window = ReactEditor.getWindow(editor)\n    const domRange = window.document.createRange()\n    const [startNode, startOffset] = isBackward ? domFocus : domAnchor\n    const [endNode, endOffset] = isBackward ? domAnchor : domFocus\n\n    // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n    const startEl = (isDOMElement(startNode)\n      ? startNode\n      : startNode.parentElement) as HTMLElement\n    const isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width')\n    const endEl = (isDOMElement(endNode)\n      ? endNode\n      : endNode.parentElement) as HTMLElement\n    const isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width')\n\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset)\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset)\n    return domRange\n  },\n\n  /**\n   * Find a Slate node from a native DOM `element`.\n   */\n\n  toSlateNode(editor: ReactEditor, domNode: DOMNode): Node {\n    let domEl = isDOMElement(domNode) ? domNode : domNode.parentElement\n\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(`[data-slate-node]`)\n    }\n\n    const node = domEl ? ELEMENT_TO_NODE.get(domEl as HTMLElement) : null\n\n    if (!node) {\n      throw new Error(`Cannot resolve a Slate node from DOM node: ${domEl}`)\n    }\n\n    return node\n  },\n\n  /**\n   * Get the target range from a DOM `event`.\n   */\n\n  findEventRange(editor: ReactEditor, event: any): Range {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent\n    }\n\n    const { clientX: x, clientY: y, target } = event\n\n    if (x == null || y == null) {\n      throw new Error(`Cannot resolve a Slate range from a DOM event: ${event}`)\n    }\n\n    const node = ReactEditor.toSlateNode(editor, event.target)\n    const path = ReactEditor.findPath(editor, node)\n\n    // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n    if (Element.isElement(node) && Editor.isVoid(editor, node)) {\n      const rect = target.getBoundingClientRect()\n      const isPrev = editor.isInline(node)\n        ? x - rect.left < rect.left + rect.width - x\n        : y - rect.top < rect.top + rect.height - y\n\n      const edge = Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end',\n      })\n      const point = isPrev\n        ? Editor.before(editor, edge)\n        : Editor.after(editor, edge)\n\n      if (point) {\n        const range = Editor.range(editor, point)\n        return range\n      }\n    }\n\n    // Else resolve a range from the caret position where the drop occured.\n    let domRange\n    const { document } = ReactEditor.getWindow(editor)\n\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y)\n    } else {\n      const position = document.caretPositionFromPoint(x, y)\n\n      if (position) {\n        domRange = document.createRange()\n        domRange.setStart(position.offsetNode, position.offset)\n        domRange.setEnd(position.offsetNode, position.offset)\n      }\n    }\n\n    if (!domRange) {\n      throw new Error(`Cannot resolve a Slate range from a DOM event: ${event}`)\n    }\n\n    // Resolve a Slate range from the DOM range.\n    const range = ReactEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      suppressThrow: false,\n    })\n    return range\n  },\n\n  /**\n   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.\n   */\n\n  toSlatePoint<T extends boolean>(\n    editor: ReactEditor,\n    domPoint: DOMPoint,\n    options: {\n      exactMatch: boolean\n      suppressThrow: T\n    }\n  ): T extends true ? Point | null : Point {\n    const { exactMatch, suppressThrow } = options\n    const [nearestNode, nearestOffset] = exactMatch\n      ? domPoint\n      : normalizeDOMPoint(domPoint)\n    const parentNode = nearestNode.parentNode as DOMElement\n    let textNode: DOMElement | null = null\n    let offset = 0\n\n    if (parentNode) {\n      const editorEl = ReactEditor.toDOMNode(editor, editor)\n      const potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]')\n      // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n      const voidNode =\n        potentialVoidNode && editorEl.contains(potentialVoidNode)\n          ? potentialVoidNode\n          : null\n      let leafNode = parentNode.closest('[data-slate-leaf]')\n      let domNode: DOMElement | null = null\n\n      // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]')\n\n        if (textNode) {\n          const window = ReactEditor.getWindow(editor)\n          const range = window.document.createRange()\n          range.setStart(textNode, 0)\n          range.setEnd(nearestNode, nearestOffset)\n\n          const contents = range.cloneContents()\n          const removals = [\n            ...Array.prototype.slice.call(\n              contents.querySelectorAll('[data-slate-zero-width]')\n            ),\n            ...Array.prototype.slice.call(\n              contents.querySelectorAll('[contenteditable=false]')\n            ),\n          ]\n\n          removals.forEach(el => {\n            // COMPAT: While composing at the start of a text node, some keyboards put\n            // the text content inside the zero width space.\n            if (\n              IS_ANDROID &&\n              !exactMatch &&\n              el.hasAttribute('data-slate-zero-width') &&\n              el.textContent.length > 0 &&\n              el.textContext !== '\\uFEFF'\n            ) {\n              if (el.textContent.startsWith('\\uFEFF')) {\n                el.textContent = el.textContent.slice(1)\n              }\n\n              return\n            }\n\n            el!.parentNode!.removeChild(el)\n          })\n\n          // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-react\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n          offset = contents.textContent!.length\n          domNode = textNode\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent and taking the\n        // first one that isn't inside a nested editor.\n        const leafNodes = voidNode.querySelectorAll('[data-slate-leaf]')\n        for (let index = 0; index < leafNodes.length; index++) {\n          const current = leafNodes[index]\n          if (ReactEditor.hasDOMNode(editor, current)) {\n            leafNode = current\n            break\n          }\n        }\n\n        // COMPAT: In read-only editors the leaf is not rendered.\n        if (!leafNode) {\n          offset = 1\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]')!\n          domNode = leafNode\n          offset = domNode.textContent!.length\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n            offset -= el.textContent!.length\n          })\n        }\n      }\n\n      if (\n        domNode &&\n        offset === domNode.textContent!.length &&\n        // COMPAT: Android IMEs might remove the zero width space while composing,\n        // and we don't add it for line-breaks.\n        IS_ANDROID &&\n        domNode.getAttribute('data-slate-zero-width') === 'z' &&\n        domNode.textContent?.startsWith('\\uFEFF') &&\n        // COMPAT: If the parent node is a Slate zero-width space, editor is\n        // because the text node should have no characters. However, during IME\n        // composition the ASCII characters will be prepended to the zero-width\n        // space, so subtract 1 from the offset to account for the zero-width\n        // space character.\n        (parentNode.hasAttribute('data-slate-zero-width') ||\n          // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\\n'\n          // when the document ends with a new-line character. This results in the offset\n          // length being off by one, so we need to subtract one to account for this.\n          (IS_FIREFOX && domNode.textContent?.endsWith('\\n\\n')))\n      ) {\n        offset--\n      }\n    }\n\n    if (IS_ANDROID && !textNode && !exactMatch) {\n      const node = parentNode.hasAttribute('data-slate-node')\n        ? parentNode\n        : parentNode.closest('[data-slate-node]')\n\n      if (node && ReactEditor.hasDOMNode(editor, node, { editable: true })) {\n        const slateNode = ReactEditor.toSlateNode(editor, node)\n        let { path, offset } = Editor.start(\n          editor,\n          ReactEditor.findPath(editor, slateNode)\n        )\n\n        if (!node.querySelector('[data-slate-leaf]')) {\n          offset = nearestOffset\n        }\n\n        return { path, offset } as T extends true ? Point | null : Point\n      }\n    }\n\n    if (!textNode) {\n      if (suppressThrow) {\n        return null as T extends true ? Point | null : Point\n      }\n      throw new Error(\n        `Cannot resolve a Slate point from DOM point: ${domPoint}`\n      )\n    }\n\n    // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n    const slateNode = ReactEditor.toSlateNode(editor, textNode!)\n    const path = ReactEditor.findPath(editor, slateNode)\n    return { path, offset } as T extends true ? Point | null : Point\n  },\n\n  /**\n   * Find a Slate range from a DOM range or selection.\n   */\n\n  toSlateRange<T extends boolean>(\n    editor: ReactEditor,\n    domRange: DOMRange | DOMStaticRange | DOMSelection,\n    options: {\n      exactMatch: boolean\n      suppressThrow: T\n    }\n  ): T extends true ? Range | null : Range {\n    const { exactMatch, suppressThrow } = options\n    const el = isDOMSelection(domRange)\n      ? domRange.anchorNode\n      : domRange.startContainer\n    let anchorNode\n    let anchorOffset\n    let focusNode\n    let focusOffset\n    let isCollapsed\n\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        anchorNode = domRange.anchorNode\n        anchorOffset = domRange.anchorOffset\n        focusNode = domRange.focusNode\n        focusOffset = domRange.focusOffset\n        // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n        if (IS_CHROME && hasShadowRoot(anchorNode)) {\n          isCollapsed =\n            domRange.anchorNode === domRange.focusNode &&\n            domRange.anchorOffset === domRange.focusOffset\n        } else {\n          isCollapsed = domRange.isCollapsed\n        }\n      } else {\n        anchorNode = domRange.startContainer\n        anchorOffset = domRange.startOffset\n        focusNode = domRange.endContainer\n        focusOffset = domRange.endOffset\n        isCollapsed = domRange.collapsed\n      }\n    }\n\n    if (\n      anchorNode == null ||\n      focusNode == null ||\n      anchorOffset == null ||\n      focusOffset == null\n    ) {\n      throw new Error(\n        `Cannot resolve a Slate range from DOM range: ${domRange}`\n      )\n    }\n\n    // COMPAT: Triple-clicking a word in chrome will sometimes place the focus\n    // inside a `contenteditable=\"false\"` DOM node following the word, which\n    // will cause `toSlatePoint` to throw an error. (2023/03/07)\n    if (\n      'getAttribute' in focusNode &&\n      (focusNode as HTMLElement).getAttribute('contenteditable') === 'false'\n    ) {\n      focusNode = anchorNode\n      focusOffset = anchorNode.textContent?.length || 0\n    }\n\n    let anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {\n      exactMatch,\n      suppressThrow,\n    })\n    if (!anchor) {\n      return null as T extends true ? Range | null : Range\n    }\n\n    let focus = isCollapsed\n      ? anchor\n      : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset], {\n          exactMatch,\n          suppressThrow,\n        })\n    if (!focus) {\n      return null as T extends true ? Range | null : Range\n    }\n\n    /**\n     * suppose we have this document:\n     *\n     * { type: 'paragraph',\n     *   children: [\n     *     { text: 'foo ' },\n     *     { text: 'bar' },\n     *     { text: ' baz' }\n     *   ]\n     * }\n     *\n     * a double click on \"bar\" on chrome will create this range:\n     *\n     * anchor -> [0,1] offset 0\n     * focus  -> [0,1] offset 3\n     *\n     * while on firefox will create this range:\n     *\n     * anchor -> [0,0] offset 4\n     * focus  -> [0,2] offset 0\n     *\n     * let's try to fix it...\n     */\n\n    if (IS_FIREFOX && !isCollapsed && anchorNode !== focusNode) {\n      const isEnd = Editor.isEnd(editor, anchor!, anchor.path)\n      const isStart = Editor.isStart(editor, focus!, focus.path)\n\n      if (isEnd) {\n        const after = Editor.after(editor, anchor as Point)\n        // Editor.after() might return undefined\n        anchor = (after || anchor!) as T extends true ? Point | null : Point\n      }\n\n      if (isStart) {\n        const before = Editor.before(editor, focus as Point)\n        focus = (before || focus!) as T extends true ? Point | null : Point\n      }\n    }\n\n    let range: Range = { anchor: anchor as Point, focus: focus as Point }\n    // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n    if (\n      Range.isExpanded(range) &&\n      Range.isForward(range) &&\n      isDOMElement(focusNode) &&\n      Editor.void(editor, { at: range.focus, mode: 'highest' })\n    ) {\n      range = Editor.unhangRange(editor, range, { voids: true })\n    }\n\n    return (range as unknown) as T extends true ? Range | null : Range\n  },\n\n  hasRange(editor: ReactEditor, range: Range): boolean {\n    const { anchor, focus } = range\n    return (\n      Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus.path)\n    )\n  },\n\n  /**\n   * Check if the target is in the editor.\n   */\n  hasTarget(\n    editor: ReactEditor,\n    target: EventTarget | null\n  ): target is DOMNode {\n    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target)\n  },\n\n  /**\n   * Check if the target is editable and in the editor.\n   */\n  hasEditableTarget(\n    editor: ReactEditor,\n    target: EventTarget | null\n  ): target is DOMNode {\n    return (\n      isDOMNode(target) &&\n      ReactEditor.hasDOMNode(editor, target, { editable: true })\n    )\n  },\n\n  /**\n   * Check if the target can be selectable\n   */\n  hasSelectableTarget(\n    editor: ReactEditor,\n    target: EventTarget | null\n  ): boolean {\n    return (\n      ReactEditor.hasEditableTarget(editor, target) ||\n      ReactEditor.isTargetInsideNonReadonlyVoid(editor, target)\n    )\n  },\n\n  /**\n   * Check if the target is inside void and in an non-readonly editor.\n   */\n  isTargetInsideNonReadonlyVoid(\n    editor: ReactEditor,\n    target: EventTarget | null\n  ): boolean {\n    if (IS_READ_ONLY.get(editor)) return false\n\n    const slateNode =\n      ReactEditor.hasTarget(editor, target) &&\n      ReactEditor.toSlateNode(editor, target)\n    return Element.isElement(slateNode) && Editor.isVoid(editor, slateNode)\n  },\n\n  /**\n   * Experimental and android specific: Flush all pending diffs and cancel composition at the next possible time.\n   */\n  androidScheduleFlush(editor: Editor) {\n    EDITOR_TO_SCHEDULE_FLUSH.get(editor)?.()\n  },\n\n  /**\n   * Experimental and android specific: Get pending diffs\n   */\n  androidPendingDiffs(editor: Editor) {\n    return EDITOR_TO_PENDING_DIFFS.get(editor)\n  },\n}\n","import { createContext, useContext } from 'react'\nimport { Range, NodeEntry } from '@seafile/slate'\n\n/**\n * A React context for sharing the `decorate` prop of the editable.\n */\n\nexport const DecorateContext = createContext<(entry: NodeEntry) => Range[]>(\n  () => []\n)\n\n/**\n * Get the current `decorate` prop of the editable.\n */\n\nexport const useDecorate = (): ((entry: NodeEntry) => Range[]) => {\n  return useContext(DecorateContext)\n}\n","import { useLayoutEffect, useEffect } from 'react'\nimport { CAN_USE_DOM } from '../utils/environment'\n\n/**\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\n */\n\nexport const useIsomorphicLayoutEffect = CAN_USE_DOM\n  ? useLayoutEffect\n  : useEffect\n","import { createContext, useContext } from 'react'\n\n/**\n * A React context for sharing the `readOnly` state of the editor.\n */\n\nexport const ReadOnlyContext = createContext(false)\n\n/**\n * Get the current `readOnly` state of the editor.\n */\n\nexport const useReadOnly = (): boolean => {\n  return useContext(ReadOnlyContext)\n}\n","import { createContext, useContext } from 'react'\nimport { Editor } from '@seafile/slate'\nimport { ReactEditor } from '../plugin/react-editor'\n\n/**\n * A React context for sharing the editor object, in a way that re-renders the\n * context whenever changes occur.\n */\n\nexport interface SlateContextValue {\n  v: number\n  editor: ReactEditor\n}\n\nexport const SlateContext = createContext<{\n  v: number\n  editor: ReactEditor\n} | null>(null)\n\n/**\n * Get the current editor object from the React context.\n */\n\nexport const useSlate = (): Editor => {\n  const context = useContext(SlateContext)\n\n  if (!context) {\n    throw new Error(\n      `The \\`useSlate\\` hook must be used inside the <Slate> component's context.`\n    )\n  }\n\n  const { editor } = context\n  return editor\n}\n\nexport const useSlateWithV = () => {\n  const context = useContext(SlateContext)\n\n  if (!context) {\n    throw new Error(\n      `The \\`useSlate\\` hook must be used inside the <Slate> component's context.`\n    )\n  }\n\n  return context\n}\n","export const TRIPLE_CLICK = 3\n","import { isKeyHotkey } from 'is-hotkey'\nimport { IS_APPLE } from './environment'\n\n/**\n * Hotkey mappings for each platform.\n */\n\nconst HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z',\n}\n\nconst APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t',\n}\n\nconst WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z'],\n}\n\n/**\n * Create a platform-aware hotkey checker.\n */\n\nconst create = (key: string) => {\n  const generic = HOTKEYS[key]\n  const apple = APPLE_HOTKEYS[key]\n  const windows = WINDOWS_HOTKEYS[key]\n  const isGeneric = generic && isKeyHotkey(generic)\n  const isApple = apple && isKeyHotkey(apple)\n  const isWindows = windows && isKeyHotkey(windows)\n\n  return (event: KeyboardEvent) => {\n    if (isGeneric && isGeneric(event)) return true\n    if (IS_APPLE && isApple && isApple(event)) return true\n    if (!IS_APPLE && isWindows && isWindows(event)) return true\n    return false\n  }\n}\n\n/**\n * Hotkeys.\n */\n\nexport default {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo'),\n}\n","import { createContext, useContext } from 'react'\nimport { ReactEditor } from '../plugin/react-editor'\nimport { Editor } from '@seafile/slate'\n\n/**\n * A React context for sharing the editor object.\n */\n\nexport const EditorContext = createContext<ReactEditor | null>(null)\n\n/**\n * Get the current editor object from the React context.\n */\n\nexport const useSlateStatic = (): Editor => {\n  const editor = useContext(EditorContext)\n\n  if (!editor) {\n    throw new Error(\n      `The \\`useSlateStatic\\` hook must be used inside the <Slate> component's context.`\n    )\n  }\n\n  return editor\n}\n","import { RefObject } from 'react'\nimport { ReactEditor } from '../../plugin/react-editor'\nimport { isTrackedMutation } from '../../utils/dom'\n\nexport type RestoreDOMManager = {\n  registerMutations: (mutations: MutationRecord[]) => void\n  restoreDOM: () => void\n  clear: () => void\n}\n\nexport const createRestoreDomManager = (\n  editor: ReactEditor,\n  receivedUserInput: RefObject<boolean>\n): RestoreDOMManager => {\n  let bufferedMutations: MutationRecord[] = []\n\n  const clear = () => {\n    bufferedMutations = []\n  }\n\n  const registerMutations = (mutations: MutationRecord[]) => {\n    if (!receivedUserInput.current) {\n      return\n    }\n\n    const trackedMutations = mutations.filter(mutation =>\n      isTrackedMutation(editor, mutation, mutations)\n    )\n\n    bufferedMutations.push(...trackedMutations)\n  }\n\n  function restoreDOM() {\n    if (bufferedMutations.length > 0) {\n      bufferedMutations.reverse().forEach(mutation => {\n        if (mutation.type === 'characterData') {\n          // We don't want to restore the DOM for characterData mutations\n          // because this interrupts the composition.\n          return\n        }\n\n        mutation.removedNodes.forEach(node => {\n          mutation.target.insertBefore(node, mutation.nextSibling)\n        })\n\n        mutation.addedNodes.forEach(node => {\n          mutation.target.removeChild(node)\n        })\n      })\n\n      // Clear buffered mutations to ensure we don't undo them twice\n      clear()\n    }\n  }\n\n  return {\n    registerMutations,\n    restoreDOM,\n    clear,\n  }\n}\n","import React, { Component, ComponentType, ContextType, RefObject } from 'react'\nimport { EditorContext } from '../../hooks/use-slate-static'\nimport { IS_ANDROID } from '../../utils/environment'\nimport {\n  createRestoreDomManager,\n  RestoreDOMManager,\n} from './restore-dom-manager'\n\nconst MUTATION_OBSERVER_CONFIG: MutationObserverInit = {\n  subtree: true,\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true,\n}\n\ntype RestoreDOMProps = {\n  receivedUserInput: RefObject<boolean>\n  node: RefObject<HTMLDivElement>\n}\n\n// We have to use a class component here since we rely on `getSnapshotBeforeUpdate` which has no FC equivalent\n// to run code synchronously immediately before react commits the component update to the DOM.\nclass RestoreDOMComponent extends Component<RestoreDOMProps> {\n  static contextType = EditorContext\n  context: ContextType<typeof EditorContext> = null\n\n  private manager: RestoreDOMManager | null = null\n  private mutationObserver: MutationObserver | null = null\n\n  observe() {\n    const { node } = this.props\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined')\n    }\n\n    this.mutationObserver?.observe(node.current, MUTATION_OBSERVER_CONFIG)\n  }\n\n  componentDidMount() {\n    const { receivedUserInput } = this.props\n    const editor = this.context!\n\n    this.manager = createRestoreDomManager(editor, receivedUserInput)\n    this.mutationObserver = new MutationObserver(this.manager.registerMutations)\n\n    this.observe()\n  }\n\n  getSnapshotBeforeUpdate() {\n    const pendingMutations = this.mutationObserver?.takeRecords()\n    if (pendingMutations?.length) {\n      this.manager?.registerMutations(pendingMutations)\n    }\n\n    this.mutationObserver?.disconnect()\n    this.manager?.restoreDOM()\n\n    return null\n  }\n\n  componentDidUpdate() {\n    this.manager?.clear()\n    this.observe()\n  }\n\n  componentWillUnmount() {\n    this.mutationObserver?.disconnect()\n  }\n\n  render() {\n    return this.props.children\n  }\n}\n\nexport const RestoreDOM: ComponentType<RestoreDOMProps> = IS_ANDROID\n  ? RestoreDOMComponent\n  : ({ children }) => <>{children}</>\n","import {\n  Editor,\n  Node,\n  Operation,\n  Path,\n  Point,\n  Range,\n  Text,\n  Element,\n} from '@seafile/slate'\nimport { EDITOR_TO_PENDING_DIFFS } from './weak-maps'\n\nexport type StringDiff = {\n  start: number\n  end: number\n  text: string\n}\n\nexport type TextDiff = {\n  id: number\n  path: Path\n  diff: StringDiff\n}\n\n/**\n * Check whether a text diff was applied in a way we can perform the pending action on /\n * recover the pending selection.\n */\nexport function verifyDiffState(editor: Editor, textDiff: TextDiff): boolean {\n  const { path, diff } = textDiff\n  if (!Editor.hasPath(editor, path)) {\n    return false\n  }\n\n  const node = Node.get(editor, path)\n  if (!Text.isText(node)) {\n    return false\n  }\n\n  if (diff.start !== node.text.length || diff.text.length === 0) {\n    return (\n      node.text.slice(diff.start, diff.start + diff.text.length) === diff.text\n    )\n  }\n\n  const nextPath = Path.next(path)\n  if (!Editor.hasPath(editor, nextPath)) {\n    return false\n  }\n\n  const nextNode = Node.get(editor, nextPath)\n  return Text.isText(nextNode) && nextNode.text.startsWith(diff.text)\n}\n\nexport function applyStringDiff(text: string, ...diffs: StringDiff[]) {\n  return diffs.reduce(\n    (text, diff) =>\n      text.slice(0, diff.start) + diff.text + text.slice(diff.end),\n    text\n  )\n}\n\nfunction longestCommonPrefixLength(str: string, another: string) {\n  const length = Math.min(str.length, another.length)\n\n  for (let i = 0; i < length; i++) {\n    if (str.charAt(i) !== another.charAt(i)) {\n      return i\n    }\n  }\n\n  return length\n}\n\nfunction longestCommonSuffixLength(\n  str: string,\n  another: string,\n  max: number\n): number {\n  const length = Math.min(str.length, another.length, max)\n\n  for (let i = 0; i < length; i++) {\n    if (\n      str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)\n    ) {\n      return i\n    }\n  }\n\n  return length\n}\n\n/**\n * Remove redundant changes from the diff so that it spans the minimal possible range\n */\nexport function normalizeStringDiff(targetText: string, diff: StringDiff) {\n  const { start, end, text } = diff\n  const removedText = targetText.slice(start, end)\n\n  const prefixLength = longestCommonPrefixLength(removedText, text)\n  const max = Math.min(\n    removedText.length - prefixLength,\n    text.length - prefixLength\n  )\n  const suffixLength = longestCommonSuffixLength(removedText, text, max)\n\n  const normalized: StringDiff = {\n    start: start + prefixLength,\n    end: end - suffixLength,\n    text: text.slice(prefixLength, text.length - suffixLength),\n  }\n\n  if (normalized.start === normalized.end && normalized.text.length === 0) {\n    return null\n  }\n\n  return normalized\n}\n\n/**\n * Return a string diff that is equivalent to applying b after a spanning the range of\n * both changes\n */\nexport function mergeStringDiffs(\n  targetText: string,\n  a: StringDiff,\n  b: StringDiff\n): StringDiff | null {\n  const start = Math.min(a.start, b.start)\n  const overlap = Math.max(\n    0,\n    Math.min(a.start + a.text.length, b.end) - b.start\n  )\n\n  const applied = applyStringDiff(targetText, a, b)\n  const sliceEnd = Math.max(\n    b.start + b.text.length,\n    a.start +\n      a.text.length +\n      (a.start + a.text.length > b.start ? b.text.length : 0) -\n      overlap\n  )\n\n  const text = applied.slice(start, sliceEnd)\n  const end = Math.max(a.end, b.end - a.text.length + (a.end - a.start))\n  return normalizeStringDiff(targetText, { start, end, text })\n}\n\n/**\n * Get the slate range the text diff spans.\n */\nexport function targetRange(textDiff: TextDiff): Range {\n  const { path, diff } = textDiff\n  return {\n    anchor: { path, offset: diff.start },\n    focus: { path, offset: diff.end },\n  }\n}\n\n/**\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\n * the pending diffs. Since the pending diffs might have been inserted with different\n * marks we have to 'walk' the offset from the starting position to ensure we still\n * have a valid point inside the document\n */\nexport function normalizePoint(editor: Editor, point: Point): Point | null {\n  let { path, offset } = point\n  if (!Editor.hasPath(editor, path)) {\n    return null\n  }\n\n  let leaf = Node.get(editor, path)\n  if (!Text.isText(leaf)) {\n    return null\n  }\n\n  const parentBlock = Editor.above(editor, {\n    match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n    at: path,\n  })\n\n  if (!parentBlock) {\n    return null\n  }\n\n  while (offset > leaf.text.length) {\n    const entry = Editor.next(editor, { at: path, match: Text.isText })\n    if (!entry || !Path.isDescendant(entry[1], parentBlock[1])) {\n      return null\n    }\n\n    offset -= leaf.text.length\n    leaf = entry[0]\n    path = entry[1]\n  }\n\n  return { path, offset }\n}\n\n/**\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\n */\nexport function normalizeRange(editor: Editor, range: Range): Range | null {\n  const anchor = normalizePoint(editor, range.anchor)\n  if (!anchor) {\n    return null\n  }\n\n  if (Range.isCollapsed(range)) {\n    return { anchor, focus: anchor }\n  }\n\n  const focus = normalizePoint(editor, range.focus)\n  if (!focus) {\n    return null\n  }\n\n  return { anchor, focus }\n}\n\nexport function transformPendingPoint(\n  editor: Editor,\n  point: Point,\n  op: Operation\n): Point | null {\n  const pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor)\n  const textDiff = pendingDiffs?.find(({ path }) =>\n    Path.equals(path, point.path)\n  )\n\n  if (!textDiff || point.offset <= textDiff.diff.start) {\n    return Point.transform(point, op, { affinity: 'backward' })\n  }\n\n  const { diff } = textDiff\n  // Point references location inside the diff => transform the point based on the location\n  // the diff will be applied to and add the offset inside the diff.\n  if (point.offset <= diff.start + diff.text.length) {\n    const anchor = { path: point.path, offset: diff.start }\n    const transformed = Point.transform(anchor, op, {\n      affinity: 'backward',\n    })\n\n    if (!transformed) {\n      return null\n    }\n\n    return {\n      path: transformed.path,\n      offset: transformed.offset + point.offset - diff.start,\n    }\n  }\n\n  // Point references location after the diff\n  const anchor = {\n    path: point.path,\n    offset: point.offset - diff.text.length + diff.end - diff.start,\n  }\n  const transformed = Point.transform(anchor, op, {\n    affinity: 'backward',\n  })\n  if (!transformed) {\n    return null\n  }\n\n  if (\n    op.type === 'split_node' &&\n    Path.equals(op.path, point.path) &&\n    anchor.offset < op.position &&\n    diff.start < op.position\n  ) {\n    return transformed\n  }\n\n  return {\n    path: transformed.path,\n    offset: transformed.offset + diff.text.length - diff.end + diff.start,\n  }\n}\n\nexport function transformPendingRange(\n  editor: Editor,\n  range: Range,\n  op: Operation\n): Range | null {\n  const anchor = transformPendingPoint(editor, range.anchor, op)\n  if (!anchor) {\n    return null\n  }\n\n  if (Range.isCollapsed(range)) {\n    return { anchor, focus: anchor }\n  }\n\n  const focus = transformPendingPoint(editor, range.focus, op)\n  if (!focus) {\n    return null\n  }\n\n  return { anchor, focus }\n}\n\nexport function transformTextDiff(\n  textDiff: TextDiff,\n  op: Operation\n): TextDiff | null {\n  const { path, diff, id } = textDiff\n\n  switch (op.type) {\n    case 'insert_text': {\n      if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n        return textDiff\n      }\n\n      if (op.offset <= diff.start) {\n        return {\n          diff: {\n            start: op.text.length + diff.start,\n            end: op.text.length + diff.end,\n            text: diff.text,\n          },\n          id,\n          path,\n        }\n      }\n\n      return {\n        diff: {\n          start: diff.start,\n          end: diff.end + op.text.length,\n          text: diff.text,\n        },\n        id,\n        path,\n      }\n    }\n    case 'remove_text': {\n      if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n        return textDiff\n      }\n\n      if (op.offset + op.text.length <= diff.start) {\n        return {\n          diff: {\n            start: diff.start - op.text.length,\n            end: diff.end - op.text.length,\n            text: diff.text,\n          },\n          id,\n          path,\n        }\n      }\n\n      return {\n        diff: {\n          start: diff.start,\n          end: diff.end - op.text.length,\n          text: diff.text,\n        },\n        id,\n        path,\n      }\n    }\n    case 'split_node': {\n      if (!Path.equals(op.path, path) || op.position >= diff.end) {\n        return {\n          diff,\n          id,\n          path: Path.transform(path, op, { affinity: 'backward' })!,\n        }\n      }\n\n      if (op.position > diff.start) {\n        return {\n          diff: {\n            start: diff.start,\n            end: Math.min(op.position, diff.end),\n            text: diff.text,\n          },\n          id,\n          path,\n        }\n      }\n\n      return {\n        diff: {\n          start: diff.start - op.position,\n          end: diff.end - op.position,\n          text: diff.text,\n        },\n        id,\n        path: Path.transform(path, op, { affinity: 'forward' })!,\n      }\n    }\n    case 'merge_node': {\n      if (!Path.equals(op.path, path)) {\n        return {\n          diff,\n          id,\n          path: Path.transform(path, op)!,\n        }\n      }\n\n      return {\n        diff: {\n          start: diff.start + op.position,\n          end: diff.end + op.position,\n          text: diff.text,\n        },\n        id,\n        path: Path.transform(path, op)!,\n      }\n    }\n  }\n\n  const newPath = Path.transform(path, op)\n  if (!newPath) {\n    return null\n  }\n\n  return {\n    diff,\n    path: newPath,\n    id,\n  }\n}\n","import { DebouncedFunc } from 'lodash'\nimport {\n  Editor,\n  Node,\n  Path,\n  Point,\n  Range,\n  Text,\n  Transforms,\n} from '@seafile/slate'\nimport { ReactEditor } from '../../plugin/react-editor'\nimport {\n  applyStringDiff,\n  mergeStringDiffs,\n  normalizePoint,\n  normalizeRange,\n  normalizeStringDiff,\n  StringDiff,\n  targetRange,\n  TextDiff,\n  verifyDiffState,\n} from '../../utils/diff-text'\nimport { isDOMSelection, isTrackedMutation } from '../../utils/dom'\nimport {\n  EDITOR_TO_FORCE_RENDER,\n  EDITOR_TO_PENDING_ACTION,\n  EDITOR_TO_PENDING_DIFFS,\n  EDITOR_TO_PENDING_INSERTION_MARKS,\n  EDITOR_TO_PENDING_SELECTION,\n  EDITOR_TO_PLACEHOLDER_ELEMENT,\n  EDITOR_TO_USER_MARKS,\n  IS_COMPOSING,\n} from '../../utils/weak-maps'\n\nexport type Action = { at?: Point | Range; run: () => void }\n\n// https://github.com/facebook/draft-js/blob/main/src/component/handlers/composition/DraftEditorCompositionHandler.js#L41\n// When using keyboard English association function, conpositionEnd triggered too fast, resulting in after `insertText` still maintain association state.\nconst RESOLVE_DELAY = 25\n\n// Time with no user interaction before the current user action is considered as done.\nconst FLUSH_DELAY = 200\n\n// Replace with `const debug = console.log` to debug\nconst debug = (..._: unknown[]) => {}\n\n// Type guard to check if a value is a DataTransfer\nconst isDataTransfer = (value: any): value is DataTransfer =>\n  value?.constructor.name === 'DataTransfer'\n\nexport type CreateAndroidInputManagerOptions = {\n  editor: ReactEditor\n\n  scheduleOnDOMSelectionChange: DebouncedFunc<() => void>\n  onDOMSelectionChange: DebouncedFunc<() => void>\n}\n\nexport type AndroidInputManager = {\n  flush: () => void\n  scheduleFlush: () => void\n\n  hasPendingDiffs: () => boolean\n  hasPendingAction: () => boolean\n  hasPendingChanges: () => boolean\n  isFlushing: () => boolean | 'action'\n\n  handleUserSelect: (range: Range | null) => void\n  handleCompositionEnd: (event: React.CompositionEvent<HTMLDivElement>) => void\n  handleCompositionStart: (\n    event: React.CompositionEvent<HTMLDivElement>\n  ) => void\n  handleDOMBeforeInput: (event: InputEvent) => void\n  handleKeyDown: (event: React.KeyboardEvent<HTMLDivElement>) => void\n\n  handleDomMutations: (mutations: MutationRecord[]) => void\n  handleInput: () => void\n}\n\nexport function createAndroidInputManager({\n  editor,\n  scheduleOnDOMSelectionChange,\n  onDOMSelectionChange,\n}: CreateAndroidInputManagerOptions): AndroidInputManager {\n  let flushing: 'action' | boolean = false\n  let compositionEndTimeoutId: ReturnType<typeof setTimeout> | null = null\n  let flushTimeoutId: ReturnType<typeof setTimeout> | null = null\n  let actionTimeoutId: ReturnType<typeof setTimeout> | null = null\n\n  let idCounter = 0\n  let insertPositionHint: StringDiff | null | false = false\n\n  const applyPendingSelection = () => {\n    const pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor)\n    EDITOR_TO_PENDING_SELECTION.delete(editor)\n\n    if (pendingSelection) {\n      const { selection } = editor\n      const normalized = normalizeRange(editor, pendingSelection)\n\n      debug('apply pending selection', pendingSelection, normalized)\n\n      if (normalized && (!selection || !Range.equals(normalized, selection))) {\n        Transforms.select(editor, normalized)\n      }\n    }\n  }\n\n  const performAction = () => {\n    const action = EDITOR_TO_PENDING_ACTION.get(editor)\n    EDITOR_TO_PENDING_ACTION.delete(editor)\n    if (!action) {\n      return\n    }\n\n    if (action.at) {\n      const target = Point.isPoint(action.at)\n        ? normalizePoint(editor, action.at)\n        : normalizeRange(editor, action.at)\n\n      if (!target) {\n        return\n      }\n\n      const targetRange = Editor.range(editor, target)\n      if (!editor.selection || !Range.equals(editor.selection, targetRange)) {\n        Transforms.select(editor, target)\n      }\n    }\n\n    action.run()\n  }\n\n  const flush = () => {\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId)\n      flushTimeoutId = null\n    }\n\n    if (actionTimeoutId) {\n      clearTimeout(actionTimeoutId)\n      actionTimeoutId = null\n    }\n\n    if (!hasPendingDiffs() && !hasPendingAction()) {\n      applyPendingSelection()\n      return\n    }\n\n    if (!flushing) {\n      flushing = true\n      setTimeout(() => (flushing = false))\n    }\n\n    if (hasPendingAction()) {\n      flushing = 'action'\n    }\n\n    const selectionRef =\n      editor.selection &&\n      Editor.rangeRef(editor, editor.selection, { affinity: 'forward' })\n    EDITOR_TO_USER_MARKS.set(editor, editor.marks)\n\n    debug(\n      'flush',\n      EDITOR_TO_PENDING_ACTION.get(editor),\n      EDITOR_TO_PENDING_DIFFS.get(editor)\n    )\n\n    let scheduleSelectionChange = hasPendingDiffs()\n\n    let diff: TextDiff | undefined\n    while ((diff = EDITOR_TO_PENDING_DIFFS.get(editor)?.[0])) {\n      const pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)\n\n      if (pendingMarks !== undefined) {\n        EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor)\n        editor.marks = pendingMarks\n      }\n\n      if (pendingMarks && insertPositionHint === false) {\n        insertPositionHint = null\n        debug('insert after mark placeholder')\n      }\n\n      const range = targetRange(diff)\n      if (!editor.selection || !Range.equals(editor.selection, range)) {\n        Transforms.select(editor, range)\n      }\n\n      if (diff.diff.text) {\n        Editor.insertText(editor, diff.diff.text)\n      } else {\n        Editor.deleteFragment(editor)\n      }\n\n      // Remove diff only after we have applied it to account for it when transforming\n      // pending ranges.\n      EDITOR_TO_PENDING_DIFFS.set(\n        editor,\n        EDITOR_TO_PENDING_DIFFS.get(editor)?.filter(\n          ({ id }) => id !== diff!.id\n        )!\n      )\n\n      if (!verifyDiffState(editor, diff)) {\n        debug('invalid diff state')\n        scheduleSelectionChange = false\n        EDITOR_TO_PENDING_ACTION.delete(editor)\n        EDITOR_TO_USER_MARKS.delete(editor)\n        flushing = 'action'\n\n        // Ensure we don't restore the pending user (dom) selection\n        // since the document and dom state do not match.\n        EDITOR_TO_PENDING_SELECTION.delete(editor)\n        scheduleOnDOMSelectionChange.cancel()\n        onDOMSelectionChange.cancel()\n        selectionRef?.unref()\n      }\n    }\n\n    const selection = selectionRef?.unref()\n    if (\n      selection &&\n      !EDITOR_TO_PENDING_SELECTION.get(editor) &&\n      (!editor.selection || !Range.equals(selection, editor.selection))\n    ) {\n      Transforms.select(editor, selection)\n    }\n\n    if (hasPendingAction()) {\n      performAction()\n      return\n    }\n\n    // COMPAT: The selectionChange event is fired after the action is performed,\n    // so we have to manually schedule it to ensure we don't 'throw away' the selection\n    // while rendering if we have pending changes.\n    if (scheduleSelectionChange) {\n      debug('scheduleOnDOMSelectionChange pending changes')\n      scheduleOnDOMSelectionChange()\n    }\n\n    scheduleOnDOMSelectionChange.flush()\n    onDOMSelectionChange.flush()\n\n    applyPendingSelection()\n\n    const userMarks = EDITOR_TO_USER_MARKS.get(editor)\n    EDITOR_TO_USER_MARKS.delete(editor)\n    if (userMarks !== undefined) {\n      editor.marks = userMarks\n      editor.onChange()\n    }\n  }\n\n  const handleCompositionEnd = (\n    _event: React.CompositionEvent<HTMLDivElement>\n  ) => {\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId)\n    }\n\n    compositionEndTimeoutId = setTimeout(() => {\n      IS_COMPOSING.set(editor, false)\n      flush()\n    }, RESOLVE_DELAY)\n  }\n\n  const handleCompositionStart = (\n    _event: React.CompositionEvent<HTMLDivElement>\n  ) => {\n    debug('composition start')\n\n    IS_COMPOSING.set(editor, true)\n\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId)\n      compositionEndTimeoutId = null\n    }\n  }\n\n  const updatePlaceholderVisibility = (forceHide = false) => {\n    const placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor)\n    if (!placeholderElement) {\n      return\n    }\n\n    if (hasPendingDiffs() || forceHide) {\n      placeholderElement.style.display = 'none'\n      return\n    }\n\n    placeholderElement.style.removeProperty('display')\n  }\n\n  const storeDiff = (path: Path, diff: StringDiff) => {\n    debug('storeDiff', path, diff)\n\n    const pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor) ?? []\n    EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs)\n\n    const target = Node.leaf(editor, path)\n    const idx = pendingDiffs.findIndex(change => Path.equals(change.path, path))\n    if (idx < 0) {\n      const normalized = normalizeStringDiff(target.text, diff)\n      if (normalized) {\n        pendingDiffs.push({ path, diff, id: idCounter++ })\n      }\n\n      updatePlaceholderVisibility()\n      return\n    }\n\n    const merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff)\n    if (!merged) {\n      pendingDiffs.splice(idx, 1)\n      updatePlaceholderVisibility()\n      return\n    }\n\n    pendingDiffs[idx] = {\n      ...pendingDiffs[idx],\n      diff: merged,\n    }\n  }\n\n  const scheduleAction = (\n    run: () => void,\n    { at }: { at?: Point | Range } = {}\n  ): void => {\n    insertPositionHint = false\n    debug('scheduleAction', { at, run })\n\n    EDITOR_TO_PENDING_SELECTION.delete(editor)\n    scheduleOnDOMSelectionChange.cancel()\n    onDOMSelectionChange.cancel()\n\n    if (hasPendingAction()) {\n      flush()\n    }\n\n    EDITOR_TO_PENDING_ACTION.set(editor, { at, run })\n\n    // COMPAT: When deleting before a non-contenteditable element chrome only fires a beforeinput,\n    // (no input) and doesn't perform any dom mutations. Without a flush timeout we would never flush\n    // in this case and thus never actually perform the action.\n    actionTimeoutId = setTimeout(flush)\n  }\n\n  const handleDOMBeforeInput = (event: InputEvent): void => {\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId)\n      flushTimeoutId = null\n    }\n\n    const { inputType: type } = event\n    let targetRange: Range | null = null\n    const data: DataTransfer | string | undefined =\n      (event as any).dataTransfer || event.data || undefined\n\n    if (\n      insertPositionHint !== false &&\n      type !== 'insertText' &&\n      type !== 'insertCompositionText'\n    ) {\n      insertPositionHint = false\n    }\n\n    let [nativeTargetRange] = (event as any).getTargetRanges()\n    if (nativeTargetRange) {\n      targetRange = ReactEditor.toSlateRange(editor, nativeTargetRange, {\n        exactMatch: false,\n        suppressThrow: true,\n      })\n    }\n\n    // COMPAT: SelectionChange event is fired after the action is performed, so we\n    // have to manually get the selection here to ensure it's up-to-date.\n    const window = ReactEditor.getWindow(editor)\n    const domSelection = window.getSelection()\n    if (!targetRange && domSelection) {\n      nativeTargetRange = domSelection\n      targetRange = ReactEditor.toSlateRange(editor, domSelection, {\n        exactMatch: false,\n        suppressThrow: true,\n      })\n    }\n\n    targetRange = targetRange ?? editor.selection\n    if (!targetRange) {\n      return\n    }\n\n    // By default, the input manager tries to store text diffs so that we can\n    // defer flushing them at a later point in time. We don't want to flush\n    // for every input event as this can be expensive. However, there are some\n    // scenarios where we cannot safely store the text diff and must instead\n    // schedule an action to let Slate normalize the editor state.\n    let canStoreDiff = true\n\n    if (type.startsWith('delete')) {\n      if (Range.isExpanded(targetRange)) {\n        const [start, end] = Range.edges(targetRange)\n        const leaf = Node.leaf(editor, start.path)\n\n        if (leaf.text.length === start.offset && end.offset === 0) {\n          const next = Editor.next(editor, {\n            at: start.path,\n            match: Text.isText,\n          })\n          if (next && Path.equals(next[1], end.path)) {\n            targetRange = { anchor: end, focus: end }\n          }\n        }\n      }\n\n      const direction = type.endsWith('Backward') ? 'backward' : 'forward'\n      const [start, end] = Range.edges(targetRange)\n      const [leaf, path] = Editor.leaf(editor, start.path)\n\n      const diff = {\n        text: '',\n        start: start.offset,\n        end: end.offset,\n      }\n      const pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor)\n      const relevantPendingDiffs = pendingDiffs?.find(change =>\n        Path.equals(change.path, path)\n      )\n      const diffs = relevantPendingDiffs\n        ? [relevantPendingDiffs.diff, diff]\n        : [diff]\n      const text = applyStringDiff(leaf.text, ...diffs)\n\n      if (text.length === 0) {\n        // Text leaf will be removed, so we need to schedule an\n        // action to remove it so that Slate can normalize instead\n        // of storing as a diff\n        canStoreDiff = false\n      }\n\n      if (Range.isExpanded(targetRange)) {\n        if (\n          canStoreDiff &&\n          Path.equals(targetRange.anchor.path, targetRange.focus.path)\n        ) {\n          const point = { path: targetRange.anchor.path, offset: start.offset }\n          const range = Editor.range(editor, point, point)\n          handleUserSelect(range)\n\n          return storeDiff(targetRange.anchor.path, {\n            text: '',\n            end: end.offset,\n            start: start.offset,\n          })\n        }\n\n        return scheduleAction(\n          () => Editor.deleteFragment(editor, { direction }),\n          { at: targetRange }\n        )\n      }\n    }\n\n    switch (type) {\n      case 'deleteByComposition':\n      case 'deleteByCut':\n      case 'deleteByDrag': {\n        return scheduleAction(() => Editor.deleteFragment(editor), {\n          at: targetRange,\n        })\n      }\n\n      case 'deleteContent':\n      case 'deleteContentForward': {\n        const { anchor } = targetRange\n        if (canStoreDiff && Range.isCollapsed(targetRange)) {\n          const targetNode = Node.leaf(editor, anchor.path)\n\n          if (anchor.offset < targetNode.text.length) {\n            return storeDiff(anchor.path, {\n              text: '',\n              start: anchor.offset,\n              end: anchor.offset + 1,\n            })\n          }\n        }\n\n        return scheduleAction(() => Editor.deleteForward(editor), {\n          at: targetRange,\n        })\n      }\n\n      case 'deleteContentBackward': {\n        const { anchor } = targetRange\n\n        // If we have a mismatch between the native and slate selection being collapsed\n        // we are most likely deleting a zero-width placeholder and thus should perform it\n        // as an action to ensure correct behavior (mostly happens with mark placeholders)\n        const nativeCollapsed = isDOMSelection(nativeTargetRange)\n          ? nativeTargetRange.isCollapsed\n          : !!nativeTargetRange?.collapsed\n\n        if (\n          canStoreDiff &&\n          nativeCollapsed &&\n          Range.isCollapsed(targetRange) &&\n          anchor.offset > 0\n        ) {\n          return storeDiff(anchor.path, {\n            text: '',\n            start: anchor.offset - 1,\n            end: anchor.offset,\n          })\n        }\n\n        return scheduleAction(() => Editor.deleteBackward(editor), {\n          at: targetRange,\n        })\n      }\n\n      case 'deleteEntireSoftLine': {\n        return scheduleAction(\n          () => {\n            Editor.deleteBackward(editor, { unit: 'line' })\n            Editor.deleteForward(editor, { unit: 'line' })\n          },\n          { at: targetRange }\n        )\n      }\n\n      case 'deleteHardLineBackward': {\n        return scheduleAction(\n          () => Editor.deleteBackward(editor, { unit: 'block' }),\n          { at: targetRange }\n        )\n      }\n\n      case 'deleteSoftLineBackward': {\n        return scheduleAction(\n          () => Editor.deleteBackward(editor, { unit: 'line' }),\n          { at: targetRange }\n        )\n      }\n\n      case 'deleteHardLineForward': {\n        return scheduleAction(\n          () => Editor.deleteForward(editor, { unit: 'block' }),\n          { at: targetRange }\n        )\n      }\n\n      case 'deleteSoftLineForward': {\n        return scheduleAction(\n          () => Editor.deleteForward(editor, { unit: 'line' }),\n          { at: targetRange }\n        )\n      }\n\n      case 'deleteWordBackward': {\n        return scheduleAction(\n          () => Editor.deleteBackward(editor, { unit: 'word' }),\n          { at: targetRange }\n        )\n      }\n\n      case 'deleteWordForward': {\n        return scheduleAction(\n          () => Editor.deleteForward(editor, { unit: 'word' }),\n          { at: targetRange }\n        )\n      }\n\n      case 'insertLineBreak': {\n        return scheduleAction(() => Editor.insertSoftBreak(editor), {\n          at: targetRange,\n        })\n      }\n\n      case 'insertParagraph': {\n        return scheduleAction(() => Editor.insertBreak(editor), {\n          at: targetRange,\n        })\n      }\n      case 'insertCompositionText':\n      case 'deleteCompositionText':\n      case 'insertFromComposition':\n      case 'insertFromDrop':\n      case 'insertFromPaste':\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText': {\n        if (isDataTransfer(data)) {\n          return scheduleAction(() => ReactEditor.insertData(editor, data), {\n            at: targetRange,\n          })\n        }\n\n        let text = data ?? ''\n\n        // COMPAT: If we are writing inside a placeholder, the ime inserts the text inside\n        // the placeholder itself and thus includes the zero-width space inside edit events.\n        if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {\n          text = text.replace('\\uFEFF', '')\n        }\n\n        // Pastes from the Android clipboard will generate `insertText` events.\n        // If the copied text contains any newlines, Android will append an\n        // extra newline to the end of the copied text.\n        if (type === 'insertText' && /.*\\n.*\\n$/.test(text)) {\n          text = text.slice(0, -1)\n        }\n\n        // If the text includes a newline, split it at newlines and paste each component\n        // string, with soft breaks in between each.\n        if (text.includes('\\n')) {\n          return scheduleAction(\n            () => {\n              const parts = text.split('\\n')\n              parts.forEach((line, i) => {\n                if (line) {\n                  Editor.insertText(editor, line)\n                }\n                if (i !== parts.length - 1) {\n                  Editor.insertSoftBreak(editor)\n                }\n              })\n            },\n            {\n              at: targetRange,\n            }\n          )\n        }\n\n        if (Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n          const [start, end] = Range.edges(targetRange)\n\n          const diff = {\n            start: start.offset,\n            end: end.offset,\n            text,\n          }\n\n          // COMPAT: Swiftkey has a weird bug where the target range of the 2nd word\n          // inserted after a mark placeholder is inserted with an anchor offset off by 1.\n          // So writing 'some text' will result in 'some ttext'. Luckily all 'normal' insert\n          // text events are fired with the correct target ranges, only the final 'insertComposition'\n          // isn't, so we can adjust the target range start offset if we are confident this is the\n          // swiftkey insert causing the issue.\n          if (text && insertPositionHint && type === 'insertCompositionText') {\n            const hintPosition =\n              insertPositionHint.start + insertPositionHint.text.search(/\\S|$/)\n            const diffPosition = diff.start + diff.text.search(/\\S|$/)\n\n            if (\n              diffPosition === hintPosition + 1 &&\n              diff.end ===\n                insertPositionHint.start + insertPositionHint.text.length\n            ) {\n              debug('adjusting swiftKey insert position using hint')\n              diff.start -= 1\n              insertPositionHint = null\n              scheduleFlush()\n            } else {\n              insertPositionHint = false\n            }\n          } else if (type === 'insertText') {\n            if (insertPositionHint === null) {\n              insertPositionHint = diff\n            } else if (\n              insertPositionHint &&\n              Range.isCollapsed(targetRange) &&\n              insertPositionHint.end + insertPositionHint.text.length ===\n                start.offset\n            ) {\n              insertPositionHint = {\n                ...insertPositionHint,\n                text: insertPositionHint.text + text,\n              }\n            } else {\n              insertPositionHint = false\n            }\n          } else {\n            insertPositionHint = false\n          }\n\n          if (canStoreDiff) {\n            storeDiff(start.path, diff)\n            return\n          }\n        }\n\n        return scheduleAction(() => Editor.insertText(editor, text), {\n          at: targetRange,\n        })\n      }\n    }\n  }\n\n  const hasPendingAction = () => {\n    return !!EDITOR_TO_PENDING_ACTION.get(editor)\n  }\n\n  const hasPendingDiffs = () => {\n    return !!EDITOR_TO_PENDING_DIFFS.get(editor)?.length\n  }\n\n  const hasPendingChanges = () => {\n    return hasPendingAction() || hasPendingDiffs()\n  }\n\n  const isFlushing = () => {\n    return flushing\n  }\n\n  const handleUserSelect = (range: Range | null) => {\n    EDITOR_TO_PENDING_SELECTION.set(editor, range)\n\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId)\n      flushTimeoutId = null\n    }\n\n    const { selection } = editor\n    if (!range) {\n      return\n    }\n\n    const pathChanged =\n      !selection || !Path.equals(selection.anchor.path, range.anchor.path)\n    const parentPathChanged =\n      !selection ||\n      !Path.equals(\n        selection.anchor.path.slice(0, -1),\n        range.anchor.path.slice(0, -1)\n      )\n\n    if ((pathChanged && insertPositionHint) || parentPathChanged) {\n      insertPositionHint = false\n    }\n\n    if (pathChanged || hasPendingDiffs()) {\n      flushTimeoutId = setTimeout(flush, FLUSH_DELAY)\n    }\n  }\n\n  const handleInput = () => {\n    if (hasPendingAction() || !hasPendingDiffs()) {\n      debug('flush input')\n      flush()\n    }\n  }\n\n  const handleKeyDown = (_: React.KeyboardEvent) => {\n    // COMPAT: Swiftkey closes the keyboard when typing inside a empty node\n    // directly next to a non-contenteditable element (= the placeholder).\n    // The only event fired soon enough for us to allow hiding the placeholder\n    // without swiftkey picking it up is the keydown event, so we have to hide it\n    // here. See https://github.com/ianstormtaylor/slate/pull/4988#issuecomment-1201050535\n    if (!hasPendingDiffs()) {\n      updatePlaceholderVisibility(true)\n      setTimeout(updatePlaceholderVisibility)\n    }\n  }\n\n  const scheduleFlush = () => {\n    if (!hasPendingAction()) {\n      actionTimeoutId = setTimeout(flush)\n    }\n  }\n\n  const handleDomMutations = (mutations: MutationRecord[]) => {\n    if (hasPendingDiffs() || hasPendingAction()) {\n      return\n    }\n\n    if (\n      mutations.some(mutation => isTrackedMutation(editor, mutation, mutations))\n    ) {\n      // Cause a re-render to restore the dom state if we encounter tracked mutations without\n      // a corresponding pending action.\n      EDITOR_TO_FORCE_RENDER.get(editor)?.()\n    }\n  }\n\n  return {\n    flush,\n    scheduleFlush,\n\n    hasPendingDiffs,\n    hasPendingAction,\n    hasPendingChanges,\n\n    isFlushing,\n\n    handleUserSelect,\n    handleCompositionEnd,\n    handleCompositionStart,\n    handleDOMBeforeInput,\n    handleKeyDown,\n\n    handleDomMutations,\n    handleInput,\n  }\n}\n","import { useEffect, useRef } from 'react'\n\nexport function useIsMounted() {\n  const isMountedRef = useRef(false)\n\n  useEffect(() => {\n    isMountedRef.current = true\n    return () => {\n      isMountedRef.current = false\n    }\n  }, [])\n\n  return isMountedRef.current\n}\n","import { RefObject, useEffect, useState } from 'react'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\nimport { isDOMElement } from '../utils/dom'\nimport { ReactEditor } from '../plugin/react-editor'\n\nexport function useMutationObserver(\n  node: RefObject<HTMLElement>,\n  callback: MutationCallback,\n  options: MutationObserverInit\n) {\n  const [mutationObserver] = useState(() => new MutationObserver(callback))\n\n  useIsomorphicLayoutEffect(() => {\n    // Discard mutations caused during render phase. This works due to react calling\n    // useLayoutEffect synchronously after the render phase before the next tick.\n    mutationObserver.takeRecords()\n  })\n\n  useEffect(() => {\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined')\n    }\n\n    mutationObserver.observe(node.current, options)\n    return () => mutationObserver.disconnect()\n  }, [mutationObserver, node, options])\n}\n","import { RefObject, useState } from 'react'\nimport { useSlateStatic } from '../use-slate-static'\nimport { IS_ANDROID } from '../../utils/environment'\nimport { EDITOR_TO_SCHEDULE_FLUSH } from '../../utils/weak-maps'\nimport {\n  createAndroidInputManager,\n  CreateAndroidInputManagerOptions,\n} from './android-input-manager'\nimport { useIsMounted } from '../use-is-mounted'\nimport { useMutationObserver } from '../use-mutation-observer'\n\ntype UseAndroidInputManagerOptions = {\n  node: RefObject<HTMLElement>\n} & Omit<\n  CreateAndroidInputManagerOptions,\n  'editor' | 'onUserInput' | 'receivedUserInput'\n>\n\nconst MUTATION_OBSERVER_CONFIG: MutationObserverInit = {\n  subtree: true,\n  childList: true,\n  characterData: true,\n}\n\nexport const useAndroidInputManager = !IS_ANDROID\n  ? () => null\n  : ({ node, ...options }: UseAndroidInputManagerOptions) => {\n      if (!IS_ANDROID) {\n        return null\n      }\n\n      const editor = useSlateStatic()\n      const isMounted = useIsMounted()\n\n      const [inputManager] = useState(() =>\n        createAndroidInputManager({\n          editor,\n          ...options,\n        })\n      )\n\n      useMutationObserver(\n        node,\n        inputManager.handleDomMutations,\n        MUTATION_OBSERVER_CONFIG\n      )\n\n      EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush)\n      if (isMounted) {\n        inputManager.flush()\n      }\n\n      return inputManager\n    }\n","import { useCallback, useRef, useEffect } from 'react'\nimport { ReactEditor } from '../plugin/react-editor'\nimport { useSlateStatic } from './use-slate-static'\n\nexport function useTrackUserInput() {\n  const editor = useSlateStatic()\n\n  const receivedUserInput = useRef<boolean>(false)\n  const animationFrameIdRef = useRef<number>(0)\n\n  const onUserInput = useCallback(() => {\n    if (receivedUserInput.current) {\n      return\n    }\n\n    receivedUserInput.current = true\n\n    const window = ReactEditor.getWindow(editor)\n    window.cancelAnimationFrame(animationFrameIdRef.current)\n\n    animationFrameIdRef.current = window.requestAnimationFrame(() => {\n      receivedUserInput.current = false\n    })\n  }, [editor])\n\n  useEffect(() => () => cancelAnimationFrame(animationFrameIdRef.current), [])\n\n  return {\n    receivedUserInput,\n    onUserInput,\n  }\n}\n","import { Range } from '@seafile/slate'\nimport { PLACEHOLDER_SYMBOL } from './weak-maps'\n\nexport const shallowCompare = (obj1: {}, obj2: {}) =>\n  Object.keys(obj1).length === Object.keys(obj2).length &&\n  Object.keys(obj1).every(\n    key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]\n  )\n\nconst isDecorationFlagsEqual = (range: Range, other: Range) => {\n  const { anchor: rangeAnchor, focus: rangeFocus, ...rangeOwnProps } = range\n  const { anchor: otherAnchor, focus: otherFocus, ...otherOwnProps } = other\n\n  return (\n    range[PLACEHOLDER_SYMBOL] === other[PLACEHOLDER_SYMBOL] &&\n    shallowCompare(rangeOwnProps, otherOwnProps)\n  )\n}\n\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\n\nexport const isElementDecorationsEqual = (\n  list: Range[],\n  another: Range[]\n): boolean => {\n  if (list.length !== another.length) {\n    return false\n  }\n\n  for (let i = 0; i < list.length; i++) {\n    const range = list[i]\n    const other = another[i]\n\n    if (!Range.equals(range, other) || !isDecorationFlagsEqual(range, other)) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\n\nexport const isTextDecorationsEqual = (\n  list: Range[],\n  another: Range[]\n): boolean => {\n  if (list.length !== another.length) {\n    return false\n  }\n\n  for (let i = 0; i < list.length; i++) {\n    const range = list[i]\n    const other = another[i]\n\n    // compare only offsets because paths doesn't matter for text\n    if (\n      range.anchor.offset !== other.anchor.offset ||\n      range.focus.offset !== other.focus.offset ||\n      !isDecorationFlagsEqual(range, other)\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n","import React, { forwardRef, memo, useRef, useState } from 'react'\nimport { Editor, Text, Path, Element, Node } from '@seafile/slate'\n\nimport { ReactEditor, useSlateStatic } from '..'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { IS_ANDROID } from '../utils/environment'\nimport { MARK_PLACEHOLDER_SYMBOL } from '../utils/weak-maps'\n\n/**\n * Leaf content strings.\n */\n\nconst String = (props: {\n  isLast: boolean\n  leaf: Text\n  parent: Element\n  text: Text\n}) => {\n  const { isLast, leaf, parent, text } = props\n  const editor = useSlateStatic()\n  const path = ReactEditor.findPath(editor, text)\n  const parentPath = Path.parent(path)\n  const isMarkPlaceholder = leaf[MARK_PLACEHOLDER_SYMBOL] === true\n\n  // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n  if (editor.isVoid(parent)) {\n    return <ZeroWidthString length={Node.string(parent).length} />\n  }\n\n  // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n  if (\n    leaf.text === '' &&\n    parent.children[parent.children.length - 1] === text &&\n    !editor.isInline(parent) &&\n    Editor.string(editor, parentPath) === ''\n  ) {\n    return <ZeroWidthString isLineBreak isMarkPlaceholder={isMarkPlaceholder} />\n  }\n\n  // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n  if (leaf.text === '') {\n    return <ZeroWidthString isMarkPlaceholder={isMarkPlaceholder} />\n  }\n\n  // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return <TextString isTrailing text={leaf.text} />\n  }\n\n  return <TextString text={leaf.text} />\n}\n\n/**\n * Leaf strings with text in them.\n */\nconst TextString = (props: { text: string; isTrailing?: boolean }) => {\n  const { text, isTrailing = false } = props\n  const ref = useRef<HTMLSpanElement>(null)\n  const getTextContent = () => {\n    return `${text ?? ''}${isTrailing ? '\\n' : ''}`\n  }\n  const [initialText] = useState(getTextContent)\n\n  // This is the actual text rendering boundary where we interface with the DOM\n  // The text is not rendered as part of the virtual DOM, as since we handle basic character insertions natively,\n  // updating the DOM is not a one way dataflow anymore. What we need here is not reconciliation and diffing\n  // with previous version of the virtual DOM, but rather diffing with the actual DOM element, and replace the DOM <span> content\n  // exactly if and only if its current content does not match our current virtual DOM.\n  // Otherwise the DOM TextNode would always be replaced by React as the user types, which interferes with native text features,\n  // eg makes native spellcheck opt out from checking the text node.\n\n  // useLayoutEffect: updating our span before browser paint\n  useIsomorphicLayoutEffect(() => {\n    // null coalescing text to make sure we're not outputing \"null\" as a string in the extreme case it is nullish at runtime\n    const textWithTrailing = getTextContent()\n\n    if (ref.current && ref.current.textContent !== textWithTrailing) {\n      ref.current.textContent = textWithTrailing\n    }\n\n    // intentionally not specifying dependencies, so that this effect runs on every render\n    // as this effectively replaces \"specifying the text in the virtual DOM under the <span> below\" on each render\n  })\n\n  // We intentionally render a memoized <span> that only receives the initial text content when the component is mounted.\n  // We defer to the layout effect above to update the `textContent` of the span element when needed.\n  return <MemoizedText ref={ref}>{initialText}</MemoizedText>\n}\n\nconst MemoizedText = memo(\n  forwardRef<HTMLSpanElement, { children: string }>((props, ref) => {\n    return (\n      <span data-slate-string ref={ref}>\n        {props.children}\n      </span>\n    )\n  })\n)\n\n/**\n * Leaf strings without text, render as zero-width strings.\n */\n\nexport const ZeroWidthString = (props: {\n  length?: number\n  isLineBreak?: boolean\n  isMarkPlaceholder?: boolean\n}) => {\n  const { length = 0, isLineBreak = false, isMarkPlaceholder = false } = props\n\n  const attributes = {\n    'data-slate-zero-width': isLineBreak ? 'n' : 'z',\n    'data-slate-length': length,\n  }\n\n  if (isMarkPlaceholder) {\n    attributes['data-slate-mark-placeholder'] = true\n  }\n\n  return (\n    <span {...attributes}>\n      {!IS_ANDROID || !isLineBreak ? '\\uFEFF' : null}\n      {isLineBreak ? <br /> : null}\n    </span>\n  )\n}\n\nexport default String\n","import React, {\n  useRef,\n  useCallback,\n  MutableRefObject,\n  useState,\n  useEffect,\n} from 'react'\nimport { Element, Text } from '@seafile/slate'\nimport { ResizeObserver as ResizeObserverPolyfill } from '@juggle/resize-observer'\nimport String from './string'\nimport {\n  PLACEHOLDER_SYMBOL,\n  EDITOR_TO_PLACEHOLDER_ELEMENT,\n  EDITOR_TO_FORCE_RENDER,\n} from '../utils/weak-maps'\nimport { RenderLeafProps, RenderPlaceholderProps } from './editable'\nimport { useSlateStatic } from '../hooks/use-slate-static'\n\nfunction disconnectPlaceholderResizeObserver(\n  placeholderResizeObserver: MutableRefObject<ResizeObserver | null>,\n  releaseObserver: boolean\n) {\n  if (placeholderResizeObserver.current) {\n    placeholderResizeObserver.current.disconnect()\n    if (releaseObserver) {\n      placeholderResizeObserver.current = null\n    }\n  }\n}\n\ntype TimerId = ReturnType<typeof setTimeout> | null\n\nfunction clearTimeoutRef(timeoutRef: MutableRefObject<TimerId>) {\n  if (timeoutRef.current) {\n    clearTimeout(timeoutRef.current)\n    timeoutRef.current = null\n  }\n}\n\n/**\n * Individual leaves in a text node with unique formatting.\n */\nconst Leaf = (props: {\n  isLast: boolean\n  leaf: Text\n  parent: Element\n  renderPlaceholder: (props: RenderPlaceholderProps) => JSX.Element\n  renderLeaf?: (props: RenderLeafProps) => JSX.Element\n  text: Text\n}) => {\n  const {\n    leaf,\n    isLast,\n    text,\n    parent,\n    renderPlaceholder,\n    renderLeaf = (props: RenderLeafProps) => <DefaultLeaf {...props} />,\n  } = props\n\n  const editor = useSlateStatic()\n  const placeholderResizeObserver = useRef<ResizeObserver | null>(null)\n  const placeholderRef = useRef<HTMLElement | null>(null)\n  const [showPlaceholder, setShowPlaceholder] = useState(false)\n  const showPlaceholderTimeoutRef = useRef<TimerId>(null)\n\n  const callbackPlaceholderRef = useCallback(\n    (placeholderEl: HTMLElement | null) => {\n      disconnectPlaceholderResizeObserver(\n        placeholderResizeObserver,\n        placeholderEl == null\n      )\n\n      if (placeholderEl == null) {\n        EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor)\n        leaf.onPlaceholderResize?.(null)\n      } else {\n        EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl)\n\n        if (!placeholderResizeObserver.current) {\n          // Create a new observer and observe the placeholder element.\n          const ResizeObserver = window.ResizeObserver || ResizeObserverPolyfill\n          placeholderResizeObserver.current = new ResizeObserver(() => {\n            leaf.onPlaceholderResize?.(placeholderEl)\n          })\n        }\n        placeholderResizeObserver.current.observe(placeholderEl)\n        placeholderRef.current = placeholderEl\n      }\n    },\n    [placeholderRef, leaf, editor]\n  )\n\n  let children = (\n    <String isLast={isLast} leaf={leaf} parent={parent} text={text} />\n  )\n\n  const leafIsPlaceholder = leaf[PLACEHOLDER_SYMBOL]\n  useEffect(() => {\n    if (leafIsPlaceholder) {\n      if (!showPlaceholderTimeoutRef.current) {\n        // Delay the placeholder so it will not render in a selection\n        showPlaceholderTimeoutRef.current = setTimeout(() => {\n          setShowPlaceholder(true)\n          showPlaceholderTimeoutRef.current = null\n        }, 300)\n      }\n    } else {\n      clearTimeoutRef(showPlaceholderTimeoutRef)\n      setShowPlaceholder(false)\n    }\n    return () => clearTimeoutRef(showPlaceholderTimeoutRef)\n  }, [leafIsPlaceholder, setShowPlaceholder])\n\n  if (leafIsPlaceholder && showPlaceholder) {\n    const placeholderProps: RenderPlaceholderProps = {\n      children: leaf.placeholder,\n      attributes: {\n        'data-slate-placeholder': true,\n        style: {\n          position: 'absolute',\n          pointerEvents: 'none',\n          width: '100%',\n          maxWidth: '100%',\n          display: 'block',\n          opacity: '0.333',\n          userSelect: 'none',\n          textDecoration: 'none',\n        },\n        contentEditable: false,\n        ref: callbackPlaceholderRef,\n      },\n    }\n\n    children = (\n      <React.Fragment>\n        {renderPlaceholder(placeholderProps)}\n        {children}\n      </React.Fragment>\n    )\n  }\n\n  // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n  const attributes: {\n    'data-slate-leaf': true\n  } = {\n    'data-slate-leaf': true,\n  }\n\n  return renderLeaf({ attributes, children, leaf, text })\n}\n\nconst MemoizedLeaf = React.memo(Leaf, (prev, next) => {\n  return (\n    next.parent === prev.parent &&\n    next.isLast === prev.isLast &&\n    next.renderLeaf === prev.renderLeaf &&\n    next.renderPlaceholder === prev.renderPlaceholder &&\n    next.text === prev.text &&\n    Text.equals(next.leaf, prev.leaf) &&\n    next.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL]\n  )\n})\n\nexport const DefaultLeaf = (props: RenderLeafProps) => {\n  const { attributes, children } = props\n  return <span {...attributes}>{children}</span>\n}\n\nexport default MemoizedLeaf\n","import React, { useRef, useCallback } from 'react'\nimport { Element, Range, Text as SlateText } from '@seafile/slate'\nimport { ReactEditor, useSlateStatic } from '..'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { isTextDecorationsEqual } from '../utils/range-list'\nimport {\n  EDITOR_TO_KEY_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  NODE_TO_ELEMENT,\n} from '../utils/weak-maps'\nimport { RenderLeafProps, RenderPlaceholderProps } from './editable'\nimport Leaf from './leaf'\n\n/**\n * Text.\n */\n\nconst Text = (props: {\n  decorations: Range[]\n  isLast: boolean\n  parent: Element\n  renderPlaceholder: (props: RenderPlaceholderProps) => JSX.Element\n  renderLeaf?: (props: RenderLeafProps) => JSX.Element\n  text: SlateText\n}) => {\n  const {\n    decorations,\n    isLast,\n    parent,\n    renderPlaceholder,\n    renderLeaf,\n    text,\n  } = props\n  const editor = useSlateStatic()\n  const ref = useRef<HTMLSpanElement | null>(null)\n  const leaves = SlateText.decorations(text, decorations)\n  const key = ReactEditor.findKey(editor, text)\n  const children = []\n\n  for (let i = 0; i < leaves.length; i++) {\n    const leaf = leaves[i]\n\n    children.push(\n      <Leaf\n        isLast={isLast && i === leaves.length - 1}\n        key={`${key.id}-${i}`}\n        renderPlaceholder={renderPlaceholder}\n        leaf={leaf}\n        text={text}\n        parent={parent}\n        renderLeaf={renderLeaf}\n      />\n    )\n  }\n\n  // Update element-related weak maps with the DOM element ref.\n  const callbackRef = useCallback(\n    (span: HTMLSpanElement | null) => {\n      const KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor)\n      if (span) {\n        KEY_TO_ELEMENT?.set(key, span)\n        NODE_TO_ELEMENT.set(text, span)\n        ELEMENT_TO_NODE.set(span, text)\n      } else {\n        KEY_TO_ELEMENT?.delete(key)\n        NODE_TO_ELEMENT.delete(text)\n        if (ref.current) {\n          ELEMENT_TO_NODE.delete(ref.current)\n        }\n      }\n      ref.current = span\n    },\n    [ref, editor, key, text]\n  )\n  return (\n    <span data-slate-node=\"text\" ref={callbackRef}>\n      {children}\n    </span>\n  )\n}\n\nconst MemoizedText = React.memo(Text, (prev, next) => {\n  return (\n    next.parent === prev.parent &&\n    next.isLast === prev.isLast &&\n    next.renderLeaf === prev.renderLeaf &&\n    next.renderPlaceholder === prev.renderPlaceholder &&\n    next.text === prev.text &&\n    isTextDecorationsEqual(next.decorations, prev.decorations)\n  )\n})\n\nexport default MemoizedText\n","import { createContext, useContext } from 'react'\n\n/**\n * A React context for sharing the `selected` state of an element.\n */\n\nexport const SelectedContext = createContext(false)\n\n/**\n * Get the current `selected` state of an element.\n */\n\nexport const useSelected = (): boolean => {\n  return useContext(SelectedContext)\n}\n","import { NodeEntry, Range, Path, Text } from '@seafile/slate'\nimport { Cursors } from '../cursor'\n\nexport const hasCursors = (cursors: Cursors, node: NodeEntry): Boolean => {\n  const [, path] = node\n  if (!cursors) return false\n  return cursors.some(cursor => {\n    if (Range.includes(cursor, path)) return true\n    return false\n  })\n}\n\nexport const decorateCursors = (\n  cursors: Cursors,\n  nodeEntry: NodeEntry\n): Range[] => {\n  if (!cursors) return []\n  const ranges: Range[] = []\n  const [node, path] = nodeEntry\n  if (Text.isText(node) && cursors?.length) {\n    cursors.forEach(cursor => {\n      if (Range.includes(cursor, path)) {\n        const { focus, anchor } = cursor\n\n        const isFocusNode = Path.equals(focus.path, path)\n        const isAnchorNode = Path.equals(anchor.path, path)\n\n        ranges.push({\n          ...cursor,\n          isCaret: isFocusNode,\n          anchor: {\n            path,\n            offset: isAnchorNode ? anchor.offset : node.text.length,\n          },\n          focus: {\n            path,\n            offset: isFocusNode ? focus.offset : 0,\n          },\n        })\n      }\n    })\n  }\n  return ranges\n}\n","import React from 'react'\nimport {\n  Editor,\n  Range,\n  Element,\n  Ancestor,\n  Descendant,\n} from '@seafile/slate'\n\nimport ElementComponent from '../components/element'\nimport TextComponent from '../components/text'\nimport { ReactEditor } from '../plugin/react-editor'\nimport { useSlateStatic } from './use-slate-static'\nimport { useDecorate } from './use-decorate'\nimport { NODE_TO_INDEX, NODE_TO_PARENT } from '../utils/weak-maps'\nimport {\n  RenderElementProps,\n  RenderLeafProps,\n  RenderPlaceholderProps,\n} from '../components/editable'\nimport { SelectedContext } from './use-selected'\nimport { decorateCursors, hasCursors } from '../utils/cusors'\nimport { Cursors } from '../cursor'\n\n/**\n * Children.\n */\n\nconst useChildren = (props: {\n  decorations: Range[]\n  node: Ancestor\n  renderElement?: (props: RenderElementProps) => JSX.Element\n  renderPlaceholder: (props: RenderPlaceholderProps) => JSX.Element\n  renderLeaf?: (props: RenderLeafProps) => JSX.Element\n  selection: Range | null\n  cursors?: Cursors\n}) => {\n  const {\n    decorations,\n    node,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection,\n    cursors,\n  } = props\n  const decorate = useDecorate()\n  const editor = useSlateStatic()\n  const path = ReactEditor.findPath(editor, node)\n  const children = []\n  const isLeafBlock =\n    Element.isElement(node) &&\n    !editor.isInline(node) &&\n    Editor.hasInlines(editor, node)\n\n  for (let i = 0; i < node.children.length; i++) {\n    const p = path.concat(i)\n    const n = node.children[i] as Descendant\n    const key = ReactEditor.findKey(editor, n)\n    const range = Editor.range(editor, p)\n    const sel = selection && Range.intersection(range, selection)\n    const ds = decorate([n, p])\n\n    for (const dec of decorations) {\n      const d = Range.intersection(dec, range)\n\n      if (d) {\n        ds.push(d)\n      }\n    }\n\n    if (Element.isElement(n)) {\n      // cursors\n      const hasCursor = hasCursors(cursors, [n, p])\n      const childCursors = hasCursor ? cursors : null\n\n      children.push(\n        <SelectedContext.Provider key={`provider-${key.id}`} value={!!sel}>\n          <ElementComponent\n            decorations={ds}\n            element={n}\n            key={key.id}\n            renderElement={renderElement}\n            renderPlaceholder={renderPlaceholder}\n            renderLeaf={renderLeaf}\n            selection={sel}\n            cursors={childCursors}\n          />\n        </SelectedContext.Provider>\n      )\n    } else {\n      if (cursors) {\n        const ranges = decorateCursors(cursors, [n, p])\n        ds.push(...ranges)\n      }\n      children.push(\n        <TextComponent\n          decorations={ds}\n          key={key.id}\n          isLast={isLeafBlock && i === node.children.length - 1}\n          parent={node}\n          renderPlaceholder={renderPlaceholder}\n          renderLeaf={renderLeaf}\n          text={n}\n        />\n      )\n    }\n\n    NODE_TO_INDEX.set(n, i)\n    NODE_TO_PARENT.set(n, node)\n  }\n\n  return children\n}\n\nexport default useChildren\n","import React, { useCallback } from 'react'\nimport getDirection from 'direction'\nimport { Editor, Node, Range, Element as SlateElement } from '@seafile/slate'\n\nimport Text from './text'\nimport useChildren from '../hooks/use-children'\nimport { ReactEditor, useSlateStatic, useReadOnly } from '..'\nimport {\n  NODE_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  NODE_TO_PARENT,\n  NODE_TO_INDEX,\n  EDITOR_TO_KEY_TO_ELEMENT,\n} from '../utils/weak-maps'\nimport { isElementDecorationsEqual } from '../utils/range-list'\nimport {\n  RenderElementProps,\n  RenderLeafProps,\n  RenderPlaceholderProps,\n} from './editable'\nimport { Cursors } from '../cursor'\n\n/**\n * Element.\n */\n\nconst Element = (props: {\n  decorations: Range[]\n  element: SlateElement\n  renderElement?: (props: RenderElementProps) => JSX.Element\n  renderPlaceholder: (props: RenderPlaceholderProps) => JSX.Element\n  renderLeaf?: (props: RenderLeafProps) => JSX.Element\n  selection: Range | null\n  cursors?: Cursors\n  isComposing?: boolean\n}) => {\n  const {\n    decorations,\n    element,\n    renderElement = (p: RenderElementProps) => <DefaultElement {...p} />,\n    renderPlaceholder,\n    renderLeaf,\n    selection,\n    cursors,\n    isComposing,\n  } = props\n  const editor = useSlateStatic()\n  const readOnly = useReadOnly()\n  const isInline = editor.isInline(element)\n  const key = ReactEditor.findKey(editor, element)\n  const ref = useCallback(\n    (ref: HTMLElement | null) => {\n      // Update element-related weak maps with the DOM element ref.\n      const KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor)\n      if (ref) {\n        KEY_TO_ELEMENT?.set(key, ref)\n        NODE_TO_ELEMENT.set(element, ref)\n        ELEMENT_TO_NODE.set(ref, element)\n      } else {\n        KEY_TO_ELEMENT?.delete(key)\n        NODE_TO_ELEMENT.delete(element)\n      }\n    },\n    [editor, key, element]\n  )\n  let children: React.ReactNode = useChildren({\n    decorations,\n    node: element,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection,\n    cursors,\n  })\n\n  // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n  const attributes: {\n    'data-slate-node': 'element'\n    'data-slate-void'?: true\n    'data-slate-inline'?: true\n    contentEditable?: false\n    dir?: 'rtl'\n    ref: any\n  } = {\n    'data-slate-node': 'element',\n    ref,\n  }\n\n  if (isInline) {\n    attributes['data-slate-inline'] = true\n  }\n\n  // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n  if (!isInline && Editor.hasInlines(editor, element)) {\n    const text = Node.string(element)\n    const dir = getDirection(text)\n\n    if (dir === 'rtl') {\n      attributes.dir = dir\n    }\n  }\n\n  // If it's a void node, wrap the children in extra void-specific elements.\n  if (Editor.isVoid(editor, element)) {\n    attributes['data-slate-void'] = true\n\n    if (!readOnly && isInline) {\n      attributes.contentEditable = false\n    }\n\n    const Tag = isInline ? 'span' : 'div'\n    const [[text]] = Node.texts(element)\n\n    children = (\n      <Tag\n        data-slate-spacer\n        style={{\n          height: '0',\n          color: 'transparent',\n          outline: 'none',\n          position: 'absolute',\n        }}\n      >\n        <Text\n          renderPlaceholder={renderPlaceholder}\n          decorations={[]}\n          isLast={false}\n          parent={element}\n          text={text}\n        />\n      </Tag>\n    )\n\n    NODE_TO_INDEX.set(text, 0)\n    NODE_TO_PARENT.set(text, element)\n  }\n\n  return renderElement({ attributes, children, element, isComposing })\n}\n\nconst MemoizedElement = React.memo(Element, (prev, next) => {\n  return (\n    prev.element === next.element &&\n    prev.renderElement === next.renderElement &&\n    prev.renderLeaf === next.renderLeaf &&\n    prev.renderPlaceholder === next.renderPlaceholder &&\n    isElementDecorationsEqual(prev.decorations, next.decorations) &&\n    (prev.selection === next.selection ||\n      (!!prev.selection &&\n        !!next.selection &&\n        Range.equals(prev.selection, next.selection))) &&\n    prev.cursors === next.cursors &&\n    prev.isComposing === next.isComposing\n  )\n})\n\n/**\n * The default element renderer.\n */\n\nexport const DefaultElement = (props: RenderElementProps) => {\n  const { attributes, children, element } = props\n  const editor = useSlateStatic()\n  const Tag = editor.isInline(element) ? 'span' : 'div'\n  return (\n    <Tag {...attributes} style={{ position: 'relative' }}>\n      {children}\n    </Tag>\n  )\n}\n\nexport default MemoizedElement\n","import React from 'react'\nimport { Editor, Range, Element, Ancestor, Node } from '@seafile/slate'\n\nimport ElementComponent from './element'\nimport { ReactEditor } from '../plugin/react-editor'\nimport { useSlateStatic } from '../hooks/use-slate-static'\nimport { useDecorate } from '../hooks/use-decorate'\nimport { NODE_TO_INDEX, NODE_TO_PARENT } from '../utils/weak-maps'\nimport {\n  RenderElementProps,\n  RenderLeafProps,\n  RenderPlaceholderProps,\n} from '../components/editable'\nimport { SelectedContext } from '../hooks/use-selected'\nimport { hasCursors } from '../utils/cusors'\nimport { Cursors } from '../cursor'\n\n/**\n * Children.\n */\n\nconst Children = (props: {\n  decorations: Range[]\n  node: Ancestor\n  renderElement?: (props: RenderElementProps) => JSX.Element\n  renderPlaceholder: (props: RenderPlaceholderProps) => JSX.Element\n  renderLeaf?: (props: RenderLeafProps) => JSX.Element\n  selection: Range | null\n  cursors?: Cursors\n  composingNode?: Node | null | undefined\n}) => {\n  const {\n    decorations,\n    node,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection,\n    cursors,\n    composingNode,\n  } = props\n  const decorate = useDecorate()\n  const editor = useSlateStatic()\n  const path = ReactEditor.findPath(editor, node)\n\n  const children = []\n\n  for (let i = 0; i < node.children.length; i++) {\n    const p = path.concat(i)\n    const n = node.children[i] as Element\n    const key = ReactEditor.findKey(editor, n)\n    const range = Editor.range(editor, p)\n    const sel = selection && Range.intersection(range, selection)\n\n    // decorate\n    const ds = decorate([n, p])\n\n    for (const dec of decorations) {\n      const d = Range.intersection(dec, range)\n\n      if (d) {\n        ds.push(d)\n      }\n    }\n\n    // cursors\n    const hasCursor = hasCursors(cursors, [n, p])\n    const childCursors = hasCursor ? cursors : null\n\n    // placeholder\n    const isComposing = composingNode?.id === n.id\n\n    children.push(\n      <SelectedContext.Provider key={`provider-${key.id}`} value={!!sel}>\n        <ElementComponent\n          decorations={ds}\n          element={n}\n          key={key.id}\n          renderElement={renderElement}\n          renderPlaceholder={renderPlaceholder}\n          renderLeaf={renderLeaf}\n          selection={sel}\n          cursors={childCursors}\n          isComposing={isComposing}\n        />\n      </SelectedContext.Provider>\n    )\n\n    NODE_TO_INDEX.set(n, i)\n    NODE_TO_PARENT.set(n, node)\n  }\n\n  return <React.Fragment>{children}</React.Fragment>\n}\n\nexport default Children\n","import getDirection from 'direction'\nimport debounce from 'lodash/debounce'\nimport throttle from 'lodash/throttle'\nimport React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from 'react'\nimport scrollIntoView from 'scroll-into-view-if-needed'\nimport {\n  Editor,\n  Element,\n  Node,\n  NodeEntry,\n  Path,\n  Range,\n  Text,\n  Transforms,\n} from '@seafile/slate'\nimport { ReactEditor } from '../plugin/react-editor'\nimport { DecorateContext } from '../hooks/use-decorate'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { ReadOnlyContext } from '../hooks/use-read-only'\nimport { useSlate } from '../hooks/use-slate'\nimport { TRIPLE_CLICK } from '../utils/constants'\nimport {\n  DOMElement,\n  DOMRange,\n  DOMText,\n  getDefaultView,\n  isDOMElement,\n  isDOMNode,\n  isPlainTextOnlyPaste,\n} from '../utils/dom'\nimport {\n  CAN_USE_DOM,\n  HAS_BEFORE_INPUT_SUPPORT,\n  IS_ANDROID,\n  IS_CHROME,\n  IS_FIREFOX,\n  IS_FIREFOX_LEGACY,\n  IS_IOS,\n  IS_SAFARI,\n  IS_UC_MOBILE,\n  IS_WECHATBROWSER,\n} from '../utils/environment'\nimport Hotkeys from '../utils/hotkeys'\nimport {\n  EDITOR_TO_ELEMENT,\n  EDITOR_TO_FORCE_RENDER,\n  EDITOR_TO_PENDING_INSERTION_MARKS,\n  EDITOR_TO_PLACEHOLDER_ELEMENT,\n  EDITOR_TO_USER_MARKS,\n  EDITOR_TO_USER_SELECTION,\n  EDITOR_TO_WINDOW,\n  ELEMENT_TO_NODE,\n  IS_COMPOSING,\n  IS_FOCUSED,\n  IS_READ_ONLY,\n  MARK_PLACEHOLDER_SYMBOL,\n  NODE_TO_ELEMENT,\n  PLACEHOLDER_SYMBOL,\n} from '../utils/weak-maps'\nimport { RestoreDOM } from './restore-dom/restore-dom'\nimport { useAndroidInputManager } from '../hooks/android-input-manager/use-android-input-manager'\nimport { useTrackUserInput } from '../hooks/use-track-user-input'\nimport { AndroidInputManager } from '../hooks/android-input-manager/android-input-manager'\nimport Children from './children'\nimport { Cursors } from '../cursor'\n\ntype DeferredOperation = () => void\n\n/**\n * `RenderElementProps` are passed to the `renderElement` handler.\n */\n\nexport interface RenderElementProps {\n  children: any\n  element: Element\n  attributes: {\n    'data-slate-node': 'element'\n    'data-slate-inline'?: true\n    'data-slate-void'?: true\n    dir?: 'rtl'\n    ref: any\n  }\n  cursors?: Cursors\n  isComposing?: boolean\n}\n\n/**\n * `RenderLeafProps` are passed to the `renderLeaf` handler.\n */\n\nexport interface RenderLeafProps {\n  children: any\n  leaf: Text\n  text: Text\n  attributes: {\n    'data-slate-leaf': true\n  }\n}\n\n/**\n * `EditableProps` are passed to the `<Editable>` component.\n */\n\nexport type EditableProps = {\n  decorate?: (entry: NodeEntry) => Range[]\n  onDOMBeforeInput?: (event: InputEvent) => void\n  placeholder?: string\n  readOnly?: boolean\n  role?: string\n  style?: React.CSSProperties\n  renderElement?: (props: RenderElementProps) => JSX.Element\n  renderLeaf?: (props: RenderLeafProps) => JSX.Element\n  renderPlaceholder?: (props: RenderPlaceholderProps) => JSX.Element\n  scrollSelectionIntoView?: (editor: ReactEditor, domRange: DOMRange) => void\n  as?: React.ElementType\n  disableDefaultStyles?: boolean\n  cursors: Cursors\n} & React.TextareaHTMLAttributes<HTMLDivElement>\n\n/**\n * Editable.\n */\n\nexport const Editable = (props: EditableProps) => {\n  const defaultRenderPlaceholder = useCallback(\n    (props: RenderPlaceholderProps) => <DefaultPlaceholder {...props} />,\n    []\n  )\n  const {\n    autoFocus,\n    decorate = defaultDecorate,\n    onDOMBeforeInput: propsOnDOMBeforeInput,\n    placeholder,\n    readOnly = false,\n    renderElement,\n    renderLeaf,\n    renderPlaceholder = defaultRenderPlaceholder,\n    scrollSelectionIntoView = defaultScrollSelectionIntoView,\n    style: userStyle = {},\n    as: Component = 'div',\n    disableDefaultStyles = false,\n    cursors,\n    ...attributes\n  } = props\n  const editor = useSlate()\n  // Rerender editor when composition status changed\n  const [isComposing, setIsComposing] = useState(false)\n  const ref = useRef<HTMLDivElement | null>(null)\n  const deferredOperations = useRef<DeferredOperation[]>([])\n  const [placeholderHeight, setPlaceholderHeight] = useState<\n    number | undefined\n  >()\n\n  const { onUserInput, receivedUserInput } = useTrackUserInput()\n  const composingNode = useMemo(() => {\n    if (!isComposing) return null\n    const block = Editor.above(editor, {\n      mode: 'highest',\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n    })\n    return block ? block[0] : null\n  }, [editor, isComposing])\n\n  const [, forceRender] = useReducer(s => s + 1, 0)\n  EDITOR_TO_FORCE_RENDER.set(editor, forceRender)\n\n  // Update internal state on each render.\n  IS_READ_ONLY.set(editor, readOnly)\n\n  // Keep track of some state for the event handler logic.\n  const state = useMemo(\n    () => ({\n      isDraggingInternally: false,\n      isUpdatingSelection: false,\n      latestElement: null as DOMElement | null,\n      hasMarkPlaceholder: false,\n    }),\n    []\n  )\n\n  // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n  // needs to be manually focused.\n  useEffect(() => {\n    if (ref.current && autoFocus) {\n      ref.current.focus()\n    }\n  }, [autoFocus])\n\n  /**\n   * The AndroidInputManager object has a cyclical dependency on onDOMSelectionChange\n   *\n   * It is defined as a reference to simplify hook dependencies and clarify that\n   * it needs to be initialized.\n   */\n  const androidInputManagerRef = useRef<\n    AndroidInputManager | null | undefined\n  >()\n\n  // Listen on the native `selectionchange` event to be able to update any time\n  // the selection changes. This is required because React's `onSelect` is leaky\n  // and non-standard so it doesn't fire until after a selection has been\n  // released. This causes issues in situations where another change happens\n  // while a selection is being dragged.\n  const onDOMSelectionChange = useMemo(\n    () =>\n      throttle(() => {\n        const androidInputManager = androidInputManagerRef.current\n        if (\n          (IS_ANDROID || !ReactEditor.isComposing(editor)) &&\n          (!state.isUpdatingSelection || androidInputManager?.isFlushing()) &&\n          !state.isDraggingInternally\n        ) {\n          const root = ReactEditor.findDocumentOrShadowRoot(editor)\n          const { activeElement } = root\n          const el = ReactEditor.toDOMNode(editor, editor)\n          const domSelection = root.getSelection()\n\n          if (activeElement === el) {\n            state.latestElement = activeElement\n            IS_FOCUSED.set(editor, true)\n          } else {\n            IS_FOCUSED.delete(editor)\n          }\n\n          if (!domSelection) {\n            return Transforms.deselect(editor)\n          }\n\n          const { anchorNode, focusNode } = domSelection\n\n          const anchorNodeSelectable =\n            ReactEditor.hasEditableTarget(editor, anchorNode) ||\n            ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode)\n\n          const focusNodeSelectable =\n            ReactEditor.hasEditableTarget(editor, focusNode) ||\n            ReactEditor.isTargetInsideNonReadonlyVoid(editor, focusNode)\n\n          if (anchorNodeSelectable && focusNodeSelectable) {\n            const range = ReactEditor.toSlateRange(editor, domSelection, {\n              exactMatch: false,\n              suppressThrow: true,\n            })\n\n            if (range) {\n              if (\n                !ReactEditor.isComposing(editor) &&\n                !androidInputManager?.hasPendingChanges() &&\n                !androidInputManager?.isFlushing()\n              ) {\n                Transforms.select(editor, range)\n              } else {\n                androidInputManager?.handleUserSelect(range)\n              }\n            }\n          }\n\n          // Deselect the editor if the dom selection is not selectable in readonly mode\n          if (readOnly && (!anchorNodeSelectable || !focusNodeSelectable)) {\n            Transforms.deselect(editor)\n          }\n        }\n      }, 100),\n    [editor, readOnly, state]\n  )\n\n  const scheduleOnDOMSelectionChange = useMemo(\n    () => debounce(onDOMSelectionChange, 0),\n    [onDOMSelectionChange]\n  )\n\n  androidInputManagerRef.current = useAndroidInputManager({\n    node: ref,\n    onDOMSelectionChange,\n    scheduleOnDOMSelectionChange,\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    // Update element-related weak maps with the DOM element ref.\n    let window\n    if (ref.current && (window = getDefaultView(ref.current))) {\n      EDITOR_TO_WINDOW.set(editor, window)\n      EDITOR_TO_ELEMENT.set(editor, ref.current)\n      NODE_TO_ELEMENT.set(editor, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, editor)\n    } else {\n      NODE_TO_ELEMENT.delete(editor)\n    }\n\n    // Make sure the DOM selection state is in sync.\n    const { selection } = editor\n    const root = ReactEditor.findDocumentOrShadowRoot(editor)\n    const domSelection = root.getSelection()\n\n    if (\n      !domSelection ||\n      !ReactEditor.isFocused(editor) ||\n      androidInputManagerRef.current?.hasPendingAction()\n    ) {\n      return\n    }\n\n    const setDomSelection = (forceChange?: boolean) => {\n      const hasDomSelection = domSelection.type !== 'None'\n\n      // If the DOM selection is properly unset, we're done.\n      if (!selection && !hasDomSelection) {\n        return\n      }\n\n      // verify that the dom selection is in the editor\n      const editorElement = EDITOR_TO_ELEMENT.get(editor)!\n      let hasDomSelectionInEditor = false\n      if (\n        editorElement.contains(domSelection.anchorNode) &&\n        editorElement.contains(domSelection.focusNode)\n      ) {\n        hasDomSelectionInEditor = true\n      }\n\n      // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n      if (\n        hasDomSelection &&\n        hasDomSelectionInEditor &&\n        selection &&\n        !forceChange\n      ) {\n        const slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: true,\n\n          // domSelection is not necessarily a valid Slate range\n          // (e.g. when clicking on contentEditable:false element)\n          suppressThrow: true,\n        })\n\n        if (slateRange && Range.equals(slateRange, selection)) {\n          if (!state.hasMarkPlaceholder) {\n            return\n          }\n\n          // Ensure selection is inside the mark placeholder\n          const { anchorNode } = domSelection\n          if (\n            anchorNode?.parentElement?.hasAttribute(\n              'data-slate-mark-placeholder'\n            )\n          ) {\n            return\n          }\n        }\n      }\n\n      // when <Editable/> is being controlled through external value\n      // then its children might just change - DOM responds to it on its own\n      // but Slate's value is not being updated through any operation\n      // and thus it doesn't transform selection on its own\n      if (selection && !ReactEditor.hasRange(editor, selection)) {\n        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true,\n        })\n        return\n      }\n\n      // Otherwise the DOM selection is out of sync, so update it.\n      state.isUpdatingSelection = true\n\n      const newDomRange: DOMRange | null =\n        selection && ReactEditor.toDOMRange(editor, selection)\n\n      if (newDomRange) {\n        if (Range.isBackward(selection!)) {\n          domSelection.setBaseAndExtent(\n            newDomRange.endContainer,\n            newDomRange.endOffset,\n            newDomRange.startContainer,\n            newDomRange.startOffset\n          )\n        } else {\n          domSelection.setBaseAndExtent(\n            newDomRange.startContainer,\n            newDomRange.startOffset,\n            newDomRange.endContainer,\n            newDomRange.endOffset\n          )\n        }\n        scrollSelectionIntoView(editor, newDomRange)\n      } else {\n        domSelection.removeAllRanges()\n      }\n\n      return newDomRange\n    }\n\n    const newDomRange = setDomSelection()\n    const ensureSelection =\n      androidInputManagerRef.current?.isFlushing() === 'action'\n\n    if (!IS_ANDROID || !ensureSelection) {\n      setTimeout(() => {\n        // COMPAT: In Firefox, it's not enough to create a range, you also need\n        // to focus the contenteditable element too. (2016/11/16)\n        if (newDomRange && IS_FIREFOX) {\n          const el = ReactEditor.toDOMNode(editor, editor)\n          el.focus()\n        }\n\n        state.isUpdatingSelection = false\n      })\n      return\n    }\n\n    let timeoutId: ReturnType<typeof setTimeout> | null = null\n    const animationFrameId = requestAnimationFrame(() => {\n      if (ensureSelection) {\n        const ensureDomSelection = (forceChange?: boolean) => {\n          try {\n            const el = ReactEditor.toDOMNode(editor, editor)\n            el.focus()\n\n            setDomSelection(forceChange)\n          } catch (e) {\n            // Ignore, dom and state might be out of sync\n          }\n        }\n\n        // Compat: Android IMEs try to force their selection by manually re-applying it even after we set it.\n        // This essentially would make setting the slate selection during an update meaningless, so we force it\n        // again here. We can't only do it in the setTimeout after the animation frame since that would cause a\n        // visible flicker.\n        ensureDomSelection()\n\n        timeoutId = setTimeout(() => {\n          // COMPAT: While setting the selection in an animation frame visually correctly sets the selection,\n          // it doesn't update GBoards spellchecker state. We have to manually trigger a selection change after\n          // the animation frame to ensure it displays the correct state.\n          ensureDomSelection(true)\n          state.isUpdatingSelection = false\n        })\n      }\n    })\n\n    return () => {\n      cancelAnimationFrame(animationFrameId)\n      if (timeoutId) {\n        clearTimeout(timeoutId)\n      }\n    }\n  })\n\n  // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n  // is required because React's `beforeinput` is fake and never really attaches\n  // to the real event sadly. (2019/11/01)\n  // https://github.com/facebook/react/issues/11211\n  const onDOMBeforeInput = useCallback(\n    (event: InputEvent) => {\n      onUserInput()\n\n      if (\n        !readOnly &&\n        ReactEditor.hasEditableTarget(editor, event.target) &&\n        !isDOMEventHandled(event, propsOnDOMBeforeInput)\n      ) {\n        // COMPAT: BeforeInput events aren't cancelable on android, so we have to handle them differently using the android input manager.\n        if (androidInputManagerRef.current) {\n          return androidInputManagerRef.current.handleDOMBeforeInput(event)\n        }\n\n        // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before\n        // triggering a `beforeinput` expecting the change to be applied to the immediately before\n        // set selection.\n        scheduleOnDOMSelectionChange.flush()\n        onDOMSelectionChange.flush()\n\n        const { selection } = editor\n        const { inputType: type } = event\n        const data = (event as any).dataTransfer || event.data || undefined\n\n        const isCompositionChange =\n          type === 'insertCompositionText' || type === 'deleteCompositionText'\n\n        // COMPAT: use composition change events as a hint to where we should insert\n        // composition text if we aren't composing to work around https://github.com/ianstormtaylor/slate/issues/5038\n        if (isCompositionChange && ReactEditor.isComposing(editor)) {\n          return\n        }\n\n        let native = false\n        if (\n          type === 'insertText' &&\n          selection &&\n          Range.isCollapsed(selection) &&\n          // Only use native character insertion for single characters a-z or space for now.\n          // Long-press events (hold a + press 4 = ) to choose a special character otherwise\n          // causes duplicate inserts.\n          event.data &&\n          event.data.length === 1 &&\n          /[a-z ]/i.test(event.data) &&\n          // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405\n          // When there is an inline element, e.g. a link, and you select\n          // right after it (the start of the next node).\n          selection.anchor.offset !== 0\n        ) {\n          native = true\n\n          // Skip native if there are marks, as\n          // `insertText` will insert a node, not just text.\n          if (editor.marks) {\n            native = false\n          }\n\n          // Chrome also has issues correctly editing the end of anchor elements: https://bugs.chromium.org/p/chromium/issues/detail?id=1259100\n          // Therefore we don't allow native events to insert text at the end of anchor nodes.\n          const { anchor } = selection\n\n          const [node, offset] = ReactEditor.toDOMPoint(editor, anchor)\n          const anchorNode = node.parentElement?.closest('a')\n\n          const window = ReactEditor.getWindow(editor)\n\n          if (\n            native &&\n            anchorNode &&\n            ReactEditor.hasDOMNode(editor, anchorNode)\n          ) {\n            // Find the last text node inside the anchor.\n            const lastText = window?.document\n              .createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT)\n              .lastChild() as DOMText | null\n\n            if (lastText === node && lastText.textContent?.length === offset) {\n              native = false\n            }\n          }\n\n          // Chrome has issues with the presence of tab characters inside elements with whiteSpace = 'pre'\n          // causing abnormal insert behavior: https://bugs.chromium.org/p/chromium/issues/detail?id=1219139\n          if (\n            native &&\n            node.parentElement &&\n            window?.getComputedStyle(node.parentElement)?.whiteSpace === 'pre'\n          ) {\n            const block = Editor.above(editor, {\n              at: anchor.path,\n              match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n            })\n\n            if (block && Node.string(block[0]).includes('\\t')) {\n              native = false\n            }\n          }\n        }\n\n        // COMPAT: For the deleting forward/backward input types we don't want\n        // to change the selection because it is the range that will be deleted,\n        // and those commands determine that for themselves.\n        if (!type.startsWith('delete') || type.startsWith('deleteBy')) {\n          const [targetRange] = (event as any).getTargetRanges()\n\n          if (targetRange) {\n            const range = ReactEditor.toSlateRange(editor, targetRange, {\n              exactMatch: false,\n              suppressThrow: false,\n            })\n\n            if (!selection || !Range.equals(selection, range)) {\n              native = false\n\n              const selectionRef =\n                !isCompositionChange &&\n                editor.selection &&\n                Editor.rangeRef(editor, editor.selection)\n\n              Transforms.select(editor, range)\n\n              if (selectionRef) {\n                EDITOR_TO_USER_SELECTION.set(editor, selectionRef)\n              }\n            }\n          }\n        }\n\n        // Composition change types occur while a user is composing text and can't be\n        // cancelled. Let them through and wait for the composition to end.\n        if (isCompositionChange) {\n          return\n        }\n\n        if (!native) {\n          event.preventDefault()\n        }\n\n        // COMPAT: If the selection is expanded, even if the command seems like\n        // a delete forward/backward command it should delete the selection.\n        if (\n          selection &&\n          Range.isExpanded(selection) &&\n          type.startsWith('delete')\n        ) {\n          const direction = type.endsWith('Backward') ? 'backward' : 'forward'\n          Editor.deleteFragment(editor, { direction })\n          return\n        }\n\n        switch (type) {\n          case 'deleteByComposition':\n          case 'deleteByCut':\n          case 'deleteByDrag': {\n            Editor.deleteFragment(editor)\n            break\n          }\n\n          case 'deleteContent':\n          case 'deleteContentForward': {\n            Editor.deleteForward(editor)\n            break\n          }\n\n          case 'deleteContentBackward': {\n            Editor.deleteBackward(editor)\n            break\n          }\n\n          case 'deleteEntireSoftLine': {\n            Editor.deleteBackward(editor, { unit: 'line' })\n            Editor.deleteForward(editor, { unit: 'line' })\n            break\n          }\n\n          case 'deleteHardLineBackward': {\n            Editor.deleteBackward(editor, { unit: 'block' })\n            break\n          }\n\n          case 'deleteSoftLineBackward': {\n            Editor.deleteBackward(editor, { unit: 'line' })\n            break\n          }\n\n          case 'deleteHardLineForward': {\n            Editor.deleteForward(editor, { unit: 'block' })\n            break\n          }\n\n          case 'deleteSoftLineForward': {\n            Editor.deleteForward(editor, { unit: 'line' })\n            break\n          }\n\n          case 'deleteWordBackward': {\n            Editor.deleteBackward(editor, { unit: 'word' })\n            break\n          }\n\n          case 'deleteWordForward': {\n            Editor.deleteForward(editor, { unit: 'word' })\n            break\n          }\n\n          case 'insertLineBreak':\n            Editor.insertSoftBreak(editor)\n            break\n\n          case 'insertParagraph': {\n            Editor.insertBreak(editor)\n            break\n          }\n\n          case 'insertFromComposition':\n          case 'insertFromDrop':\n          case 'insertFromPaste':\n          case 'insertFromYank':\n          case 'insertReplacementText':\n          case 'insertText': {\n            if (type === 'insertFromComposition') {\n              // COMPAT: in Safari, `compositionend` is dispatched after the\n              // `beforeinput` for \"insertFromComposition\". But if we wait for it\n              // then we will abort because we're still composing and the selection\n              // won't be updated properly.\n              // https://www.w3.org/TR/input-events-2/\n              if (ReactEditor.isComposing(editor)) {\n                setIsComposing(false)\n                IS_COMPOSING.set(editor, false)\n              }\n            }\n\n            // use a weak comparison instead of 'instanceof' to allow\n            // programmatic access of paste events coming from external windows\n            // like cypress where cy.window does not work realibly\n            if (data?.constructor.name === 'DataTransfer') {\n              ReactEditor.insertData(editor, data)\n            } else if (typeof data === 'string') {\n              // Only insertText operations use the native functionality, for now.\n              // Potentially expand to single character deletes, as well.\n              if (native) {\n                deferredOperations.current.push(() =>\n                  Editor.insertText(editor, data)\n                )\n              } else {\n                Editor.insertText(editor, data)\n              }\n            }\n\n            break\n          }\n        }\n\n        // Restore the actual user section if nothing manually set it.\n        const toRestore = EDITOR_TO_USER_SELECTION.get(editor)?.unref()\n        EDITOR_TO_USER_SELECTION.delete(editor)\n\n        if (\n          toRestore &&\n          (!editor.selection || !Range.equals(editor.selection, toRestore))\n        ) {\n          Transforms.select(editor, toRestore)\n        }\n      }\n    },\n    [\n      editor,\n      onDOMSelectionChange,\n      onUserInput,\n      propsOnDOMBeforeInput,\n      readOnly,\n      scheduleOnDOMSelectionChange,\n    ]\n  )\n\n  const callbackRef = useCallback(\n    node => {\n      if (node == null) {\n        onDOMSelectionChange.cancel()\n        scheduleOnDOMSelectionChange.cancel()\n\n        EDITOR_TO_ELEMENT.delete(editor)\n        NODE_TO_ELEMENT.delete(editor)\n\n        if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n          // @ts-ignore The `beforeinput` event isn't recognized.\n          ref.current.removeEventListener('beforeinput', onDOMBeforeInput)\n        }\n      } else {\n        // Attach a native DOM event handler for `beforeinput` events, because React's\n        // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n        // real `beforeinput` events sadly... (2019/11/04)\n        // https://github.com/facebook/react/issues/11211\n        if (HAS_BEFORE_INPUT_SUPPORT) {\n          // @ts-ignore The `beforeinput` event isn't recognized.\n          node.addEventListener('beforeinput', onDOMBeforeInput)\n        }\n      }\n\n      ref.current = node\n    },\n    [\n      onDOMSelectionChange,\n      scheduleOnDOMSelectionChange,\n      editor,\n      onDOMBeforeInput,\n    ]\n  )\n\n  // Attach a native DOM event handler for `selectionchange`, because React's\n  // built-in `onSelect` handler doesn't fire for all selection changes. It's a\n  // leaky polyfill that only fires on keypresses or clicks. Instead, we want to\n  // fire for any change to the selection inside the editor. (2019/11/04)\n  // https://github.com/facebook/react/issues/5785\n  useIsomorphicLayoutEffect(() => {\n    const window = ReactEditor.getWindow(editor)\n\n    window.document.addEventListener(\n      'selectionchange',\n      scheduleOnDOMSelectionChange\n    )\n\n    return () => {\n      window.document.removeEventListener(\n        'selectionchange',\n        scheduleOnDOMSelectionChange\n      )\n    }\n  }, [scheduleOnDOMSelectionChange])\n\n  const decorations = decorate([editor, []])\n\n  const showPlaceholder =\n    placeholder &&\n    editor.children.length === 1 &&\n    Array.from(Node.texts(editor)).length === 1 &&\n    Node.string(editor) === '' &&\n    !isComposing\n\n  const placeHolderResizeHandler = useCallback(\n    (placeholderEl: HTMLElement | null) => {\n      if (placeholderEl && showPlaceholder) {\n        setPlaceholderHeight(placeholderEl.getBoundingClientRect()?.height)\n      } else {\n        setPlaceholderHeight(undefined)\n      }\n    },\n    [showPlaceholder]\n  )\n\n  if (showPlaceholder) {\n    const start = Editor.start(editor, [])\n    decorations.push({\n      [PLACEHOLDER_SYMBOL]: true,\n      placeholder,\n      onPlaceholderResize: placeHolderResizeHandler,\n      anchor: start,\n      focus: start,\n    })\n  }\n\n  const { marks } = editor\n  state.hasMarkPlaceholder = false\n\n  if (editor.selection && Range.isCollapsed(editor.selection) && marks) {\n    const { anchor } = editor.selection\n    const leaf = Node.leaf(editor, anchor.path)\n    const { text, ...rest } = leaf\n\n    // While marks isn't a 'complete' text, we can still use loose Text.equals\n    // here which only compares marks anyway.\n    if (!Text.equals(leaf, marks as Text, { loose: true })) {\n      state.hasMarkPlaceholder = true\n\n      const unset = Object.fromEntries(\n        Object.keys(rest).map(mark => [mark, null])\n      )\n\n      decorations.push({\n        [MARK_PLACEHOLDER_SYMBOL]: true,\n        ...unset,\n        ...marks,\n\n        anchor,\n        focus: anchor,\n      })\n    }\n  }\n\n  // Update EDITOR_TO_MARK_PLACEHOLDER_MARKS in setTimeout useEffect to ensure we don't set it\n  // before we receive the composition end event.\n  useEffect(() => {\n    setTimeout(() => {\n      const { selection } = editor\n      if (selection) {\n        const { anchor } = selection\n        const text = Node.leaf(editor, anchor.path)\n\n        // While marks isn't a 'complete' text, we can still use loose Text.equals\n        // here which only compares marks anyway.\n        if (marks && !Text.equals(text, marks as Text, { loose: true })) {\n          EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks)\n          return\n        }\n      }\n\n      EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor)\n    })\n  })\n\n  return (\n    <ReadOnlyContext.Provider value={readOnly}>\n      <DecorateContext.Provider value={decorate}>\n        <RestoreDOM node={ref} receivedUserInput={receivedUserInput}>\n          <Component\n            role={readOnly ? undefined : 'textbox'}\n            aria-multiline={readOnly ? undefined : true}\n            {...attributes}\n            // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n            // have to use hacks to make these replacement-based features work.\n            // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop\n            // mismatch warning app moves to browser. Pass-through consumer props when\n            // not CAN_USE_DOM (SSR) and default to falsy value\n            spellCheck={\n              HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM\n                ? attributes.spellCheck\n                : false\n            }\n            autoCorrect={\n              HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM\n                ? attributes.autoCorrect\n                : 'false'\n            }\n            autoCapitalize={\n              HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM\n                ? attributes.autoCapitalize\n                : 'false'\n            }\n            data-slate-editor\n            data-slate-node=\"value\"\n            // explicitly set this\n            contentEditable={!readOnly}\n            // in some cases, a decoration needs access to the range / selection to decorate a text node,\n            // then you will select the whole text node when you select part the of text\n            // this magic zIndex=\"-1\" will fix it\n            zindex={-1}\n            suppressContentEditableWarning\n            ref={callbackRef}\n            style={{\n              ...(disableDefaultStyles\n                ? {}\n                : {\n                    // Allow positioning relative to the editable element.\n                    position: 'relative',\n                    // Prevent the default outline styles.\n                    outline: 'none',\n                    // Preserve adjacent whitespace and new lines.\n                    whiteSpace: 'pre-wrap',\n                    // Allow words to break if they are too long.\n                    wordWrap: 'break-word',\n                    // Make the minimum height that of the placeholder.\n                    ...(placeholderHeight\n                      ? { minHeight: placeholderHeight }\n                      : {}),\n                  }),\n              // Allow for passed-in styles to override anything.\n              ...userStyle,\n            }}\n            onBeforeInput={useCallback(\n              (event: React.FormEvent<HTMLDivElement>) => {\n                // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n                // fall back to React's leaky polyfill instead just for it. It\n                // only works for the `insertText` input type.\n                if (\n                  !HAS_BEFORE_INPUT_SUPPORT &&\n                  !readOnly &&\n                  !isEventHandled(event, attributes.onBeforeInput) &&\n                  ReactEditor.hasSelectableTarget(editor, event.target)\n                ) {\n                  event.preventDefault()\n                  if (!ReactEditor.isComposing(editor)) {\n                    const text = (event as any).data as string\n                    Editor.insertText(editor, text)\n                  }\n                }\n              },\n              [attributes.onBeforeInput, editor, readOnly]\n            )}\n            onInput={useCallback(\n              (event: React.FormEvent<HTMLDivElement>) => {\n                if (isEventHandled(event, attributes.onInput)) {\n                  return\n                }\n\n                if (androidInputManagerRef.current) {\n                  androidInputManagerRef.current.handleInput()\n                  return\n                }\n\n                // Flush native operations, as native events will have propogated\n                // and we can correctly compare DOM text values in components\n                // to stop rendering, so that browser functions like autocorrect\n                // and spellcheck work as expected.\n                for (const op of deferredOperations.current) {\n                  op()\n                }\n                deferredOperations.current = []\n              },\n              [attributes.onInput]\n            )}\n            onBlur={useCallback(\n              (event: React.FocusEvent<HTMLDivElement>) => {\n                if (\n                  readOnly ||\n                  state.isUpdatingSelection ||\n                  !ReactEditor.hasSelectableTarget(editor, event.target) ||\n                  isEventHandled(event, attributes.onBlur)\n                ) {\n                  return\n                }\n\n                // COMPAT: If the current `activeElement` is still the previous\n                // one, this is due to the window being blurred when the tab\n                // itself becomes unfocused, so we want to abort early to allow to\n                // editor to stay focused when the tab becomes focused again.\n                const root = ReactEditor.findDocumentOrShadowRoot(editor)\n                if (state.latestElement === root.activeElement) {\n                  return\n                }\n\n                const { relatedTarget } = event\n                const el = ReactEditor.toDOMNode(editor, editor)\n\n                // COMPAT: The event should be ignored if the focus is returning\n                // to the editor from an embedded editable element (eg. an <input>\n                // element inside a void node).\n                if (relatedTarget === el) {\n                  return\n                }\n\n                // COMPAT: The event should be ignored if the focus is moving from\n                // the editor to inside a void node's spacer element.\n                if (\n                  isDOMElement(relatedTarget) &&\n                  relatedTarget.hasAttribute('data-slate-spacer')\n                ) {\n                  return\n                }\n\n                // COMPAT: The event should be ignored if the focus is moving to a\n                // non- editable section of an element that isn't a void node (eg.\n                // a list item of the check list example).\n                if (\n                  relatedTarget != null &&\n                  isDOMNode(relatedTarget) &&\n                  ReactEditor.hasDOMNode(editor, relatedTarget)\n                ) {\n                  const node = ReactEditor.toSlateNode(editor, relatedTarget)\n\n                  if (Element.isElement(node) && !editor.isVoid(node)) {\n                    return\n                  }\n                }\n\n                // COMPAT: Safari doesn't always remove the selection even if the content-\n                // editable element no longer has focus. Refer to:\n                // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web\n                if (IS_SAFARI) {\n                  const domSelection = root.getSelection()\n                  domSelection?.removeAllRanges()\n                }\n\n                IS_FOCUSED.delete(editor)\n              },\n              [\n                readOnly,\n                state.isUpdatingSelection,\n                state.latestElement,\n                editor,\n                attributes.onBlur,\n              ]\n            )}\n            onClick={useCallback(\n              (event: React.MouseEvent<HTMLDivElement>) => {\n                if (\n                  ReactEditor.hasTarget(editor, event.target) &&\n                  !isEventHandled(event, attributes.onClick) &&\n                  isDOMNode(event.target)\n                ) {\n                  const node = ReactEditor.toSlateNode(editor, event.target)\n                  const path = ReactEditor.findPath(editor, node)\n\n                  // At this time, the Slate document may be arbitrarily different,\n                  // because onClick handlers can change the document before we get here.\n                  // Therefore we must check that this path actually exists,\n                  // and that it still refers to the same node.\n                  if (\n                    !Editor.hasPath(editor, path) ||\n                    Node.get(editor, path) !== node\n                  ) {\n                    return\n                  }\n\n                  if (event.detail === TRIPLE_CLICK && path.length >= 1) {\n                    let blockPath = path\n                    if (\n                      !(Element.isElement(node) && Editor.isBlock(editor, node))\n                    ) {\n                      const block = Editor.above(editor, {\n                        match: n =>\n                          Element.isElement(n) && Editor.isBlock(editor, n),\n                        at: path,\n                      })\n\n                      blockPath = block?.[1] ?? path.slice(0, 1)\n                    }\n\n                    const range = Editor.range(editor, blockPath)\n                    Transforms.select(editor, range)\n                    return\n                  }\n\n                  if (readOnly) {\n                    return\n                  }\n\n                  const start = Editor.start(editor, path)\n                  const end = Editor.end(editor, path)\n                  const startVoid = Editor.void(editor, { at: start })\n                  const endVoid = Editor.void(editor, { at: end })\n\n                  if (\n                    startVoid &&\n                    endVoid &&\n                    Path.equals(startVoid[1], endVoid[1])\n                  ) {\n                    const range = Editor.range(editor, start)\n                    Transforms.select(editor, range)\n                  }\n                }\n              },\n              [editor, attributes.onClick, readOnly]\n            )}\n            onCompositionEnd={useCallback(\n              (event: React.CompositionEvent<HTMLDivElement>) => {\n                if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n                  if (ReactEditor.isComposing(editor)) {\n                    setIsComposing(false)\n                    IS_COMPOSING.set(editor, false)\n                  }\n\n                  androidInputManagerRef.current?.handleCompositionEnd(event)\n\n                  if (\n                    isEventHandled(event, attributes.onCompositionEnd) ||\n                    IS_ANDROID\n                  ) {\n                    return\n                  }\n\n                  // COMPAT: In Chrome, `beforeinput` events for compositions\n                  // aren't correct and never fire the \"insertFromComposition\"\n                  // type that we need. So instead, insert whenever a composition\n                  // ends since it will already have been committed to the DOM.\n                  if (\n                    !IS_SAFARI &&\n                    !IS_FIREFOX_LEGACY &&\n                    !IS_IOS &&\n                    !IS_WECHATBROWSER &&\n                    !IS_UC_MOBILE &&\n                    event.data\n                  ) {\n                    const placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(\n                      editor\n                    )\n                    EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor)\n\n                    // Ensure we insert text with the marks the user was actually seeing\n                    if (placeholderMarks !== undefined) {\n                      EDITOR_TO_USER_MARKS.set(editor, editor.marks)\n                      editor.marks = placeholderMarks\n                    }\n\n                    Editor.insertText(editor, event.data)\n\n                    const userMarks = EDITOR_TO_USER_MARKS.get(editor)\n                    EDITOR_TO_USER_MARKS.delete(editor)\n                    if (userMarks !== undefined) {\n                      editor.marks = userMarks\n                    }\n                  }\n                }\n              },\n              [attributes.onCompositionEnd, editor]\n            )}\n            onCompositionUpdate={useCallback(\n              (event: React.CompositionEvent<HTMLDivElement>) => {\n                if (\n                  ReactEditor.hasSelectableTarget(editor, event.target) &&\n                  !isEventHandled(event, attributes.onCompositionUpdate)\n                ) {\n                  if (!ReactEditor.isComposing(editor)) {\n                    setIsComposing(true)\n                    IS_COMPOSING.set(editor, true)\n                  }\n                }\n              },\n              [attributes.onCompositionUpdate, editor]\n            )}\n            onCompositionStart={useCallback(\n              (event: React.CompositionEvent<HTMLDivElement>) => {\n                if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n                  androidInputManagerRef.current?.handleCompositionStart(event)\n\n                  if (\n                    isEventHandled(event, attributes.onCompositionStart) ||\n                    IS_ANDROID\n                  ) {\n                    return\n                  }\n\n                  setIsComposing(true)\n\n                  const { selection } = editor\n                  if (selection) {\n                    if (Range.isExpanded(selection)) {\n                      Editor.deleteFragment(editor)\n                      return\n                    }\n                    const inline = Editor.above(editor, {\n                      match: n =>\n                        Element.isElement(n) && Editor.isInline(editor, n),\n                      mode: 'highest',\n                    })\n                    if (inline) {\n                      const [, inlinePath] = inline\n                      if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n                        const point = Editor.after(editor, inlinePath)!\n                        Transforms.setSelection(editor, {\n                          anchor: point,\n                          focus: point,\n                        })\n                      }\n                    }\n                  }\n                }\n              },\n              [attributes.onCompositionStart, editor]\n            )}\n            onCopy={useCallback(\n              (event: React.ClipboardEvent<HTMLDivElement>) => {\n                if (\n                  ReactEditor.hasSelectableTarget(editor, event.target) &&\n                  !isEventHandled(event, attributes.onCopy) &&\n                  !isDOMEventTargetInput(event)\n                ) {\n                  event.preventDefault()\n                  ReactEditor.setFragmentData(\n                    editor,\n                    event.clipboardData,\n                    'copy'\n                  )\n                }\n              },\n              [attributes.onCopy, editor]\n            )}\n            onCut={useCallback(\n              (event: React.ClipboardEvent<HTMLDivElement>) => {\n                if (\n                  !readOnly &&\n                  ReactEditor.hasSelectableTarget(editor, event.target) &&\n                  !isEventHandled(event, attributes.onCut) &&\n                  !isDOMEventTargetInput(event)\n                ) {\n                  event.preventDefault()\n                  ReactEditor.setFragmentData(\n                    editor,\n                    event.clipboardData,\n                    'cut'\n                  )\n                  const { selection } = editor\n\n                  if (selection) {\n                    if (Range.isExpanded(selection)) {\n                      Editor.deleteFragment(editor)\n                    } else {\n                      const node = Node.parent(editor, selection.anchor.path)\n                      if (Editor.isVoid(editor, node)) {\n                        Transforms.delete(editor)\n                      }\n                    }\n                  }\n                }\n              },\n              [readOnly, editor, attributes.onCut]\n            )}\n            onDragOver={useCallback(\n              (event: React.DragEvent<HTMLDivElement>) => {\n                if (\n                  ReactEditor.hasTarget(editor, event.target) &&\n                  !isEventHandled(event, attributes.onDragOver)\n                ) {\n                  // Only when the target is void, call `preventDefault` to signal\n                  // that drops are allowed. Editable content is droppable by\n                  // default, and calling `preventDefault` hides the cursor.\n                  const node = ReactEditor.toSlateNode(editor, event.target)\n\n                  if (Element.isElement(node) && Editor.isVoid(editor, node)) {\n                    event.preventDefault()\n                  }\n                }\n              },\n              [attributes.onDragOver, editor]\n            )}\n            onDragStart={useCallback(\n              (event: React.DragEvent<HTMLDivElement>) => {\n                if (\n                  !readOnly &&\n                  ReactEditor.hasTarget(editor, event.target) &&\n                  !isEventHandled(event, attributes.onDragStart)\n                ) {\n                  const node = ReactEditor.toSlateNode(editor, event.target)\n                  const path = ReactEditor.findPath(editor, node)\n                  const voidMatch =\n                    (Element.isElement(node) && Editor.isVoid(editor, node)) ||\n                    Editor.void(editor, { at: path, voids: true })\n\n                  // If starting a drag on a void node, make sure it is selected\n                  // so that it shows up in the selection's fragment.\n                  if (voidMatch) {\n                    const range = Editor.range(editor, path)\n                    Transforms.select(editor, range)\n                  }\n\n                  state.isDraggingInternally = true\n\n                  ReactEditor.setFragmentData(\n                    editor,\n                    event.dataTransfer,\n                    'drag'\n                  )\n                }\n              },\n              [readOnly, editor, attributes.onDragStart, state]\n            )}\n            onDrop={useCallback(\n              (event: React.DragEvent<HTMLDivElement>) => {\n                if (\n                  !readOnly &&\n                  ReactEditor.hasTarget(editor, event.target) &&\n                  !isEventHandled(event, attributes.onDrop)\n                ) {\n                  event.preventDefault()\n\n                  // Keep a reference to the dragged range before updating selection\n                  const draggedRange = editor.selection\n\n                  // Find the range where the drop happened\n                  const range = ReactEditor.findEventRange(editor, event)\n                  const data = event.dataTransfer\n\n                  Transforms.select(editor, range)\n\n                  if (state.isDraggingInternally) {\n                    if (\n                      draggedRange &&\n                      !Range.equals(draggedRange, range) &&\n                      !Editor.void(editor, { at: range, voids: true })\n                    ) {\n                      Transforms.delete(editor, {\n                        at: draggedRange,\n                      })\n                    }\n                  }\n\n                  ReactEditor.insertData(editor, data)\n\n                  // When dragging from another source into the editor, it's possible\n                  // that the current editor does not have focus.\n                  if (!ReactEditor.isFocused(editor)) {\n                    ReactEditor.focus(editor)\n                  }\n                }\n\n                state.isDraggingInternally = false\n              },\n              [readOnly, editor, attributes.onDrop, state]\n            )}\n            onDragEnd={useCallback(\n              (event: React.DragEvent<HTMLDivElement>) => {\n                if (\n                  !readOnly &&\n                  state.isDraggingInternally &&\n                  attributes.onDragEnd &&\n                  ReactEditor.hasTarget(editor, event.target)\n                ) {\n                  attributes.onDragEnd(event)\n                }\n\n                // When dropping on a different droppable element than the current editor,\n                // `onDrop` is not called. So we need to clean up in `onDragEnd` instead.\n                // Note: `onDragEnd` is only called when `onDrop` is not called\n                state.isDraggingInternally = false\n              },\n              [readOnly, state, attributes, editor]\n            )}\n            onFocus={useCallback(\n              (event: React.FocusEvent<HTMLDivElement>) => {\n                if (\n                  !readOnly &&\n                  !state.isUpdatingSelection &&\n                  ReactEditor.hasEditableTarget(editor, event.target) &&\n                  !isEventHandled(event, attributes.onFocus)\n                ) {\n                  const el = ReactEditor.toDOMNode(editor, editor)\n                  const root = ReactEditor.findDocumentOrShadowRoot(editor)\n                  state.latestElement = root.activeElement\n\n                  // COMPAT: If the editor has nested editable elements, the focus\n                  // can go to them. In Firefox, this must be prevented because it\n                  // results in issues with keyboard navigation. (2017/03/30)\n                  if (IS_FIREFOX && event.target !== el) {\n                    el.focus()\n                    return\n                  }\n\n                  IS_FOCUSED.set(editor, true)\n                }\n              },\n              [readOnly, state, editor, attributes.onFocus]\n            )}\n            onKeyDown={useCallback(\n              (event: React.KeyboardEvent<HTMLDivElement>) => {\n                if (\n                  !readOnly &&\n                  ReactEditor.hasEditableTarget(editor, event.target)\n                ) {\n                  androidInputManagerRef.current?.handleKeyDown(event)\n\n                  const { nativeEvent } = event\n\n                  // COMPAT: The composition end event isn't fired reliably in all browsers,\n                  // so we sometimes might end up stuck in a composition state even though we\n                  // aren't composing any more.\n                  if (\n                    ReactEditor.isComposing(editor) &&\n                    nativeEvent.isComposing === false\n                  ) {\n                    IS_COMPOSING.set(editor, false)\n                    setIsComposing(false)\n                  }\n\n                  if (\n                    isEventHandled(event, attributes.onKeyDown) ||\n                    ReactEditor.isComposing(editor)\n                  ) {\n                    return\n                  }\n\n                  const { selection } = editor\n                  const element =\n                    editor.children[\n                      selection !== null ? selection.focus.path[0] : 0\n                    ]\n                  const isRTL = getDirection(Node.string(element)) === 'rtl'\n\n                  // COMPAT: Since we prevent the default behavior on\n                  // `beforeinput` events, the browser doesn't think there's ever\n                  // any history stack to undo or redo, so we have to manage these\n                  // hotkeys ourselves. (2019/11/06)\n                  if (Hotkeys.isRedo(nativeEvent)) {\n                    event.preventDefault()\n                    const maybeHistoryEditor: any = editor\n\n                    if (typeof maybeHistoryEditor.redo === 'function') {\n                      maybeHistoryEditor.redo()\n                    }\n\n                    return\n                  }\n\n                  if (Hotkeys.isUndo(nativeEvent)) {\n                    event.preventDefault()\n                    const maybeHistoryEditor: any = editor\n\n                    if (typeof maybeHistoryEditor.undo === 'function') {\n                      maybeHistoryEditor.undo()\n                    }\n\n                    return\n                  }\n\n                  // COMPAT: Certain browsers don't handle the selection updates\n                  // properly. In Chrome, the selection isn't properly extended.\n                  // And in Firefox, the selection isn't properly collapsed.\n                  // (2017/10/17)\n                  if (Hotkeys.isMoveLineBackward(nativeEvent)) {\n                    event.preventDefault()\n                    Transforms.move(editor, { unit: 'line', reverse: true })\n                    return\n                  }\n\n                  if (Hotkeys.isMoveLineForward(nativeEvent)) {\n                    event.preventDefault()\n                    Transforms.move(editor, { unit: 'line' })\n                    return\n                  }\n\n                  if (Hotkeys.isExtendLineBackward(nativeEvent)) {\n                    event.preventDefault()\n                    Transforms.move(editor, {\n                      unit: 'line',\n                      edge: 'focus',\n                      reverse: true,\n                    })\n                    return\n                  }\n\n                  if (Hotkeys.isExtendLineForward(nativeEvent)) {\n                    event.preventDefault()\n                    Transforms.move(editor, { unit: 'line', edge: 'focus' })\n                    return\n                  }\n\n                  // COMPAT: If a void node is selected, or a zero-width text node\n                  // adjacent to an inline is selected, we need to handle these\n                  // hotkeys manually because browsers won't be able to skip over\n                  // the void node with the zero-width space not being an empty\n                  // string.\n                  if (Hotkeys.isMoveBackward(nativeEvent)) {\n                    event.preventDefault()\n\n                    if (selection && Range.isCollapsed(selection)) {\n                      Transforms.move(editor, { reverse: !isRTL })\n                    } else {\n                      Transforms.collapse(editor, { edge: 'start' })\n                    }\n\n                    return\n                  }\n\n                  if (Hotkeys.isMoveForward(nativeEvent)) {\n                    event.preventDefault()\n\n                    if (selection && Range.isCollapsed(selection)) {\n                      Transforms.move(editor, { reverse: isRTL })\n                    } else {\n                      Transforms.collapse(editor, { edge: 'end' })\n                    }\n\n                    return\n                  }\n\n                  if (Hotkeys.isMoveWordBackward(nativeEvent)) {\n                    event.preventDefault()\n\n                    if (selection && Range.isExpanded(selection)) {\n                      Transforms.collapse(editor, { edge: 'focus' })\n                    }\n\n                    Transforms.move(editor, { unit: 'word', reverse: !isRTL })\n                    return\n                  }\n\n                  if (Hotkeys.isMoveWordForward(nativeEvent)) {\n                    event.preventDefault()\n\n                    if (selection && Range.isExpanded(selection)) {\n                      Transforms.collapse(editor, { edge: 'focus' })\n                    }\n\n                    Transforms.move(editor, { unit: 'word', reverse: isRTL })\n                    return\n                  }\n\n                  // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n                  // fall back to guessing at the input intention for hotkeys.\n                  // COMPAT: In iOS, some of these hotkeys are handled in the\n                  if (!HAS_BEFORE_INPUT_SUPPORT) {\n                    // We don't have a core behavior for these, but they change the\n                    // DOM if we don't prevent them, so we have to.\n                    if (\n                      Hotkeys.isBold(nativeEvent) ||\n                      Hotkeys.isItalic(nativeEvent) ||\n                      Hotkeys.isTransposeCharacter(nativeEvent)\n                    ) {\n                      event.preventDefault()\n                      return\n                    }\n\n                    if (Hotkeys.isSoftBreak(nativeEvent)) {\n                      event.preventDefault()\n                      Editor.insertSoftBreak(editor)\n                      return\n                    }\n\n                    if (Hotkeys.isSplitBlock(nativeEvent)) {\n                      event.preventDefault()\n                      Editor.insertBreak(editor)\n                      return\n                    }\n\n                    if (Hotkeys.isDeleteBackward(nativeEvent)) {\n                      event.preventDefault()\n\n                      if (selection && Range.isExpanded(selection)) {\n                        Editor.deleteFragment(editor, { direction: 'backward' })\n                      } else {\n                        Editor.deleteBackward(editor)\n                      }\n\n                      return\n                    }\n\n                    if (Hotkeys.isDeleteForward(nativeEvent)) {\n                      event.preventDefault()\n\n                      if (selection && Range.isExpanded(selection)) {\n                        Editor.deleteFragment(editor, { direction: 'forward' })\n                      } else {\n                        Editor.deleteForward(editor)\n                      }\n\n                      return\n                    }\n\n                    if (Hotkeys.isDeleteLineBackward(nativeEvent)) {\n                      event.preventDefault()\n\n                      if (selection && Range.isExpanded(selection)) {\n                        Editor.deleteFragment(editor, { direction: 'backward' })\n                      } else {\n                        Editor.deleteBackward(editor, { unit: 'line' })\n                      }\n\n                      return\n                    }\n\n                    if (Hotkeys.isDeleteLineForward(nativeEvent)) {\n                      event.preventDefault()\n\n                      if (selection && Range.isExpanded(selection)) {\n                        Editor.deleteFragment(editor, { direction: 'forward' })\n                      } else {\n                        Editor.deleteForward(editor, { unit: 'line' })\n                      }\n\n                      return\n                    }\n\n                    if (Hotkeys.isDeleteWordBackward(nativeEvent)) {\n                      event.preventDefault()\n\n                      if (selection && Range.isExpanded(selection)) {\n                        Editor.deleteFragment(editor, { direction: 'backward' })\n                      } else {\n                        Editor.deleteBackward(editor, { unit: 'word' })\n                      }\n\n                      return\n                    }\n\n                    if (Hotkeys.isDeleteWordForward(nativeEvent)) {\n                      event.preventDefault()\n\n                      if (selection && Range.isExpanded(selection)) {\n                        Editor.deleteFragment(editor, { direction: 'forward' })\n                      } else {\n                        Editor.deleteForward(editor, { unit: 'word' })\n                      }\n\n                      return\n                    }\n                  } else {\n                    if (IS_CHROME || IS_SAFARI) {\n                      // COMPAT: Chrome and Safari support `beforeinput` event but do not fire\n                      // an event when deleting backwards in a selected void inline node\n                      if (\n                        selection &&\n                        (Hotkeys.isDeleteBackward(nativeEvent) ||\n                          Hotkeys.isDeleteForward(nativeEvent)) &&\n                        Range.isCollapsed(selection)\n                      ) {\n                        const currentNode = Node.parent(\n                          editor,\n                          selection.anchor.path\n                        )\n\n                        if (\n                          Element.isElement(currentNode) &&\n                          Editor.isVoid(editor, currentNode) &&\n                          (Editor.isInline(editor, currentNode) ||\n                            Editor.isBlock(editor, currentNode))\n                        ) {\n                          event.preventDefault()\n                          Editor.deleteBackward(editor, { unit: 'block' })\n\n                          return\n                        }\n                      }\n                    }\n                  }\n                }\n              },\n              [readOnly, editor, attributes.onKeyDown]\n            )}\n            onPaste={useCallback(\n              (event: React.ClipboardEvent<HTMLDivElement>) => {\n                if (\n                  !readOnly &&\n                  ReactEditor.hasEditableTarget(editor, event.target) &&\n                  !isEventHandled(event, attributes.onPaste)\n                ) {\n                  // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n                  // fall back to React's `onPaste` here instead.\n                  // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events\n                  // when \"paste without formatting\" is used, so fallback. (2020/02/20)\n                  // COMPAT: Safari InputEvents generated by pasting won't include\n                  // application/x-slate-fragment items, so use the\n                  // ClipboardEvent here. (2023/03/15)\n                  if (\n                    !HAS_BEFORE_INPUT_SUPPORT ||\n                    isPlainTextOnlyPaste(event.nativeEvent) ||\n                    IS_SAFARI\n                  ) {\n                    event.preventDefault()\n                    ReactEditor.insertData(editor, event.clipboardData)\n                  }\n                }\n              },\n              [readOnly, editor, attributes.onPaste]\n            )}\n          >\n            <Children\n              decorations={decorations}\n              node={editor}\n              renderElement={renderElement}\n              renderPlaceholder={renderPlaceholder}\n              renderLeaf={renderLeaf}\n              selection={editor.selection}\n              cursors={cursors}\n              composingNode={composingNode}\n            />\n          </Component>\n        </RestoreDOM>\n      </DecorateContext.Provider>\n    </ReadOnlyContext.Provider>\n  )\n}\n\n/**\n * The props that get passed to renderPlaceholder\n */\nexport type RenderPlaceholderProps = {\n  children: any\n  attributes: {\n    'data-slate-placeholder': boolean\n    dir?: 'rtl'\n    contentEditable: boolean\n    ref: React.RefCallback<any>\n    style: React.CSSProperties\n  }\n}\n\n/**\n * The default placeholder element\n */\n\nexport const DefaultPlaceholder = ({\n  attributes,\n  children,\n}: RenderPlaceholderProps) => (\n  // COMPAT: Artificially add a line-break to the end on the placeholder element\n  // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter\n  <span {...attributes}>\n    {children}\n    {IS_ANDROID && <br />}\n  </span>\n)\n\n/**\n * A default memoized decorate function.\n */\n\nexport const defaultDecorate: (entry: NodeEntry) => Range[] = () => []\n\n/**\n * A default implement to scroll dom range into view.\n */\n\nconst defaultScrollSelectionIntoView = (\n  editor: ReactEditor,\n  domRange: DOMRange\n) => {\n  // This was affecting the selection of multiple blocks and dragging behavior,\n  // so enabled only if the selection has been collapsed.\n  if (\n    domRange.getBoundingClientRect &&\n    (!editor.selection ||\n      (editor.selection && Range.isCollapsed(editor.selection)))\n  ) {\n    const leafEl = domRange.startContainer.parentElement!\n    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange)\n    scrollIntoView(leafEl, {\n      scrollMode: 'if-needed',\n    })\n\n    // @ts-expect-error an unorthodox delete D:\n    delete leafEl.getBoundingClientRect\n  }\n}\n\n/**\n * Check if an event is overrided by a handler.\n */\n\nexport const isEventHandled = <\n  EventType extends React.SyntheticEvent<unknown, unknown>\n>(\n  event: EventType,\n  handler?: (event: EventType) => void | boolean\n) => {\n  if (!handler) {\n    return false\n  }\n  // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n  const shouldTreatEventAsHandled = handler(event)\n\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled\n  }\n\n  return event.isDefaultPrevented() || event.isPropagationStopped()\n}\n\n/**\n * Check if the event's target is an input element\n */\nexport const isDOMEventTargetInput = <\n  EventType extends React.SyntheticEvent<unknown, unknown>\n>(\n  event: EventType\n) => {\n  return (\n    isDOMNode(event.target) &&\n    (event.target instanceof HTMLInputElement ||\n      event.target instanceof HTMLTextAreaElement)\n  )\n}\n\n/**\n * Check if a DOM event is overrided by a handler.\n */\n\nexport const isDOMEventHandled = <E extends Event>(\n  event: E,\n  handler?: (event: E) => void | boolean\n) => {\n  if (!handler) {\n    return false\n  }\n\n  // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n  const shouldTreatEventAsHandled = handler(event)\n\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled\n  }\n\n  return event.defaultPrevented\n}\n","import { createContext, useContext } from 'react'\n\n/**\n * A React context for sharing the `focused` state of the editor.\n */\n\nexport const FocusedContext = createContext(false)\n\n/**\n * Get the current `focused` state of the editor.\n */\n\nexport const useFocused = (): boolean => {\n  return useContext(FocusedContext)\n}\n","import {\n  createContext,\n  useCallback,\n  useContext,\n  useMemo,\n  useReducer,\n  useRef,\n} from 'react'\nimport { Editor } from '@seafile/slate'\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect'\n\nfunction isError(error: any): error is Error {\n  return error instanceof Error\n}\n\ntype EditorChangeHandler = (editor: Editor) => void\n/**\n * A React context for sharing the editor selector context in a way to control rerenders\n */\n\nexport const SlateSelectorContext = createContext<{\n  getSlate: () => Editor\n  addEventListener: (callback: EditorChangeHandler) => () => void\n}>({} as any)\n\nconst refEquality = (a: any, b: any) => a === b\n\n/**\n * use redux style selectors to prevent rerendering on every keystroke.\n * Bear in mind rerendering can only prevented if the returned value is a value type or for reference types (e.g. objects and arrays) add a custom equality function.\n *\n * Example:\n * ```\n *  const isSelectionActive = useSlateSelector(editor => Boolean(editor.selection));\n * ```\n */\nexport function useSlateSelector<T>(\n  selector: (editor: Editor) => T,\n  equalityFn: (a: T, b: T) => boolean = refEquality\n) {\n  const [, forceRender] = useReducer(s => s + 1, 0)\n  const context = useContext(SlateSelectorContext)\n  if (!context) {\n    throw new Error(\n      `The \\`useSlateSelector\\` hook must be used inside the <Slate> component's context.`\n    )\n  }\n  const { getSlate, addEventListener } = context\n\n  const latestSubscriptionCallbackError = useRef<Error | undefined>()\n  const latestSelector = useRef<(editor: Editor) => T>(() => null as any)\n  const latestSelectedState = useRef<T>((null as any) as T)\n  let selectedState: T\n\n  try {\n    if (\n      selector !== latestSelector.current ||\n      latestSubscriptionCallbackError.current\n    ) {\n      selectedState = selector(getSlate())\n    } else {\n      selectedState = latestSelectedState.current\n    }\n  } catch (err) {\n    if (latestSubscriptionCallbackError.current && isError(err)) {\n      err.message += `\\nThe error may be correlated with this previous error:\\n${latestSubscriptionCallbackError.current.stack}\\n\\n`\n    }\n\n    throw err\n  }\n  useIsomorphicLayoutEffect(() => {\n    latestSelector.current = selector\n    latestSelectedState.current = selectedState\n    latestSubscriptionCallbackError.current = undefined\n  })\n\n  useIsomorphicLayoutEffect(\n    () => {\n      function checkForUpdates() {\n        try {\n          const newSelectedState = latestSelector.current(getSlate())\n\n          if (equalityFn(newSelectedState, latestSelectedState.current)) {\n            return\n          }\n\n          latestSelectedState.current = newSelectedState\n        } catch (err) {\n          // we ignore all errors here, since when the component\n          // is re-rendered, the selectors are called again, and\n          // will throw again, if neither props nor store state\n          // changed\n          latestSubscriptionCallbackError.current = err\n        }\n\n        forceRender()\n      }\n\n      const unsubscribe = addEventListener(checkForUpdates)\n\n      checkForUpdates()\n\n      return () => unsubscribe()\n    },\n    // don't rerender on equalityFn change since we want to be able to define it inline\n    [addEventListener, getSlate]\n  )\n\n  return selectedState\n}\n\n/**\n * Create selector context with editor updating on every editor change\n */\nexport function useSelectorContext(editor: Editor) {\n  const eventListeners = useRef<EditorChangeHandler[]>([]).current\n  const slateRef = useRef<{\n    editor: Editor\n  }>({\n    editor,\n  }).current\n  const onChange = useCallback(\n    (editor: Editor) => {\n      slateRef.editor = editor\n      eventListeners.forEach((listener: EditorChangeHandler) =>\n        listener(editor)\n      )\n    },\n    [eventListeners, slateRef]\n  )\n\n  const selectorContext = useMemo(() => {\n    return {\n      getSlate: () => slateRef.editor,\n      addEventListener: (callback: EditorChangeHandler) => {\n        eventListeners.push(callback)\n        return () => {\n          eventListeners.splice(eventListeners.indexOf(callback), 1)\n        }\n      },\n    }\n  }, [eventListeners, slateRef])\n  return { selectorContext, onChange }\n}\n","import React, { useState, useCallback, useEffect, useRef } from 'react'\nimport { Editor, Node, Descendant, Scrubber } from '@seafile/slate'\nimport { ReactEditor } from '../plugin/react-editor'\nimport { FocusedContext } from '../hooks/use-focused'\nimport { EditorContext } from '../hooks/use-slate-static'\nimport { SlateContext, SlateContextValue } from '../hooks/use-slate'\nimport {\n  useSelectorContext,\n  SlateSelectorContext,\n} from '../hooks/use-slate-selector'\nimport { EDITOR_TO_ON_CHANGE } from '../utils/weak-maps'\nimport { IS_REACT_VERSION_17_OR_ABOVE } from '../utils/environment'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\n\n/**\n * A wrapper around the provider to handle `onChange` events, because the editor\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\n */\n\nexport const Slate = (props: {\n  editor: ReactEditor\n  value: Descendant[]\n  children: React.ReactNode\n  onChange?: (value: Descendant[]) => void\n}) => {\n  const { editor, children, onChange, value, ...rest } = props\n  const unmountRef = useRef(false)\n\n  const [context, setContext] = React.useState<SlateContextValue>(() => {\n    if (!Node.isNodeList(value)) {\n      throw new Error(\n        `[Slate] value is invalid! Expected a list of elements but got: ${Scrubber.stringify(\n          value\n        )}`\n      )\n    }\n    if (!Editor.isEditor(editor)) {\n      throw new Error(\n        `[Slate] editor is invalid! You passed: ${Scrubber.stringify(editor)}`\n      )\n    }\n    editor.children = value\n    Object.assign(editor, rest)\n    return { v: 0, editor }\n  })\n\n  const {\n    selectorContext,\n    onChange: handleSelectorChange,\n  } = useSelectorContext(editor)\n\n  const onContextChange = useCallback(() => {\n    if (onChange) {\n      onChange(editor.children)\n    }\n\n    setContext(prevContext => ({\n      v: prevContext.v + 1,\n      editor,\n    }))\n    handleSelectorChange(editor)\n  }, [editor, handleSelectorChange, onChange])\n\n  useEffect(() => {\n    EDITOR_TO_ON_CHANGE.set(editor, onContextChange)\n\n    return () => {\n      EDITOR_TO_ON_CHANGE.set(editor, () => {})\n      unmountRef.current = true\n    }\n  }, [editor, onContextChange])\n\n  const [isFocused, setIsFocused] = useState(ReactEditor.isFocused(editor))\n\n  useEffect(() => {\n    setIsFocused(ReactEditor.isFocused(editor))\n  }, [editor])\n\n  useIsomorphicLayoutEffect(() => {\n    const fn = () => setIsFocused(ReactEditor.isFocused(editor))\n    if (IS_REACT_VERSION_17_OR_ABOVE) {\n      // In React >= 17 onFocus and onBlur listen to the focusin and focusout events during the bubbling phase.\n      // Therefore in order for <Editable />'s handlers to run first, which is necessary for ReactEditor.isFocused(editor)\n      // to return the correct value, we have to listen to the focusin and focusout events without useCapture here.\n      document.addEventListener('focusin', fn)\n      document.addEventListener('focusout', fn)\n      return () => {\n        document.removeEventListener('focusin', fn)\n        document.removeEventListener('focusout', fn)\n      }\n    } else {\n      document.addEventListener('focus', fn, true)\n      document.addEventListener('blur', fn, true)\n      return () => {\n        document.removeEventListener('focus', fn, true)\n        document.removeEventListener('blur', fn, true)\n      }\n    }\n  }, [])\n\n  return (\n    <SlateSelectorContext.Provider value={selectorContext}>\n      <SlateContext.Provider value={context}>\n        <EditorContext.Provider value={context.editor}>\n          <FocusedContext.Provider value={isFocused}>\n            {children}\n          </FocusedContext.Provider>\n        </EditorContext.Provider>\n      </SlateContext.Provider>\n    </SlateSelectorContext.Provider>\n  )\n}\n","import { useContext } from 'react'\n\nimport { EditorContext } from './use-slate-static'\n\n/**\n * Get the current editor object from the React context.\n * @deprecated Use useSlateStatic instead.\n */\n\nexport const useEditor = () => {\n  const editor = useContext(EditorContext)\n\n  if (!editor) {\n    throw new Error(\n      `The \\`useEditor\\` hook must be used inside the <Slate> component's context.`\n    )\n  }\n\n  return editor\n}\n","import { BaseSelection, Range } from '@seafile/slate'\n\nimport { useSlateSelector } from './use-slate-selector'\n\n/**\n * Get the current slate selection.\n * Only triggers a rerender when the selection actually changes\n */\nexport const useSlateSelection = () => {\n  return useSlateSelector(editor => editor.selection, isSelectionEqual)\n}\n\nconst isSelectionEqual = (a: BaseSelection, b: BaseSelection) => {\n  if (!a && !b) return true\n  if (!a || !b) return false\n  return Range.equals(a, b)\n}\n","/**\n * Utilities for single-line deletion\n */\n\nimport { Range, Editor } from '@seafile/slate'\nimport { ReactEditor } from '../plugin/react-editor'\n\nconst doRectsIntersect = (rect: DOMRect, compareRect: DOMRect) => {\n  const middle = (compareRect.top + compareRect.bottom) / 2\n\n  return rect.top <= middle && rect.bottom >= middle\n}\n\nconst areRangesSameLine = (\n  editor: ReactEditor,\n  range1: Range,\n  range2: Range\n) => {\n  const rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect()\n  const rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect()\n\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1)\n}\n\n/**\n * A helper utility that returns the end portion of a `Range`\n * which is located on a single line.\n *\n * @param {Editor} editor The editor object to compare against\n * @param {Range} parentRange The parent range to compare against\n * @returns {Range} A valid portion of the parentRange which is one a single line\n */\nexport const findCurrentLineRange = (\n  editor: ReactEditor,\n  parentRange: Range\n): Range => {\n  const parentRangeBoundary = Editor.range(editor, Range.end(parentRange))\n  const positions = Array.from(Editor.positions(editor, { at: parentRange }))\n\n  let left = 0\n  let right = positions.length\n  let middle = Math.floor(right / 2)\n\n  if (\n    areRangesSameLine(\n      editor,\n      Editor.range(editor, positions[left]),\n      parentRangeBoundary\n    )\n  ) {\n    return Editor.range(editor, positions[left], parentRangeBoundary)\n  }\n\n  if (positions.length < 2) {\n    return Editor.range(\n      editor,\n      positions[positions.length - 1],\n      parentRangeBoundary\n    )\n  }\n\n  while (middle !== positions.length && middle !== left) {\n    if (\n      areRangesSameLine(\n        editor,\n        Editor.range(editor, positions[middle]),\n        parentRangeBoundary\n      )\n    ) {\n      right = middle\n    } else {\n      left = middle\n    }\n\n    middle = Math.floor((left + right) / 2)\n  }\n\n  return Editor.range(editor, positions[right], parentRangeBoundary)\n}\n","import ReactDOM from 'react-dom'\nimport {\n  BaseEditor,\n  Editor,\n  Element,\n  Node,\n  Operation,\n  Path,\n  Point,\n  Range,\n  Transforms,\n} from '@seafile/slate'\nimport {\n  TextDiff,\n  transformPendingPoint,\n  transformPendingRange,\n  transformTextDiff,\n} from '../utils/diff-text'\nimport {\n  getPlainText,\n  getSlateFragmentAttribute,\n  isDOMText,\n} from '../utils/dom'\nimport { Key } from '../utils/key'\nimport { findCurrentLineRange } from '../utils/lines'\nimport {\n  EDITOR_TO_KEY_TO_ELEMENT,\n  EDITOR_TO_ON_CHANGE,\n  EDITOR_TO_PENDING_ACTION,\n  EDITOR_TO_PENDING_DIFFS,\n  EDITOR_TO_PENDING_INSERTION_MARKS,\n  EDITOR_TO_PENDING_SELECTION,\n  EDITOR_TO_SCHEDULE_FLUSH,\n  EDITOR_TO_USER_MARKS,\n  EDITOR_TO_USER_SELECTION,\n  NODE_TO_KEY,\n} from '../utils/weak-maps'\nimport { ReactEditor } from './react-editor'\n\n/**\n * `withReact` adds React and DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\n\nexport const withReact = <T extends BaseEditor>(\n  editor: T,\n  clipboardFormatKey = 'x-slate-fragment'\n): T & ReactEditor => {\n  const e = editor as T & ReactEditor\n  const { apply, onChange, deleteBackward, addMark, removeMark } = e\n\n  // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap())\n\n  e.addMark = (key, value) => {\n    EDITOR_TO_SCHEDULE_FLUSH.get(e)?.()\n\n    if (\n      !EDITOR_TO_PENDING_INSERTION_MARKS.get(e) &&\n      EDITOR_TO_PENDING_DIFFS.get(e)?.length\n    ) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null)\n    }\n\n    EDITOR_TO_USER_MARKS.delete(e)\n\n    addMark(key, value)\n  }\n\n  e.removeMark = key => {\n    if (\n      !EDITOR_TO_PENDING_INSERTION_MARKS.get(e) &&\n      EDITOR_TO_PENDING_DIFFS.get(e)?.length\n    ) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null)\n    }\n\n    EDITOR_TO_USER_MARKS.delete(e)\n\n    removeMark(key)\n  }\n\n  e.deleteBackward = unit => {\n    if (unit !== 'line') {\n      return deleteBackward(unit)\n    }\n\n    if (e.selection && Range.isCollapsed(e.selection)) {\n      const parentBlockEntry = Editor.above(e, {\n        match: n => Element.isElement(n) && Editor.isBlock(e, n),\n        at: e.selection,\n      })\n\n      if (parentBlockEntry) {\n        const [, parentBlockPath] = parentBlockEntry\n        const parentElementRange = Editor.range(\n          e,\n          parentBlockPath,\n          e.selection.anchor\n        )\n\n        const currentLineRange = findCurrentLineRange(e, parentElementRange)\n\n        if (!Range.isCollapsed(currentLineRange)) {\n          Transforms.delete(e, { at: currentLineRange })\n        }\n      }\n    }\n  }\n\n  // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n  e.apply = (op: Operation) => {\n    const matches: [Path, Key][] = []\n\n    const pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e)\n    if (pendingDiffs?.length) {\n      const transformed = pendingDiffs\n        .map(textDiff => transformTextDiff(textDiff, op))\n        .filter(Boolean) as TextDiff[]\n\n      EDITOR_TO_PENDING_DIFFS.set(e, transformed)\n    }\n\n    const pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e)\n    if (pendingSelection) {\n      EDITOR_TO_PENDING_SELECTION.set(\n        e,\n        transformPendingRange(e, pendingSelection, op)\n      )\n    }\n\n    const pendingAction = EDITOR_TO_PENDING_ACTION.get(e)\n    if (pendingAction?.at) {\n      const at = Point.isPoint(pendingAction?.at)\n        ? transformPendingPoint(e, pendingAction.at, op)\n        : transformPendingRange(e, pendingAction.at, op)\n\n      EDITOR_TO_PENDING_ACTION.set(e, at ? { ...pendingAction, at } : null)\n    }\n\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node': {\n        matches.push(...getMatches(e, op.path))\n        break\n      }\n\n      case 'set_selection': {\n        // Selection was manually set, don't restore the user selection after the change.\n        EDITOR_TO_USER_SELECTION.get(e)?.unref()\n        EDITOR_TO_USER_SELECTION.delete(e)\n        break\n      }\n\n      case 'insert_node':\n      case 'remove_node': {\n        matches.push(...getMatches(e, Path.parent(op.path)))\n        break\n      }\n\n      case 'merge_node': {\n        const prevPath = Path.previous(op.path)\n        matches.push(...getMatches(e, prevPath))\n        break\n      }\n\n      case 'move_node': {\n        const commonPath = Path.common(\n          Path.parent(op.path),\n          Path.parent(op.newPath)\n        )\n        matches.push(...getMatches(e, commonPath))\n        break\n      }\n    }\n\n    apply(op)\n\n    for (const [path, key] of matches) {\n      const [node] = Editor.node(e, path)\n      NODE_TO_KEY.set(node, key)\n    }\n  }\n\n  e.setFragmentData = (data: Pick<DataTransfer, 'getData' | 'setData'>) => {\n    const { selection } = e\n\n    if (!selection) {\n      return\n    }\n\n    const [start, end] = Range.edges(selection)\n    const startVoid = Editor.void(e, { at: start.path })\n    const endVoid = Editor.void(e, { at: end.path })\n\n    if (Range.isCollapsed(selection) && !startVoid) {\n      return\n    }\n\n    // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n    const domRange = ReactEditor.toDOMRange(e, selection)\n    let contents = domRange.cloneContents()\n    let attach = contents.childNodes[0] as HTMLElement\n\n    // Make sure attach is non-empty, since empty nodes will not get copied.\n    contents.childNodes.forEach(node => {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node as HTMLElement\n      }\n    })\n\n    // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n    if (endVoid) {\n      const [voidNode] = endVoid\n      const r = domRange.cloneRange()\n      const domNode = ReactEditor.toDOMNode(e, voidNode)\n      r.setEndAfter(domNode)\n      contents = r.cloneContents()\n    }\n\n    // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]')! as HTMLElement\n    }\n\n    // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(\n      zw => {\n        const isNewline = zw.getAttribute('data-slate-zero-width') === 'n'\n        zw.textContent = isNewline ? '\\n' : ''\n      }\n    )\n\n    // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n    if (isDOMText(attach)) {\n      const span = attach.ownerDocument.createElement('span')\n      // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n      span.style.whiteSpace = 'pre'\n      span.appendChild(attach)\n      contents.appendChild(span)\n      attach = span\n    }\n\n    const fragment = e.getFragment()\n    const string = JSON.stringify(fragment)\n    const encoded = window.btoa(encodeURIComponent(string))\n    attach.setAttribute('data-slate-fragment', encoded)\n    data.setData(`application/${clipboardFormatKey}`, encoded)\n\n    // Add the content to a <div> so that we can get its inner HTML.\n    const div = contents.ownerDocument.createElement('div')\n    div.appendChild(contents)\n    div.setAttribute('hidden', 'true')\n    contents.ownerDocument.body.appendChild(div)\n    data.setData('text/html', div.innerHTML)\n    data.setData('text/plain', getPlainText(div))\n    contents.ownerDocument.body.removeChild(div)\n    return data\n  }\n\n  e.insertData = (data: DataTransfer) => {\n    if (!e.insertFragmentData(data)) {\n      e.insertTextData(data)\n    }\n  }\n\n  e.insertFragmentData = (data: DataTransfer): boolean => {\n    /**\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\n     */\n    const fragment =\n      data.getData(`application/${clipboardFormatKey}`) ||\n      getSlateFragmentAttribute(data)\n\n    if (fragment) {\n      const decoded = decodeURIComponent(window.atob(fragment))\n      const parsed = JSON.parse(decoded) as Node[]\n      e.insertFragment(parsed)\n      return true\n    }\n    return false\n  }\n\n  e.insertTextData = (data: DataTransfer): boolean => {\n    const text = data.getData('text/plain')\n\n    if (text) {\n      const lines = text.split(/\\r\\n|\\r|\\n/)\n      let split = false\n\n      for (const line of lines) {\n        if (split) {\n          Transforms.splitNodes(e, { always: true })\n        }\n\n        e.insertText(line)\n        split = true\n      }\n      return true\n    }\n    return false\n  }\n\n  e.onChange = options => {\n    // COMPAT: React doesn't batch `setState` hook calls, which means that the\n    // children and selection can get out of sync for one render pass. So we\n    // have to use this unstable API to ensure it batches them. (2019/12/03)\n    // https://github.com/facebook/react/issues/14259#issuecomment-439702367\n    ReactDOM.unstable_batchedUpdates(() => {\n      const onContextChange = EDITOR_TO_ON_CHANGE.get(e)\n\n      if (onContextChange) {\n        onContextChange()\n      }\n\n      onChange(options)\n    })\n  }\n\n  return e\n}\n\nconst getMatches = (e: Editor, path: Path) => {\n  const matches: [Path, Key][] = []\n  for (const [n, p] of Editor.levels(e, { at: path })) {\n    const key = ReactEditor.findKey(e, n)\n    matches.push([p, key])\n  }\n  return matches\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}