{"ast":null,"code":"function words(str) {\n  var obj = {},\n    words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\nvar blockKeywordsStr = \"body catch class do else enum for foreach foreach_reverse if in interface mixin \" + \"out scope struct switch try union unittest version while with\";\nvar parserConfig = {\n  keywords: words(\"abstract alias align asm assert auto break case cast cdouble cent cfloat const continue \" + \"debug default delegate delete deprecated export extern final finally function goto immutable \" + \"import inout invariant is lazy macro module new nothrow override package pragma private \" + \"protected public pure ref return shared short static super synchronized template this \" + \"throw typedef typeid typeof volatile __FILE__ __LINE__ __gshared __traits __vector __parameters \" + blockKeywordsStr),\n  blockKeywords: words(blockKeywordsStr),\n  builtin: words(\"bool byte char creal dchar double float idouble ifloat int ireal long real short ubyte \" + \"ucent uint ulong ushort wchar wstring void size_t sizediff_t\"),\n  atoms: words(\"exit failure success true false null\"),\n  hooks: {\n    \"@\": function _(stream, _state) {\n      stream.eatWhile(/[\\w\\$_]/);\n      return \"meta\";\n    }\n  }\n};\nvar statementIndentUnit = parserConfig.statementIndentUnit,\n  keywords = parserConfig.keywords,\n  builtin = parserConfig.builtin,\n  blockKeywords = parserConfig.blockKeywords,\n  atoms = parserConfig.atoms,\n  hooks = parserConfig.hooks,\n  multiLineStrings = parserConfig.multiLineStrings;\nvar isOperatorChar = /[+\\-*&%=<>!?|\\/]/;\nvar curPunc;\nfunction tokenBase(stream, state) {\n  var ch = stream.next();\n  if (hooks[ch]) {\n    var result = hooks[ch](stream, state);\n    if (result !== false) return result;\n  }\n  if (ch == '\"' || ch == \"'\" || ch == \"`\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  }\n  if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    curPunc = ch;\n    return null;\n  }\n  if (/\\d/.test(ch)) {\n    stream.eatWhile(/[\\w\\.]/);\n    return \"number\";\n  }\n  if (ch == \"/\") {\n    if (stream.eat(\"+\")) {\n      state.tokenize = tokenNestedComment;\n      return tokenNestedComment(stream, state);\n    }\n    if (stream.eat(\"*\")) {\n      state.tokenize = tokenComment;\n      return tokenComment(stream, state);\n    }\n    if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n  }\n  if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return \"operator\";\n  }\n  stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n  var cur = stream.current();\n  if (keywords.propertyIsEnumerable(cur)) {\n    if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n    return \"keyword\";\n  }\n  if (builtin.propertyIsEnumerable(cur)) {\n    if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n    return \"builtin\";\n  }\n  if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n  return \"variable\";\n}\nfunction tokenString(quote) {\n  return function (stream, state) {\n    var escaped = false,\n      next,\n      end = false;\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped) {\n        end = true;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    if (end || !(escaped || multiLineStrings)) state.tokenize = null;\n    return \"string\";\n  };\n}\nfunction tokenComment(stream, state) {\n  var maybeEnd = false,\n    ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = null;\n      break;\n    }\n    maybeEnd = ch == \"*\";\n  }\n  return \"comment\";\n}\nfunction tokenNestedComment(stream, state) {\n  var maybeEnd = false,\n    ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = null;\n      break;\n    }\n    maybeEnd = ch == \"+\";\n  }\n  return \"comment\";\n}\nfunction Context(indented, column, type, align, prev) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.align = align;\n  this.prev = prev;\n}\nfunction pushContext(state, col, type) {\n  var indent = state.indented;\n  if (state.context && state.context.type == \"statement\") indent = state.context.indented;\n  return state.context = new Context(indent, col, type, null, state.context);\n}\nfunction popContext(state) {\n  var t = state.context.type;\n  if (t == \")\" || t == \"]\" || t == \"}\") state.indented = state.context.indented;\n  return state.context = state.context.prev;\n}\n\n// Interface\n\nexport var d = {\n  name: \"d\",\n  startState: function startState(indentUnit) {\n    return {\n      tokenize: null,\n      context: new Context(-indentUnit, 0, \"top\", false),\n      indented: 0,\n      startOfLine: true\n    };\n  },\n  token: function token(stream, state) {\n    var ctx = state.context;\n    if (stream.sol()) {\n      if (ctx.align == null) ctx.align = false;\n      state.indented = stream.indentation();\n      state.startOfLine = true;\n    }\n    if (stream.eatSpace()) return null;\n    curPunc = null;\n    var style = (state.tokenize || tokenBase)(stream, state);\n    if (style == \"comment\" || style == \"meta\") return style;\n    if (ctx.align == null) ctx.align = true;\n    if ((curPunc == \";\" || curPunc == \":\" || curPunc == \",\") && ctx.type == \"statement\") popContext(state);else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");else if (curPunc == \"}\") {\n      while (ctx.type == \"statement\") ctx = popContext(state);\n      if (ctx.type == \"}\") ctx = popContext(state);\n      while (ctx.type == \"statement\") ctx = popContext(state);\n    } else if (curPunc == ctx.type) popContext(state);else if ((ctx.type == \"}\" || ctx.type == \"top\") && curPunc != ';' || ctx.type == \"statement\" && curPunc == \"newstatement\") pushContext(state, stream.column(), \"statement\");\n    state.startOfLine = false;\n    return style;\n  },\n  indent: function indent(state, textAfter, cx) {\n    if (state.tokenize != tokenBase && state.tokenize != null) return null;\n    var ctx = state.context,\n      firstChar = textAfter && textAfter.charAt(0);\n    if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n    var closing = firstChar == ctx.type;\n    if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit || cx.unit);else if (ctx.align) return ctx.column + (closing ? 0 : 1);else return ctx.indented + (closing ? 0 : cx.unit);\n  },\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    }\n  }\n};","map":{"version":3,"names":["words","str","obj","split","i","length","blockKeywordsStr","parserConfig","keywords","blockKeywords","builtin","atoms","hooks","_","stream","_state","eatWhile","statementIndentUnit","multiLineStrings","isOperatorChar","curPunc","tokenBase","state","ch","next","result","tokenize","tokenString","test","eat","tokenNestedComment","tokenComment","skipToEnd","cur","current","propertyIsEnumerable","quote","escaped","end","maybeEnd","Context","indented","column","type","align","prev","pushContext","col","indent","context","popContext","t","d","name","startState","indentUnit","startOfLine","token","ctx","sol","indentation","eatSpace","style","textAfter","cx","firstChar","charAt","closing","unit","languageData","indentOnInput","commentTokens","line","block","open","close"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@codemirror/legacy-modes/mode/d.js"],"sourcesContent":["function words(str) {\n  var obj = {}, words = str.split(\" \");\n  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n  return obj;\n}\n\nvar blockKeywordsStr = \"body catch class do else enum for foreach foreach_reverse if in interface mixin \" +\n    \"out scope struct switch try union unittest version while with\";\n\nconst parserConfig = {\n  keywords: words(\"abstract alias align asm assert auto break case cast cdouble cent cfloat const continue \" +\n                  \"debug default delegate delete deprecated export extern final finally function goto immutable \" +\n                  \"import inout invariant is lazy macro module new nothrow override package pragma private \" +\n                  \"protected public pure ref return shared short static super synchronized template this \" +\n                  \"throw typedef typeid typeof volatile __FILE__ __LINE__ __gshared __traits __vector __parameters \" +\n                  blockKeywordsStr),\n  blockKeywords: words(blockKeywordsStr),\n  builtin: words(\"bool byte char creal dchar double float idouble ifloat int ireal long real short ubyte \" +\n                 \"ucent uint ulong ushort wchar wstring void size_t sizediff_t\"),\n  atoms: words(\"exit failure success true false null\"),\n  hooks: {\n    \"@\": function(stream, _state) {\n      stream.eatWhile(/[\\w\\$_]/);\n      return \"meta\";\n    }\n  }\n}\n\nvar statementIndentUnit = parserConfig.statementIndentUnit,\n    keywords = parserConfig.keywords,\n    builtin = parserConfig.builtin,\n    blockKeywords = parserConfig.blockKeywords,\n    atoms = parserConfig.atoms,\n    hooks = parserConfig.hooks,\n    multiLineStrings = parserConfig.multiLineStrings;\nvar isOperatorChar = /[+\\-*&%=<>!?|\\/]/;\n\nvar curPunc;\n\nfunction tokenBase(stream, state) {\n  var ch = stream.next();\n  if (hooks[ch]) {\n    var result = hooks[ch](stream, state);\n    if (result !== false) return result;\n  }\n  if (ch == '\"' || ch == \"'\" || ch == \"`\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  }\n  if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    curPunc = ch;\n    return null;\n  }\n  if (/\\d/.test(ch)) {\n    stream.eatWhile(/[\\w\\.]/);\n    return \"number\";\n  }\n  if (ch == \"/\") {\n    if (stream.eat(\"+\")) {\n      state.tokenize = tokenNestedComment;\n      return tokenNestedComment(stream, state);\n    }\n    if (stream.eat(\"*\")) {\n      state.tokenize = tokenComment;\n      return tokenComment(stream, state);\n    }\n    if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n  }\n  if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return \"operator\";\n  }\n  stream.eatWhile(/[\\w\\$_\\xa1-\\uffff]/);\n  var cur = stream.current();\n  if (keywords.propertyIsEnumerable(cur)) {\n    if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n    return \"keyword\";\n  }\n  if (builtin.propertyIsEnumerable(cur)) {\n    if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n    return \"builtin\";\n  }\n  if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n  return \"variable\";\n}\n\nfunction tokenString(quote) {\n  return function(stream, state) {\n    var escaped = false, next, end = false;\n    while ((next = stream.next()) != null) {\n      if (next == quote && !escaped) {end = true; break;}\n      escaped = !escaped && next == \"\\\\\";\n    }\n    if (end || !(escaped || multiLineStrings))\n      state.tokenize = null;\n    return \"string\";\n  };\n}\n\nfunction tokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = null;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return \"comment\";\n}\n\nfunction tokenNestedComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = null;\n      break;\n    }\n    maybeEnd = (ch == \"+\");\n  }\n  return \"comment\";\n}\n\nfunction Context(indented, column, type, align, prev) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.align = align;\n  this.prev = prev;\n}\nfunction pushContext(state, col, type) {\n  var indent = state.indented;\n  if (state.context && state.context.type == \"statement\")\n    indent = state.context.indented;\n  return state.context = new Context(indent, col, type, null, state.context);\n}\nfunction popContext(state) {\n  var t = state.context.type;\n  if (t == \")\" || t == \"]\" || t == \"}\")\n    state.indented = state.context.indented;\n  return state.context = state.context.prev;\n}\n\n// Interface\n\nexport const d = {\n  name: \"d\",\n  startState: function(indentUnit) {\n    return {\n      tokenize: null,\n      context: new Context(-indentUnit, 0, \"top\", false),\n      indented: 0,\n      startOfLine: true\n    };\n  },\n\n  token: function(stream, state) {\n    var ctx = state.context;\n    if (stream.sol()) {\n      if (ctx.align == null) ctx.align = false;\n      state.indented = stream.indentation();\n      state.startOfLine = true;\n    }\n    if (stream.eatSpace()) return null;\n    curPunc = null;\n    var style = (state.tokenize || tokenBase)(stream, state);\n    if (style == \"comment\" || style == \"meta\") return style;\n    if (ctx.align == null) ctx.align = true;\n\n    if ((curPunc == \";\" || curPunc == \":\" || curPunc == \",\") && ctx.type == \"statement\") popContext(state);\n    else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");\n    else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");\n    else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");\n    else if (curPunc == \"}\") {\n      while (ctx.type == \"statement\") ctx = popContext(state);\n      if (ctx.type == \"}\") ctx = popContext(state);\n      while (ctx.type == \"statement\") ctx = popContext(state);\n    }\n    else if (curPunc == ctx.type) popContext(state);\n    else if (((ctx.type == \"}\" || ctx.type == \"top\") && curPunc != ';') || (ctx.type == \"statement\" && curPunc == \"newstatement\"))\n      pushContext(state, stream.column(), \"statement\");\n    state.startOfLine = false;\n    return style;\n  },\n\n  indent: function(state, textAfter, cx) {\n    if (state.tokenize != tokenBase && state.tokenize != null) return null;\n    var ctx = state.context, firstChar = textAfter && textAfter.charAt(0);\n    if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n    var closing = firstChar == ctx.type;\n    if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit || cx.unit);\n    else if (ctx.align) return ctx.column + (closing ? 0 : 1);\n    else return ctx.indented + (closing ? 0 : cx.unit);\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\n  }\n};\n"],"mappings":"AAAA,SAASA,KAAKA,CAACC,GAAG,EAAE;EAClB,IAAIC,GAAG,GAAG,CAAC,CAAC;IAAEF,KAAK,GAAGC,GAAG,CAACE,KAAK,CAAC,GAAG,CAAC;EACpC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,CAACK,MAAM,EAAE,EAAED,CAAC,EAAEF,GAAG,CAACF,KAAK,CAACI,CAAC,CAAC,CAAC,GAAG,IAAI;EAC3D,OAAOF,GAAG;AACZ;AAEA,IAAII,gBAAgB,GAAG,kFAAkF,GACrG,+DAA+D;AAEnE,IAAMC,YAAY,GAAG;EACnBC,QAAQ,EAAER,KAAK,CAAC,0FAA0F,GAC1F,+FAA+F,GAC/F,0FAA0F,GAC1F,wFAAwF,GACxF,kGAAkG,GAClGM,gBAAgB,CAAC;EACjCG,aAAa,EAAET,KAAK,CAACM,gBAAgB,CAAC;EACtCI,OAAO,EAAEV,KAAK,CAAC,yFAAyF,GACzF,8DAA8D,CAAC;EAC9EW,KAAK,EAAEX,KAAK,CAAC,sCAAsC,CAAC;EACpDY,KAAK,EAAE;IACL,GAAG,EAAE,SAAAC,EAASC,MAAM,EAAEC,MAAM,EAAE;MAC5BD,MAAM,CAACE,QAAQ,CAAC,SAAS,CAAC;MAC1B,OAAO,MAAM;IACf;EACF;AACF,CAAC;AAED,IAAIC,mBAAmB,GAAGV,YAAY,CAACU,mBAAmB;EACtDT,QAAQ,GAAGD,YAAY,CAACC,QAAQ;EAChCE,OAAO,GAAGH,YAAY,CAACG,OAAO;EAC9BD,aAAa,GAAGF,YAAY,CAACE,aAAa;EAC1CE,KAAK,GAAGJ,YAAY,CAACI,KAAK;EAC1BC,KAAK,GAAGL,YAAY,CAACK,KAAK;EAC1BM,gBAAgB,GAAGX,YAAY,CAACW,gBAAgB;AACpD,IAAIC,cAAc,GAAG,kBAAkB;AAEvC,IAAIC,OAAO;AAEX,SAASC,SAASA,CAACP,MAAM,EAAEQ,KAAK,EAAE;EAChC,IAAIC,EAAE,GAAGT,MAAM,CAACU,IAAI,CAAC,CAAC;EACtB,IAAIZ,KAAK,CAACW,EAAE,CAAC,EAAE;IACb,IAAIE,MAAM,GAAGb,KAAK,CAACW,EAAE,CAAC,CAACT,MAAM,EAAEQ,KAAK,CAAC;IACrC,IAAIG,MAAM,KAAK,KAAK,EAAE,OAAOA,MAAM;EACrC;EACA,IAAIF,EAAE,IAAI,GAAG,IAAIA,EAAE,IAAI,GAAG,IAAIA,EAAE,IAAI,GAAG,EAAE;IACvCD,KAAK,CAACI,QAAQ,GAAGC,WAAW,CAACJ,EAAE,CAAC;IAChC,OAAOD,KAAK,CAACI,QAAQ,CAACZ,MAAM,EAAEQ,KAAK,CAAC;EACtC;EACA,IAAI,oBAAoB,CAACM,IAAI,CAACL,EAAE,CAAC,EAAE;IACjCH,OAAO,GAAGG,EAAE;IACZ,OAAO,IAAI;EACb;EACA,IAAI,IAAI,CAACK,IAAI,CAACL,EAAE,CAAC,EAAE;IACjBT,MAAM,CAACE,QAAQ,CAAC,QAAQ,CAAC;IACzB,OAAO,QAAQ;EACjB;EACA,IAAIO,EAAE,IAAI,GAAG,EAAE;IACb,IAAIT,MAAM,CAACe,GAAG,CAAC,GAAG,CAAC,EAAE;MACnBP,KAAK,CAACI,QAAQ,GAAGI,kBAAkB;MACnC,OAAOA,kBAAkB,CAAChB,MAAM,EAAEQ,KAAK,CAAC;IAC1C;IACA,IAAIR,MAAM,CAACe,GAAG,CAAC,GAAG,CAAC,EAAE;MACnBP,KAAK,CAACI,QAAQ,GAAGK,YAAY;MAC7B,OAAOA,YAAY,CAACjB,MAAM,EAAEQ,KAAK,CAAC;IACpC;IACA,IAAIR,MAAM,CAACe,GAAG,CAAC,GAAG,CAAC,EAAE;MACnBf,MAAM,CAACkB,SAAS,CAAC,CAAC;MAClB,OAAO,SAAS;IAClB;EACF;EACA,IAAIb,cAAc,CAACS,IAAI,CAACL,EAAE,CAAC,EAAE;IAC3BT,MAAM,CAACE,QAAQ,CAACG,cAAc,CAAC;IAC/B,OAAO,UAAU;EACnB;EACAL,MAAM,CAACE,QAAQ,CAAC,oBAAoB,CAAC;EACrC,IAAIiB,GAAG,GAAGnB,MAAM,CAACoB,OAAO,CAAC,CAAC;EAC1B,IAAI1B,QAAQ,CAAC2B,oBAAoB,CAACF,GAAG,CAAC,EAAE;IACtC,IAAIxB,aAAa,CAAC0B,oBAAoB,CAACF,GAAG,CAAC,EAAEb,OAAO,GAAG,cAAc;IACrE,OAAO,SAAS;EAClB;EACA,IAAIV,OAAO,CAACyB,oBAAoB,CAACF,GAAG,CAAC,EAAE;IACrC,IAAIxB,aAAa,CAAC0B,oBAAoB,CAACF,GAAG,CAAC,EAAEb,OAAO,GAAG,cAAc;IACrE,OAAO,SAAS;EAClB;EACA,IAAIT,KAAK,CAACwB,oBAAoB,CAACF,GAAG,CAAC,EAAE,OAAO,MAAM;EAClD,OAAO,UAAU;AACnB;AAEA,SAASN,WAAWA,CAACS,KAAK,EAAE;EAC1B,OAAO,UAAStB,MAAM,EAAEQ,KAAK,EAAE;IAC7B,IAAIe,OAAO,GAAG,KAAK;MAAEb,IAAI;MAAEc,GAAG,GAAG,KAAK;IACtC,OAAO,CAACd,IAAI,GAAGV,MAAM,CAACU,IAAI,CAAC,CAAC,KAAK,IAAI,EAAE;MACrC,IAAIA,IAAI,IAAIY,KAAK,IAAI,CAACC,OAAO,EAAE;QAACC,GAAG,GAAG,IAAI;QAAE;MAAM;MAClDD,OAAO,GAAG,CAACA,OAAO,IAAIb,IAAI,IAAI,IAAI;IACpC;IACA,IAAIc,GAAG,IAAI,EAAED,OAAO,IAAInB,gBAAgB,CAAC,EACvCI,KAAK,CAACI,QAAQ,GAAG,IAAI;IACvB,OAAO,QAAQ;EACjB,CAAC;AACH;AAEA,SAASK,YAAYA,CAACjB,MAAM,EAAEQ,KAAK,EAAE;EACnC,IAAIiB,QAAQ,GAAG,KAAK;IAAEhB,EAAE;EACxB,OAAOA,EAAE,GAAGT,MAAM,CAACU,IAAI,CAAC,CAAC,EAAE;IACzB,IAAID,EAAE,IAAI,GAAG,IAAIgB,QAAQ,EAAE;MACzBjB,KAAK,CAACI,QAAQ,GAAG,IAAI;MACrB;IACF;IACAa,QAAQ,GAAIhB,EAAE,IAAI,GAAI;EACxB;EACA,OAAO,SAAS;AAClB;AAEA,SAASO,kBAAkBA,CAAChB,MAAM,EAAEQ,KAAK,EAAE;EACzC,IAAIiB,QAAQ,GAAG,KAAK;IAAEhB,EAAE;EACxB,OAAOA,EAAE,GAAGT,MAAM,CAACU,IAAI,CAAC,CAAC,EAAE;IACzB,IAAID,EAAE,IAAI,GAAG,IAAIgB,QAAQ,EAAE;MACzBjB,KAAK,CAACI,QAAQ,GAAG,IAAI;MACrB;IACF;IACAa,QAAQ,GAAIhB,EAAE,IAAI,GAAI;EACxB;EACA,OAAO,SAAS;AAClB;AAEA,SAASiB,OAAOA,CAACC,QAAQ,EAAEC,MAAM,EAAEC,IAAI,EAAEC,KAAK,EAAEC,IAAI,EAAE;EACpD,IAAI,CAACJ,QAAQ,GAAGA,QAAQ;EACxB,IAAI,CAACC,MAAM,GAAGA,MAAM;EACpB,IAAI,CAACC,IAAI,GAAGA,IAAI;EAChB,IAAI,CAACC,KAAK,GAAGA,KAAK;EAClB,IAAI,CAACC,IAAI,GAAGA,IAAI;AAClB;AACA,SAASC,WAAWA,CAACxB,KAAK,EAAEyB,GAAG,EAAEJ,IAAI,EAAE;EACrC,IAAIK,MAAM,GAAG1B,KAAK,CAACmB,QAAQ;EAC3B,IAAInB,KAAK,CAAC2B,OAAO,IAAI3B,KAAK,CAAC2B,OAAO,CAACN,IAAI,IAAI,WAAW,EACpDK,MAAM,GAAG1B,KAAK,CAAC2B,OAAO,CAACR,QAAQ;EACjC,OAAOnB,KAAK,CAAC2B,OAAO,GAAG,IAAIT,OAAO,CAACQ,MAAM,EAAED,GAAG,EAAEJ,IAAI,EAAE,IAAI,EAAErB,KAAK,CAAC2B,OAAO,CAAC;AAC5E;AACA,SAASC,UAAUA,CAAC5B,KAAK,EAAE;EACzB,IAAI6B,CAAC,GAAG7B,KAAK,CAAC2B,OAAO,CAACN,IAAI;EAC1B,IAAIQ,CAAC,IAAI,GAAG,IAAIA,CAAC,IAAI,GAAG,IAAIA,CAAC,IAAI,GAAG,EAClC7B,KAAK,CAACmB,QAAQ,GAAGnB,KAAK,CAAC2B,OAAO,CAACR,QAAQ;EACzC,OAAOnB,KAAK,CAAC2B,OAAO,GAAG3B,KAAK,CAAC2B,OAAO,CAACJ,IAAI;AAC3C;;AAEA;;AAEA,OAAO,IAAMO,CAAC,GAAG;EACfC,IAAI,EAAE,GAAG;EACTC,UAAU,EAAE,SAAAA,WAASC,UAAU,EAAE;IAC/B,OAAO;MACL7B,QAAQ,EAAE,IAAI;MACduB,OAAO,EAAE,IAAIT,OAAO,CAAC,CAACe,UAAU,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,CAAC;MAClDd,QAAQ,EAAE,CAAC;MACXe,WAAW,EAAE;IACf,CAAC;EACH,CAAC;EAEDC,KAAK,EAAE,SAAAA,MAAS3C,MAAM,EAAEQ,KAAK,EAAE;IAC7B,IAAIoC,GAAG,GAAGpC,KAAK,CAAC2B,OAAO;IACvB,IAAInC,MAAM,CAAC6C,GAAG,CAAC,CAAC,EAAE;MAChB,IAAID,GAAG,CAACd,KAAK,IAAI,IAAI,EAAEc,GAAG,CAACd,KAAK,GAAG,KAAK;MACxCtB,KAAK,CAACmB,QAAQ,GAAG3B,MAAM,CAAC8C,WAAW,CAAC,CAAC;MACrCtC,KAAK,CAACkC,WAAW,GAAG,IAAI;IAC1B;IACA,IAAI1C,MAAM,CAAC+C,QAAQ,CAAC,CAAC,EAAE,OAAO,IAAI;IAClCzC,OAAO,GAAG,IAAI;IACd,IAAI0C,KAAK,GAAG,CAACxC,KAAK,CAACI,QAAQ,IAAIL,SAAS,EAAEP,MAAM,EAAEQ,KAAK,CAAC;IACxD,IAAIwC,KAAK,IAAI,SAAS,IAAIA,KAAK,IAAI,MAAM,EAAE,OAAOA,KAAK;IACvD,IAAIJ,GAAG,CAACd,KAAK,IAAI,IAAI,EAAEc,GAAG,CAACd,KAAK,GAAG,IAAI;IAEvC,IAAI,CAACxB,OAAO,IAAI,GAAG,IAAIA,OAAO,IAAI,GAAG,IAAIA,OAAO,IAAI,GAAG,KAAKsC,GAAG,CAACf,IAAI,IAAI,WAAW,EAAEO,UAAU,CAAC5B,KAAK,CAAC,CAAC,KAClG,IAAIF,OAAO,IAAI,GAAG,EAAE0B,WAAW,CAACxB,KAAK,EAAER,MAAM,CAAC4B,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,KAC7D,IAAItB,OAAO,IAAI,GAAG,EAAE0B,WAAW,CAACxB,KAAK,EAAER,MAAM,CAAC4B,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,KAC7D,IAAItB,OAAO,IAAI,GAAG,EAAE0B,WAAW,CAACxB,KAAK,EAAER,MAAM,CAAC4B,MAAM,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,KAC7D,IAAItB,OAAO,IAAI,GAAG,EAAE;MACvB,OAAOsC,GAAG,CAACf,IAAI,IAAI,WAAW,EAAEe,GAAG,GAAGR,UAAU,CAAC5B,KAAK,CAAC;MACvD,IAAIoC,GAAG,CAACf,IAAI,IAAI,GAAG,EAAEe,GAAG,GAAGR,UAAU,CAAC5B,KAAK,CAAC;MAC5C,OAAOoC,GAAG,CAACf,IAAI,IAAI,WAAW,EAAEe,GAAG,GAAGR,UAAU,CAAC5B,KAAK,CAAC;IACzD,CAAC,MACI,IAAIF,OAAO,IAAIsC,GAAG,CAACf,IAAI,EAAEO,UAAU,CAAC5B,KAAK,CAAC,CAAC,KAC3C,IAAK,CAACoC,GAAG,CAACf,IAAI,IAAI,GAAG,IAAIe,GAAG,CAACf,IAAI,IAAI,KAAK,KAAKvB,OAAO,IAAI,GAAG,IAAMsC,GAAG,CAACf,IAAI,IAAI,WAAW,IAAIvB,OAAO,IAAI,cAAe,EAC3H0B,WAAW,CAACxB,KAAK,EAAER,MAAM,CAAC4B,MAAM,CAAC,CAAC,EAAE,WAAW,CAAC;IAClDpB,KAAK,CAACkC,WAAW,GAAG,KAAK;IACzB,OAAOM,KAAK;EACd,CAAC;EAEDd,MAAM,EAAE,SAAAA,OAAS1B,KAAK,EAAEyC,SAAS,EAAEC,EAAE,EAAE;IACrC,IAAI1C,KAAK,CAACI,QAAQ,IAAIL,SAAS,IAAIC,KAAK,CAACI,QAAQ,IAAI,IAAI,EAAE,OAAO,IAAI;IACtE,IAAIgC,GAAG,GAAGpC,KAAK,CAAC2B,OAAO;MAAEgB,SAAS,GAAGF,SAAS,IAAIA,SAAS,CAACG,MAAM,CAAC,CAAC,CAAC;IACrE,IAAIR,GAAG,CAACf,IAAI,IAAI,WAAW,IAAIsB,SAAS,IAAI,GAAG,EAAEP,GAAG,GAAGA,GAAG,CAACb,IAAI;IAC/D,IAAIsB,OAAO,GAAGF,SAAS,IAAIP,GAAG,CAACf,IAAI;IACnC,IAAIe,GAAG,CAACf,IAAI,IAAI,WAAW,EAAE,OAAOe,GAAG,CAACjB,QAAQ,IAAIwB,SAAS,IAAI,GAAG,GAAG,CAAC,GAAGhD,mBAAmB,IAAI+C,EAAE,CAACI,IAAI,CAAC,CAAC,KACtG,IAAIV,GAAG,CAACd,KAAK,EAAE,OAAOc,GAAG,CAAChB,MAAM,IAAIyB,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,KACrD,OAAOT,GAAG,CAACjB,QAAQ,IAAI0B,OAAO,GAAG,CAAC,GAAGH,EAAE,CAACI,IAAI,CAAC;EACpD,CAAC;EAEDC,YAAY,EAAE;IACZC,aAAa,EAAE,WAAW;IAC1BC,aAAa,EAAE;MAACC,IAAI,EAAE,IAAI;MAAEC,KAAK,EAAE;QAACC,IAAI,EAAE,IAAI;QAAEC,KAAK,EAAE;MAAI;IAAC;EAC9D;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}