{"ast":null,"code":"import _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport { Editor, Element, Node, Text, Transforms } from '@seafile/slate';\nimport { ReactEditor } from '@seafile/slate-react';\nimport { CODE_BLOCK, IMAGE } from '../../constants';\nimport { DEFAULT_SEARCH_HIGHLIGHT_FILL_COLOR, FOCUSSED_SEARCH_HIGHLIGHT_FILL_COLOR } from './constant';\n\n// Check the node iff contains text or inline node\nvar isInlineContainer = function isInlineContainer(editor, node) {\n  if (Text.isText(node)) return false;\n  if (node.children) {\n    return node.children.every(function (child) {\n      return Text.isText(child) || Editor.isInline(editor, child);\n    });\n  }\n  return false;\n};\nvar formatTextEntries = function formatTextEntries(textEntries) {\n  return textEntries.reduce(function (pre, cur) {\n    var _pre$passedLength, _pre;\n    var currentLength = cur[0].text.length;\n    var previousLength = (_pre$passedLength = (_pre = pre[pre.length - 1]) === null || _pre === void 0 ? void 0 : _pre.passedLength) !== null && _pre$passedLength !== void 0 ? _pre$passedLength : 0;\n    var currentItem = {\n      passedLength: previousLength + currentLength,\n      textEntry: _toConsumableArray(cur)\n    };\n    return pre.concat(currentItem);\n  }, []);\n};\nvar splitTextNode = function splitTextNode(node) {\n  return node.children.reduce(function (pre, cur) {\n    if (cur.type === IMAGE) {\n      pre.push(_objectSpread(_objectSpread({}, node), {}, {\n        children: []\n      }));\n    } else {\n      pre[pre.length - 1].children.push(cur);\n    }\n    return pre;\n  }, [_objectSpread(_objectSpread({}, node), {}, {\n    children: []\n  })]);\n};\nvar matchSearchWordPosition = function matchSearchWordPosition(node, searchWord) {\n  var content = Node.string(node);\n  var regex = new RegExp(searchWord, 'gi');\n  var matches = _toConsumableArray(content.matchAll(regex));\n  return matches.map(function (match) {\n    return match.index;\n  }) || [];\n};\nvar getMatchedTextInfos = function getMatchedTextInfos(editor, node, keyword) {\n  var matchedTextNodeEntires = [];\n  if (node.children) {\n    // If node is text container, match keyword in text\n    if (isInlineContainer(editor, node)) {\n      var splitNodes = splitTextNode(node);\n      splitNodes.forEach(function (node) {\n        var textEntries = Array.from(Node.texts(node));\n        if (!textEntries) return;\n        var newTextEntries = formatTextEntries(textEntries);\n        var positions = matchSearchWordPosition(node, keyword);\n        var res = positions.reduce(function (pre, position) {\n          var ranges = pre.ranges,\n            startMatchIndex = pre.startMatchIndex;\n          var anchor;\n          for (var index = startMatchIndex; index < newTextEntries.length; index++) {\n            var _newTextEntries$index = newTextEntries[index],\n              passedLength = _newTextEntries$index.passedLength,\n              textEntry = _newTextEntries$index.textEntry;\n            var passedNodeLength = passedLength - textEntry[0].text.length;\n            if (!anchor && passedLength > position) {\n              anchor = {\n                path: ReactEditor.findPath(editor, textEntry[0]),\n                offset: position - passedNodeLength\n              };\n            }\n            if (passedLength >= position + keyword.length) {\n              var range = {\n                anchor: anchor,\n                focus: {\n                  path: ReactEditor.findPath(editor, textEntry[0]),\n                  offset: position + keyword.length - passedNodeLength\n                }\n              };\n              return {\n                ranges: [].concat(_toConsumableArray(ranges), [range]),\n                startMatchIndex: index\n              };\n            }\n          }\n          return pre;\n        }, {\n          ranges: [],\n          startMatchIndex: 0\n        });\n        matchedTextNodeEntires.push(res.ranges);\n      });\n    }\n  }\n  return matchedTextNodeEntires;\n};\nvar generateRangeWhenWrapLine = function generateRangeWhenWrapLine(editor, path, index, count, domRange, baseHeight) {\n  var i = 0;\n  var j = 1;\n  var isOverrideForwardRange = true;\n  var subHighlightInfos = [];\n  while (j <= count) {\n    var subSplitRange = {\n      anchor: {\n        path: path,\n        offset: index + i\n      },\n      focus: {\n        path: path,\n        offset: index + j\n      }\n    };\n    var subRange = ReactEditor.toDOMRange(editor, subSplitRange);\n    var subRangeHeight = Math.round(subRange.getBoundingClientRect().height);\n    if (subRangeHeight === baseHeight) {\n      isOverrideForwardRange && subHighlightInfos.pop();\n      if (!isOverrideForwardRange) isOverrideForwardRange = true;\n      subHighlightInfos.push({\n        rangeInfo: subRange.getBoundingClientRect(),\n        domRange: domRange\n      });\n      j++;\n    } else {\n      i = j - 1;\n      isOverrideForwardRange = false;\n    }\n  }\n  return subHighlightInfos;\n};\nvar findHighlightTextInfos = function findHighlightTextInfos(editor, keyword) {\n  var matchedBlockEntries = _toConsumableArray(Editor.nodes(editor, {\n    match: function match(n) {\n      if (Element.isElement(n) && Editor.isBlock(editor, n)) {\n        try {\n          var blockString = Node.string(n);\n          return blockString.toLowerCase().includes(keyword.toLowerCase());\n        } catch (error) {\n          return false;\n        }\n      }\n    },\n    mode: 'lowest',\n    at: []\n  }));\n  var matchedTextEntriesList = Array.from(matchedBlockEntries).reduce(function (pre, _ref) {\n    var _ref4 = _slicedToArray(_ref, 1),\n      node = _ref4[0];\n    return [].concat(_toConsumableArray(pre), _toConsumableArray(getMatchedTextInfos(editor, node, keyword.toLowerCase())));\n  }, []).flat();\n  return matchedTextEntriesList;\n};\nvar getBaseHeight = function getBaseHeight(editor, range) {\n  var path = range.anchor.path;\n  var subRange = {\n    anchor: {\n      path: path,\n      offset: 0\n    },\n    focus: {\n      path: path,\n      offset: 1\n    }\n  };\n  var letterHeight = ReactEditor.toDOMRange(editor, subRange).getBoundingClientRect().height;\n  var baseHeight = Math.round(letterHeight);\n  return baseHeight;\n};\nexport var getHighlightInfos = function getHighlightInfos(editor, keyword) {\n  if (keyword === '') return [];\n  var highlightTextInfos = findHighlightTextInfos(editor, keyword);\n  var rangeList = highlightTextInfos === null || highlightTextInfos === void 0 ? void 0 : highlightTextInfos.map(function (range) {\n    var domRange = ReactEditor.toDOMRange(editor, range);\n    var rangeInfo = domRange.getBoundingClientRect();\n    var baseHeight = getBaseHeight(editor, range);\n    // highlight word wrap line, assume line height is more then letter height\n    // Windows systems may have precision issues. truncate decimal to avoid this problem\n    var currentRangeHeight = Math.round(rangeInfo.height);\n    if (currentRangeHeight > baseHeight) return generateRangeWhenWrapLine(editor, range.anchor.path, range.anchor.offset, keyword.length, domRange, baseHeight);\n    return [{\n      rangeInfo: rangeInfo,\n      domRange: domRange\n    }];\n  });\n  return rangeList;\n};\nexport var handleReplaceKeyword = function handleReplaceKeyword(editor, highlightInfos, replacedContent) {\n  if (!highlightInfos || !highlightInfos.length) return;\n  // Delete from backward avoiding the range changed\n  highlightInfos.reverse().forEach(function (highlightInfo) {\n    var domRange = highlightInfo[highlightInfo.length - 1].domRange;\n    var slateRange = ReactEditor.toSlateRange(editor, domRange, {\n      exactMatch: true\n    });\n    Transforms.insertText(editor, replacedContent, {\n      at: Editor.end(editor, slateRange)\n    });\n    Transforms.delete(editor, {\n      at: slateRange\n    });\n  });\n};\nexport var clearCanvas = function clearCanvas(canvases) {\n  canvases.forEach(function (canvas) {\n    return canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);\n  });\n};\nexport var scrollIntoView = function scrollIntoView(articleContainerTop, highlightX, highlightY, codeBlockDom, width) {\n  if (!articleContainerTop) return;\n  var scrollContainer = document.getElementById('sdoc-scroll-container');\n  // Scroll into view when highlight block overflow y\n  var scrollTop = highlightY - articleContainerTop - 20;\n  var isOverflowY = scrollContainer.scrollTop > scrollTop || scrollContainer.scrollTop + scrollContainer.clientHeight < scrollTop;\n  isOverflowY && scrollContainer.scrollTo({\n    top: scrollTop\n  });\n  // Scroll into view when code block overflow x\n  if (codeBlockDom) {\n    var isOverflowX = false;\n    var codeBlockDomLeft = codeBlockDom.getBoundingClientRect().left;\n    var leftDistance = codeBlockDomLeft + 50;\n    var rightDistance = leftDistance + codeBlockDom.clientWidth - 50;\n    isOverflowX = leftDistance > highlightX + width || rightDistance < highlightX + width;\n    isOverflowX && codeBlockDom.scrollTo({\n      left: highlightX - leftDistance + width\n    });\n  }\n};\nvar getNowrapCodeBlockInfos = function getNowrapCodeBlockInfos(editor) {\n  var codeBlockEntries = Editor.nodes(editor, {\n    match: function match(n) {\n      var _n$style;\n      var isCodeBlock = Element.isElement(n) && n.type === CODE_BLOCK;\n      if (!isCodeBlock) return false;\n      // To compatible with old version,which has no style property with white_space, by default, it is 'nowrap'\n      var nodeWhiteSpace = (n === null || n === void 0 ? void 0 : (_n$style = n.style) === null || _n$style === void 0 ? void 0 : _n$style['white_space']) || 'nowrap';\n      if (nodeWhiteSpace === 'nowrap') return true;\n      return false;\n    },\n    at: []\n  }) || [];\n\n  // Get code block dom and range info\n  var codeBlockInfos = Array.from(codeBlockEntries).map(function (_ref2) {\n    var _ref5 = _slicedToArray(_ref2, 1),\n      codeBlockNode = _ref5[0];\n    var codeBlockRange = ReactEditor.toDOMNode(editor, codeBlockNode).getBoundingClientRect();\n    return {\n      codeBlockRange: codeBlockRange,\n      codeBlockNode: codeBlockNode\n    };\n  });\n  return codeBlockInfos;\n};\n\n// Hide highlight block when overflow article container\nvar updateInfoAsMatchedInCodeBlock = function updateInfoAsMatchedInCodeBlock(editor, codeBlockInfos, highlightX, highlightY, highlightHeight, highlightWidth) {\n  if (!codeBlockInfos.length) return;\n  var codeBlockDom = null;\n  codeBlockInfos.some(function (_ref3) {\n    var codeBlockRange = _ref3.codeBlockRange,\n      codeBlockNode = _ref3.codeBlockNode;\n    var isInCodeBlockArea = codeBlockRange.y <= highlightY && codeBlockRange.y + codeBlockRange.height > highlightY + highlightHeight;\n    if (isInCodeBlockArea) {\n      codeBlockDom = ReactEditor.toDOMNode(editor, codeBlockNode).querySelector('.sdoc-code-block-pre');\n      var codeBlockRightSidePosition = codeBlockRange.x + codeBlockRange.width;\n      var isOverflowX = codeBlockRange.x > highlightX || codeBlockRightSidePosition < highlightX + highlightWidth;\n      if (isOverflowX) {\n        // Calculate forward and backward hidden width\n        var overflowForward = codeBlockRange.x - highlightX > 0 ? codeBlockRange.x - highlightX : 0;\n        var overflowBackward = highlightX + highlightWidth - codeBlockRightSidePosition > 0 ? highlightX + highlightWidth - codeBlockRightSidePosition : 0;\n        highlightWidth = highlightWidth - overflowForward - overflowBackward;\n      }\n      if (highlightWidth < 0) highlightWidth = 0;\n      if (highlightX < codeBlockRange.x) highlightX = codeBlockRange.x;\n      return true;\n    }\n    return false;\n  });\n  return {\n    codeBlockDom: codeBlockDom,\n    highlightX: highlightX,\n    highlightWidth: highlightWidth\n  };\n};\nexport var drawHighlights = function drawHighlights(editor, ranges, selectIndex) {\n  var isMoveIntoView = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var canvases = document.querySelectorAll('.sdoc-find-search-highlight-canvas');\n  clearCanvas(canvases);\n  if (ranges.length === 0) return;\n  var articleContainer = document.querySelector('.sdoc-article-container');\n  var _articleContainer$get = articleContainer.getBoundingClientRect(),\n    top = _articleContainer$get.top,\n    left = _articleContainer$get.left;\n  var rangeIndex = 0;\n  var splitRangeIndex = 0;\n  var canvasIndex = 0;\n  var codeBlockInfos = getNowrapCodeBlockInfos(editor);\n  do {\n    var canvas = canvases[canvasIndex];\n    if (!canvas) return;\n    var ctx = canvas.getContext('2d');\n    var splitRanges = ranges[rangeIndex];\n    for (var j = splitRangeIndex; j < splitRanges.length; j++) {\n      var isFocussedHighlight = rangeIndex === selectIndex;\n      var _splitRanges$j$rangeI = splitRanges[j].rangeInfo,\n        x = _splitRanges$j$rangeI.x,\n        y = _splitRanges$j$rangeI.y,\n        width = _splitRanges$j$rangeI.width,\n        height = _splitRanges$j$rangeI.height;\n      var codeBlockDom = null;\n      if (y - top < (canvasIndex + 1) * 5000) {\n        // Hide highlight block when overflow article container\n        var updateInfo = updateInfoAsMatchedInCodeBlock(editor, codeBlockInfos, x, y, height, width);\n        if (updateInfo) {\n          x = updateInfo.highlightX;\n          width = updateInfo.highlightWidth;\n          if (isFocussedHighlight) codeBlockDom = updateInfo.codeBlockDom;\n        }\n\n        // Draw highlight block\n        ctx.fillStyle = isFocussedHighlight ? FOCUSSED_SEARCH_HIGHLIGHT_FILL_COLOR : DEFAULT_SEARCH_HIGHLIGHT_FILL_COLOR;\n        ctx.fillRect(x - left, y - top - canvasIndex * 5000, width, height);\n\n        // Scroll into view\n        isMoveIntoView && isFocussedHighlight && scrollIntoView(top, x, y, codeBlockDom, width);\n        if (j === splitRanges.length - 1) rangeIndex++;\n        splitRangeIndex = 0;\n      } else {\n        splitRangeIndex = j;\n        canvasIndex = Math.ceil((y - top) / 5000 - 1);\n      }\n    }\n  } while (rangeIndex < ranges.length);\n};","map":{"version":3,"names":["_objectSpread","Editor","Element","Node","Text","Transforms","ReactEditor","CODE_BLOCK","IMAGE","DEFAULT_SEARCH_HIGHLIGHT_FILL_COLOR","FOCUSSED_SEARCH_HIGHLIGHT_FILL_COLOR","isInlineContainer","editor","node","isText","children","every","child","isInline","formatTextEntries","textEntries","reduce","pre","cur","_pre$passedLength","_pre","currentLength","text","length","previousLength","passedLength","currentItem","textEntry","_toConsumableArray","concat","splitTextNode","type","push","matchSearchWordPosition","searchWord","content","string","regex","RegExp","matches","matchAll","map","match","index","getMatchedTextInfos","keyword","matchedTextNodeEntires","splitNodes","forEach","Array","from","texts","newTextEntries","positions","res","position","ranges","startMatchIndex","anchor","_newTextEntries$index","passedNodeLength","path","findPath","offset","range","focus","generateRangeWhenWrapLine","count","domRange","baseHeight","i","j","isOverrideForwardRange","subHighlightInfos","subSplitRange","subRange","toDOMRange","subRangeHeight","Math","round","getBoundingClientRect","height","pop","rangeInfo","findHighlightTextInfos","matchedBlockEntries","nodes","n","isElement","isBlock","blockString","toLowerCase","includes","error","mode","at","matchedTextEntriesList","_ref","_ref4","_slicedToArray","flat","getBaseHeight","letterHeight","getHighlightInfos","highlightTextInfos","rangeList","currentRangeHeight","handleReplaceKeyword","highlightInfos","replacedContent","reverse","highlightInfo","slateRange","toSlateRange","exactMatch","insertText","end","delete","clearCanvas","canvases","canvas","getContext","clearRect","width","scrollIntoView","articleContainerTop","highlightX","highlightY","codeBlockDom","scrollContainer","document","getElementById","scrollTop","isOverflowY","clientHeight","scrollTo","top","isOverflowX","codeBlockDomLeft","left","leftDistance","rightDistance","clientWidth","getNowrapCodeBlockInfos","codeBlockEntries","_n$style","isCodeBlock","nodeWhiteSpace","style","codeBlockInfos","_ref2","_ref5","codeBlockNode","codeBlockRange","toDOMNode","updateInfoAsMatchedInCodeBlock","highlightHeight","highlightWidth","some","_ref3","isInCodeBlockArea","y","querySelector","codeBlockRightSidePosition","x","overflowForward","overflowBackward","drawHighlights","selectIndex","isMoveIntoView","arguments","undefined","querySelectorAll","articleContainer","_articleContainer$get","rangeIndex","splitRangeIndex","canvasIndex","ctx","splitRanges","isFocussedHighlight","_splitRanges$j$rangeI","updateInfo","fillStyle","fillRect","ceil"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/plugins/search-replace/helper.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport { Editor, Element, Node, Text, Transforms } from '@seafile/slate';\nimport { ReactEditor } from '@seafile/slate-react';\nimport { CODE_BLOCK, IMAGE } from '../../constants';\nimport { DEFAULT_SEARCH_HIGHLIGHT_FILL_COLOR, FOCUSSED_SEARCH_HIGHLIGHT_FILL_COLOR } from './constant';\n\n// Check the node iff contains text or inline node\nconst isInlineContainer = (editor, node) => {\n  if (Text.isText(node)) return false;\n  if (node.children) {\n    return node.children.every(child => Text.isText(child) || Editor.isInline(editor, child));\n  }\n  return false;\n};\nconst formatTextEntries = textEntries => {\n  return textEntries.reduce((pre, cur) => {\n    var _pre$passedLength, _pre;\n    const currentLength = cur[0].text.length;\n    const previousLength = (_pre$passedLength = (_pre = pre[pre.length - 1]) === null || _pre === void 0 ? void 0 : _pre.passedLength) !== null && _pre$passedLength !== void 0 ? _pre$passedLength : 0;\n    const currentItem = {\n      passedLength: previousLength + currentLength,\n      textEntry: [...cur]\n    };\n    return pre.concat(currentItem);\n  }, []);\n};\nconst splitTextNode = node => {\n  return node.children.reduce((pre, cur) => {\n    if (cur.type === IMAGE) {\n      pre.push(_objectSpread(_objectSpread({}, node), {}, {\n        children: []\n      }));\n    } else {\n      pre[pre.length - 1].children.push(cur);\n    }\n    return pre;\n  }, [_objectSpread(_objectSpread({}, node), {}, {\n    children: []\n  })]);\n};\nconst matchSearchWordPosition = (node, searchWord) => {\n  const content = Node.string(node);\n  const regex = new RegExp(searchWord, 'gi');\n  const matches = [...content.matchAll(regex)];\n  return matches.map(match => match.index) || [];\n};\nconst getMatchedTextInfos = (editor, node, keyword) => {\n  const matchedTextNodeEntires = [];\n  if (node.children) {\n    // If node is text container, match keyword in text\n    if (isInlineContainer(editor, node)) {\n      const splitNodes = splitTextNode(node);\n      splitNodes.forEach(node => {\n        const textEntries = Array.from(Node.texts(node));\n        if (!textEntries) return;\n        const newTextEntries = formatTextEntries(textEntries);\n        const positions = matchSearchWordPosition(node, keyword);\n        const res = positions.reduce((pre, position) => {\n          const {\n            ranges,\n            startMatchIndex\n          } = pre;\n          let anchor;\n          for (let index = startMatchIndex; index < newTextEntries.length; index++) {\n            const {\n              passedLength,\n              textEntry\n            } = newTextEntries[index];\n            const passedNodeLength = passedLength - textEntry[0].text.length;\n            if (!anchor && passedLength > position) {\n              anchor = {\n                path: ReactEditor.findPath(editor, textEntry[0]),\n                offset: position - passedNodeLength\n              };\n            }\n            if (passedLength >= position + keyword.length) {\n              const range = {\n                anchor,\n                focus: {\n                  path: ReactEditor.findPath(editor, textEntry[0]),\n                  offset: position + keyword.length - passedNodeLength\n                }\n              };\n              return {\n                ranges: [...ranges, range],\n                startMatchIndex: index\n              };\n            }\n          }\n          return pre;\n        }, {\n          ranges: [],\n          startMatchIndex: 0\n        });\n        matchedTextNodeEntires.push(res.ranges);\n      });\n    }\n  }\n  return matchedTextNodeEntires;\n};\nconst generateRangeWhenWrapLine = (editor, path, index, count, domRange, baseHeight) => {\n  let i = 0;\n  let j = 1;\n  let isOverrideForwardRange = true;\n  const subHighlightInfos = [];\n  while (j <= count) {\n    const subSplitRange = {\n      anchor: {\n        path,\n        offset: index + i\n      },\n      focus: {\n        path,\n        offset: index + j\n      }\n    };\n    const subRange = ReactEditor.toDOMRange(editor, subSplitRange);\n    const subRangeHeight = Math.round(subRange.getBoundingClientRect().height);\n    if (subRangeHeight === baseHeight) {\n      isOverrideForwardRange && subHighlightInfos.pop();\n      if (!isOverrideForwardRange) isOverrideForwardRange = true;\n      subHighlightInfos.push({\n        rangeInfo: subRange.getBoundingClientRect(),\n        domRange\n      });\n      j++;\n    } else {\n      i = j - 1;\n      isOverrideForwardRange = false;\n    }\n  }\n  return subHighlightInfos;\n};\nconst findHighlightTextInfos = (editor, keyword) => {\n  const matchedBlockEntries = [...Editor.nodes(editor, {\n    match: n => {\n      if (Element.isElement(n) && Editor.isBlock(editor, n)) {\n        try {\n          const blockString = Node.string(n);\n          return blockString.toLowerCase().includes(keyword.toLowerCase());\n        } catch (error) {\n          return false;\n        }\n      }\n    },\n    mode: 'lowest',\n    at: []\n  })];\n  const matchedTextEntriesList = Array.from(matchedBlockEntries).reduce((pre, _ref) => {\n    let [node] = _ref;\n    return [...pre, ...getMatchedTextInfos(editor, node, keyword.toLowerCase())];\n  }, []).flat();\n  return matchedTextEntriesList;\n};\nconst getBaseHeight = (editor, range) => {\n  const {\n    anchor: {\n      path\n    }\n  } = range;\n  const subRange = {\n    anchor: {\n      path,\n      offset: 0\n    },\n    focus: {\n      path,\n      offset: 1\n    }\n  };\n  const letterHeight = ReactEditor.toDOMRange(editor, subRange).getBoundingClientRect().height;\n  const baseHeight = Math.round(letterHeight);\n  return baseHeight;\n};\nexport const getHighlightInfos = (editor, keyword) => {\n  if (keyword === '') return [];\n  const highlightTextInfos = findHighlightTextInfos(editor, keyword);\n  const rangeList = highlightTextInfos === null || highlightTextInfos === void 0 ? void 0 : highlightTextInfos.map(range => {\n    const domRange = ReactEditor.toDOMRange(editor, range);\n    const rangeInfo = domRange.getBoundingClientRect();\n    const baseHeight = getBaseHeight(editor, range);\n    // highlight word wrap line, assume line height is more then letter height\n    // Windows systems may have precision issues. truncate decimal to avoid this problem\n    const currentRangeHeight = Math.round(rangeInfo.height);\n    if (currentRangeHeight > baseHeight) return generateRangeWhenWrapLine(editor, range.anchor.path, range.anchor.offset, keyword.length, domRange, baseHeight);\n    return [{\n      rangeInfo,\n      domRange\n    }];\n  });\n  return rangeList;\n};\nexport const handleReplaceKeyword = (editor, highlightInfos, replacedContent) => {\n  if (!highlightInfos || !highlightInfos.length) return;\n  // Delete from backward avoiding the range changed\n  highlightInfos.reverse().forEach(highlightInfo => {\n    const {\n      domRange\n    } = highlightInfo[highlightInfo.length - 1];\n    const slateRange = ReactEditor.toSlateRange(editor, domRange, {\n      exactMatch: true\n    });\n    Transforms.insertText(editor, replacedContent, {\n      at: Editor.end(editor, slateRange)\n    });\n    Transforms.delete(editor, {\n      at: slateRange\n    });\n  });\n};\nexport const clearCanvas = canvases => {\n  canvases.forEach(canvas => canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height));\n};\nexport const scrollIntoView = (articleContainerTop, highlightX, highlightY, codeBlockDom, width) => {\n  if (!articleContainerTop) return;\n  const scrollContainer = document.getElementById('sdoc-scroll-container');\n  // Scroll into view when highlight block overflow y\n  const scrollTop = highlightY - articleContainerTop - 20;\n  const isOverflowY = scrollContainer.scrollTop > scrollTop || scrollContainer.scrollTop + scrollContainer.clientHeight < scrollTop;\n  isOverflowY && scrollContainer.scrollTo({\n    top: scrollTop\n  });\n  // Scroll into view when code block overflow x\n  if (codeBlockDom) {\n    let isOverflowX = false;\n    const codeBlockDomLeft = codeBlockDom.getBoundingClientRect().left;\n    const leftDistance = codeBlockDomLeft + 50;\n    const rightDistance = leftDistance + codeBlockDom.clientWidth - 50;\n    isOverflowX = leftDistance > highlightX + width || rightDistance < highlightX + width;\n    isOverflowX && codeBlockDom.scrollTo({\n      left: highlightX - leftDistance + width\n    });\n  }\n};\nconst getNowrapCodeBlockInfos = editor => {\n  const codeBlockEntries = Editor.nodes(editor, {\n    match: n => {\n      var _n$style;\n      const isCodeBlock = Element.isElement(n) && n.type === CODE_BLOCK;\n      if (!isCodeBlock) return false;\n      // To compatible with old version,which has no style property with white_space, by default, it is 'nowrap'\n      const nodeWhiteSpace = (n === null || n === void 0 ? void 0 : (_n$style = n.style) === null || _n$style === void 0 ? void 0 : _n$style['white_space']) || 'nowrap';\n      if (nodeWhiteSpace === 'nowrap') return true;\n      return false;\n    },\n    at: []\n  }) || [];\n\n  // Get code block dom and range info\n  const codeBlockInfos = Array.from(codeBlockEntries).map(_ref2 => {\n    let [codeBlockNode] = _ref2;\n    const codeBlockRange = ReactEditor.toDOMNode(editor, codeBlockNode).getBoundingClientRect();\n    return {\n      codeBlockRange,\n      codeBlockNode\n    };\n  });\n  return codeBlockInfos;\n};\n\n// Hide highlight block when overflow article container\nconst updateInfoAsMatchedInCodeBlock = (editor, codeBlockInfos, highlightX, highlightY, highlightHeight, highlightWidth) => {\n  if (!codeBlockInfos.length) return;\n  let codeBlockDom = null;\n  codeBlockInfos.some(_ref3 => {\n    let {\n      codeBlockRange,\n      codeBlockNode\n    } = _ref3;\n    const isInCodeBlockArea = codeBlockRange.y <= highlightY && codeBlockRange.y + codeBlockRange.height > highlightY + highlightHeight;\n    if (isInCodeBlockArea) {\n      codeBlockDom = ReactEditor.toDOMNode(editor, codeBlockNode).querySelector('.sdoc-code-block-pre');\n      const codeBlockRightSidePosition = codeBlockRange.x + codeBlockRange.width;\n      const isOverflowX = codeBlockRange.x > highlightX || codeBlockRightSidePosition < highlightX + highlightWidth;\n      if (isOverflowX) {\n        // Calculate forward and backward hidden width\n        const overflowForward = codeBlockRange.x - highlightX > 0 ? codeBlockRange.x - highlightX : 0;\n        const overflowBackward = highlightX + highlightWidth - codeBlockRightSidePosition > 0 ? highlightX + highlightWidth - codeBlockRightSidePosition : 0;\n        highlightWidth = highlightWidth - overflowForward - overflowBackward;\n      }\n      if (highlightWidth < 0) highlightWidth = 0;\n      if (highlightX < codeBlockRange.x) highlightX = codeBlockRange.x;\n      return true;\n    }\n    return false;\n  });\n  return {\n    codeBlockDom,\n    highlightX,\n    highlightWidth\n  };\n};\nexport const drawHighlights = function (editor, ranges, selectIndex) {\n  let isMoveIntoView = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const canvases = document.querySelectorAll('.sdoc-find-search-highlight-canvas');\n  clearCanvas(canvases);\n  if (ranges.length === 0) return;\n  const articleContainer = document.querySelector('.sdoc-article-container');\n  const {\n    top,\n    left\n  } = articleContainer.getBoundingClientRect();\n  let rangeIndex = 0;\n  let splitRangeIndex = 0;\n  let canvasIndex = 0;\n  const codeBlockInfos = getNowrapCodeBlockInfos(editor);\n  do {\n    let canvas = canvases[canvasIndex];\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    const splitRanges = ranges[rangeIndex];\n    for (let j = splitRangeIndex; j < splitRanges.length; j++) {\n      const isFocussedHighlight = rangeIndex === selectIndex;\n      let {\n        x,\n        y,\n        width,\n        height\n      } = splitRanges[j].rangeInfo;\n      let codeBlockDom = null;\n      if (y - top < (canvasIndex + 1) * 5000) {\n        // Hide highlight block when overflow article container\n        const updateInfo = updateInfoAsMatchedInCodeBlock(editor, codeBlockInfos, x, y, height, width);\n        if (updateInfo) {\n          x = updateInfo.highlightX;\n          width = updateInfo.highlightWidth;\n          if (isFocussedHighlight) codeBlockDom = updateInfo.codeBlockDom;\n        }\n\n        // Draw highlight block\n        ctx.fillStyle = isFocussedHighlight ? FOCUSSED_SEARCH_HIGHLIGHT_FILL_COLOR : DEFAULT_SEARCH_HIGHLIGHT_FILL_COLOR;\n        ctx.fillRect(x - left, y - top - canvasIndex * 5000, width, height);\n\n        // Scroll into view\n        isMoveIntoView && isFocussedHighlight && scrollIntoView(top, x, y, codeBlockDom, width);\n        if (j === splitRanges.length - 1) rangeIndex++;\n        splitRangeIndex = 0;\n      } else {\n        splitRangeIndex = j;\n        canvasIndex = Math.ceil((y - top) / 5000 - 1);\n      }\n    }\n  } while (rangeIndex < ranges.length);\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}