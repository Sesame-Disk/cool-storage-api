{"ast":null,"code":"/*global Blob,File*/\n\n/**\n * Module requirements\n */\n\nvar isArray = require('isarray');\nvar isBuf = require('./is-buffer');\nvar toString = Object.prototype.toString;\nvar withNativeBlob = typeof Blob === 'function' || typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]';\nvar withNativeFile = typeof File === 'function' || typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]';\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function (packet) {\n  var buffers = [];\n  var packetData = packet.data;\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData, buffers);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {\n    packet: pack,\n    buffers: buffers\n  };\n};\nfunction _deconstructPacket(data, buffers) {\n  if (!data) return data;\n  if (isBuf(data)) {\n    var placeholder = {\n      _placeholder: true,\n      num: buffers.length\n    };\n    buffers.push(data);\n    return placeholder;\n  } else if (isArray(data)) {\n    var newData = new Array(data.length);\n    for (var i = 0; i < data.length; i++) {\n      newData[i] = _deconstructPacket(data[i], buffers);\n    }\n    return newData;\n  } else if (typeof data === 'object' && !(data instanceof Date)) {\n    var newData = {};\n    for (var key in data) {\n      newData[key] = _deconstructPacket(data[key], buffers);\n    }\n    return newData;\n  }\n  return data;\n}\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function (packet, buffers) {\n  packet.data = _reconstructPacket(packet.data, buffers);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\nfunction _reconstructPacket(data, buffers) {\n  if (!data) return data;\n  if (data && data._placeholder === true) {\n    var isIndexValid = typeof data.num === \"number\" && data.num >= 0 && data.num < buffers.length;\n    if (isIndexValid) {\n      return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n    } else {\n      throw new Error(\"illegal attachments\");\n    }\n  } else if (isArray(data)) {\n    for (var i = 0; i < data.length; i++) {\n      data[i] = _reconstructPacket(data[i], buffers);\n    }\n  } else if (typeof data === 'object') {\n    for (var key in data) {\n      data[key] = _reconstructPacket(data[key], buffers);\n    }\n  }\n  return data;\n}\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function (data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if (withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function () {\n        // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        } else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if (! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) {\n      // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (typeof obj === 'object' && !isBuf(obj)) {\n      // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  _removeBlobs(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};","map":{"version":3,"names":["isArray","require","isBuf","toString","Object","prototype","withNativeBlob","Blob","call","withNativeFile","File","exports","deconstructPacket","packet","buffers","packetData","data","pack","_deconstructPacket","attachments","length","placeholder","_placeholder","num","push","newData","Array","i","Date","key","reconstructPacket","_reconstructPacket","undefined","isIndexValid","Error","removeBlobs","callback","_removeBlobs","obj","curKey","containingObject","pendingBlobs","fileReader","FileReader","onload","result","bloblessData","readAsArrayBuffer"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/socket.io-parser/binary.js"],"sourcesContent":["/*global Blob,File*/\n\n/**\n * Module requirements\n */\n\nvar isArray = require('isarray');\nvar isBuf = require('./is-buffer');\nvar toString = Object.prototype.toString;\nvar withNativeBlob = typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');\nvar withNativeFile = typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');\n\n/**\n * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.\n * Anything with blobs or files should be fed through removeBlobs before coming\n * here.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @api public\n */\n\nexports.deconstructPacket = function(packet) {\n  var buffers = [];\n  var packetData = packet.data;\n  var pack = packet;\n  pack.data = _deconstructPacket(packetData, buffers);\n  pack.attachments = buffers.length; // number of binary 'attachments'\n  return {packet: pack, buffers: buffers};\n};\n\nfunction _deconstructPacket(data, buffers) {\n  if (!data) return data;\n\n  if (isBuf(data)) {\n    var placeholder = { _placeholder: true, num: buffers.length };\n    buffers.push(data);\n    return placeholder;\n  } else if (isArray(data)) {\n    var newData = new Array(data.length);\n    for (var i = 0; i < data.length; i++) {\n      newData[i] = _deconstructPacket(data[i], buffers);\n    }\n    return newData;\n  } else if (typeof data === 'object' && !(data instanceof Date)) {\n    var newData = {};\n    for (var key in data) {\n      newData[key] = _deconstructPacket(data[key], buffers);\n    }\n    return newData;\n  }\n  return data;\n}\n\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @api public\n */\n\nexports.reconstructPacket = function(packet, buffers) {\n  packet.data = _reconstructPacket(packet.data, buffers);\n  packet.attachments = undefined; // no longer useful\n  return packet;\n};\n\nfunction _reconstructPacket(data, buffers) {\n  if (!data) return data;\n\n  if (data && data._placeholder === true) {\n    var isIndexValid =\n      typeof data.num === \"number\" &&\n      data.num >= 0 &&\n      data.num < buffers.length;\n    if (isIndexValid) {\n      return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n    } else {\n      throw new Error(\"illegal attachments\");\n    }\n  } else if (isArray(data)) {\n    for (var i = 0; i < data.length; i++) {\n      data[i] = _reconstructPacket(data[i], buffers);\n    }\n  } else if (typeof data === 'object') {\n    for (var key in data) {\n      data[key] = _reconstructPacket(data[key], buffers);\n    }\n  }\n\n  return data;\n}\n\n/**\n * Asynchronously removes Blobs or Files from data via\n * FileReader's readAsArrayBuffer method. Used before encoding\n * data as msgpack. Calls callback with the blobless data.\n *\n * @param {Object} data\n * @param {Function} callback\n * @api private\n */\n\nexports.removeBlobs = function(data, callback) {\n  function _removeBlobs(obj, curKey, containingObject) {\n    if (!obj) return obj;\n\n    // convert any blob\n    if ((withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File)) {\n      pendingBlobs++;\n\n      // async filereader\n      var fileReader = new FileReader();\n      fileReader.onload = function() { // this.result == arraybuffer\n        if (containingObject) {\n          containingObject[curKey] = this.result;\n        }\n        else {\n          bloblessData = this.result;\n        }\n\n        // if nothing pending its callback time\n        if(! --pendingBlobs) {\n          callback(bloblessData);\n        }\n      };\n\n      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer\n    } else if (isArray(obj)) { // handle array\n      for (var i = 0; i < obj.length; i++) {\n        _removeBlobs(obj[i], i, obj);\n      }\n    } else if (typeof obj === 'object' && !isBuf(obj)) { // and object\n      for (var key in obj) {\n        _removeBlobs(obj[key], key, obj);\n      }\n    }\n  }\n\n  var pendingBlobs = 0;\n  var bloblessData = data;\n  _removeBlobs(bloblessData);\n  if (!pendingBlobs) {\n    callback(bloblessData);\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}