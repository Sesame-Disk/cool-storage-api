{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeTokens = void 0;\nvar newlineRe = /\\r\\n|\\r|\\n/;\nvar normalizeEmptyLines = function normalizeEmptyLines(line) {\n  if (line.length === 0) {\n    line.push({\n      types: ['plain'],\n      content: '\\n',\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === '') {\n    line[0].content = '\\n';\n    line[0].empty = true;\n  }\n};\nvar appendTypes = function appendTypes(types, add) {\n  var typesSize = types.length;\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n  return types.concat(add);\n};\nvar normalizeTokens = function normalizeTokens(tokens) {\n  var typeArrStack = [[]];\n  var tokenArrStack = [tokens];\n  var tokenArrIndexStack = [0];\n  var tokenArrSizeStack = [tokens.length];\n  var i = 0;\n  var stackIndex = 0;\n  var currentLine = [];\n  var acc = [currentLine];\n  while (stackIndex > -1) {\n    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      var content = void 0;\n      var types = typeArrStack[stackIndex];\n      var tokenArr = tokenArrStack[stackIndex];\n      var token = tokenArr[i];\n\n      // Determine content and append type to types if necessary\n      if (typeof token === 'string') {\n        types = stackIndex > 0 ? types : ['plain'];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n        content = token.content;\n      }\n\n      // If token.content is an array, increase the stack depth and repeat this while-loop\n      if (typeof content !== 'string') {\n        stackIndex++;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        continue;\n      }\n\n      // Split by newlines\n      var splitByNewlines = content.split(newlineRe);\n      var newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types: types,\n        content: splitByNewlines[0]\n      });\n\n      // Create a new line for each string on a new line\n      for (var _i = 1; _i < newlineCount; _i++) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types: types,\n          content: splitByNewlines[_i]\n        });\n      }\n    }\n\n    // Decreate the stack depth\n    stackIndex--;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\nexports.normalizeTokens = normalizeTokens;","map":{"version":3,"names":["Object","defineProperty","exports","value","normalizeTokens","newlineRe","normalizeEmptyLines","line","length","push","types","content","empty","appendTypes","add","typesSize","concat","tokens","typeArrStack","tokenArrStack","tokenArrIndexStack","tokenArrSizeStack","i","stackIndex","currentLine","acc","tokenArr","token","type","alias","splitByNewlines","split","newlineCount","pop"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/seafile-editor/dist/extension/highlight/normalize-tokens.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeTokens = void 0;\nconst newlineRe = /\\r\\n|\\r|\\n/;\nconst normalizeEmptyLines = line => {\n  if (line.length === 0) {\n    line.push({\n      types: ['plain'],\n      content: '\\n',\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === '') {\n    line[0].content = '\\n';\n    line[0].empty = true;\n  }\n};\nconst appendTypes = (types, add) => {\n  const typesSize = types.length;\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n  return types.concat(add);\n};\nconst normalizeTokens = tokens => {\n  const typeArrStack = [[]];\n  const tokenArrStack = [tokens];\n  const tokenArrIndexStack = [0];\n  const tokenArrSizeStack = [tokens.length];\n  let i = 0;\n  let stackIndex = 0;\n  let currentLine = [];\n  const acc = [currentLine];\n  while (stackIndex > -1) {\n    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      let content;\n      let types = typeArrStack[stackIndex];\n      const tokenArr = tokenArrStack[stackIndex];\n      const token = tokenArr[i];\n\n      // Determine content and append type to types if necessary\n      if (typeof token === 'string') {\n        types = stackIndex > 0 ? types : ['plain'];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n        content = token.content;\n      }\n\n      // If token.content is an array, increase the stack depth and repeat this while-loop\n      if (typeof content !== 'string') {\n        stackIndex++;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        continue;\n      }\n\n      // Split by newlines\n      const splitByNewlines = content.split(newlineRe);\n      const newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types,\n        content: splitByNewlines[0]\n      });\n\n      // Create a new line for each string on a new line\n      for (let i = 1; i < newlineCount; i++) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types,\n          content: splitByNewlines[i]\n        });\n      }\n    }\n\n    // Decreate the stack depth\n    stackIndex--;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\nexports.normalizeTokens = normalizeTokens;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}