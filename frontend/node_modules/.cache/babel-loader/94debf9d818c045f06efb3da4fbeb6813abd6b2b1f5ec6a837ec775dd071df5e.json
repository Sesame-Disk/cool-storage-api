{"ast":null,"code":"import { stringToBytes, toUint8, bytesMatch, bytesToString, toHexString, padStart, bytesToNumber } from './byte-helpers.js';\nimport { getAvcCodec, getHvcCodec, getAv1Codec } from './codec-helpers.js';\nimport { parseOpusHead } from './opus-helpers.js';\nvar normalizePath = function normalizePath(path) {\n  if (typeof path === 'string') {\n    return stringToBytes(path);\n  }\n  if (typeof path === 'number') {\n    return path;\n  }\n  return path;\n};\nvar normalizePaths = function normalizePaths(paths) {\n  if (!Array.isArray(paths)) {\n    return [normalizePath(paths)];\n  }\n  return paths.map(function (p) {\n    return normalizePath(p);\n  });\n};\nvar DESCRIPTORS;\nexport var parseDescriptors = function parseDescriptors(bytes) {\n  bytes = toUint8(bytes);\n  var results = [];\n  var i = 0;\n  while (bytes.length > i) {\n    var tag = bytes[i];\n    var size = 0;\n    var headerSize = 0; // tag\n\n    headerSize++;\n    var byte = bytes[headerSize]; // first byte\n\n    headerSize++;\n    while (byte & 0x80) {\n      size = (byte & 0x7F) << 7;\n      byte = bytes[headerSize];\n      headerSize++;\n    }\n    size += byte & 0x7F;\n    for (var z = 0; z < DESCRIPTORS.length; z++) {\n      var _DESCRIPTORS$z = DESCRIPTORS[z],\n        id = _DESCRIPTORS$z.id,\n        parser = _DESCRIPTORS$z.parser;\n      if (tag === id) {\n        results.push(parser(bytes.subarray(headerSize, headerSize + size)));\n        break;\n      }\n    }\n    i += size + headerSize;\n  }\n  return results;\n};\nDESCRIPTORS = [{\n  id: 0x03,\n  parser: function parser(bytes) {\n    var desc = {\n      tag: 0x03,\n      id: bytes[0] << 8 | bytes[1],\n      flags: bytes[2],\n      size: 3,\n      dependsOnEsId: 0,\n      ocrEsId: 0,\n      descriptors: [],\n      url: ''\n    }; // depends on es id\n\n    if (desc.flags & 0x80) {\n      desc.dependsOnEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];\n      desc.size += 2;\n    } // url\n\n    if (desc.flags & 0x40) {\n      var len = bytes[desc.size];\n      desc.url = bytesToString(bytes.subarray(desc.size + 1, desc.size + 1 + len));\n      desc.size += len;\n    } // ocr es id\n\n    if (desc.flags & 0x20) {\n      desc.ocrEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];\n      desc.size += 2;\n    }\n    desc.descriptors = parseDescriptors(bytes.subarray(desc.size)) || [];\n    return desc;\n  }\n}, {\n  id: 0x04,\n  parser: function parser(bytes) {\n    // DecoderConfigDescriptor\n    var desc = {\n      tag: 0x04,\n      oti: bytes[0],\n      streamType: bytes[1],\n      bufferSize: bytes[2] << 16 | bytes[3] << 8 | bytes[4],\n      maxBitrate: bytes[5] << 24 | bytes[6] << 16 | bytes[7] << 8 | bytes[8],\n      avgBitrate: bytes[9] << 24 | bytes[10] << 16 | bytes[11] << 8 | bytes[12],\n      descriptors: parseDescriptors(bytes.subarray(13))\n    };\n    return desc;\n  }\n}, {\n  id: 0x05,\n  parser: function parser(bytes) {\n    // DecoderSpecificInfo\n    return {\n      tag: 0x05,\n      bytes: bytes\n    };\n  }\n}, {\n  id: 0x06,\n  parser: function parser(bytes) {\n    // SLConfigDescriptor\n    return {\n      tag: 0x06,\n      bytes: bytes\n    };\n  }\n}];\n/**\n * find any number of boxes by name given a path to it in an iso bmff\n * such as mp4.\n *\n * @param {TypedArray} bytes\n *        bytes for the iso bmff to search for boxes in\n *\n * @param {Uint8Array[]|string[]|string|Uint8Array} name\n *        An array of paths or a single path representing the name\n *        of boxes to search through in bytes. Paths may be\n *        uint8 (character codes) or strings.\n *\n * @param {boolean} [complete=false]\n *        Should we search only for complete boxes on the final path.\n *        This is very useful when you do not want to get back partial boxes\n *        in the case of streaming files.\n *\n * @return {Uint8Array[]}\n *         An array of the end paths that we found.\n */\n\nexport var findBox = function findBox(bytes, paths, complete) {\n  if (complete === void 0) {\n    complete = false;\n  }\n  paths = normalizePaths(paths);\n  bytes = toUint8(bytes);\n  var results = [];\n  if (!paths.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n  var i = 0;\n  while (i < bytes.length) {\n    var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;\n    var type = bytes.subarray(i + 4, i + 8); // invalid box format.\n\n    if (size === 0) {\n      break;\n    }\n    var end = i + size;\n    if (end > bytes.length) {\n      // this box is bigger than the number of bytes we have\n      // and complete is set, we cannot find any more boxes.\n      if (complete) {\n        break;\n      }\n      end = bytes.length;\n    }\n    var data = bytes.subarray(i + 8, end);\n    if (bytesMatch(type, paths[0])) {\n      if (paths.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data);\n      } else {\n        // recursively search for the next box along the path\n        results.push.apply(results, findBox(data, paths.slice(1), complete));\n      }\n    }\n    i = end;\n  } // we've finished searching all of bytes\n\n  return results;\n};\n/**\n * Search for a single matching box by name in an iso bmff format like\n * mp4. This function is useful for finding codec boxes which\n * can be placed arbitrarily in sample descriptions depending\n * on the version of the file or file type.\n *\n * @param {TypedArray} bytes\n *        bytes for the iso bmff to search for boxes in\n *\n * @param {string|Uint8Array} name\n *        The name of the box to find.\n *\n * @return {Uint8Array[]}\n *         a subarray of bytes representing the name boxed we found.\n */\n\nexport var findNamedBox = function findNamedBox(bytes, name) {\n  name = normalizePath(name);\n  if (!name.length) {\n    // short-circuit the search for empty paths\n    return bytes.subarray(bytes.length);\n  }\n  var i = 0;\n  while (i < bytes.length) {\n    if (bytesMatch(bytes.subarray(i, i + name.length), name)) {\n      var size = (bytes[i - 4] << 24 | bytes[i - 3] << 16 | bytes[i - 2] << 8 | bytes[i - 1]) >>> 0;\n      var end = size > 1 ? i + size : bytes.byteLength;\n      return bytes.subarray(i + 4, end);\n    }\n    i++;\n  } // we've finished searching all of bytes\n\n  return bytes.subarray(bytes.length);\n};\nvar parseSamples = function parseSamples(data, entrySize, parseEntry) {\n  if (entrySize === void 0) {\n    entrySize = 4;\n  }\n  if (parseEntry === void 0) {\n    parseEntry = function parseEntry(d) {\n      return bytesToNumber(d);\n    };\n  }\n  var entries = [];\n  if (!data || !data.length) {\n    return entries;\n  }\n  var entryCount = bytesToNumber(data.subarray(4, 8));\n  for (var i = 8; entryCount; i += entrySize, entryCount--) {\n    entries.push(parseEntry(data.subarray(i, i + entrySize)));\n  }\n  return entries;\n};\nexport var buildFrameTable = function buildFrameTable(stbl, timescale) {\n  var keySamples = parseSamples(findBox(stbl, ['stss'])[0]);\n  var chunkOffsets = parseSamples(findBox(stbl, ['stco'])[0]);\n  var timeToSamples = parseSamples(findBox(stbl, ['stts'])[0], 8, function (entry) {\n    return {\n      sampleCount: bytesToNumber(entry.subarray(0, 4)),\n      sampleDelta: bytesToNumber(entry.subarray(4, 8))\n    };\n  });\n  var samplesToChunks = parseSamples(findBox(stbl, ['stsc'])[0], 12, function (entry) {\n    return {\n      firstChunk: bytesToNumber(entry.subarray(0, 4)),\n      samplesPerChunk: bytesToNumber(entry.subarray(4, 8)),\n      sampleDescriptionIndex: bytesToNumber(entry.subarray(8, 12))\n    };\n  });\n  var stsz = findBox(stbl, ['stsz'])[0]; // stsz starts with a 4 byte sampleSize which we don't need\n\n  var sampleSizes = parseSamples(stsz && stsz.length && stsz.subarray(4) || null);\n  var frames = [];\n  for (var chunkIndex = 0; chunkIndex < chunkOffsets.length; chunkIndex++) {\n    var samplesInChunk = void 0;\n    for (var i = 0; i < samplesToChunks.length; i++) {\n      var sampleToChunk = samplesToChunks[i];\n      var isThisOne = chunkIndex + 1 >= sampleToChunk.firstChunk && (i + 1 >= samplesToChunks.length || chunkIndex + 1 < samplesToChunks[i + 1].firstChunk);\n      if (isThisOne) {\n        samplesInChunk = sampleToChunk.samplesPerChunk;\n        break;\n      }\n    }\n    var chunkOffset = chunkOffsets[chunkIndex];\n    for (var _i = 0; _i < samplesInChunk; _i++) {\n      var frameEnd = sampleSizes[frames.length]; // if we don't have key samples every frame is a keyframe\n\n      var keyframe = !keySamples.length;\n      if (keySamples.length && keySamples.indexOf(frames.length + 1) !== -1) {\n        keyframe = true;\n      }\n      var frame = {\n        keyframe: keyframe,\n        start: chunkOffset,\n        end: chunkOffset + frameEnd\n      };\n      for (var k = 0; k < timeToSamples.length; k++) {\n        var _timeToSamples$k = timeToSamples[k],\n          sampleCount = _timeToSamples$k.sampleCount,\n          sampleDelta = _timeToSamples$k.sampleDelta;\n        if (frames.length <= sampleCount) {\n          // ms to ns\n          var lastTimestamp = frames.length ? frames[frames.length - 1].timestamp : 0;\n          frame.timestamp = lastTimestamp + sampleDelta / timescale * 1000;\n          frame.duration = sampleDelta;\n          break;\n        }\n      }\n      frames.push(frame);\n      chunkOffset += frameEnd;\n    }\n  }\n  return frames;\n};\nexport var addSampleDescription = function addSampleDescription(track, bytes) {\n  var codec = bytesToString(bytes.subarray(0, 4));\n  if (track.type === 'video') {\n    track.info = track.info || {};\n    track.info.width = bytes[28] << 8 | bytes[29];\n    track.info.height = bytes[30] << 8 | bytes[31];\n  } else if (track.type === 'audio') {\n    track.info = track.info || {};\n    track.info.channels = bytes[20] << 8 | bytes[21];\n    track.info.bitDepth = bytes[22] << 8 | bytes[23];\n    track.info.sampleRate = bytes[28] << 8 | bytes[29];\n  }\n  if (codec === 'avc1') {\n    var avcC = findNamedBox(bytes, 'avcC'); // AVCDecoderConfigurationRecord\n\n    codec += \".\" + getAvcCodec(avcC);\n    track.info.avcC = avcC; // TODO: do we need to parse all this?\n\n    /* {\n      configurationVersion: avcC[0],\n      profile: avcC[1],\n      profileCompatibility: avcC[2],\n      level: avcC[3],\n      lengthSizeMinusOne: avcC[4] & 0x3\n    };\n     let spsNalUnitCount = avcC[5] & 0x1F;\n    const spsNalUnits = track.info.avc.spsNalUnits = [];\n     // past spsNalUnitCount\n    let offset = 6;\n     while (spsNalUnitCount--) {\n      const nalLen = avcC[offset] << 8 | avcC[offset + 1];\n       spsNalUnits.push(avcC.subarray(offset + 2, offset + 2 + nalLen));\n       offset += nalLen + 2;\n    }\n    let ppsNalUnitCount = avcC[offset];\n    const ppsNalUnits = track.info.avc.ppsNalUnits = [];\n     // past ppsNalUnitCount\n    offset += 1;\n     while (ppsNalUnitCount--) {\n      const nalLen = avcC[offset] << 8 | avcC[offset + 1];\n       ppsNalUnits.push(avcC.subarray(offset + 2, offset + 2 + nalLen));\n       offset += nalLen + 2;\n    }*/\n    // HEVCDecoderConfigurationRecord\n  } else if (codec === 'hvc1' || codec === 'hev1') {\n    codec += \".\" + getHvcCodec(findNamedBox(bytes, 'hvcC'));\n  } else if (codec === 'mp4a' || codec === 'mp4v') {\n    var esds = findNamedBox(bytes, 'esds');\n    var esDescriptor = parseDescriptors(esds.subarray(4))[0];\n    var decoderConfig = esDescriptor && esDescriptor.descriptors.filter(function (_ref) {\n      var tag = _ref.tag;\n      return tag === 0x04;\n    })[0];\n    if (decoderConfig) {\n      // most codecs do not have a further '.'\n      // such as 0xa5 for ac-3 and 0xa6 for e-ac-3\n      codec += '.' + toHexString(decoderConfig.oti);\n      if (decoderConfig.oti === 0x40) {\n        codec += '.' + (decoderConfig.descriptors[0].bytes[0] >> 3).toString();\n      } else if (decoderConfig.oti === 0x20) {\n        codec += '.' + decoderConfig.descriptors[0].bytes[4].toString();\n      } else if (decoderConfig.oti === 0xdd) {\n        codec = 'vorbis';\n      }\n    } else if (track.type === 'audio') {\n      codec += '.40.2';\n    } else {\n      codec += '.20.9';\n    }\n  } else if (codec === 'av01') {\n    // AV1DecoderConfigurationRecord\n    codec += \".\" + getAv1Codec(findNamedBox(bytes, 'av1C'));\n  } else if (codec === 'vp09') {\n    // VPCodecConfigurationRecord\n    var vpcC = findNamedBox(bytes, 'vpcC'); // https://www.webmproject.org/vp9/mp4/\n\n    var profile = vpcC[0];\n    var level = vpcC[1];\n    var bitDepth = vpcC[2] >> 4;\n    var chromaSubsampling = (vpcC[2] & 0x0F) >> 1;\n    var videoFullRangeFlag = (vpcC[2] & 0x0F) >> 3;\n    var colourPrimaries = vpcC[3];\n    var transferCharacteristics = vpcC[4];\n    var matrixCoefficients = vpcC[5];\n    codec += \".\" + padStart(profile, 2, '0');\n    codec += \".\" + padStart(level, 2, '0');\n    codec += \".\" + padStart(bitDepth, 2, '0');\n    codec += \".\" + padStart(chromaSubsampling, 2, '0');\n    codec += \".\" + padStart(colourPrimaries, 2, '0');\n    codec += \".\" + padStart(transferCharacteristics, 2, '0');\n    codec += \".\" + padStart(matrixCoefficients, 2, '0');\n    codec += \".\" + padStart(videoFullRangeFlag, 2, '0');\n  } else if (codec === 'theo') {\n    codec = 'theora';\n  } else if (codec === 'spex') {\n    codec = 'speex';\n  } else if (codec === '.mp3') {\n    codec = 'mp4a.40.34';\n  } else if (codec === 'msVo') {\n    codec = 'vorbis';\n  } else if (codec === 'Opus') {\n    codec = 'opus';\n    var dOps = findNamedBox(bytes, 'dOps');\n    track.info.opus = parseOpusHead(dOps); // TODO: should this go into the webm code??\n    // Firefox requires a codecDelay for opus playback\n    // see https://bugzilla.mozilla.org/show_bug.cgi?id=1276238\n\n    track.info.codecDelay = 6500000;\n  } else {\n    codec = codec.toLowerCase();\n  }\n  /* eslint-enable */\n  // flac, ac-3, ec-3, opus\n\n  track.codec = codec;\n};\nexport var parseTracks = function parseTracks(bytes, frameTable) {\n  if (frameTable === void 0) {\n    frameTable = true;\n  }\n  bytes = toUint8(bytes);\n  var traks = findBox(bytes, ['moov', 'trak'], true);\n  var tracks = [];\n  traks.forEach(function (trak) {\n    var track = {\n      bytes: trak\n    };\n    var mdia = findBox(trak, ['mdia'])[0];\n    var hdlr = findBox(mdia, ['hdlr'])[0];\n    var trakType = bytesToString(hdlr.subarray(8, 12));\n    if (trakType === 'soun') {\n      track.type = 'audio';\n    } else if (trakType === 'vide') {\n      track.type = 'video';\n    } else {\n      track.type = trakType;\n    }\n    var tkhd = findBox(trak, ['tkhd'])[0];\n    if (tkhd) {\n      var view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n      var tkhdVersion = view.getUint8(0);\n      track.number = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);\n    }\n    var mdhd = findBox(mdia, ['mdhd'])[0];\n    if (mdhd) {\n      // mdhd is a FullBox, meaning it will have its own version as the first byte\n      var version = mdhd[0];\n      var index = version === 0 ? 12 : 20;\n      track.timescale = (mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]) >>> 0;\n    }\n    var stbl = findBox(mdia, ['minf', 'stbl'])[0];\n    var stsd = findBox(stbl, ['stsd'])[0];\n    var descriptionCount = bytesToNumber(stsd.subarray(4, 8));\n    var offset = 8; // add codec and codec info\n\n    while (descriptionCount--) {\n      var len = bytesToNumber(stsd.subarray(offset, offset + 4));\n      var sampleDescriptor = stsd.subarray(offset + 4, offset + 4 + len);\n      addSampleDescription(track, sampleDescriptor);\n      offset += 4 + len;\n    }\n    if (frameTable) {\n      track.frameTable = buildFrameTable(stbl, track.timescale);\n    } // codec has no sub parameters\n\n    tracks.push(track);\n  });\n  return tracks;\n};\nexport var parseMediaInfo = function parseMediaInfo(bytes) {\n  var mvhd = findBox(bytes, ['moov', 'mvhd'], true)[0];\n  if (!mvhd || !mvhd.length) {\n    return;\n  }\n  var info = {}; // ms to ns\n  // mvhd v1 has 8 byte duration and other fields too\n\n  if (mvhd[0] === 1) {\n    info.timestampScale = bytesToNumber(mvhd.subarray(20, 24));\n    info.duration = bytesToNumber(mvhd.subarray(24, 32));\n  } else {\n    info.timestampScale = bytesToNumber(mvhd.subarray(12, 16));\n    info.duration = bytesToNumber(mvhd.subarray(16, 20));\n  }\n  info.bytes = mvhd;\n  return info;\n};","map":{"version":3,"names":["stringToBytes","toUint8","bytesMatch","bytesToString","toHexString","padStart","bytesToNumber","getAvcCodec","getHvcCodec","getAv1Codec","parseOpusHead","normalizePath","path","normalizePaths","paths","Array","isArray","map","p","DESCRIPTORS","parseDescriptors","bytes","results","i","length","tag","size","headerSize","byte","z","_DESCRIPTORS$z","id","parser","push","subarray","desc","flags","dependsOnEsId","ocrEsId","descriptors","url","len","oti","streamType","bufferSize","maxBitrate","avgBitrate","findBox","complete","type","end","data","apply","slice","findNamedBox","name","byteLength","parseSamples","entrySize","parseEntry","d","entries","entryCount","buildFrameTable","stbl","timescale","keySamples","chunkOffsets","timeToSamples","entry","sampleCount","sampleDelta","samplesToChunks","firstChunk","samplesPerChunk","sampleDescriptionIndex","stsz","sampleSizes","frames","chunkIndex","samplesInChunk","sampleToChunk","isThisOne","chunkOffset","_i","frameEnd","keyframe","indexOf","frame","start","k","_timeToSamples$k","lastTimestamp","timestamp","duration","addSampleDescription","track","codec","info","width","height","channels","bitDepth","sampleRate","avcC","esds","esDescriptor","decoderConfig","filter","_ref","toString","vpcC","profile","level","chromaSubsampling","videoFullRangeFlag","colourPrimaries","transferCharacteristics","matrixCoefficients","dOps","opus","codecDelay","toLowerCase","parseTracks","frameTable","traks","tracks","forEach","trak","mdia","hdlr","trakType","tkhd","view","DataView","buffer","byteOffset","tkhdVersion","getUint8","number","getUint32","mdhd","version","index","stsd","descriptionCount","offset","sampleDescriptor","parseMediaInfo","mvhd","timestampScale"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@videojs/vhs-utils/es/mp4-helpers.js"],"sourcesContent":["import { stringToBytes, toUint8, bytesMatch, bytesToString, toHexString, padStart, bytesToNumber } from './byte-helpers.js';\nimport { getAvcCodec, getHvcCodec, getAv1Codec } from './codec-helpers.js';\nimport { parseOpusHead } from './opus-helpers.js';\n\nvar normalizePath = function normalizePath(path) {\n  if (typeof path === 'string') {\n    return stringToBytes(path);\n  }\n\n  if (typeof path === 'number') {\n    return path;\n  }\n\n  return path;\n};\n\nvar normalizePaths = function normalizePaths(paths) {\n  if (!Array.isArray(paths)) {\n    return [normalizePath(paths)];\n  }\n\n  return paths.map(function (p) {\n    return normalizePath(p);\n  });\n};\n\nvar DESCRIPTORS;\nexport var parseDescriptors = function parseDescriptors(bytes) {\n  bytes = toUint8(bytes);\n  var results = [];\n  var i = 0;\n\n  while (bytes.length > i) {\n    var tag = bytes[i];\n    var size = 0;\n    var headerSize = 0; // tag\n\n    headerSize++;\n    var byte = bytes[headerSize]; // first byte\n\n    headerSize++;\n\n    while (byte & 0x80) {\n      size = (byte & 0x7F) << 7;\n      byte = bytes[headerSize];\n      headerSize++;\n    }\n\n    size += byte & 0x7F;\n\n    for (var z = 0; z < DESCRIPTORS.length; z++) {\n      var _DESCRIPTORS$z = DESCRIPTORS[z],\n          id = _DESCRIPTORS$z.id,\n          parser = _DESCRIPTORS$z.parser;\n\n      if (tag === id) {\n        results.push(parser(bytes.subarray(headerSize, headerSize + size)));\n        break;\n      }\n    }\n\n    i += size + headerSize;\n  }\n\n  return results;\n};\nDESCRIPTORS = [{\n  id: 0x03,\n  parser: function parser(bytes) {\n    var desc = {\n      tag: 0x03,\n      id: bytes[0] << 8 | bytes[1],\n      flags: bytes[2],\n      size: 3,\n      dependsOnEsId: 0,\n      ocrEsId: 0,\n      descriptors: [],\n      url: ''\n    }; // depends on es id\n\n    if (desc.flags & 0x80) {\n      desc.dependsOnEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];\n      desc.size += 2;\n    } // url\n\n\n    if (desc.flags & 0x40) {\n      var len = bytes[desc.size];\n      desc.url = bytesToString(bytes.subarray(desc.size + 1, desc.size + 1 + len));\n      desc.size += len;\n    } // ocr es id\n\n\n    if (desc.flags & 0x20) {\n      desc.ocrEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];\n      desc.size += 2;\n    }\n\n    desc.descriptors = parseDescriptors(bytes.subarray(desc.size)) || [];\n    return desc;\n  }\n}, {\n  id: 0x04,\n  parser: function parser(bytes) {\n    // DecoderConfigDescriptor\n    var desc = {\n      tag: 0x04,\n      oti: bytes[0],\n      streamType: bytes[1],\n      bufferSize: bytes[2] << 16 | bytes[3] << 8 | bytes[4],\n      maxBitrate: bytes[5] << 24 | bytes[6] << 16 | bytes[7] << 8 | bytes[8],\n      avgBitrate: bytes[9] << 24 | bytes[10] << 16 | bytes[11] << 8 | bytes[12],\n      descriptors: parseDescriptors(bytes.subarray(13))\n    };\n    return desc;\n  }\n}, {\n  id: 0x05,\n  parser: function parser(bytes) {\n    // DecoderSpecificInfo\n    return {\n      tag: 0x05,\n      bytes: bytes\n    };\n  }\n}, {\n  id: 0x06,\n  parser: function parser(bytes) {\n    // SLConfigDescriptor\n    return {\n      tag: 0x06,\n      bytes: bytes\n    };\n  }\n}];\n/**\n * find any number of boxes by name given a path to it in an iso bmff\n * such as mp4.\n *\n * @param {TypedArray} bytes\n *        bytes for the iso bmff to search for boxes in\n *\n * @param {Uint8Array[]|string[]|string|Uint8Array} name\n *        An array of paths or a single path representing the name\n *        of boxes to search through in bytes. Paths may be\n *        uint8 (character codes) or strings.\n *\n * @param {boolean} [complete=false]\n *        Should we search only for complete boxes on the final path.\n *        This is very useful when you do not want to get back partial boxes\n *        in the case of streaming files.\n *\n * @return {Uint8Array[]}\n *         An array of the end paths that we found.\n */\n\nexport var findBox = function findBox(bytes, paths, complete) {\n  if (complete === void 0) {\n    complete = false;\n  }\n\n  paths = normalizePaths(paths);\n  bytes = toUint8(bytes);\n  var results = [];\n\n  if (!paths.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;\n    var type = bytes.subarray(i + 4, i + 8); // invalid box format.\n\n    if (size === 0) {\n      break;\n    }\n\n    var end = i + size;\n\n    if (end > bytes.length) {\n      // this box is bigger than the number of bytes we have\n      // and complete is set, we cannot find any more boxes.\n      if (complete) {\n        break;\n      }\n\n      end = bytes.length;\n    }\n\n    var data = bytes.subarray(i + 8, end);\n\n    if (bytesMatch(type, paths[0])) {\n      if (paths.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data);\n      } else {\n        // recursively search for the next box along the path\n        results.push.apply(results, findBox(data, paths.slice(1), complete));\n      }\n    }\n\n    i = end;\n  } // we've finished searching all of bytes\n\n\n  return results;\n};\n/**\n * Search for a single matching box by name in an iso bmff format like\n * mp4. This function is useful for finding codec boxes which\n * can be placed arbitrarily in sample descriptions depending\n * on the version of the file or file type.\n *\n * @param {TypedArray} bytes\n *        bytes for the iso bmff to search for boxes in\n *\n * @param {string|Uint8Array} name\n *        The name of the box to find.\n *\n * @return {Uint8Array[]}\n *         a subarray of bytes representing the name boxed we found.\n */\n\nexport var findNamedBox = function findNamedBox(bytes, name) {\n  name = normalizePath(name);\n\n  if (!name.length) {\n    // short-circuit the search for empty paths\n    return bytes.subarray(bytes.length);\n  }\n\n  var i = 0;\n\n  while (i < bytes.length) {\n    if (bytesMatch(bytes.subarray(i, i + name.length), name)) {\n      var size = (bytes[i - 4] << 24 | bytes[i - 3] << 16 | bytes[i - 2] << 8 | bytes[i - 1]) >>> 0;\n      var end = size > 1 ? i + size : bytes.byteLength;\n      return bytes.subarray(i + 4, end);\n    }\n\n    i++;\n  } // we've finished searching all of bytes\n\n\n  return bytes.subarray(bytes.length);\n};\n\nvar parseSamples = function parseSamples(data, entrySize, parseEntry) {\n  if (entrySize === void 0) {\n    entrySize = 4;\n  }\n\n  if (parseEntry === void 0) {\n    parseEntry = function parseEntry(d) {\n      return bytesToNumber(d);\n    };\n  }\n\n  var entries = [];\n\n  if (!data || !data.length) {\n    return entries;\n  }\n\n  var entryCount = bytesToNumber(data.subarray(4, 8));\n\n  for (var i = 8; entryCount; i += entrySize, entryCount--) {\n    entries.push(parseEntry(data.subarray(i, i + entrySize)));\n  }\n\n  return entries;\n};\n\nexport var buildFrameTable = function buildFrameTable(stbl, timescale) {\n  var keySamples = parseSamples(findBox(stbl, ['stss'])[0]);\n  var chunkOffsets = parseSamples(findBox(stbl, ['stco'])[0]);\n  var timeToSamples = parseSamples(findBox(stbl, ['stts'])[0], 8, function (entry) {\n    return {\n      sampleCount: bytesToNumber(entry.subarray(0, 4)),\n      sampleDelta: bytesToNumber(entry.subarray(4, 8))\n    };\n  });\n  var samplesToChunks = parseSamples(findBox(stbl, ['stsc'])[0], 12, function (entry) {\n    return {\n      firstChunk: bytesToNumber(entry.subarray(0, 4)),\n      samplesPerChunk: bytesToNumber(entry.subarray(4, 8)),\n      sampleDescriptionIndex: bytesToNumber(entry.subarray(8, 12))\n    };\n  });\n  var stsz = findBox(stbl, ['stsz'])[0]; // stsz starts with a 4 byte sampleSize which we don't need\n\n  var sampleSizes = parseSamples(stsz && stsz.length && stsz.subarray(4) || null);\n  var frames = [];\n\n  for (var chunkIndex = 0; chunkIndex < chunkOffsets.length; chunkIndex++) {\n    var samplesInChunk = void 0;\n\n    for (var i = 0; i < samplesToChunks.length; i++) {\n      var sampleToChunk = samplesToChunks[i];\n      var isThisOne = chunkIndex + 1 >= sampleToChunk.firstChunk && (i + 1 >= samplesToChunks.length || chunkIndex + 1 < samplesToChunks[i + 1].firstChunk);\n\n      if (isThisOne) {\n        samplesInChunk = sampleToChunk.samplesPerChunk;\n        break;\n      }\n    }\n\n    var chunkOffset = chunkOffsets[chunkIndex];\n\n    for (var _i = 0; _i < samplesInChunk; _i++) {\n      var frameEnd = sampleSizes[frames.length]; // if we don't have key samples every frame is a keyframe\n\n      var keyframe = !keySamples.length;\n\n      if (keySamples.length && keySamples.indexOf(frames.length + 1) !== -1) {\n        keyframe = true;\n      }\n\n      var frame = {\n        keyframe: keyframe,\n        start: chunkOffset,\n        end: chunkOffset + frameEnd\n      };\n\n      for (var k = 0; k < timeToSamples.length; k++) {\n        var _timeToSamples$k = timeToSamples[k],\n            sampleCount = _timeToSamples$k.sampleCount,\n            sampleDelta = _timeToSamples$k.sampleDelta;\n\n        if (frames.length <= sampleCount) {\n          // ms to ns\n          var lastTimestamp = frames.length ? frames[frames.length - 1].timestamp : 0;\n          frame.timestamp = lastTimestamp + sampleDelta / timescale * 1000;\n          frame.duration = sampleDelta;\n          break;\n        }\n      }\n\n      frames.push(frame);\n      chunkOffset += frameEnd;\n    }\n  }\n\n  return frames;\n};\nexport var addSampleDescription = function addSampleDescription(track, bytes) {\n  var codec = bytesToString(bytes.subarray(0, 4));\n\n  if (track.type === 'video') {\n    track.info = track.info || {};\n    track.info.width = bytes[28] << 8 | bytes[29];\n    track.info.height = bytes[30] << 8 | bytes[31];\n  } else if (track.type === 'audio') {\n    track.info = track.info || {};\n    track.info.channels = bytes[20] << 8 | bytes[21];\n    track.info.bitDepth = bytes[22] << 8 | bytes[23];\n    track.info.sampleRate = bytes[28] << 8 | bytes[29];\n  }\n\n  if (codec === 'avc1') {\n    var avcC = findNamedBox(bytes, 'avcC'); // AVCDecoderConfigurationRecord\n\n    codec += \".\" + getAvcCodec(avcC);\n    track.info.avcC = avcC; // TODO: do we need to parse all this?\n\n    /* {\n      configurationVersion: avcC[0],\n      profile: avcC[1],\n      profileCompatibility: avcC[2],\n      level: avcC[3],\n      lengthSizeMinusOne: avcC[4] & 0x3\n    };\n     let spsNalUnitCount = avcC[5] & 0x1F;\n    const spsNalUnits = track.info.avc.spsNalUnits = [];\n     // past spsNalUnitCount\n    let offset = 6;\n     while (spsNalUnitCount--) {\n      const nalLen = avcC[offset] << 8 | avcC[offset + 1];\n       spsNalUnits.push(avcC.subarray(offset + 2, offset + 2 + nalLen));\n       offset += nalLen + 2;\n    }\n    let ppsNalUnitCount = avcC[offset];\n    const ppsNalUnits = track.info.avc.ppsNalUnits = [];\n     // past ppsNalUnitCount\n    offset += 1;\n     while (ppsNalUnitCount--) {\n      const nalLen = avcC[offset] << 8 | avcC[offset + 1];\n       ppsNalUnits.push(avcC.subarray(offset + 2, offset + 2 + nalLen));\n       offset += nalLen + 2;\n    }*/\n    // HEVCDecoderConfigurationRecord\n  } else if (codec === 'hvc1' || codec === 'hev1') {\n    codec += \".\" + getHvcCodec(findNamedBox(bytes, 'hvcC'));\n  } else if (codec === 'mp4a' || codec === 'mp4v') {\n    var esds = findNamedBox(bytes, 'esds');\n    var esDescriptor = parseDescriptors(esds.subarray(4))[0];\n    var decoderConfig = esDescriptor && esDescriptor.descriptors.filter(function (_ref) {\n      var tag = _ref.tag;\n      return tag === 0x04;\n    })[0];\n\n    if (decoderConfig) {\n      // most codecs do not have a further '.'\n      // such as 0xa5 for ac-3 and 0xa6 for e-ac-3\n      codec += '.' + toHexString(decoderConfig.oti);\n\n      if (decoderConfig.oti === 0x40) {\n        codec += '.' + (decoderConfig.descriptors[0].bytes[0] >> 3).toString();\n      } else if (decoderConfig.oti === 0x20) {\n        codec += '.' + decoderConfig.descriptors[0].bytes[4].toString();\n      } else if (decoderConfig.oti === 0xdd) {\n        codec = 'vorbis';\n      }\n    } else if (track.type === 'audio') {\n      codec += '.40.2';\n    } else {\n      codec += '.20.9';\n    }\n  } else if (codec === 'av01') {\n    // AV1DecoderConfigurationRecord\n    codec += \".\" + getAv1Codec(findNamedBox(bytes, 'av1C'));\n  } else if (codec === 'vp09') {\n    // VPCodecConfigurationRecord\n    var vpcC = findNamedBox(bytes, 'vpcC'); // https://www.webmproject.org/vp9/mp4/\n\n    var profile = vpcC[0];\n    var level = vpcC[1];\n    var bitDepth = vpcC[2] >> 4;\n    var chromaSubsampling = (vpcC[2] & 0x0F) >> 1;\n    var videoFullRangeFlag = (vpcC[2] & 0x0F) >> 3;\n    var colourPrimaries = vpcC[3];\n    var transferCharacteristics = vpcC[4];\n    var matrixCoefficients = vpcC[5];\n    codec += \".\" + padStart(profile, 2, '0');\n    codec += \".\" + padStart(level, 2, '0');\n    codec += \".\" + padStart(bitDepth, 2, '0');\n    codec += \".\" + padStart(chromaSubsampling, 2, '0');\n    codec += \".\" + padStart(colourPrimaries, 2, '0');\n    codec += \".\" + padStart(transferCharacteristics, 2, '0');\n    codec += \".\" + padStart(matrixCoefficients, 2, '0');\n    codec += \".\" + padStart(videoFullRangeFlag, 2, '0');\n  } else if (codec === 'theo') {\n    codec = 'theora';\n  } else if (codec === 'spex') {\n    codec = 'speex';\n  } else if (codec === '.mp3') {\n    codec = 'mp4a.40.34';\n  } else if (codec === 'msVo') {\n    codec = 'vorbis';\n  } else if (codec === 'Opus') {\n    codec = 'opus';\n    var dOps = findNamedBox(bytes, 'dOps');\n    track.info.opus = parseOpusHead(dOps); // TODO: should this go into the webm code??\n    // Firefox requires a codecDelay for opus playback\n    // see https://bugzilla.mozilla.org/show_bug.cgi?id=1276238\n\n    track.info.codecDelay = 6500000;\n  } else {\n    codec = codec.toLowerCase();\n  }\n  /* eslint-enable */\n  // flac, ac-3, ec-3, opus\n\n\n  track.codec = codec;\n};\nexport var parseTracks = function parseTracks(bytes, frameTable) {\n  if (frameTable === void 0) {\n    frameTable = true;\n  }\n\n  bytes = toUint8(bytes);\n  var traks = findBox(bytes, ['moov', 'trak'], true);\n  var tracks = [];\n  traks.forEach(function (trak) {\n    var track = {\n      bytes: trak\n    };\n    var mdia = findBox(trak, ['mdia'])[0];\n    var hdlr = findBox(mdia, ['hdlr'])[0];\n    var trakType = bytesToString(hdlr.subarray(8, 12));\n\n    if (trakType === 'soun') {\n      track.type = 'audio';\n    } else if (trakType === 'vide') {\n      track.type = 'video';\n    } else {\n      track.type = trakType;\n    }\n\n    var tkhd = findBox(trak, ['tkhd'])[0];\n\n    if (tkhd) {\n      var view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n      var tkhdVersion = view.getUint8(0);\n      track.number = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);\n    }\n\n    var mdhd = findBox(mdia, ['mdhd'])[0];\n\n    if (mdhd) {\n      // mdhd is a FullBox, meaning it will have its own version as the first byte\n      var version = mdhd[0];\n      var index = version === 0 ? 12 : 20;\n      track.timescale = (mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]) >>> 0;\n    }\n\n    var stbl = findBox(mdia, ['minf', 'stbl'])[0];\n    var stsd = findBox(stbl, ['stsd'])[0];\n    var descriptionCount = bytesToNumber(stsd.subarray(4, 8));\n    var offset = 8; // add codec and codec info\n\n    while (descriptionCount--) {\n      var len = bytesToNumber(stsd.subarray(offset, offset + 4));\n      var sampleDescriptor = stsd.subarray(offset + 4, offset + 4 + len);\n      addSampleDescription(track, sampleDescriptor);\n      offset += 4 + len;\n    }\n\n    if (frameTable) {\n      track.frameTable = buildFrameTable(stbl, track.timescale);\n    } // codec has no sub parameters\n\n\n    tracks.push(track);\n  });\n  return tracks;\n};\nexport var parseMediaInfo = function parseMediaInfo(bytes) {\n  var mvhd = findBox(bytes, ['moov', 'mvhd'], true)[0];\n\n  if (!mvhd || !mvhd.length) {\n    return;\n  }\n\n  var info = {}; // ms to ns\n  // mvhd v1 has 8 byte duration and other fields too\n\n  if (mvhd[0] === 1) {\n    info.timestampScale = bytesToNumber(mvhd.subarray(20, 24));\n    info.duration = bytesToNumber(mvhd.subarray(24, 32));\n  } else {\n    info.timestampScale = bytesToNumber(mvhd.subarray(12, 16));\n    info.duration = bytesToNumber(mvhd.subarray(16, 20));\n  }\n\n  info.bytes = mvhd;\n  return info;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}