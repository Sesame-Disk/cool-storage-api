{"ast":null,"code":"import _inherits from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _toConsumableArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _defineProperty from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar _DefaultSkipMarkup;\nimport { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\nimport { styleTags, tags, Tag } from '@lezer/highlight';\nvar CompositeBlock = /*#__PURE__*/function () {\n  function CompositeBlock(type,\n  // Used for indentation in list items, markup character in lists\n  value, from, hash, end, children, positions) {\n    _classCallCheck(this, CompositeBlock);\n    this.type = type;\n    this.value = value;\n    this.from = from;\n    this.hash = hash;\n    this.end = end;\n    this.children = children;\n    this.positions = positions;\n    this.hashProp = [[NodeProp.contextHash, hash]];\n  }\n  _createClass(CompositeBlock, [{\n    key: \"addChild\",\n    value: function addChild(child, pos) {\n      if (child.prop(NodeProp.contextHash) != this.hash) child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n      this.children.push(child);\n      this.positions.push(pos);\n    }\n  }, {\n    key: \"toTree\",\n    value: function toTree(nodeSet) {\n      var _this = this;\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.end;\n      var last = this.children.length - 1;\n      if (last >= 0) end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n      return new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n        makeTree: function makeTree(children, positions, length) {\n          return new Tree(NodeType.none, children, positions, length, _this.hashProp);\n        }\n      });\n    }\n  }], [{\n    key: \"create\",\n    value: function create(type, value, from, parentHash, end) {\n      var hash = parentHash + (parentHash << 8) + type + (value << 4) | 0;\n      return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n  }]);\n  return CompositeBlock;\n}();\nvar Type;\n(function (Type) {\n  Type[Type[\"Document\"] = 1] = \"Document\";\n  Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n  Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n  Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n  Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n  Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n  Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n  Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n  Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n  Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n  Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n  Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n  Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n  Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n  Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n  Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n  Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n  Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n  Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n  Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n  Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n  // Inline\n  Type[Type[\"Escape\"] = 22] = \"Escape\";\n  Type[Type[\"Entity\"] = 23] = \"Entity\";\n  Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n  Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n  Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n  Type[Type[\"Link\"] = 27] = \"Link\";\n  Type[Type[\"Image\"] = 28] = \"Image\";\n  Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n  Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n  Type[Type[\"Comment\"] = 31] = \"Comment\";\n  Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n  Type[Type[\"URL\"] = 33] = \"URL\";\n  // Smaller tokens\n  Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n  Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n  Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n  Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n  Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n  Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n  Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n  Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n  Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n  Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n})(Type || (Type = {}));\n/// Data structure used to accumulate a block's content during [leaf\n/// block parsing](#BlockParser.leaf).\nvar LeafBlock = /*#__PURE__*/_createClass(\n/// @internal\nfunction LeafBlock(\n/// The start position of the block.\nstart,\n/// The block's text content.\ncontent) {\n  _classCallCheck(this, LeafBlock);\n  this.start = start;\n  this.content = content;\n  /// @internal\n  this.marks = [];\n  /// The block parsers active for this block.\n  this.parsers = [];\n}); /// Data structure used during block-level per-line parsing.\nvar Line = /*#__PURE__*/function () {\n  function Line() {\n    _classCallCheck(this, Line);\n    /// The line's full text.\n    this.text = \"\";\n    /// The base indent provided by the composite contexts (that have\n    /// been handled so far).\n    this.baseIndent = 0;\n    /// The string position corresponding to the base indent.\n    this.basePos = 0;\n    /// The number of contexts handled @internal\n    this.depth = 0;\n    /// Any markers (i.e. block quote markers) parsed for the contexts. @internal\n    this.markers = [];\n    /// The position of the next non-whitespace character beyond any\n    /// list, blockquote, or other composite block markers.\n    this.pos = 0;\n    /// The column of the next non-whitespace character.\n    this.indent = 0;\n    /// The character code of the character after `pos`.\n    this.next = -1;\n  }\n  /// @internal\n  _createClass(Line, [{\n    key: \"forward\",\n    value: function forward() {\n      if (this.basePos > this.pos) this.forwardInner();\n    }\n    /// @internal\n  }, {\n    key: \"forwardInner\",\n    value: function forwardInner() {\n      var newPos = this.skipSpace(this.basePos);\n      this.indent = this.countIndent(newPos, this.pos, this.indent);\n      this.pos = newPos;\n      this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /// Skip whitespace after the given position, return the position of\n    /// the next non-space character or the end of the line if there's\n    /// only space after `from`.\n  }, {\n    key: \"skipSpace\",\n    value: function skipSpace(from) {\n      return _skipSpace(this.text, from);\n    }\n    /// @internal\n  }, {\n    key: \"reset\",\n    value: function reset(text) {\n      this.text = text;\n      this.baseIndent = this.basePos = this.pos = this.indent = 0;\n      this.forwardInner();\n      this.depth = 1;\n      while (this.markers.length) this.markers.pop();\n    }\n    /// Move the line's base position forward to the given position.\n    /// This should only be called by composite [block\n    /// parsers](#BlockParser.parse) or [markup skipping\n    /// functions](#NodeSpec.composite).\n  }, {\n    key: \"moveBase\",\n    value: function moveBase(to) {\n      this.basePos = to;\n      this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /// Move the line's base position forward to the given _column_.\n  }, {\n    key: \"moveBaseColumn\",\n    value: function moveBaseColumn(indent) {\n      this.baseIndent = indent;\n      this.basePos = this.findColumn(indent);\n    }\n    /// Store a composite-block-level marker. Should be called from\n    /// [markup skipping functions](#NodeSpec.composite) when they\n    /// consume any non-whitespace characters.\n  }, {\n    key: \"addMarker\",\n    value: function addMarker(elt) {\n      this.markers.push(elt);\n    }\n    /// Find the column position at `to`, optionally starting at a given\n    /// position and column.\n  }, {\n    key: \"countIndent\",\n    value: function countIndent(to) {\n      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var indent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      for (var i = from; i < to; i++) indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n      return indent;\n    }\n    /// Find the position corresponding to the given column.\n  }, {\n    key: \"findColumn\",\n    value: function findColumn(goal) {\n      var i = 0;\n      for (var indent = 0; i < this.text.length && indent < goal; i++) indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n      return i;\n    }\n    /// @internal\n  }, {\n    key: \"scrub\",\n    value: function scrub() {\n      if (!this.baseIndent) return this.text;\n      var result = \"\";\n      for (var i = 0; i < this.basePos; i++) result += \" \";\n      return result + this.text.slice(this.basePos);\n    }\n  }]);\n  return Line;\n}();\nfunction skipForList(bl, cx, line) {\n  if (line.pos == line.text.length || bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent) return true;\n  if (line.indent >= line.baseIndent + 4) return false;\n  var size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n  return size > 0 && (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) && line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nvar DefaultSkipMarkup = (_DefaultSkipMarkup = {}, _defineProperty(_DefaultSkipMarkup, Type.Blockquote, function (bl, cx, line) {\n  if (line.next != 62 /* '>' */) return false;\n  line.markers.push(_elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n  line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n  bl.end = cx.lineStart + line.text.length;\n  return true;\n}), _defineProperty(_DefaultSkipMarkup, Type.ListItem, function (bl, _cx, line) {\n  if (line.indent < line.baseIndent + bl.value && line.next > -1) return false;\n  line.moveBaseColumn(line.baseIndent + bl.value);\n  return true;\n}), _defineProperty(_DefaultSkipMarkup, Type.OrderedList, skipForList), _defineProperty(_DefaultSkipMarkup, Type.BulletList, skipForList), _defineProperty(_DefaultSkipMarkup, Type.Document, function () {\n  return true;\n}), _DefaultSkipMarkup);\nfunction space(ch) {\n  return ch == 32 || ch == 9 || ch == 10 || ch == 13;\n}\nfunction _skipSpace(line) {\n  var i = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  while (i < line.length && space(line.charCodeAt(i))) i++;\n  return i;\n}\nfunction skipSpaceBack(line, i, to) {\n  while (i > to && space(line.charCodeAt(i - 1))) i--;\n  return i;\n}\nfunction isFencedCode(line) {\n  if (line.next != 96 && line.next != 126 /* '`~' */) return -1;\n  var pos = line.pos + 1;\n  while (pos < line.text.length && line.text.charCodeAt(pos) == line.next) pos++;\n  if (pos < line.pos + 3) return -1;\n  if (line.next == 96) for (var i = pos; i < line.text.length; i++) if (line.text.charCodeAt(i) == 96) return -1;\n  return pos;\n}\nfunction isBlockquote(line) {\n  return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n  if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */) return -1;\n  var count = 1;\n  for (var pos = line.pos + 1; pos < line.text.length; pos++) {\n    var ch = line.text.charCodeAt(pos);\n    if (ch == line.next) count++;else if (!space(ch)) return -1;\n  }\n  // Setext headers take precedence\n  if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length) return -1;\n  return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n  for (var i = cx.stack.length - 1; i >= 0; i--) if (cx.stack[i].type == type) return true;\n  return false;\n}\nfunction isBulletList(line, cx, breaking) {\n  return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) && (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) && (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n  var pos = line.pos,\n    next = line.next;\n  for (;;) {\n    if (next >= 48 && next <= 57 /* '0-9' */) pos++;else break;\n    if (pos == line.text.length) return -1;\n    next = line.text.charCodeAt(pos);\n  }\n  if (pos == line.pos || pos > line.pos + 9 || next != 46 && next != 41 /* '.)' */ || pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1)) || breaking && !inList(cx, Type.OrderedList) && (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */)) return -1;\n  return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n  if (line.next != 35 /* '#' */) return -1;\n  var pos = line.pos + 1;\n  while (pos < line.text.length && line.text.charCodeAt(pos) == 35) pos++;\n  if (pos < line.text.length && line.text.charCodeAt(pos) != 32) return -1;\n  var size = pos - line.pos;\n  return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n  if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4) return -1;\n  var pos = line.pos + 1;\n  while (pos < line.text.length && line.text.charCodeAt(pos) == line.next) pos++;\n  var end = pos;\n  while (pos < line.text.length && space(line.text.charCodeAt(pos))) pos++;\n  return pos == line.text.length ? end : -1;\n}\nvar EmptyLine = /^[ \\t]*$/,\n  CommentEnd = /-->/,\n  ProcessingEnd = /\\?>/;\nvar HTMLBlockStyle = [[/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i], [/^\\s*<!--/, CommentEnd], [/^\\s*<\\?/, ProcessingEnd], [/^\\s*<![A-Z]/, />/], [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/], [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine], [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]];\nfunction isHTMLBlock(line, _cx, breaking) {\n  if (line.next != 60 /* '<' */) return -1;\n  var rest = line.text.slice(line.pos);\n  for (var i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++) if (HTMLBlockStyle[i][0].test(rest)) return i;\n  return -1;\n}\nfunction getListIndent(line, pos) {\n  var indentAfter = line.countIndent(pos, line.pos, line.indent);\n  var indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n  return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n  var last = marks.length - 1;\n  if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText) marks[last].to = to;else marks.push(_elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nvar DefaultBlockParsers = {\n  LinkReference: undefined,\n  IndentedCode: function IndentedCode(cx, line) {\n    var base = line.baseIndent + 4;\n    if (line.indent < base) return false;\n    var start = line.findColumn(base);\n    var from = cx.lineStart + start,\n      to = cx.lineStart + line.text.length;\n    var marks = [],\n      pendingMarks = [];\n    addCodeText(marks, from, to);\n    while (cx.nextLine() && line.depth >= cx.stack.length) {\n      if (line.pos == line.text.length) {\n        // Empty\n        addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n        var _iterator = _createForOfIteratorHelper(line.markers),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var m = _step.value;\n            pendingMarks.push(m);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else if (line.indent < base) {\n        break;\n      } else {\n        if (pendingMarks.length) {\n          var _iterator2 = _createForOfIteratorHelper(pendingMarks),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var _m = _step2.value;\n              if (_m.type == Type.CodeText) addCodeText(marks, _m.from, _m.to);else marks.push(_m);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          pendingMarks = [];\n        }\n        addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n        var _iterator3 = _createForOfIteratorHelper(line.markers),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _m2 = _step3.value;\n            marks.push(_m2);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        to = cx.lineStart + line.text.length;\n        var codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n        if (codeStart < to) addCodeText(marks, codeStart, to);\n      }\n    }\n    if (pendingMarks.length) {\n      pendingMarks = pendingMarks.filter(function (m) {\n        return m.type != Type.CodeText;\n      });\n      if (pendingMarks.length) line.markers = pendingMarks.concat(line.markers);\n    }\n    cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n    return true;\n  },\n  FencedCode: function FencedCode(cx, line) {\n    var fenceEnd = isFencedCode(line);\n    if (fenceEnd < 0) return false;\n    var from = cx.lineStart + line.pos,\n      ch = line.next,\n      len = fenceEnd - line.pos;\n    var infoFrom = line.skipSpace(fenceEnd),\n      infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n    var marks = [_elt(Type.CodeMark, from, from + len)];\n    if (infoFrom < infoTo) marks.push(_elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n    for (var first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n      var i = line.pos;\n      if (line.indent - line.baseIndent < 4) while (i < line.text.length && line.text.charCodeAt(i) == ch) i++;\n      if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n        var _iterator4 = _createForOfIteratorHelper(line.markers),\n          _step4;\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var m = _step4.value;\n            marks.push(m);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n        marks.push(_elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n        cx.nextLine();\n        break;\n      } else {\n        if (!first) addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n        var _iterator5 = _createForOfIteratorHelper(line.markers),\n          _step5;\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var _m3 = _step5.value;\n            marks.push(_m3);\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n        var textStart = cx.lineStart + line.basePos,\n          textEnd = cx.lineStart + line.text.length;\n        if (textStart < textEnd) addCodeText(marks, textStart, textEnd);\n      }\n    }\n    cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n    return true;\n  },\n  Blockquote: function Blockquote(cx, line) {\n    var size = isBlockquote(line);\n    if (size < 0) return false;\n    cx.startContext(Type.Blockquote, line.pos);\n    cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n    line.moveBase(line.pos + size);\n    return null;\n  },\n  HorizontalRule: function HorizontalRule(cx, line) {\n    if (isHorizontalRule(line, cx, false) < 0) return false;\n    var from = cx.lineStart + line.pos;\n    cx.nextLine();\n    cx.addNode(Type.HorizontalRule, from);\n    return true;\n  },\n  BulletList: function BulletList(cx, line) {\n    var size = isBulletList(line, cx, false);\n    if (size < 0) return false;\n    if (cx.block.type != Type.BulletList) cx.startContext(Type.BulletList, line.basePos, line.next);\n    var newBase = getListIndent(line, line.pos + 1);\n    cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n    cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n    line.moveBaseColumn(newBase);\n    return null;\n  },\n  OrderedList: function OrderedList(cx, line) {\n    var size = isOrderedList(line, cx, false);\n    if (size < 0) return false;\n    if (cx.block.type != Type.OrderedList) cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n    var newBase = getListIndent(line, line.pos + size);\n    cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n    cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n    line.moveBaseColumn(newBase);\n    return null;\n  },\n  ATXHeading: function ATXHeading(cx, line) {\n    var size = isAtxHeading(line);\n    if (size < 0) return false;\n    var off = line.pos,\n      from = cx.lineStart + off;\n    var endOfSpace = skipSpaceBack(line.text, line.text.length, off),\n      after = endOfSpace;\n    while (after > off && line.text.charCodeAt(after - 1) == line.next) after--;\n    if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1))) after = line.text.length;\n    var buf = cx.buffer.write(Type.HeaderMark, 0, size).writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n    if (after < line.text.length) buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n    var node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n    cx.nextLine();\n    cx.addNode(node, from);\n    return true;\n  },\n  HTMLBlock: function HTMLBlock(cx, line) {\n    var type = isHTMLBlock(line, cx, false);\n    if (type < 0) return false;\n    var from = cx.lineStart + line.pos,\n      end = HTMLBlockStyle[type][1];\n    var marks = [],\n      trailing = end != EmptyLine;\n    while (!end.test(line.text) && cx.nextLine()) {\n      if (line.depth < cx.stack.length) {\n        trailing = false;\n        break;\n      }\n      var _iterator6 = _createForOfIteratorHelper(line.markers),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var m = _step6.value;\n          marks.push(m);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n    if (trailing) cx.nextLine();\n    var nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n    var to = cx.prevLineEnd();\n    cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n    return true;\n  },\n  SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nvar LinkReferenceParser = /*#__PURE__*/function () {\n  function LinkReferenceParser(leaf) {\n    _classCallCheck(this, LinkReferenceParser);\n    this.stage = 0 /* RefStage.Start */;\n    this.elts = [];\n    this.pos = 0;\n    this.start = leaf.start;\n    this.advance(leaf.content);\n  }\n  _createClass(LinkReferenceParser, [{\n    key: \"nextLine\",\n    value: function nextLine(cx, line, leaf) {\n      if (this.stage == -1 /* RefStage.Failed */) return false;\n      var content = leaf.content + \"\\n\" + line.scrub();\n      var finish = this.advance(content);\n      if (finish > -1 && finish < content.length) return this.complete(cx, leaf, finish);\n      return false;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish(cx, leaf) {\n      if ((this.stage == 2 /* RefStage.Link */ || this.stage == 3 /* RefStage.Title */) && _skipSpace(leaf.content, this.pos) == leaf.content.length) return this.complete(cx, leaf, leaf.content.length);\n      return false;\n    }\n  }, {\n    key: \"complete\",\n    value: function complete(cx, leaf, len) {\n      cx.addLeafElement(leaf, _elt(Type.LinkReference, this.start, this.start + len, this.elts));\n      return true;\n    }\n  }, {\n    key: \"nextStage\",\n    value: function nextStage(elt) {\n      if (elt) {\n        this.pos = elt.to - this.start;\n        this.elts.push(elt);\n        this.stage++;\n        return true;\n      }\n      if (elt === false) this.stage = -1 /* RefStage.Failed */;\n      return false;\n    }\n  }, {\n    key: \"advance\",\n    value: function advance(content) {\n      for (;;) {\n        if (this.stage == -1 /* RefStage.Failed */) {\n          return -1;\n        } else if (this.stage == 0 /* RefStage.Start */) {\n          if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true))) return -1;\n          if (content.charCodeAt(this.pos) != 58 /* ':' */) return this.stage = -1 /* RefStage.Failed */;\n          this.elts.push(_elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n          this.pos++;\n        } else if (this.stage == 1 /* RefStage.Label */) {\n          if (!this.nextStage(parseURL(content, _skipSpace(content, this.pos), this.start))) return -1;\n        } else if (this.stage == 2 /* RefStage.Link */) {\n          var skip = _skipSpace(content, this.pos),\n            end = 0;\n          if (skip > this.pos) {\n            var title = parseLinkTitle(content, skip, this.start);\n            if (title) {\n              var titleEnd = lineEnd(content, title.to - this.start);\n              if (titleEnd > 0) {\n                this.nextStage(title);\n                end = titleEnd;\n              }\n            }\n          }\n          if (!end) end = lineEnd(content, this.pos);\n          return end > 0 && end < content.length ? end : -1;\n        } else {\n          // RefStage.Title\n          return lineEnd(content, this.pos);\n        }\n      }\n    }\n  }]);\n  return LinkReferenceParser;\n}();\nfunction lineEnd(text, pos) {\n  for (; pos < text.length; pos++) {\n    var next = text.charCodeAt(pos);\n    if (next == 10) break;\n    if (!space(next)) return -1;\n  }\n  return pos;\n}\nvar SetextHeadingParser = /*#__PURE__*/function () {\n  function SetextHeadingParser() {\n    _classCallCheck(this, SetextHeadingParser);\n  }\n  _createClass(SetextHeadingParser, [{\n    key: \"nextLine\",\n    value: function nextLine(cx, line, leaf) {\n      var underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n      var next = line.next;\n      if (underline < 0) return false;\n      var underlineMark = _elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n      cx.nextLine();\n      cx.addLeafElement(leaf, _elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [].concat(_toConsumableArray(cx.parser.parseInline(leaf.content, leaf.start)), [underlineMark])));\n      return true;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      return false;\n    }\n  }]);\n  return SetextHeadingParser;\n}();\nvar DefaultLeafBlocks = {\n  LinkReference: function LinkReference(_, leaf) {\n    return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null;\n  },\n  SetextHeading: function SetextHeading() {\n    return new SetextHeadingParser();\n  }\n};\nvar DefaultEndLeaf = [function (_, line) {\n  return isAtxHeading(line) >= 0;\n}, function (_, line) {\n  return isFencedCode(line) >= 0;\n}, function (_, line) {\n  return isBlockquote(line) >= 0;\n}, function (p, line) {\n  return isBulletList(line, p, true) >= 0;\n}, function (p, line) {\n  return isOrderedList(line, p, true) >= 0;\n}, function (p, line) {\n  return isHorizontalRule(line, p, true) >= 0;\n}, function (p, line) {\n  return isHTMLBlock(line, p, true) >= 0;\n}];\nvar scanLineResult = {\n  text: \"\",\n  end: 0\n};\n/// Block-level parsing functions get access to this context object.\nvar BlockContext = /*#__PURE__*/function () {\n  /// @internal\n  function BlockContext(\n  /// The parser configuration used.\n  parser,\n  /// @internal\n  input, fragments,\n  /// @internal\n  ranges) {\n    _classCallCheck(this, BlockContext);\n    this.parser = parser;\n    this.input = input;\n    this.ranges = ranges;\n    this.line = new Line();\n    this.atEnd = false;\n    /// For reused nodes on gaps, we can't directly put the original\n    /// node into the tree, since that may be bitter than its parent.\n    /// When this happens, we create a dummy tree that is replaced by\n    /// the proper node in `injectGaps` @internal\n    this.reusePlaceholders = new Map();\n    this.stoppedAt = null;\n    /// The range index that absoluteLineStart points into @internal\n    this.rangeI = 0;\n    this.to = ranges[ranges.length - 1].to;\n    this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n    this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n    this.stack = [this.block];\n    this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n    this.readLine();\n  }\n  _createClass(BlockContext, [{\n    key: \"parsedPos\",\n    get: function get() {\n      return this.absoluteLineStart;\n    }\n  }, {\n    key: \"advance\",\n    value: function advance() {\n      if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt) return this.finish();\n      var line = this.line;\n      for (;;) {\n        while (line.depth < this.stack.length) this.finishContext();\n        var _iterator7 = _createForOfIteratorHelper(line.markers),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var mark = _step7.value;\n            this.addNode(mark.type, mark.from, mark.to);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n        if (line.pos < line.text.length) break;\n        // Empty line\n        if (!this.nextLine()) return this.finish();\n      }\n      if (this.fragments && this.reuseFragment(line.basePos)) return null;\n      start: for (;;) {\n        var _iterator8 = _createForOfIteratorHelper(this.parser.blockParsers),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var type = _step8.value;\n            if (type) {\n              var result = type(this, line);\n              if (result != false) {\n                if (result == true) return null;\n                line.forward();\n                continue start;\n              }\n            }\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n        break;\n      }\n      var leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n      var _iterator9 = _createForOfIteratorHelper(this.parser.leafBlockParsers),\n        _step9;\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var parse = _step9.value;\n          if (parse) {\n            var _parser2 = parse(this, leaf);\n            if (_parser2) leaf.parsers.push(_parser2);\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n      lines: while (this.nextLine()) {\n        if (line.pos == line.text.length) break;\n        if (line.indent < line.baseIndent + 4) {\n          var _iterator10 = _createForOfIteratorHelper(this.parser.endLeafBlock),\n            _step10;\n          try {\n            for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n              var stop = _step10.value;\n              if (stop(this, line, leaf)) break lines;\n            }\n          } catch (err) {\n            _iterator10.e(err);\n          } finally {\n            _iterator10.f();\n          }\n        }\n        var _iterator11 = _createForOfIteratorHelper(leaf.parsers),\n          _step11;\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var _parser = _step11.value;\n            if (_parser.nextLine(this, line, leaf)) return null;\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n        leaf.content += \"\\n\" + line.scrub();\n        var _iterator12 = _createForOfIteratorHelper(line.markers),\n          _step12;\n        try {\n          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n            var m = _step12.value;\n            leaf.marks.push(m);\n          }\n        } catch (err) {\n          _iterator12.e(err);\n        } finally {\n          _iterator12.f();\n        }\n      }\n      this.finishLeaf(leaf);\n      return null;\n    }\n  }, {\n    key: \"stopAt\",\n    value: function stopAt(pos) {\n      if (this.stoppedAt != null && this.stoppedAt < pos) throw new RangeError(\"Can't move stoppedAt forward\");\n      this.stoppedAt = pos;\n    }\n  }, {\n    key: \"reuseFragment\",\n    value: function reuseFragment(start) {\n      if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) || !this.fragments.matches(this.block.hash)) return false;\n      var taken = this.fragments.takeNodes(this);\n      if (!taken) return false;\n      this.absoluteLineStart += taken;\n      this.lineStart = toRelative(this.absoluteLineStart, this.ranges);\n      this.moveRangeI();\n      if (this.absoluteLineStart < this.to) {\n        this.lineStart++;\n        this.absoluteLineStart++;\n        this.readLine();\n      } else {\n        this.atEnd = true;\n        this.readLine();\n      }\n      return true;\n    }\n    /// The number of parent blocks surrounding the current block.\n  }, {\n    key: \"depth\",\n    get: function get() {\n      return this.stack.length;\n    }\n    /// Get the type of the parent block at the given depth. When no\n    /// depth is passed, return the type of the innermost parent.\n  }, {\n    key: \"parentType\",\n    value: function parentType() {\n      var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.depth - 1;\n      return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /// Move to the next input line. This should only be called by\n    /// (non-composite) [block parsers](#BlockParser.parse) that consume\n    /// the line directly, or leaf block parser\n    /// [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    /// consume the current line (and return true).\n  }, {\n    key: \"nextLine\",\n    value: function nextLine() {\n      this.lineStart += this.line.text.length;\n      if (this.absoluteLineEnd >= this.to) {\n        this.absoluteLineStart = this.absoluteLineEnd;\n        this.atEnd = true;\n        this.readLine();\n        return false;\n      } else {\n        this.lineStart++;\n        this.absoluteLineStart = this.absoluteLineEnd + 1;\n        this.moveRangeI();\n        this.readLine();\n        return true;\n      }\n    }\n  }, {\n    key: \"moveRangeI\",\n    value: function moveRangeI() {\n      while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {\n        this.rangeI++;\n        this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);\n      }\n    }\n    /// @internal\n  }, {\n    key: \"scanLine\",\n    value: function scanLine(start) {\n      var r = scanLineResult;\n      r.end = start;\n      if (start >= this.to) {\n        r.text = \"\";\n      } else {\n        r.text = this.lineChunkAt(start);\n        r.end += r.text.length;\n        if (this.ranges.length > 1) {\n          var textOffset = this.absoluteLineStart,\n            rangeI = this.rangeI;\n          while (this.ranges[rangeI].to < r.end) {\n            rangeI++;\n            var nextFrom = this.ranges[rangeI].from;\n            var after = this.lineChunkAt(nextFrom);\n            r.end = nextFrom + after.length;\n            r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n            textOffset = r.end - r.text.length;\n          }\n        }\n      }\n      return r;\n    }\n    /// @internal\n  }, {\n    key: \"readLine\",\n    value: function readLine() {\n      var line = this.line,\n        _this$scanLine = this.scanLine(this.absoluteLineStart),\n        text = _this$scanLine.text,\n        end = _this$scanLine.end;\n      this.absoluteLineEnd = end;\n      line.reset(text);\n      for (; line.depth < this.stack.length; line.depth++) {\n        var cx = this.stack[line.depth],\n          handler = this.parser.skipContextMarkup[cx.type];\n        if (!handler) throw new Error(\"Unhandled block context \" + Type[cx.type]);\n        if (!handler(cx, this, line)) break;\n        line.forward();\n      }\n    }\n  }, {\n    key: \"lineChunkAt\",\n    value: function lineChunkAt(pos) {\n      var next = this.input.chunk(pos),\n        text;\n      if (!this.input.lineChunks) {\n        var eol = next.indexOf(\"\\n\");\n        text = eol < 0 ? next : next.slice(0, eol);\n      } else {\n        text = next == \"\\n\" ? \"\" : next;\n      }\n      return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /// The end position of the previous line.\n  }, {\n    key: \"prevLineEnd\",\n    value: function prevLineEnd() {\n      return this.atEnd ? this.lineStart : this.lineStart - 1;\n    }\n    /// @internal\n  }, {\n    key: \"startContext\",\n    value: function startContext(type, start) {\n      var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n      this.stack.push(this.block);\n    }\n    /// Start a composite block. Should only be called from [block\n    /// parser functions](#BlockParser.parse) that return null.\n  }, {\n    key: \"startComposite\",\n    value: function startComposite(type, start) {\n      var value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /// @internal\n  }, {\n    key: \"addNode\",\n    value: function addNode(block, from, to) {\n      if (typeof block == \"number\") block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n      this.block.addChild(block, from - this.block.from);\n    }\n    /// Add a block element. Can be called by [block\n    /// parsers](#BlockParser.parse).\n  }, {\n    key: \"addElement\",\n    value: function addElement(elt) {\n      this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /// Add a block element from a [leaf parser](#LeafBlockParser). This\n    /// makes sure any extra composite block markup (such as blockquote\n    /// markers) inside the block are also added to the syntax tree.\n  }, {\n    key: \"addLeafElement\",\n    value: function addLeafElement(leaf, elt) {\n      this.addNode(this.buffer.writeElements(injectMarks(elt.children, leaf.marks), -elt.from).finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /// @internal\n  }, {\n    key: \"finishContext\",\n    value: function finishContext() {\n      var cx = this.stack.pop();\n      var top = this.stack[this.stack.length - 1];\n      top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n      this.block = top;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      while (this.stack.length > 1) this.finishContext();\n      return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n  }, {\n    key: \"addGaps\",\n    value: function addGaps(tree) {\n      return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders) : tree;\n    }\n    /// @internal\n  }, {\n    key: \"finishLeaf\",\n    value: function finishLeaf(leaf) {\n      var _iterator13 = _createForOfIteratorHelper(leaf.parsers),\n        _step13;\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var _parser3 = _step13.value;\n          if (_parser3.finish(this, leaf)) return;\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n      var inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n      this.addNode(this.buffer.writeElements(inline, -leaf.start).finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n  }, {\n    key: \"elt\",\n    value: function elt(type, from, to, children) {\n      if (typeof type == \"string\") return _elt(this.parser.getNodeType(type), from, to, children);\n      return new TreeElement(type, from);\n    }\n    /// @internal\n  }, {\n    key: \"buffer\",\n    get: function get() {\n      return new Buffer(this.parser.nodeSet);\n    }\n  }]);\n  return BlockContext;\n}();\nfunction injectGaps(ranges, rangeI, tree, offset, dummies) {\n  var rangeEnd = ranges[rangeI].to;\n  var children = [],\n    positions = [],\n    start = tree.from + offset;\n  function movePastNext(upto, inclusive) {\n    while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n      var size = ranges[rangeI + 1].from - rangeEnd;\n      offset += size;\n      upto += size;\n      rangeI++;\n      rangeEnd = ranges[rangeI].to;\n    }\n  }\n  for (var ch = tree.firstChild; ch; ch = ch.nextSibling) {\n    movePastNext(ch.from + offset, true);\n    var from = ch.from + offset,\n      node = void 0,\n      reuse = dummies.get(ch.tree);\n    if (reuse) {\n      node = reuse;\n    } else if (ch.to + offset > rangeEnd) {\n      node = injectGaps(ranges, rangeI, ch, offset, dummies);\n      movePastNext(ch.to + offset, false);\n    } else {\n      node = ch.toTree();\n    }\n    children.push(node);\n    positions.push(from - start);\n  }\n  movePastNext(tree.to + offset, false);\n  return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/// A Markdown parser configuration.\nvar MarkdownParser = /*#__PURE__*/function (_Parser) {\n  _inherits(MarkdownParser, _Parser);\n  var _super = _createSuper(MarkdownParser);\n  /// @internal\n  function MarkdownParser(\n  /// The parser's syntax [node\n  /// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n  nodeSet,\n  /// @internal\n  blockParsers,\n  /// @internal\n  leafBlockParsers,\n  /// @internal\n  blockNames,\n  /// @internal\n  endLeafBlock,\n  /// @internal\n  skipContextMarkup,\n  /// @internal\n  inlineParsers,\n  /// @internal\n  inlineNames,\n  /// @internal\n  wrappers) {\n    var _this2;\n    _classCallCheck(this, MarkdownParser);\n    _this2 = _super.call(this);\n    _this2.nodeSet = nodeSet;\n    _this2.blockParsers = blockParsers;\n    _this2.leafBlockParsers = leafBlockParsers;\n    _this2.blockNames = blockNames;\n    _this2.endLeafBlock = endLeafBlock;\n    _this2.skipContextMarkup = skipContextMarkup;\n    _this2.inlineParsers = inlineParsers;\n    _this2.inlineNames = inlineNames;\n    _this2.wrappers = wrappers;\n    /// @internal\n    _this2.nodeTypes = Object.create(null);\n    var _iterator14 = _createForOfIteratorHelper(nodeSet.types),\n      _step14;\n    try {\n      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n        var t = _step14.value;\n        _this2.nodeTypes[t.name] = t.id;\n      }\n    } catch (err) {\n      _iterator14.e(err);\n    } finally {\n      _iterator14.f();\n    }\n    return _this2;\n  }\n  _createClass(MarkdownParser, [{\n    key: \"createParse\",\n    value: function createParse(input, fragments, ranges) {\n      var parse = new BlockContext(this, input, fragments, ranges);\n      var _iterator15 = _createForOfIteratorHelper(this.wrappers),\n        _step15;\n      try {\n        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n          var w = _step15.value;\n          parse = w(parse, input, fragments, ranges);\n        }\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n      return parse;\n    }\n    /// Reconfigure the parser.\n  }, {\n    key: \"configure\",\n    value: function configure(spec) {\n      var _nodeSet;\n      var config = resolveConfig(spec);\n      if (!config) return this;\n      var nodeSet = this.nodeSet,\n        skipContextMarkup = this.skipContextMarkup;\n      var blockParsers = this.blockParsers.slice(),\n        leafBlockParsers = this.leafBlockParsers.slice(),\n        blockNames = this.blockNames.slice(),\n        inlineParsers = this.inlineParsers.slice(),\n        inlineNames = this.inlineNames.slice(),\n        endLeafBlock = this.endLeafBlock.slice(),\n        wrappers = this.wrappers;\n      if (nonEmpty(config.defineNodes)) {\n        skipContextMarkup = Object.assign({}, skipContextMarkup);\n        var _nodeTypes = nodeSet.types.slice(),\n          styles;\n        var _iterator16 = _createForOfIteratorHelper(config.defineNodes),\n          _step16;\n        try {\n          var _loop = function _loop() {\n            var s = _step16.value;\n            var _ref = typeof s == \"string\" ? {\n                name: s\n              } : s,\n              name = _ref.name,\n              block = _ref.block,\n              composite = _ref.composite,\n              style = _ref.style;\n            if (_nodeTypes.some(function (t) {\n              return t.name == name;\n            })) return 1; // continue\n            if (composite) skipContextMarkup[_nodeTypes.length] = function (bl, cx, line) {\n              return composite(cx, line, bl.value);\n            };\n            var id = _nodeTypes.length;\n            var group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n            _nodeTypes.push(NodeType.define({\n              id: id,\n              name: name,\n              props: group && [[NodeProp.group, group]]\n            }));\n            if (style) {\n              if (!styles) styles = {};\n              if (Array.isArray(style) || style instanceof Tag) styles[name] = style;else Object.assign(styles, style);\n            }\n          };\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            if (_loop()) continue;\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n        nodeSet = new NodeSet(_nodeTypes);\n        if (styles) nodeSet = nodeSet.extend(styleTags(styles));\n      }\n      if (nonEmpty(config.props)) nodeSet = (_nodeSet = nodeSet).extend.apply(_nodeSet, _toConsumableArray(config.props));\n      if (nonEmpty(config.remove)) {\n        var _iterator17 = _createForOfIteratorHelper(config.remove),\n          _step17;\n        try {\n          for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n            var rm = _step17.value;\n            var block = this.blockNames.indexOf(rm),\n              inline = this.inlineNames.indexOf(rm);\n            if (block > -1) blockParsers[block] = leafBlockParsers[block] = undefined;\n            if (inline > -1) inlineParsers[inline] = undefined;\n          }\n        } catch (err) {\n          _iterator17.e(err);\n        } finally {\n          _iterator17.f();\n        }\n      }\n      if (nonEmpty(config.parseBlock)) {\n        var _iterator18 = _createForOfIteratorHelper(config.parseBlock),\n          _step18;\n        try {\n          for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n            var _spec = _step18.value;\n            var found = blockNames.indexOf(_spec.name);\n            if (found > -1) {\n              blockParsers[found] = _spec.parse;\n              leafBlockParsers[found] = _spec.leaf;\n            } else {\n              var pos = _spec.before ? findName(blockNames, _spec.before) : _spec.after ? findName(blockNames, _spec.after) + 1 : blockNames.length - 1;\n              blockParsers.splice(pos, 0, _spec.parse);\n              leafBlockParsers.splice(pos, 0, _spec.leaf);\n              blockNames.splice(pos, 0, _spec.name);\n            }\n            if (_spec.endLeaf) endLeafBlock.push(_spec.endLeaf);\n          }\n        } catch (err) {\n          _iterator18.e(err);\n        } finally {\n          _iterator18.f();\n        }\n      }\n      if (nonEmpty(config.parseInline)) {\n        var _iterator19 = _createForOfIteratorHelper(config.parseInline),\n          _step19;\n        try {\n          for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n            var _spec2 = _step19.value;\n            var _found = inlineNames.indexOf(_spec2.name);\n            if (_found > -1) {\n              inlineParsers[_found] = _spec2.parse;\n            } else {\n              var _pos = _spec2.before ? findName(inlineNames, _spec2.before) : _spec2.after ? findName(inlineNames, _spec2.after) + 1 : inlineNames.length - 1;\n              inlineParsers.splice(_pos, 0, _spec2.parse);\n              inlineNames.splice(_pos, 0, _spec2.name);\n            }\n          }\n        } catch (err) {\n          _iterator19.e(err);\n        } finally {\n          _iterator19.f();\n        }\n      }\n      if (config.wrap) wrappers = wrappers.concat(config.wrap);\n      return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /// @internal\n  }, {\n    key: \"getNodeType\",\n    value: function getNodeType(name) {\n      var found = this.nodeTypes[name];\n      if (found == null) throw new RangeError(\"Unknown node type '\".concat(name, \"'\"));\n      return found;\n    }\n    /// Parse the given piece of inline text at the given offset,\n    /// returning an array of [`Element`](#Element) objects representing\n    /// the inline content.\n  }, {\n    key: \"parseInline\",\n    value: function parseInline(text, offset) {\n      var cx = new InlineContext(this, text, offset);\n      outer: for (var pos = offset; pos < cx.end;) {\n        var next = cx.char(pos);\n        var _iterator20 = _createForOfIteratorHelper(this.inlineParsers),\n          _step20;\n        try {\n          for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n            var token = _step20.value;\n            if (token) {\n              var result = token(cx, next, pos);\n              if (result >= 0) {\n                pos = result;\n                continue outer;\n              }\n            }\n          }\n        } catch (err) {\n          _iterator20.e(err);\n        } finally {\n          _iterator20.f();\n        }\n        pos++;\n      }\n      return cx.resolveMarkers(0);\n    }\n  }]);\n  return MarkdownParser;\n}(Parser);\nfunction nonEmpty(a) {\n  return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n  if (!Array.isArray(spec)) return spec;\n  if (spec.length == 0) return null;\n  var conf = resolveConfig(spec[0]);\n  if (spec.length == 1) return conf;\n  var rest = resolveConfig(spec.slice(1));\n  if (!rest || !conf) return conf || rest;\n  var conc = function conc(a, b) {\n    return (a || none).concat(b || none);\n  };\n  var wrapA = conf.wrap,\n    wrapB = rest.wrap;\n  return {\n    props: conc(conf.props, rest.props),\n    defineNodes: conc(conf.defineNodes, rest.defineNodes),\n    parseBlock: conc(conf.parseBlock, rest.parseBlock),\n    parseInline: conc(conf.parseInline, rest.parseInline),\n    remove: conc(conf.remove, rest.remove),\n    wrap: !wrapA ? wrapB : !wrapB ? wrapA : function (inner, input, fragments, ranges) {\n      return wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges);\n    }\n  };\n}\nfunction findName(names, name) {\n  var found = names.indexOf(name);\n  if (found < 0) throw new RangeError(\"Position specified relative to unknown parser \".concat(name));\n  return found;\n}\nvar nodeTypes = [NodeType.none];\nfor (var i = 1, name; name = Type[i]; i++) {\n  nodeTypes[i] = NodeType.define({\n    id: i,\n    name: name,\n    props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]],\n    top: name == \"Document\"\n  });\n}\nvar none = [];\nvar Buffer = /*#__PURE__*/function () {\n  function Buffer(nodeSet) {\n    _classCallCheck(this, Buffer);\n    this.nodeSet = nodeSet;\n    this.content = [];\n    this.nodes = [];\n  }\n  _createClass(Buffer, [{\n    key: \"write\",\n    value: function write(type, from, to) {\n      var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      this.content.push(type, from, to, 4 + children * 4);\n      return this;\n    }\n  }, {\n    key: \"writeElements\",\n    value: function writeElements(elts) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var _iterator21 = _createForOfIteratorHelper(elts),\n        _step21;\n      try {\n        for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n          var e = _step21.value;\n          e.writeTo(this, offset);\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n      return this;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish(type, length) {\n      return Tree.build({\n        buffer: this.content,\n        nodeSet: this.nodeSet,\n        reused: this.nodes,\n        topID: type,\n        length: length\n      });\n    }\n  }]);\n  return Buffer;\n}(); /// Elements are used to compose syntax nodes during parsing.\nvar Element = /*#__PURE__*/function () {\n  /// @internal\n  function Element(\n  /// The node's\n  /// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n  type,\n  /// The start of the node, as an offset from the start of the document.\n  from,\n  /// The end of the node.\n  to) {\n    var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : none;\n    _classCallCheck(this, Element);\n    this.type = type;\n    this.from = from;\n    this.to = to;\n    this.children = children;\n  }\n  /// @internal\n  _createClass(Element, [{\n    key: \"writeTo\",\n    value: function writeTo(buf, offset) {\n      var startOff = buf.content.length;\n      buf.writeElements(this.children, offset);\n      buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /// @internal\n  }, {\n    key: \"toTree\",\n    value: function toTree(nodeSet) {\n      return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n  }]);\n  return Element;\n}();\nvar TreeElement = /*#__PURE__*/function () {\n  function TreeElement(tree, from) {\n    _classCallCheck(this, TreeElement);\n    this.tree = tree;\n    this.from = from;\n  }\n  _createClass(TreeElement, [{\n    key: \"to\",\n    get: function get() {\n      return this.from + this.tree.length;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.tree.type.id;\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      return none;\n    }\n  }, {\n    key: \"writeTo\",\n    value: function writeTo(buf, offset) {\n      buf.nodes.push(this.tree);\n      buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n  }, {\n    key: \"toTree\",\n    value: function toTree() {\n      return this.tree;\n    }\n  }]);\n  return TreeElement;\n}();\nfunction _elt(type, from, to, children) {\n  return new Element(type, from, to, children);\n}\nvar EmphasisUnderscore = {\n  resolve: \"Emphasis\",\n  mark: \"EmphasisMark\"\n};\nvar EmphasisAsterisk = {\n  resolve: \"Emphasis\",\n  mark: \"EmphasisMark\"\n};\nvar LinkStart = {},\n  ImageStart = {};\nvar InlineDelimiter = /*#__PURE__*/_createClass(function InlineDelimiter(type, from, to, side) {\n  _classCallCheck(this, InlineDelimiter);\n  this.type = type;\n  this.from = from;\n  this.to = to;\n  this.side = side;\n});\nvar Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nvar Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n  Punctuation = new RegExp(\"[\\\\p{Pc}|\\\\p{Pd}|\\\\p{Pe}|\\\\p{Pf}|\\\\p{Pi}|\\\\p{Po}|\\\\p{Ps}]\", \"u\");\n} catch (_) {}\nvar DefaultInline = {\n  Escape: function Escape(cx, next, start) {\n    if (next != 92 /* '\\\\' */ || start == cx.end - 1) return -1;\n    var escaped = cx.char(start + 1);\n    for (var _i = 0; _i < Escapable.length; _i++) if (Escapable.charCodeAt(_i) == escaped) return cx.append(_elt(Type.Escape, start, start + 2));\n    return -1;\n  },\n  Entity: function Entity(cx, next, start) {\n    if (next != 38 /* '&' */) return -1;\n    var m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n    return m ? cx.append(_elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n  },\n  InlineCode: function InlineCode(cx, next, start) {\n    if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96) return -1;\n    var pos = start + 1;\n    while (pos < cx.end && cx.char(pos) == 96) pos++;\n    var size = pos - start,\n      curSize = 0;\n    for (; pos < cx.end; pos++) {\n      if (cx.char(pos) == 96) {\n        curSize++;\n        if (curSize == size && cx.char(pos + 1) != 96) return cx.append(_elt(Type.InlineCode, start, pos + 1, [_elt(Type.CodeMark, start, start + size), _elt(Type.CodeMark, pos + 1 - size, pos + 1)]));\n      } else {\n        curSize = 0;\n      }\n    }\n    return -1;\n  },\n  HTMLTag: function HTMLTag(cx, next, start) {\n    if (next != 60 /* '<' */ || start == cx.end - 1) return -1;\n    var after = cx.slice(start + 1, cx.end);\n    var url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n    if (url) return cx.append(_elt(Type.URL, start, start + 1 + url[0].length));\n    var comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n    if (comment) return cx.append(_elt(Type.Comment, start, start + 1 + comment[0].length));\n    var procInst = /^\\?[^]*?\\?>/.exec(after);\n    if (procInst) return cx.append(_elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n    var m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n    if (!m) return -1;\n    return cx.append(_elt(Type.HTMLTag, start, start + 1 + m[0].length));\n  },\n  Emphasis: function Emphasis(cx, next, start) {\n    if (next != 95 && next != 42) return -1;\n    var pos = start + 1;\n    while (cx.char(pos) == next) pos++;\n    var before = cx.slice(start - 1, start),\n      after = cx.slice(pos, pos + 1);\n    var pBefore = Punctuation.test(before),\n      pAfter = Punctuation.test(after);\n    var sBefore = /\\s|^$/.test(before),\n      sAfter = /\\s|^$/.test(after);\n    var leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n    var rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n    var canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n    var canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n    return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Mark.Open */ : 0) | (canClose ? 2 /* Mark.Close */ : 0)));\n  },\n  HardBreak: function HardBreak(cx, next, start) {\n    if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */) return cx.append(_elt(Type.HardBreak, start, start + 2));\n    if (next == 32) {\n      var pos = start + 1;\n      while (cx.char(pos) == 32) pos++;\n      if (cx.char(pos) == 10 && pos >= start + 2) return cx.append(_elt(Type.HardBreak, start, pos + 1));\n    }\n    return -1;\n  },\n  Link: function Link(cx, next, start) {\n    return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Mark.Open */)) : -1;\n  },\n  Image: function Image(cx, next, start) {\n    return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */ ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Mark.Open */)) : -1;\n  },\n  LinkEnd: function LinkEnd(cx, next, start) {\n    if (next != 93 /* ']' */) return -1;\n    // Scanning back to the next link/image start marker\n    for (var _i2 = cx.parts.length - 1; _i2 >= 0; _i2--) {\n      var part = cx.parts[_i2];\n      if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n        // If this one has been set invalid (because it would produce\n        // a nested link) or there's no valid link here ignore both.\n        if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n          cx.parts[_i2] = null;\n          return -1;\n        }\n        // Finish the content and replace the entire range in\n        // this.parts with the link/image node.\n        var content = cx.takeContent(_i2);\n        var link = cx.parts[_i2] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n        // Set any open-link markers before this link to invalid.\n        if (part.type == LinkStart) for (var j = 0; j < _i2; j++) {\n          var p = cx.parts[j];\n          if (p instanceof InlineDelimiter && p.type == LinkStart) p.side = 0;\n        }\n        return link.to;\n      }\n    }\n    return -1;\n  }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n  var text = cx.text,\n    next = cx.char(startPos),\n    endPos = startPos;\n  content.unshift(_elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n  content.push(_elt(Type.LinkMark, startPos - 1, startPos));\n  if (next == 40 /* '(' */) {\n    var pos = cx.skipSpace(startPos + 1);\n    var dest = parseURL(text, pos - cx.offset, cx.offset),\n      title;\n    if (dest) {\n      pos = cx.skipSpace(dest.to);\n      title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n      if (title) pos = cx.skipSpace(title.to);\n    }\n    if (cx.char(pos) == 41 /* ')' */) {\n      content.push(_elt(Type.LinkMark, startPos, startPos + 1));\n      endPos = pos + 1;\n      if (dest) content.push(dest);\n      if (title) content.push(title);\n      content.push(_elt(Type.LinkMark, pos, endPos));\n    }\n  } else if (next == 91 /* '[' */) {\n    var label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n    if (label) {\n      content.push(label);\n      endPos = label.to;\n    }\n  }\n  return _elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n  var next = text.charCodeAt(start);\n  if (next == 60 /* '<' */) {\n    for (var pos = start + 1; pos < text.length; pos++) {\n      var ch = text.charCodeAt(pos);\n      if (ch == 62 /* '>' */) return _elt(Type.URL, start + offset, pos + 1 + offset);\n      if (ch == 60 || ch == 10 /* '<\\n' */) return false;\n    }\n    return null;\n  } else {\n    var depth = 0,\n      _pos2 = start;\n    for (var escaped = false; _pos2 < text.length; _pos2++) {\n      var _ch = text.charCodeAt(_pos2);\n      if (space(_ch)) {\n        break;\n      } else if (escaped) {\n        escaped = false;\n      } else if (_ch == 40 /* '(' */) {\n        depth++;\n      } else if (_ch == 41 /* ')' */) {\n        if (!depth) break;\n        depth--;\n      } else if (_ch == 92 /* '\\\\' */) {\n        escaped = true;\n      }\n    }\n    return _pos2 > start ? _elt(Type.URL, start + offset, _pos2 + offset) : _pos2 == text.length ? null : false;\n  }\n}\nfunction parseLinkTitle(text, start, offset) {\n  var next = text.charCodeAt(start);\n  if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */) return false;\n  var end = next == 40 ? 41 : next;\n  for (var pos = start + 1, escaped = false; pos < text.length; pos++) {\n    var ch = text.charCodeAt(pos);\n    if (escaped) escaped = false;else if (ch == end) return _elt(Type.LinkTitle, start + offset, pos + 1 + offset);else if (ch == 92 /* '\\\\' */) escaped = true;\n  }\n  return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n  for (var escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n    var ch = text.charCodeAt(pos);\n    if (escaped) escaped = false;else if (ch == 93 /* ']' */) return requireNonWS ? false : _elt(Type.LinkLabel, start + offset, pos + 1 + offset);else {\n      if (requireNonWS && !space(ch)) requireNonWS = false;\n      if (ch == 91 /* '[' */) return false;else if (ch == 92 /* '\\\\' */) escaped = true;\n    }\n  }\n  return null;\n}\n/// Inline parsing functions get access to this context, and use it to\n/// read the content and emit syntax nodes.\nvar InlineContext = /*#__PURE__*/function () {\n  /// @internal\n  function InlineContext(\n  /// The parser that is being used.\n  parser,\n  /// The text of this inline section.\n  text,\n  /// The starting offset of the section in the document.\n  offset) {\n    _classCallCheck(this, InlineContext);\n    this.parser = parser;\n    this.text = text;\n    this.offset = offset;\n    /// @internal\n    this.parts = [];\n  }\n  /// Get the character code at the given (document-relative)\n  /// position.\n  _createClass(InlineContext, [{\n    key: \"char\",\n    value: function char(pos) {\n      return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset);\n    }\n    /// The position of the end of this inline section.\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.offset + this.text.length;\n    }\n    /// Get a substring of this inline section. Again uses\n    /// document-relative positions.\n  }, {\n    key: \"slice\",\n    value: function slice(from, to) {\n      return this.text.slice(from - this.offset, to - this.offset);\n    }\n    /// @internal\n  }, {\n    key: \"append\",\n    value: function append(elt) {\n      this.parts.push(elt);\n      return elt.to;\n    }\n    /// Add a [delimiter](#DelimiterType) at this given position. `open`\n    /// and `close` indicate whether this delimiter is opening, closing,\n    /// or both. Returns the end of the delimiter, for convenient\n    /// returning from [parse functions](#InlineParser.parse).\n  }, {\n    key: \"addDelimiter\",\n    value: function addDelimiter(type, from, to, open, close) {\n      return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Mark.Open */ : 0) | (close ? 2 /* Mark.Close */ : 0)));\n    }\n    /// Add an inline element. Returns the end of the element.\n  }, {\n    key: \"addElement\",\n    value: function addElement(elt) {\n      return this.append(elt);\n    }\n    /// Resolve markers between this.parts.length and from, wrapping matched markers in the\n    /// appropriate node and updating the content of this.parts. @internal\n  }, {\n    key: \"resolveMarkers\",\n    value: function resolveMarkers(from) {\n      // Scan forward, looking for closing tokens\n      for (var _i3 = from; _i3 < this.parts.length; _i3++) {\n        var close = this.parts[_i3];\n        if (!(close instanceof InlineDelimiter && close.type.resolve && close.side & 2 /* Mark.Close */)) continue;\n        var emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n        var closeSize = close.to - close.from;\n        var open = void 0,\n          j = _i3 - 1;\n        // Continue scanning for a matching opening token\n        for (; j >= from; j--) {\n          var part = this.parts[j];\n          if (part instanceof InlineDelimiter && part.side & 1 /* Mark.Open */ && part.type == close.type &&\n          // Ignore emphasis delimiters where the character count doesn't match\n          !(emp && (close.side & 1 /* Mark.Open */ || part.side & 2 /* Mark.Close */) && (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {\n            open = part;\n            break;\n          }\n        }\n        if (!open) continue;\n        var type = close.type.resolve,\n          content = [];\n        var start = open.from,\n          end = close.to;\n        // Emphasis marker effect depends on the character count. Size consumed is minimum of the two\n        // markers.\n        if (emp) {\n          var size = Math.min(2, open.to - open.from, closeSize);\n          start = open.to - size;\n          end = close.from + size;\n          type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n        }\n        // Move the covered region into content, optionally adding marker nodes\n        if (open.type.mark) content.push(this.elt(open.type.mark, start, open.to));\n        for (var k = j + 1; k < _i3; k++) {\n          if (this.parts[k] instanceof Element) content.push(this.parts[k]);\n          this.parts[k] = null;\n        }\n        if (close.type.mark) content.push(this.elt(close.type.mark, close.from, end));\n        var element = this.elt(type, start, end, content);\n        // If there are leftover emphasis marker characters, shrink the close/open markers. Otherwise, clear them.\n        this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n        var keep = this.parts[_i3] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n        // Insert the new element in this.parts\n        if (keep) this.parts.splice(_i3, 0, element);else this.parts[_i3] = element;\n      }\n      // Collect the elements remaining in this.parts into an array.\n      var result = [];\n      for (var _i4 = from; _i4 < this.parts.length; _i4++) {\n        var _part = this.parts[_i4];\n        if (_part instanceof Element) result.push(_part);\n      }\n      return result;\n    }\n    /// Find an opening delimiter of the given type. Returns `null` if\n    /// no delimiter is found, or an index that can be passed to\n    /// [`takeContent`](#InlineContext.takeContent) otherwise.\n  }, {\n    key: \"findOpeningDelimiter\",\n    value: function findOpeningDelimiter(type) {\n      for (var _i5 = this.parts.length - 1; _i5 >= 0; _i5--) {\n        var part = this.parts[_i5];\n        if (part instanceof InlineDelimiter && part.type == type) return _i5;\n      }\n      return null;\n    }\n    /// Remove all inline elements and delimiters starting from the\n    /// given index (which you should get from\n    /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    /// resolve delimiters inside of them, and return them as an array\n    /// of elements.\n  }, {\n    key: \"takeContent\",\n    value: function takeContent(startIndex) {\n      var content = this.resolveMarkers(startIndex);\n      this.parts.length = startIndex;\n      return content;\n    }\n    /// Skip space after the given (document) position, returning either\n    /// the position of the next non-space character or the end of the\n    /// section.\n  }, {\n    key: \"skipSpace\",\n    value: function skipSpace(from) {\n      return _skipSpace(this.text, from - this.offset) + this.offset;\n    }\n  }, {\n    key: \"elt\",\n    value: function elt(type, from, to, children) {\n      if (typeof type == \"string\") return _elt(this.parser.getNodeType(type), from, to, children);\n      return new TreeElement(type, from);\n    }\n  }]);\n  return InlineContext;\n}();\nfunction injectMarks(elements, marks) {\n  if (!marks.length) return elements;\n  if (!elements.length) return marks;\n  var elts = elements.slice(),\n    eI = 0;\n  var _iterator22 = _createForOfIteratorHelper(marks),\n    _step22;\n  try {\n    for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n      var mark = _step22.value;\n      while (eI < elts.length && elts[eI].to < mark.to) eI++;\n      if (eI < elts.length && elts[eI].from < mark.from) {\n        var e = elts[eI];\n        if (e instanceof Element) elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n      } else {\n        elts.splice(eI++, 0, mark);\n      }\n    }\n  } catch (err) {\n    _iterator22.e(err);\n  } finally {\n    _iterator22.f();\n  }\n  return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nvar NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nvar FragmentCursor = /*#__PURE__*/function () {\n  function FragmentCursor(fragments, input) {\n    _classCallCheck(this, FragmentCursor);\n    this.fragments = fragments;\n    this.input = input;\n    // Index into fragment array\n    this.i = 0;\n    // Active fragment\n    this.fragment = null;\n    this.fragmentEnd = -1;\n    // Cursor into the current fragment, if any. When `moveTo` returns\n    // true, this points at the first block after `pos`.\n    this.cursor = null;\n    if (fragments.length) this.fragment = fragments[this.i++];\n  }\n  _createClass(FragmentCursor, [{\n    key: \"nextFragment\",\n    value: function nextFragment() {\n      this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n      this.cursor = null;\n      this.fragmentEnd = -1;\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(pos, lineStart) {\n      while (this.fragment && this.fragment.to <= pos) this.nextFragment();\n      if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0)) return false;\n      if (this.fragmentEnd < 0) {\n        var end = this.fragment.to;\n        while (end > 0 && this.input.read(end - 1, end) != \"\\n\") end--;\n        this.fragmentEnd = end ? end - 1 : 0;\n      }\n      var c = this.cursor;\n      if (!c) {\n        c = this.cursor = this.fragment.tree.cursor();\n        c.firstChild();\n      }\n      var rPos = pos + this.fragment.offset;\n      while (c.to <= rPos) if (!c.parent()) return false;\n      for (;;) {\n        if (c.from >= rPos) return this.fragment.from <= lineStart;\n        if (!c.childAfter(rPos)) return false;\n      }\n    }\n  }, {\n    key: \"matches\",\n    value: function matches(hash) {\n      var tree = this.cursor.tree;\n      return tree && tree.prop(NodeProp.contextHash) == hash;\n    }\n  }, {\n    key: \"takeNodes\",\n    value: function takeNodes(cx) {\n      var cur = this.cursor,\n        off = this.fragment.offset,\n        fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n      var start = cx.absoluteLineStart,\n        end = start,\n        blockI = cx.block.children.length;\n      var prevEnd = end,\n        prevI = blockI;\n      for (;;) {\n        if (cur.to - off > fragEnd) {\n          if (cur.type.isAnonymous && cur.firstChild()) continue;\n          break;\n        }\n        var pos = toRelative(cur.from - off, cx.ranges);\n        if (cur.to - off <= cx.ranges[cx.rangeI].to) {\n          // Fits in current range\n          cx.addNode(cur.tree, pos);\n        } else {\n          var dummy = new Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp);\n          cx.reusePlaceholders.set(dummy, cur.tree);\n          cx.addNode(dummy, pos);\n        }\n        // Taken content must always end in a block, because incremental\n        // parsing happens on block boundaries. Never stop directly\n        // after an indented code block, since those can continue after\n        // any number of blank lines.\n        if (cur.type.is(\"Block\")) {\n          if (NotLast.indexOf(cur.type.id) < 0) {\n            end = cur.to - off;\n            blockI = cx.block.children.length;\n          } else {\n            end = prevEnd;\n            blockI = prevI;\n            prevEnd = cur.to - off;\n            prevI = cx.block.children.length;\n          }\n        }\n        if (!cur.nextSibling()) break;\n      }\n      while (cx.block.children.length > blockI) {\n        cx.block.children.pop();\n        cx.block.positions.pop();\n      }\n      return end - start;\n    }\n  }]);\n  return FragmentCursor;\n}(); // Convert an input-stream-relative position to a\n// Markdown-doc-relative position by subtracting the size of all input\n// gaps before `abs`.\nfunction toRelative(abs, ranges) {\n  var pos = abs;\n  for (var _i6 = 1; _i6 < ranges.length; _i6++) {\n    var gapFrom = ranges[_i6 - 1].to,\n      gapTo = ranges[_i6].from;\n    if (gapFrom < abs) pos -= gapTo - gapFrom;\n  }\n  return pos;\n}\nvar markdownHighlighting = styleTags({\n  \"Blockquote/...\": tags.quote,\n  HorizontalRule: tags.contentSeparator,\n  \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n  \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n  \"ATXHeading3/...\": tags.heading3,\n  \"ATXHeading4/...\": tags.heading4,\n  \"ATXHeading5/...\": tags.heading5,\n  \"ATXHeading6/...\": tags.heading6,\n  \"Comment CommentBlock\": tags.comment,\n  Escape: tags.escape,\n  Entity: tags.character,\n  \"Emphasis/...\": tags.emphasis,\n  \"StrongEmphasis/...\": tags.strong,\n  \"Link/... Image/...\": tags.link,\n  \"OrderedList/... BulletList/...\": tags.list,\n  \"BlockQuote/...\": tags.quote,\n  \"InlineCode CodeText\": tags.monospace,\n  URL: tags.url,\n  \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n  \"CodeInfo LinkLabel\": tags.labelName,\n  LinkTitle: tags.string,\n  Paragraph: tags.content\n});\n/// The default CommonMark parser.\nvar parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(function (n) {\n  return DefaultBlockParsers[n];\n}), Object.keys(DefaultBlockParsers).map(function (n) {\n  return DefaultLeafBlocks[n];\n}), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(function (n) {\n  return DefaultInline[n];\n}), Object.keys(DefaultInline), []);\nfunction leftOverSpace(node, from, to) {\n  var ranges = [];\n  for (var n = node.firstChild, pos = from;; n = n.nextSibling) {\n    var nextPos = n ? n.from : to;\n    if (nextPos > pos) ranges.push({\n      from: pos,\n      to: nextPos\n    });\n    if (!n) break;\n    pos = n.to;\n  }\n  return ranges;\n}\n/// Create a Markdown extension to enable nested parsing on code\n/// blocks and/or embedded HTML.\nfunction parseCode(config) {\n  var codeParser = config.codeParser,\n    htmlParser = config.htmlParser;\n  var wrap = parseMixed(function (node, input) {\n    var id = node.type.id;\n    if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n      var info = \"\";\n      if (id == Type.FencedCode) {\n        var infoNode = node.node.getChild(Type.CodeInfo);\n        if (infoNode) info = input.read(infoNode.from, infoNode.to);\n      }\n      var _parser4 = codeParser(info);\n      if (_parser4) return {\n        parser: _parser4,\n        overlay: function overlay(node) {\n          return node.type.id == Type.CodeText;\n        }\n      };\n    } else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {\n      return {\n        parser: htmlParser,\n        overlay: leftOverSpace(node.node, node.from, node.to)\n      };\n    }\n    return null;\n  });\n  return {\n    wrap: wrap\n  };\n}\nvar StrikethroughDelim = {\n  resolve: \"Strikethrough\",\n  mark: \"StrikethroughMark\"\n};\n/// An extension that implements\n/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\n/// Strikethrough syntax using `~~` delimiters.\nvar Strikethrough = {\n  defineNodes: [{\n    name: \"Strikethrough\",\n    style: {\n      \"Strikethrough/...\": tags.strikethrough\n    }\n  }, {\n    name: \"StrikethroughMark\",\n    style: tags.processingInstruction\n  }],\n  parseInline: [{\n    name: \"Strikethrough\",\n    parse: function parse(cx, next, pos) {\n      if (next != 126 /* '~' */ || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126) return -1;\n      var before = cx.slice(pos - 1, pos),\n        after = cx.slice(pos + 2, pos + 3);\n      var sBefore = /\\s|^$/.test(before),\n        sAfter = /\\s|^$/.test(after);\n      var pBefore = Punctuation.test(before),\n        pAfter = Punctuation.test(after);\n      return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));\n    },\n    after: \"Emphasis\"\n  }]\n};\nfunction parseRow(cx, line) {\n  var startI = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var elts = arguments.length > 3 ? arguments[3] : undefined;\n  var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var count = 0,\n    first = true,\n    cellStart = -1,\n    cellEnd = -1,\n    esc = false;\n  var parseCell = function parseCell() {\n    elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n  };\n  for (var _i7 = startI; _i7 < line.length; _i7++) {\n    var next = line.charCodeAt(_i7);\n    if (next == 124 /* '|' */ && !esc) {\n      if (!first || cellStart > -1) count++;\n      first = false;\n      if (elts) {\n        if (cellStart > -1) parseCell();\n        elts.push(cx.elt(\"TableDelimiter\", _i7 + offset, _i7 + offset + 1));\n      }\n      cellStart = cellEnd = -1;\n    } else if (esc || next != 32 && next != 9) {\n      if (cellStart < 0) cellStart = _i7;\n      cellEnd = _i7 + 1;\n    }\n    esc = !esc && next == 92;\n  }\n  if (cellStart > -1) {\n    count++;\n    if (elts) parseCell();\n  }\n  return count;\n}\nfunction hasPipe(str, start) {\n  for (var _i8 = start; _i8 < str.length; _i8++) {\n    var next = str.charCodeAt(_i8);\n    if (next == 124 /* '|' */) return true;\n    if (next == 92 /* '\\\\' */) _i8++;\n  }\n  return false;\n}\nvar delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nvar TableParser = /*#__PURE__*/function () {\n  function TableParser() {\n    _classCallCheck(this, TableParser);\n    // Null means we haven't seen the second line yet, false means this\n    // isn't a table, and an array means this is a table and we've\n    // parsed the given rows so far.\n    this.rows = null;\n  }\n  _createClass(TableParser, [{\n    key: \"nextLine\",\n    value: function nextLine(cx, line, leaf) {\n      if (this.rows == null) {\n        // Second line\n        this.rows = false;\n        var lineText;\n        if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) && delimiterLine.test(lineText = line.text.slice(line.pos))) {\n          var firstRow = [],\n            firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n          if (firstCount == parseRow(cx, lineText, line.pos)) this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow), cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n        }\n      } else if (this.rows) {\n        // Line after the second\n        var content = [];\n        parseRow(cx, line.text, line.pos, content, cx.lineStart);\n        this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n      }\n      return false;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish(cx, leaf) {\n      if (!this.rows) return false;\n      cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n      return true;\n    }\n  }]);\n  return TableParser;\n}(); /// This extension provides\n/// [GFM-style](https://github.github.com/gfm/#tables-extension-)\n/// tables, using syntax like this:\n///\n/// ```\n/// | head 1 | head 2 |\n/// | ---    | ---    |\n/// | cell 1 | cell 2 |\n/// ```\nvar Table = {\n  defineNodes: [{\n    name: \"Table\",\n    block: true\n  }, {\n    name: \"TableHeader\",\n    style: {\n      \"TableHeader/...\": tags.heading\n    }\n  }, \"TableRow\", {\n    name: \"TableCell\",\n    style: tags.content\n  }, {\n    name: \"TableDelimiter\",\n    style: tags.processingInstruction\n  }],\n  parseBlock: [{\n    name: \"Table\",\n    leaf: function leaf(_, _leaf) {\n      return hasPipe(_leaf.content, 0) ? new TableParser() : null;\n    },\n    endLeaf: function endLeaf(cx, line, leaf) {\n      if (leaf.parsers.some(function (p) {\n        return p instanceof TableParser;\n      }) || !hasPipe(line.text, line.basePos)) return false;\n      var next = cx.scanLine(cx.absoluteLineEnd + 1).text;\n      return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n    },\n    before: \"SetextHeading\"\n  }]\n};\nvar TaskParser = /*#__PURE__*/function () {\n  function TaskParser() {\n    _classCallCheck(this, TaskParser);\n  }\n  _createClass(TaskParser, [{\n    key: \"nextLine\",\n    value: function nextLine() {\n      return false;\n    }\n  }, {\n    key: \"finish\",\n    value: function finish(cx, leaf) {\n      cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3)].concat(_toConsumableArray(cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)))));\n      return true;\n    }\n  }]);\n  return TaskParser;\n}(); /// Extension providing\n/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\n/// task list items, where list items can be prefixed with `[ ]` or\n/// `[x]` to add a checkbox.\nvar TaskList = {\n  defineNodes: [{\n    name: \"Task\",\n    block: true,\n    style: tags.list\n  }, {\n    name: \"TaskMarker\",\n    style: tags.atom\n  }],\n  parseBlock: [{\n    name: \"TaskList\",\n    leaf: function leaf(cx, _leaf2) {\n      return /^\\[[ xX]\\][ \\t]/.test(_leaf2.content) && cx.parentType().name == \"ListItem\" ? new TaskParser() : null;\n    },\n    after: \"SetextHeading\"\n  }]\n};\nvar autolinkRE = new RegExp(\"(www\\\\.)|(https?:\\\\/\\\\/)|([\\\\w.+-]+@)|(mailto:|xmpp:)\", \"gy\");\nvar urlRE = new RegExp(\"[\\\\w-]+(\\\\.\\\\w+(\\\\.\\\\w+)?)(\\\\/[^\\\\s<]*)?\", \"gy\");\nvar emailRE = new RegExp(\"[\\\\w.+-]+@[\\\\w-]+\\\\.[\\\\w.-]+\", \"gy\");\nvar xmppResourceRE = new RegExp(\"\\\\/[a-zA-Z\\\\d@.]+\", \"gy\");\nfunction count(str, from, to, ch) {\n  var result = 0;\n  for (var _i9 = from; _i9 < to; _i9++) if (str[_i9] == ch) result++;\n  return result;\n}\nfunction autolinkURLEnd(text, from) {\n  urlRE.lastIndex = from;\n  var m = urlRE.exec(text);\n  if (!m) return -1;\n  var end = from + m[0].length;\n  for (;;) {\n    var last = text[end - 1],\n      _m4 = void 0;\n    if (/[?!.,:*_~]/.test(last) || last == \")\" && count(text, from, end, \")\") > count(text, from, end, \"(\")) end--;else if (last == \";\" && (_m4 = /&(?:#\\d+|#x[a-f\\d]+|\\w+);$/.exec(text.slice(from, end)))) end = from + _m4.index;else break;\n  }\n  return end;\n}\nfunction autolinkEmailEnd(text, from) {\n  emailRE.lastIndex = from;\n  var m = emailRE.exec(text);\n  if (!m) return -1;\n  var last = m[0][m[0].length - 1];\n  return last == \"_\" || last == \"-\" ? -1 : from + m[0].length - (last == \".\" ? 1 : 0);\n}\n/// Extension that implements autolinking for\n/// `www.`/`http://`/`https://`/`mailto:`/`xmpp:` URLs and email\n/// addresses.\nvar Autolink = {\n  parseInline: [{\n    name: \"Autolink\",\n    parse: function parse(cx, next, absPos) {\n      var pos = absPos - cx.offset;\n      autolinkRE.lastIndex = pos;\n      var m = autolinkRE.exec(cx.text),\n        end = -1;\n      if (!m) return -1;\n      if (m[1] || m[2]) {\n        // www., http://\n        end = autolinkURLEnd(cx.text, pos + m[0].length);\n      } else if (m[3]) {\n        // email address\n        end = autolinkEmailEnd(cx.text, pos);\n      } else {\n        // mailto:/xmpp:\n        end = autolinkEmailEnd(cx.text, pos + m[0].length);\n        if (end > -1 && m[0] == \"xmpp:\") {\n          xmppResourceRE.lastIndex = end;\n          m = xmppResourceRE.exec(cx.text);\n          if (m) end = m.index + m[0].length;\n        }\n      }\n      if (end < 0) return -1;\n      cx.addElement(cx.elt(\"URL\", absPos, end + cx.offset));\n      return end + cx.offset;\n    }\n  }]\n};\n/// Extension bundle containing [`Table`](#Table),\n/// [`TaskList`](#TaskList), [`Strikethrough`](#Strikethrough), and\n/// [`Autolink`](#Autolink).\nvar GFM = [Table, TaskList, Strikethrough, Autolink];\nfunction parseSubSuper(ch, node, mark) {\n  return function (cx, next, pos) {\n    if (next != ch || cx.char(pos + 1) == ch) return -1;\n    var elts = [cx.elt(mark, pos, pos + 1)];\n    for (var _i10 = pos + 1; _i10 < cx.end; _i10++) {\n      var _next = cx.char(_i10);\n      if (_next == ch) return cx.addElement(cx.elt(node, pos, _i10 + 1, elts.concat(cx.elt(mark, _i10, _i10 + 1))));\n      if (_next == 92 /* '\\\\' */) elts.push(cx.elt(\"Escape\", _i10, _i10++ + 2));\n      if (space(_next)) break;\n    }\n    return -1;\n  };\n}\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// superscript using `^` markers.\nvar Superscript = {\n  defineNodes: [{\n    name: \"Superscript\",\n    style: tags.special(tags.content)\n  }, {\n    name: \"SuperscriptMark\",\n    style: tags.processingInstruction\n  }],\n  parseInline: [{\n    name: \"Superscript\",\n    parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n  }]\n};\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// subscript using `~` markers.\nvar Subscript = {\n  defineNodes: [{\n    name: \"Subscript\",\n    style: tags.special(tags.content)\n  }, {\n    name: \"SubscriptMark\",\n    style: tags.processingInstruction\n  }],\n  parseInline: [{\n    name: \"Subscript\",\n    parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n  }]\n};\n/// Extension that parses two colons with only letters, underscores,\n/// and numbers between them as `Emoji` nodes.\nvar Emoji = {\n  defineNodes: [{\n    name: \"Emoji\",\n    style: tags.character\n  }],\n  parseInline: [{\n    name: \"Emoji\",\n    parse: function parse(cx, next, pos) {\n      var match;\n      if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end)))) return -1;\n      return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n    }\n  }]\n};\nexport { Autolink, BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };","map":{"version":3,"names":["NodeType","NodeProp","NodeSet","Tree","Parser","parseMixed","styleTags","tags","Tag","CompositeBlock","type","value","from","hash","end","children","positions","_classCallCheck","hashProp","contextHash","_createClass","key","addChild","child","pos","prop","length","push","toTree","nodeSet","_this","arguments","undefined","last","Math","max","types","balance","makeTree","none","create","parentHash","Type","LeafBlock","start","content","marks","parsers","Line","text","baseIndent","basePos","depth","markers","indent","next","forward","forwardInner","newPos","skipSpace","countIndent","charCodeAt","reset","pop","moveBase","to","moveBaseColumn","findColumn","addMarker","elt","i","goal","scrub","result","slice","skipForList","bl","cx","line","block","stack","size","OrderedList","isOrderedList","isBulletList","BulletList","isHorizontalRule","DefaultSkipMarkup","_DefaultSkipMarkup","_defineProperty","Blockquote","QuoteMark","lineStart","space","ListItem","_cx","Document","ch","skipSpaceBack","isFencedCode","isBlockquote","breaking","count","isSetextUnderline","inList","isAtxHeading","EmptyLine","CommentEnd","ProcessingEnd","HTMLBlockStyle","isHTMLBlock","rest","e","test","getListIndent","indentAfter","indented","addCodeText","CodeText","DefaultBlockParsers","LinkReference","IndentedCode","base","pendingMarks","nextLine","_iterator","_createForOfIteratorHelper","_step","s","n","done","m","err","f","_iterator2","_step2","_iterator3","_step3","codeStart","filter","concat","addNode","buffer","writeElements","finish","CodeBlock","FencedCode","fenceEnd","len","infoFrom","infoTo","CodeMark","CodeInfo","first","_iterator4","_step4","_iterator5","_step5","textStart","textEnd","prevLineEnd","startContext","HorizontalRule","newBase","ListMark","ATXHeading","off","endOfSpace","after","buf","write","HeaderMark","parser","parseInline","node","ATXHeading1","HTMLBlock","trailing","_iterator6","_step6","nodeType","CommentBlock","ProcessingInstructionBlock","SetextHeading","LinkReferenceParser","leaf","stage","elts","advance","complete","addLeafElement","nextStage","parseLinkLabel","LinkMark","parseURL","skip","title","parseLinkTitle","titleEnd","lineEnd","SetextHeadingParser","underline","underlineMark","SetextHeading1","SetextHeading2","_toConsumableArray","DefaultLeafBlocks","_","DefaultEndLeaf","p","scanLineResult","BlockContext","input","fragments","ranges","atEnd","reusePlaceholders","Map","stoppedAt","rangeI","absoluteLineStart","absoluteLineEnd","FragmentCursor","readLine","get","finishContext","_iterator7","_step7","mark","reuseFragment","_iterator8","blockParsers","_step8","_iterator9","leafBlockParsers","_step9","parse","lines","_iterator10","endLeafBlock","_step10","stop","_iterator11","_step11","_iterator12","_step12","finishLeaf","stopAt","RangeError","moveTo","matches","taken","takeNodes","toRelative","moveRangeI","parentType","scanLine","r","lineChunkAt","textOffset","nextFrom","_this$scanLine","handler","skipContextMarkup","Error","chunk","lineChunks","eol","indexOf","startComposite","getNodeType","addElement","injectMarks","top","addGaps","tree","injectGaps","topNode","_iterator13","_step13","inline","Paragraph","TreeElement","Buffer","offset","dummies","rangeEnd","movePastNext","upto","inclusive","firstChild","nextSibling","reuse","propValues","MarkdownParser","_Parser","_inherits","_super","_createSuper","blockNames","inlineParsers","inlineNames","wrappers","_this2","call","nodeTypes","Object","_iterator14","_step14","t","name","id","createParse","_iterator15","_step15","w","configure","spec","_nodeSet","config","resolveConfig","nonEmpty","defineNodes","assign","styles","_iterator16","_step16","_loop","_ref","composite","style","some","group","define","props","Array","isArray","extend","apply","remove","_iterator17","_step17","rm","parseBlock","_iterator18","_step18","found","before","findName","splice","endLeaf","_iterator19","_step19","wrap","InlineContext","outer","char","_iterator20","_step20","token","resolveMarkers","a","conf","conc","b","wrapA","wrapB","inner","names","Escape","nodes","_iterator21","_step21","writeTo","build","reused","topID","Element","startOff","EmphasisUnderscore","resolve","EmphasisAsterisk","LinkStart","ImageStart","InlineDelimiter","side","Escapable","Punctuation","RegExp","DefaultInline","escaped","append","Entity","exec","InlineCode","curSize","HTMLTag","url","URL","comment","Comment","procInst","ProcessingInstruction","Emphasis","pBefore","pAfter","sBefore","sAfter","leftFlanking","rightFlanking","canOpen","canClose","HardBreak","Link","Image","LinkEnd","parts","part","takeContent","link","finishLink","j","startPos","endPos","unshift","dest","label","LinkTitle","requireNonWS","min","LinkLabel","addDelimiter","open","close","emp","closeSize","k","element","keep","findOpeningDelimiter","startIndex","elements","eI","_iterator22","_step22","NotLast","fragment","fragmentEnd","cursor","nextFragment","read","c","rPos","parent","childAfter","cur","fragEnd","openEnd","blockI","prevEnd","prevI","isAnonymous","dummy","set","is","abs","gapFrom","gapTo","markdownHighlighting","quote","contentSeparator","heading1","heading2","heading3","heading4","heading5","heading6","escape","character","emphasis","strong","list","monospace","processingInstruction","labelName","string","keys","map","leftOverSpace","nextPos","parseCode","codeParser","htmlParser","info","infoNode","getChild","overlay","StrikethroughDelim","Strikethrough","strikethrough","parseRow","startI","cellStart","cellEnd","esc","parseCell","hasPipe","str","delimiterLine","TableParser","rows","lineText","firstRow","firstCount","Table","heading","TaskParser","TaskList","atom","autolinkRE","urlRE","emailRE","xmppResourceRE","autolinkURLEnd","lastIndex","index","autolinkEmailEnd","Autolink","absPos","GFM","parseSubSuper","Superscript","special","Subscript","Emoji","match"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@lezer/markdown/dist/index.js"],"sourcesContent":["import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\nimport { styleTags, tags, Tag } from '@lezer/highlight';\n\nclass CompositeBlock {\n    static create(type, value, from, parentHash, end) {\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\n        return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n    constructor(type, \n    // Used for indentation in list items, markup character in lists\n    value, from, hash, end, children, positions) {\n        this.type = type;\n        this.value = value;\n        this.from = from;\n        this.hash = hash;\n        this.end = end;\n        this.children = children;\n        this.positions = positions;\n        this.hashProp = [[NodeProp.contextHash, hash]];\n    }\n    addChild(child, pos) {\n        if (child.prop(NodeProp.contextHash) != this.hash)\n            child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n        this.children.push(child);\n        this.positions.push(pos);\n    }\n    toTree(nodeSet, end = this.end) {\n        let last = this.children.length - 1;\n        if (last >= 0)\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n        return new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n            makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)\n        });\n    }\n}\nvar Type;\n(function (Type) {\n    Type[Type[\"Document\"] = 1] = \"Document\";\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n    // Inline\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n    Type[Type[\"Link\"] = 27] = \"Link\";\n    Type[Type[\"Image\"] = 28] = \"Image\";\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n    Type[Type[\"URL\"] = 33] = \"URL\";\n    // Smaller tokens\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n})(Type || (Type = {}));\n/// Data structure used to accumulate a block's content during [leaf\n/// block parsing](#BlockParser.leaf).\nclass LeafBlock {\n    /// @internal\n    constructor(\n    /// The start position of the block.\n    start, \n    /// The block's text content.\n    content) {\n        this.start = start;\n        this.content = content;\n        /// @internal\n        this.marks = [];\n        /// The block parsers active for this block.\n        this.parsers = [];\n    }\n}\n/// Data structure used during block-level per-line parsing.\nclass Line {\n    constructor() {\n        /// The line's full text.\n        this.text = \"\";\n        /// The base indent provided by the composite contexts (that have\n        /// been handled so far).\n        this.baseIndent = 0;\n        /// The string position corresponding to the base indent.\n        this.basePos = 0;\n        /// The number of contexts handled @internal\n        this.depth = 0;\n        /// Any markers (i.e. block quote markers) parsed for the contexts. @internal\n        this.markers = [];\n        /// The position of the next non-whitespace character beyond any\n        /// list, blockquote, or other composite block markers.\n        this.pos = 0;\n        /// The column of the next non-whitespace character.\n        this.indent = 0;\n        /// The character code of the character after `pos`.\n        this.next = -1;\n    }\n    /// @internal\n    forward() {\n        if (this.basePos > this.pos)\n            this.forwardInner();\n    }\n    /// @internal\n    forwardInner() {\n        let newPos = this.skipSpace(this.basePos);\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\n        this.pos = newPos;\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /// Skip whitespace after the given position, return the position of\n    /// the next non-space character or the end of the line if there's\n    /// only space after `from`.\n    skipSpace(from) { return skipSpace(this.text, from); }\n    /// @internal\n    reset(text) {\n        this.text = text;\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\n        this.forwardInner();\n        this.depth = 1;\n        while (this.markers.length)\n            this.markers.pop();\n    }\n    /// Move the line's base position forward to the given position.\n    /// This should only be called by composite [block\n    /// parsers](#BlockParser.parse) or [markup skipping\n    /// functions](#NodeSpec.composite).\n    moveBase(to) {\n        this.basePos = to;\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /// Move the line's base position forward to the given _column_.\n    moveBaseColumn(indent) {\n        this.baseIndent = indent;\n        this.basePos = this.findColumn(indent);\n    }\n    /// Store a composite-block-level marker. Should be called from\n    /// [markup skipping functions](#NodeSpec.composite) when they\n    /// consume any non-whitespace characters.\n    addMarker(elt) {\n        this.markers.push(elt);\n    }\n    /// Find the column position at `to`, optionally starting at a given\n    /// position and column.\n    countIndent(to, from = 0, indent = 0) {\n        for (let i = from; i < to; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return indent;\n    }\n    /// Find the position corresponding to the given column.\n    findColumn(goal) {\n        let i = 0;\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return i;\n    }\n    /// @internal\n    scrub() {\n        if (!this.baseIndent)\n            return this.text;\n        let result = \"\";\n        for (let i = 0; i < this.basePos; i++)\n            result += \" \";\n        return result + this.text.slice(this.basePos);\n    }\n}\nfunction skipForList(bl, cx, line) {\n    if (line.pos == line.text.length ||\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\n        return true;\n    if (line.indent >= line.baseIndent + 4)\n        return false;\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n    return size > 0 &&\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nconst DefaultSkipMarkup = {\n    [Type.Blockquote](bl, cx, line) {\n        if (line.next != 62 /* '>' */)\n            return false;\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n        bl.end = cx.lineStart + line.text.length;\n        return true;\n    },\n    [Type.ListItem](bl, _cx, line) {\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\n            return false;\n        line.moveBaseColumn(line.baseIndent + bl.value);\n        return true;\n    },\n    [Type.OrderedList]: skipForList,\n    [Type.BulletList]: skipForList,\n    [Type.Document]() { return true; }\n};\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\nfunction skipSpace(line, i = 0) {\n    while (i < line.length && space(line.charCodeAt(i)))\n        i++;\n    return i;\n}\nfunction skipSpaceBack(line, i, to) {\n    while (i > to && space(line.charCodeAt(i - 1)))\n        i--;\n    return i;\n}\nfunction isFencedCode(line) {\n    if (line.next != 96 && line.next != 126 /* '`~' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    if (pos < line.pos + 3)\n        return -1;\n    if (line.next == 96)\n        for (let i = pos; i < line.text.length; i++)\n            if (line.text.charCodeAt(i) == 96)\n                return -1;\n    return pos;\n}\nfunction isBlockquote(line) {\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\n        return -1;\n    let count = 1;\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n        let ch = line.text.charCodeAt(pos);\n        if (ch == line.next)\n            count++;\n        else if (!space(ch))\n            return -1;\n    }\n    // Setext headers take precedence\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length)\n        return -1;\n    return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n    for (let i = cx.stack.length - 1; i >= 0; i--)\n        if (cx.stack[i].type == type)\n            return true;\n    return false;\n}\nfunction isBulletList(line, cx, breaking) {\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n    let pos = line.pos, next = line.next;\n    for (;;) {\n        if (next >= 48 && next <= 57 /* '0-9' */)\n            pos++;\n        else\n            break;\n        if (pos == line.text.length)\n            return -1;\n        next = line.text.charCodeAt(pos);\n    }\n    if (pos == line.pos || pos > line.pos + 9 ||\n        (next != 46 && next != 41 /* '.)' */) ||\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\n        breaking && !inList(cx, Type.OrderedList) &&\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\n        return -1;\n    return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n    if (line.next != 35 /* '#' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\n        pos++;\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\n        return -1;\n    let size = pos - line.pos;\n    return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    let end = pos;\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\n        pos++;\n    return pos == line.text.length ? end : -1;\n}\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /-->/, ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\n    [/^\\s*<!--/, CommentEnd],\n    [/^\\s*<\\?/, ProcessingEnd],\n    [/^\\s*<![A-Z]/, />/],\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\n];\nfunction isHTMLBlock(line, _cx, breaking) {\n    if (line.next != 60 /* '<' */)\n        return -1;\n    let rest = line.text.slice(line.pos);\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\n        if (HTMLBlockStyle[i][0].test(rest))\n            return i;\n    return -1;\n}\nfunction getListIndent(line, pos) {\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n    let last = marks.length - 1;\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\n        marks[last].to = to;\n    else\n        marks.push(elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nconst DefaultBlockParsers = {\n    LinkReference: undefined,\n    IndentedCode(cx, line) {\n        let base = line.baseIndent + 4;\n        if (line.indent < base)\n            return false;\n        let start = line.findColumn(base);\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\n        let marks = [], pendingMarks = [];\n        addCodeText(marks, from, to);\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\n            if (line.pos == line.text.length) { // Empty\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    pendingMarks.push(m);\n            }\n            else if (line.indent < base) {\n                break;\n            }\n            else {\n                if (pendingMarks.length) {\n                    for (let m of pendingMarks) {\n                        if (m.type == Type.CodeText)\n                            addCodeText(marks, m.from, m.to);\n                        else\n                            marks.push(m);\n                    }\n                    pendingMarks = [];\n                }\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                to = cx.lineStart + line.text.length;\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n                if (codeStart < to)\n                    addCodeText(marks, codeStart, to);\n            }\n        }\n        if (pendingMarks.length) {\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n            if (pendingMarks.length)\n                line.markers = pendingMarks.concat(line.markers);\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n        return true;\n    },\n    FencedCode(cx, line) {\n        let fenceEnd = isFencedCode(line);\n        if (fenceEnd < 0)\n            return false;\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n        let marks = [elt(Type.CodeMark, from, from + len)];\n        if (infoFrom < infoTo)\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n            let i = line.pos;\n            if (line.indent - line.baseIndent < 4)\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\n                    i++;\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n                for (let m of line.markers)\n                    marks.push(m);\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n                cx.nextLine();\n                break;\n            }\n            else {\n                if (!first)\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\n                if (textStart < textEnd)\n                    addCodeText(marks, textStart, textEnd);\n            }\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from)\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n        return true;\n    },\n    Blockquote(cx, line) {\n        let size = isBlockquote(line);\n        if (size < 0)\n            return false;\n        cx.startContext(Type.Blockquote, line.pos);\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n        line.moveBase(line.pos + size);\n        return null;\n    },\n    HorizontalRule(cx, line) {\n        if (isHorizontalRule(line, cx, false) < 0)\n            return false;\n        let from = cx.lineStart + line.pos;\n        cx.nextLine();\n        cx.addNode(Type.HorizontalRule, from);\n        return true;\n    },\n    BulletList(cx, line) {\n        let size = isBulletList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.BulletList)\n            cx.startContext(Type.BulletList, line.basePos, line.next);\n        let newBase = getListIndent(line, line.pos + 1);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    OrderedList(cx, line) {\n        let size = isOrderedList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.OrderedList)\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n        let newBase = getListIndent(line, line.pos + size);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    ATXHeading(cx, line) {\n        let size = isAtxHeading(line);\n        if (size < 0)\n            return false;\n        let off = line.pos, from = cx.lineStart + off;\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\n            after--;\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\n            after = line.text.length;\n        let buf = cx.buffer\n            .write(Type.HeaderMark, 0, size)\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n        if (after < line.text.length)\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n        cx.nextLine();\n        cx.addNode(node, from);\n        return true;\n    },\n    HTMLBlock(cx, line) {\n        let type = isHTMLBlock(line, cx, false);\n        if (type < 0)\n            return false;\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\n        let marks = [], trailing = end != EmptyLine;\n        while (!end.test(line.text) && cx.nextLine()) {\n            if (line.depth < cx.stack.length) {\n                trailing = false;\n                break;\n            }\n            for (let m of line.markers)\n                marks.push(m);\n        }\n        if (trailing)\n            cx.nextLine();\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n        let to = cx.prevLineEnd();\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n        return true;\n    },\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nclass LinkReferenceParser {\n    constructor(leaf) {\n        this.stage = 0 /* RefStage.Start */;\n        this.elts = [];\n        this.pos = 0;\n        this.start = leaf.start;\n        this.advance(leaf.content);\n    }\n    nextLine(cx, line, leaf) {\n        if (this.stage == -1 /* RefStage.Failed */)\n            return false;\n        let content = leaf.content + \"\\n\" + line.scrub();\n        let finish = this.advance(content);\n        if (finish > -1 && finish < content.length)\n            return this.complete(cx, leaf, finish);\n        return false;\n    }\n    finish(cx, leaf) {\n        if ((this.stage == 2 /* RefStage.Link */ || this.stage == 3 /* RefStage.Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\n            return this.complete(cx, leaf, leaf.content.length);\n        return false;\n    }\n    complete(cx, leaf, len) {\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n        return true;\n    }\n    nextStage(elt) {\n        if (elt) {\n            this.pos = elt.to - this.start;\n            this.elts.push(elt);\n            this.stage++;\n            return true;\n        }\n        if (elt === false)\n            this.stage = -1 /* RefStage.Failed */;\n        return false;\n    }\n    advance(content) {\n        for (;;) {\n            if (this.stage == -1 /* RefStage.Failed */) {\n                return -1;\n            }\n            else if (this.stage == 0 /* RefStage.Start */) {\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\n                    return -1;\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\n                    return this.stage = -1 /* RefStage.Failed */;\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n                this.pos++;\n            }\n            else if (this.stage == 1 /* RefStage.Label */) {\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\n                    return -1;\n            }\n            else if (this.stage == 2 /* RefStage.Link */) {\n                let skip = skipSpace(content, this.pos), end = 0;\n                if (skip > this.pos) {\n                    let title = parseLinkTitle(content, skip, this.start);\n                    if (title) {\n                        let titleEnd = lineEnd(content, title.to - this.start);\n                        if (titleEnd > 0) {\n                            this.nextStage(title);\n                            end = titleEnd;\n                        }\n                    }\n                }\n                if (!end)\n                    end = lineEnd(content, this.pos);\n                return end > 0 && end < content.length ? end : -1;\n            }\n            else { // RefStage.Title\n                return lineEnd(content, this.pos);\n            }\n        }\n    }\n}\nfunction lineEnd(text, pos) {\n    for (; pos < text.length; pos++) {\n        let next = text.charCodeAt(pos);\n        if (next == 10)\n            break;\n        if (!space(next))\n            return -1;\n    }\n    return pos;\n}\nclass SetextHeadingParser {\n    nextLine(cx, line, leaf) {\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n        let next = line.next;\n        if (underline < 0)\n            return false;\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n        cx.nextLine();\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\n            ...cx.parser.parseInline(leaf.content, leaf.start),\n            underlineMark\n        ]));\n        return true;\n    }\n    finish() {\n        return false;\n    }\n}\nconst DefaultLeafBlocks = {\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\n    SetextHeading() { return new SetextHeadingParser; }\n};\nconst DefaultEndLeaf = [\n    (_, line) => isAtxHeading(line) >= 0,\n    (_, line) => isFencedCode(line) >= 0,\n    (_, line) => isBlockquote(line) >= 0,\n    (p, line) => isBulletList(line, p, true) >= 0,\n    (p, line) => isOrderedList(line, p, true) >= 0,\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\n    (p, line) => isHTMLBlock(line, p, true) >= 0\n];\nconst scanLineResult = { text: \"\", end: 0 };\n/// Block-level parsing functions get access to this context object.\nclass BlockContext {\n    /// @internal\n    constructor(\n    /// The parser configuration used.\n    parser, \n    /// @internal\n    input, fragments, \n    /// @internal\n    ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.line = new Line();\n        this.atEnd = false;\n        /// For reused nodes on gaps, we can't directly put the original\n        /// node into the tree, since that may be bitter than its parent.\n        /// When this happens, we create a dummy tree that is replaced by\n        /// the proper node in `injectGaps` @internal\n        this.reusePlaceholders = new Map;\n        this.stoppedAt = null;\n        /// The range index that absoluteLineStart points into @internal\n        this.rangeI = 0;\n        this.to = ranges[ranges.length - 1].to;\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n        this.stack = [this.block];\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n        this.readLine();\n    }\n    get parsedPos() {\n        return this.absoluteLineStart;\n    }\n    advance() {\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\n            return this.finish();\n        let { line } = this;\n        for (;;) {\n            while (line.depth < this.stack.length)\n                this.finishContext();\n            for (let mark of line.markers)\n                this.addNode(mark.type, mark.from, mark.to);\n            if (line.pos < line.text.length)\n                break;\n            // Empty line\n            if (!this.nextLine())\n                return this.finish();\n        }\n        if (this.fragments && this.reuseFragment(line.basePos))\n            return null;\n        start: for (;;) {\n            for (let type of this.parser.blockParsers)\n                if (type) {\n                    let result = type(this, line);\n                    if (result != false) {\n                        if (result == true)\n                            return null;\n                        line.forward();\n                        continue start;\n                    }\n                }\n            break;\n        }\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n        for (let parse of this.parser.leafBlockParsers)\n            if (parse) {\n                let parser = parse(this, leaf);\n                if (parser)\n                    leaf.parsers.push(parser);\n            }\n        lines: while (this.nextLine()) {\n            if (line.pos == line.text.length)\n                break;\n            if (line.indent < line.baseIndent + 4) {\n                for (let stop of this.parser.endLeafBlock)\n                    if (stop(this, line, leaf))\n                        break lines;\n            }\n            for (let parser of leaf.parsers)\n                if (parser.nextLine(this, line, leaf))\n                    return null;\n            leaf.content += \"\\n\" + line.scrub();\n            for (let m of line.markers)\n                leaf.marks.push(m);\n        }\n        this.finishLeaf(leaf);\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    reuseFragment(start) {\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\n            !this.fragments.matches(this.block.hash))\n            return false;\n        let taken = this.fragments.takeNodes(this);\n        if (!taken)\n            return false;\n        this.absoluteLineStart += taken;\n        this.lineStart = toRelative(this.absoluteLineStart, this.ranges);\n        this.moveRangeI();\n        if (this.absoluteLineStart < this.to) {\n            this.lineStart++;\n            this.absoluteLineStart++;\n            this.readLine();\n        }\n        else {\n            this.atEnd = true;\n            this.readLine();\n        }\n        return true;\n    }\n    /// The number of parent blocks surrounding the current block.\n    get depth() {\n        return this.stack.length;\n    }\n    /// Get the type of the parent block at the given depth. When no\n    /// depth is passed, return the type of the innermost parent.\n    parentType(depth = this.depth - 1) {\n        return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /// Move to the next input line. This should only be called by\n    /// (non-composite) [block parsers](#BlockParser.parse) that consume\n    /// the line directly, or leaf block parser\n    /// [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    /// consume the current line (and return true).\n    nextLine() {\n        this.lineStart += this.line.text.length;\n        if (this.absoluteLineEnd >= this.to) {\n            this.absoluteLineStart = this.absoluteLineEnd;\n            this.atEnd = true;\n            this.readLine();\n            return false;\n        }\n        else {\n            this.lineStart++;\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\n            this.moveRangeI();\n            this.readLine();\n            return true;\n        }\n    }\n    moveRangeI() {\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {\n            this.rangeI++;\n            this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);\n        }\n    }\n    /// @internal\n    scanLine(start) {\n        let r = scanLineResult;\n        r.end = start;\n        if (start >= this.to) {\n            r.text = \"\";\n        }\n        else {\n            r.text = this.lineChunkAt(start);\n            r.end += r.text.length;\n            if (this.ranges.length > 1) {\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\n                while (this.ranges[rangeI].to < r.end) {\n                    rangeI++;\n                    let nextFrom = this.ranges[rangeI].from;\n                    let after = this.lineChunkAt(nextFrom);\n                    r.end = nextFrom + after.length;\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n                    textOffset = r.end - r.text.length;\n                }\n            }\n        }\n        return r;\n    }\n    /// @internal\n    readLine() {\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\n        this.absoluteLineEnd = end;\n        line.reset(text);\n        for (; line.depth < this.stack.length; line.depth++) {\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\n            if (!handler)\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\n            if (!handler(cx, this, line))\n                break;\n            line.forward();\n        }\n    }\n    lineChunkAt(pos) {\n        let next = this.input.chunk(pos), text;\n        if (!this.input.lineChunks) {\n            let eol = next.indexOf(\"\\n\");\n            text = eol < 0 ? next : next.slice(0, eol);\n        }\n        else {\n            text = next == \"\\n\" ? \"\" : next;\n        }\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /// The end position of the previous line.\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\n    /// @internal\n    startContext(type, start, value = 0) {\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n        this.stack.push(this.block);\n    }\n    /// Start a composite block. Should only be called from [block\n    /// parser functions](#BlockParser.parse) that return null.\n    startComposite(type, start, value = 0) {\n        this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /// @internal\n    addNode(block, from, to) {\n        if (typeof block == \"number\")\n            block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n        this.block.addChild(block, from - this.block.from);\n    }\n    /// Add a block element. Can be called by [block\n    /// parsers](#BlockParser.parse).\n    addElement(elt) {\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /// Add a block element from a [leaf parser](#LeafBlockParser). This\n    /// makes sure any extra composite block markup (such as blockquote\n    /// markers) inside the block are also added to the syntax tree.\n    addLeafElement(leaf, elt) {\n        this.addNode(this.buffer\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\n            .finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /// @internal\n    finishContext() {\n        let cx = this.stack.pop();\n        let top = this.stack[this.stack.length - 1];\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n        this.block = top;\n    }\n    finish() {\n        while (this.stack.length > 1)\n            this.finishContext();\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n    addGaps(tree) {\n        return this.ranges.length > 1 ?\n            injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders) : tree;\n    }\n    /// @internal\n    finishLeaf(leaf) {\n        for (let parser of leaf.parsers)\n            if (parser.finish(this, leaf))\n                return;\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n        this.addNode(this.buffer\n            .writeElements(inline, -leaf.start)\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n    /// @internal\n    get buffer() { return new Buffer(this.parser.nodeSet); }\n}\nfunction injectGaps(ranges, rangeI, tree, offset, dummies) {\n    let rangeEnd = ranges[rangeI].to;\n    let children = [], positions = [], start = tree.from + offset;\n    function movePastNext(upto, inclusive) {\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n            let size = ranges[rangeI + 1].from - rangeEnd;\n            offset += size;\n            upto += size;\n            rangeI++;\n            rangeEnd = ranges[rangeI].to;\n        }\n    }\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n        movePastNext(ch.from + offset, true);\n        let from = ch.from + offset, node, reuse = dummies.get(ch.tree);\n        if (reuse) {\n            node = reuse;\n        }\n        else if (ch.to + offset > rangeEnd) {\n            node = injectGaps(ranges, rangeI, ch, offset, dummies);\n            movePastNext(ch.to + offset, false);\n        }\n        else {\n            node = ch.toTree();\n        }\n        children.push(node);\n        positions.push(from - start);\n    }\n    movePastNext(tree.to + offset, false);\n    return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/// A Markdown parser configuration.\nclass MarkdownParser extends Parser {\n    /// @internal\n    constructor(\n    /// The parser's syntax [node\n    /// types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n    nodeSet, \n    /// @internal\n    blockParsers, \n    /// @internal\n    leafBlockParsers, \n    /// @internal\n    blockNames, \n    /// @internal\n    endLeafBlock, \n    /// @internal\n    skipContextMarkup, \n    /// @internal\n    inlineParsers, \n    /// @internal\n    inlineNames, \n    /// @internal\n    wrappers) {\n        super();\n        this.nodeSet = nodeSet;\n        this.blockParsers = blockParsers;\n        this.leafBlockParsers = leafBlockParsers;\n        this.blockNames = blockNames;\n        this.endLeafBlock = endLeafBlock;\n        this.skipContextMarkup = skipContextMarkup;\n        this.inlineParsers = inlineParsers;\n        this.inlineNames = inlineNames;\n        this.wrappers = wrappers;\n        /// @internal\n        this.nodeTypes = Object.create(null);\n        for (let t of nodeSet.types)\n            this.nodeTypes[t.name] = t.id;\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new BlockContext(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Reconfigure the parser.\n    configure(spec) {\n        let config = resolveConfig(spec);\n        if (!config)\n            return this;\n        let { nodeSet, skipContextMarkup } = this;\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\n        if (nonEmpty(config.defineNodes)) {\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\n            let nodeTypes = nodeSet.types.slice(), styles;\n            for (let s of config.defineNodes) {\n                let { name, block, composite, style } = typeof s == \"string\" ? { name: s } : s;\n                if (nodeTypes.some(t => t.name == name))\n                    continue;\n                if (composite)\n                    skipContextMarkup[nodeTypes.length] =\n                        (bl, cx, line) => composite(cx, line, bl.value);\n                let id = nodeTypes.length;\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n                nodeTypes.push(NodeType.define({\n                    id,\n                    name,\n                    props: group && [[NodeProp.group, group]]\n                }));\n                if (style) {\n                    if (!styles)\n                        styles = {};\n                    if (Array.isArray(style) || style instanceof Tag)\n                        styles[name] = style;\n                    else\n                        Object.assign(styles, style);\n                }\n            }\n            nodeSet = new NodeSet(nodeTypes);\n            if (styles)\n                nodeSet = nodeSet.extend(styleTags(styles));\n        }\n        if (nonEmpty(config.props))\n            nodeSet = nodeSet.extend(...config.props);\n        if (nonEmpty(config.remove)) {\n            for (let rm of config.remove) {\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\n                if (block > -1)\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\n                if (inline > -1)\n                    inlineParsers[inline] = undefined;\n            }\n        }\n        if (nonEmpty(config.parseBlock)) {\n            for (let spec of config.parseBlock) {\n                let found = blockNames.indexOf(spec.name);\n                if (found > -1) {\n                    blockParsers[found] = spec.parse;\n                    leafBlockParsers[found] = spec.leaf;\n                }\n                else {\n                    let pos = spec.before ? findName(blockNames, spec.before)\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n                    blockParsers.splice(pos, 0, spec.parse);\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\n                    blockNames.splice(pos, 0, spec.name);\n                }\n                if (spec.endLeaf)\n                    endLeafBlock.push(spec.endLeaf);\n            }\n        }\n        if (nonEmpty(config.parseInline)) {\n            for (let spec of config.parseInline) {\n                let found = inlineNames.indexOf(spec.name);\n                if (found > -1) {\n                    inlineParsers[found] = spec.parse;\n                }\n                else {\n                    let pos = spec.before ? findName(inlineNames, spec.before)\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n                    inlineParsers.splice(pos, 0, spec.parse);\n                    inlineNames.splice(pos, 0, spec.name);\n                }\n            }\n        }\n        if (config.wrap)\n            wrappers = wrappers.concat(config.wrap);\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /// @internal\n    getNodeType(name) {\n        let found = this.nodeTypes[name];\n        if (found == null)\n            throw new RangeError(`Unknown node type '${name}'`);\n        return found;\n    }\n    /// Parse the given piece of inline text at the given offset,\n    /// returning an array of [`Element`](#Element) objects representing\n    /// the inline content.\n    parseInline(text, offset) {\n        let cx = new InlineContext(this, text, offset);\n        outer: for (let pos = offset; pos < cx.end;) {\n            let next = cx.char(pos);\n            for (let token of this.inlineParsers)\n                if (token) {\n                    let result = token(cx, next, pos);\n                    if (result >= 0) {\n                        pos = result;\n                        continue outer;\n                    }\n                }\n            pos++;\n        }\n        return cx.resolveMarkers(0);\n    }\n}\nfunction nonEmpty(a) {\n    return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n    if (!Array.isArray(spec))\n        return spec;\n    if (spec.length == 0)\n        return null;\n    let conf = resolveConfig(spec[0]);\n    if (spec.length == 1)\n        return conf;\n    let rest = resolveConfig(spec.slice(1));\n    if (!rest || !conf)\n        return conf || rest;\n    let conc = (a, b) => (a || none).concat(b || none);\n    let wrapA = conf.wrap, wrapB = rest.wrap;\n    return {\n        props: conc(conf.props, rest.props),\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\n        parseInline: conc(conf.parseInline, rest.parseInline),\n        remove: conc(conf.remove, rest.remove),\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n    };\n}\nfunction findName(names, name) {\n    let found = names.indexOf(name);\n    if (found < 0)\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\n    return found;\n}\nlet nodeTypes = [NodeType.none];\nfor (let i = 1, name; name = Type[i]; i++) {\n    nodeTypes[i] = NodeType.define({\n        id: i,\n        name,\n        props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]],\n        top: name == \"Document\"\n    });\n}\nconst none = [];\nclass Buffer {\n    constructor(nodeSet) {\n        this.nodeSet = nodeSet;\n        this.content = [];\n        this.nodes = [];\n    }\n    write(type, from, to, children = 0) {\n        this.content.push(type, from, to, 4 + children * 4);\n        return this;\n    }\n    writeElements(elts, offset = 0) {\n        for (let e of elts)\n            e.writeTo(this, offset);\n        return this;\n    }\n    finish(type, length) {\n        return Tree.build({\n            buffer: this.content,\n            nodeSet: this.nodeSet,\n            reused: this.nodes,\n            topID: type,\n            length\n        });\n    }\n}\n/// Elements are used to compose syntax nodes during parsing.\nclass Element {\n    /// @internal\n    constructor(\n    /// The node's\n    /// [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n    type, \n    /// The start of the node, as an offset from the start of the document.\n    from, \n    /// The end of the node.\n    to, \n    /// The node's child nodes @internal\n    children = none) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.children = children;\n    }\n    /// @internal\n    writeTo(buf, offset) {\n        let startOff = buf.content.length;\n        buf.writeElements(this.children, offset);\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /// @internal\n    toTree(nodeSet) {\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n}\nclass TreeElement {\n    constructor(tree, from) {\n        this.tree = tree;\n        this.from = from;\n    }\n    get to() { return this.from + this.tree.length; }\n    get type() { return this.tree.type.id; }\n    get children() { return none; }\n    writeTo(buf, offset) {\n        buf.nodes.push(this.tree);\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n    toTree() { return this.tree; }\n}\nfunction elt(type, from, to, children) {\n    return new Element(type, from, to, children);\n}\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst LinkStart = {}, ImageStart = {};\nclass InlineDelimiter {\n    constructor(type, from, to, side) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.side = side;\n    }\n}\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n    Punctuation = new RegExp(\"[\\\\p{Pc}|\\\\p{Pd}|\\\\p{Pe}|\\\\p{Pf}|\\\\p{Pi}|\\\\p{Po}|\\\\p{Ps}]\", \"u\");\n}\ncatch (_) { }\nconst DefaultInline = {\n    Escape(cx, next, start) {\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\n            return -1;\n        let escaped = cx.char(start + 1);\n        for (let i = 0; i < Escapable.length; i++)\n            if (Escapable.charCodeAt(i) == escaped)\n                return cx.append(elt(Type.Escape, start, start + 2));\n        return -1;\n    },\n    Entity(cx, next, start) {\n        if (next != 38 /* '&' */)\n            return -1;\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n    },\n    InlineCode(cx, next, start) {\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\n            return -1;\n        let pos = start + 1;\n        while (pos < cx.end && cx.char(pos) == 96)\n            pos++;\n        let size = pos - start, curSize = 0;\n        for (; pos < cx.end; pos++) {\n            if (cx.char(pos) == 96) {\n                curSize++;\n                if (curSize == size && cx.char(pos + 1) != 96)\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\n                        elt(Type.CodeMark, start, start + size),\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\n                    ]));\n            }\n            else {\n                curSize = 0;\n            }\n        }\n        return -1;\n    },\n    HTMLTag(cx, next, start) {\n        if (next != 60 /* '<' */ || start == cx.end - 1)\n            return -1;\n        let after = cx.slice(start + 1, cx.end);\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n        if (url)\n            return cx.append(elt(Type.URL, start, start + 1 + url[0].length));\n        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n        if (comment)\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\n        if (procInst)\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n        if (!m)\n            return -1;\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n    },\n    Emphasis(cx, next, start) {\n        if (next != 95 && next != 42)\n            return -1;\n        let pos = start + 1;\n        while (cx.char(pos) == next)\n            pos++;\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Mark.Open */ : 0) | (canClose ? 2 /* Mark.Close */ : 0)));\n    },\n    HardBreak(cx, next, start) {\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\n            return cx.append(elt(Type.HardBreak, start, start + 2));\n        if (next == 32) {\n            let pos = start + 1;\n            while (cx.char(pos) == 32)\n                pos++;\n            if (cx.char(pos) == 10 && pos >= start + 2)\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\n        }\n        return -1;\n    },\n    Link(cx, next, start) {\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Mark.Open */)) : -1;\n    },\n    Image(cx, next, start) {\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Mark.Open */)) : -1;\n    },\n    LinkEnd(cx, next, start) {\n        if (next != 93 /* ']' */)\n            return -1;\n        // Scanning back to the next link/image start marker\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\n            let part = cx.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n                // If this one has been set invalid (because it would produce\n                // a nested link) or there's no valid link here ignore both.\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n                    cx.parts[i] = null;\n                    return -1;\n                }\n                // Finish the content and replace the entire range in\n                // this.parts with the link/image node.\n                let content = cx.takeContent(i);\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n                // Set any open-link markers before this link to invalid.\n                if (part.type == LinkStart)\n                    for (let j = 0; j < i; j++) {\n                        let p = cx.parts[j];\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\n                            p.side = 0;\n                    }\n                return link.to;\n            }\n        }\n        return -1;\n    }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\n    if (next == 40 /* '(' */) {\n        let pos = cx.skipSpace(startPos + 1);\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\n        if (dest) {\n            pos = cx.skipSpace(dest.to);\n            title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n            if (title)\n                pos = cx.skipSpace(title.to);\n        }\n        if (cx.char(pos) == 41 /* ')' */) {\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\n            endPos = pos + 1;\n            if (dest)\n                content.push(dest);\n            if (title)\n                content.push(title);\n            content.push(elt(Type.LinkMark, pos, endPos));\n        }\n    }\n    else if (next == 91 /* '[' */) {\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n        if (label) {\n            content.push(label);\n            endPos = label.to;\n        }\n    }\n    return elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next == 60 /* '<' */) {\n        for (let pos = start + 1; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (ch == 62 /* '>' */)\n                return elt(Type.URL, start + offset, pos + 1 + offset);\n            if (ch == 60 || ch == 10 /* '<\\n' */)\n                return false;\n        }\n        return null;\n    }\n    else {\n        let depth = 0, pos = start;\n        for (let escaped = false; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (space(ch)) {\n                break;\n            }\n            else if (escaped) {\n                escaped = false;\n            }\n            else if (ch == 40 /* '(' */) {\n                depth++;\n            }\n            else if (ch == 41 /* ')' */) {\n                if (!depth)\n                    break;\n                depth--;\n            }\n            else if (ch == 92 /* '\\\\' */) {\n                escaped = true;\n            }\n        }\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n    }\n}\nfunction parseLinkTitle(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\n        return false;\n    let end = next == 40 ? 41 : next;\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == end)\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\n        else if (ch == 92 /* '\\\\' */)\n            escaped = true;\n    }\n    return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == 93 /* ']' */)\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\n        else {\n            if (requireNonWS && !space(ch))\n                requireNonWS = false;\n            if (ch == 91 /* '[' */)\n                return false;\n            else if (ch == 92 /* '\\\\' */)\n                escaped = true;\n        }\n    }\n    return null;\n}\n/// Inline parsing functions get access to this context, and use it to\n/// read the content and emit syntax nodes.\nclass InlineContext {\n    /// @internal\n    constructor(\n    /// The parser that is being used.\n    parser, \n    /// The text of this inline section.\n    text, \n    /// The starting offset of the section in the document.\n    offset) {\n        this.parser = parser;\n        this.text = text;\n        this.offset = offset;\n        /// @internal\n        this.parts = [];\n    }\n    /// Get the character code at the given (document-relative)\n    /// position.\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\n    /// The position of the end of this inline section.\n    get end() { return this.offset + this.text.length; }\n    /// Get a substring of this inline section. Again uses\n    /// document-relative positions.\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\n    /// @internal\n    append(elt) {\n        this.parts.push(elt);\n        return elt.to;\n    }\n    /// Add a [delimiter](#DelimiterType) at this given position. `open`\n    /// and `close` indicate whether this delimiter is opening, closing,\n    /// or both. Returns the end of the delimiter, for convenient\n    /// returning from [parse functions](#InlineParser.parse).\n    addDelimiter(type, from, to, open, close) {\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Mark.Open */ : 0) | (close ? 2 /* Mark.Close */ : 0)));\n    }\n    /// Add an inline element. Returns the end of the element.\n    addElement(elt) {\n        return this.append(elt);\n    }\n    /// Resolve markers between this.parts.length and from, wrapping matched markers in the\n    /// appropriate node and updating the content of this.parts. @internal\n    resolveMarkers(from) {\n        // Scan forward, looking for closing tokens\n        for (let i = from; i < this.parts.length; i++) {\n            let close = this.parts[i];\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Mark.Close */)))\n                continue;\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n            let closeSize = close.to - close.from;\n            let open, j = i - 1;\n            // Continue scanning for a matching opening token\n            for (; j >= from; j--) {\n                let part = this.parts[j];\n                if (part instanceof InlineDelimiter && (part.side & 1 /* Mark.Open */) && part.type == close.type &&\n                    // Ignore emphasis delimiters where the character count doesn't match\n                    !(emp && ((close.side & 1 /* Mark.Open */) || (part.side & 2 /* Mark.Close */)) &&\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {\n                    open = part;\n                    break;\n                }\n            }\n            if (!open)\n                continue;\n            let type = close.type.resolve, content = [];\n            let start = open.from, end = close.to;\n            // Emphasis marker effect depends on the character count. Size consumed is minimum of the two\n            // markers.\n            if (emp) {\n                let size = Math.min(2, open.to - open.from, closeSize);\n                start = open.to - size;\n                end = close.from + size;\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n            }\n            // Move the covered region into content, optionally adding marker nodes\n            if (open.type.mark)\n                content.push(this.elt(open.type.mark, start, open.to));\n            for (let k = j + 1; k < i; k++) {\n                if (this.parts[k] instanceof Element)\n                    content.push(this.parts[k]);\n                this.parts[k] = null;\n            }\n            if (close.type.mark)\n                content.push(this.elt(close.type.mark, close.from, end));\n            let element = this.elt(type, start, end, content);\n            // If there are leftover emphasis marker characters, shrink the close/open markers. Otherwise, clear them.\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n            // Insert the new element in this.parts\n            if (keep)\n                this.parts.splice(i, 0, element);\n            else\n                this.parts[i] = element;\n        }\n        // Collect the elements remaining in this.parts into an array.\n        let result = [];\n        for (let i = from; i < this.parts.length; i++) {\n            let part = this.parts[i];\n            if (part instanceof Element)\n                result.push(part);\n        }\n        return result;\n    }\n    /// Find an opening delimiter of the given type. Returns `null` if\n    /// no delimiter is found, or an index that can be passed to\n    /// [`takeContent`](#InlineContext.takeContent) otherwise.\n    findOpeningDelimiter(type) {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && part.type == type)\n                return i;\n        }\n        return null;\n    }\n    /// Remove all inline elements and delimiters starting from the\n    /// given index (which you should get from\n    /// [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    /// resolve delimiters inside of them, and return them as an array\n    /// of elements.\n    takeContent(startIndex) {\n        let content = this.resolveMarkers(startIndex);\n        this.parts.length = startIndex;\n        return content;\n    }\n    /// Skip space after the given (document) position, returning either\n    /// the position of the next non-space character or the end of the\n    /// section.\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n}\nfunction injectMarks(elements, marks) {\n    if (!marks.length)\n        return elements;\n    if (!elements.length)\n        return marks;\n    let elts = elements.slice(), eI = 0;\n    for (let mark of marks) {\n        while (eI < elts.length && elts[eI].to < mark.to)\n            eI++;\n        if (eI < elts.length && elts[eI].from < mark.from) {\n            let e = elts[eI];\n            if (e instanceof Element)\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n        }\n        else {\n            elts.splice(eI++, 0, mark);\n        }\n    }\n    return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nclass FragmentCursor {\n    constructor(fragments, input) {\n        this.fragments = fragments;\n        this.input = input;\n        // Index into fragment array\n        this.i = 0;\n        // Active fragment\n        this.fragment = null;\n        this.fragmentEnd = -1;\n        // Cursor into the current fragment, if any. When `moveTo` returns\n        // true, this points at the first block after `pos`.\n        this.cursor = null;\n        if (fragments.length)\n            this.fragment = fragments[this.i++];\n    }\n    nextFragment() {\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n        this.cursor = null;\n        this.fragmentEnd = -1;\n    }\n    moveTo(pos, lineStart) {\n        while (this.fragment && this.fragment.to <= pos)\n            this.nextFragment();\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\n            return false;\n        if (this.fragmentEnd < 0) {\n            let end = this.fragment.to;\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\n                end--;\n            this.fragmentEnd = end ? end - 1 : 0;\n        }\n        let c = this.cursor;\n        if (!c) {\n            c = this.cursor = this.fragment.tree.cursor();\n            c.firstChild();\n        }\n        let rPos = pos + this.fragment.offset;\n        while (c.to <= rPos)\n            if (!c.parent())\n                return false;\n        for (;;) {\n            if (c.from >= rPos)\n                return this.fragment.from <= lineStart;\n            if (!c.childAfter(rPos))\n                return false;\n        }\n    }\n    matches(hash) {\n        let tree = this.cursor.tree;\n        return tree && tree.prop(NodeProp.contextHash) == hash;\n    }\n    takeNodes(cx) {\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\n        let prevEnd = end, prevI = blockI;\n        for (;;) {\n            if (cur.to - off > fragEnd) {\n                if (cur.type.isAnonymous && cur.firstChild())\n                    continue;\n                break;\n            }\n            let pos = toRelative(cur.from - off, cx.ranges);\n            if (cur.to - off <= cx.ranges[cx.rangeI].to) { // Fits in current range\n                cx.addNode(cur.tree, pos);\n            }\n            else {\n                let dummy = new Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp);\n                cx.reusePlaceholders.set(dummy, cur.tree);\n                cx.addNode(dummy, pos);\n            }\n            // Taken content must always end in a block, because incremental\n            // parsing happens on block boundaries. Never stop directly\n            // after an indented code block, since those can continue after\n            // any number of blank lines.\n            if (cur.type.is(\"Block\")) {\n                if (NotLast.indexOf(cur.type.id) < 0) {\n                    end = cur.to - off;\n                    blockI = cx.block.children.length;\n                }\n                else {\n                    end = prevEnd;\n                    blockI = prevI;\n                    prevEnd = cur.to - off;\n                    prevI = cx.block.children.length;\n                }\n            }\n            if (!cur.nextSibling())\n                break;\n        }\n        while (cx.block.children.length > blockI) {\n            cx.block.children.pop();\n            cx.block.positions.pop();\n        }\n        return end - start;\n    }\n}\n// Convert an input-stream-relative position to a\n// Markdown-doc-relative position by subtracting the size of all input\n// gaps before `abs`.\nfunction toRelative(abs, ranges) {\n    let pos = abs;\n    for (let i = 1; i < ranges.length; i++) {\n        let gapFrom = ranges[i - 1].to, gapTo = ranges[i].from;\n        if (gapFrom < abs)\n            pos -= gapTo - gapFrom;\n    }\n    return pos;\n}\nconst markdownHighlighting = styleTags({\n    \"Blockquote/...\": tags.quote,\n    HorizontalRule: tags.contentSeparator,\n    \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n    \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n    \"ATXHeading3/...\": tags.heading3,\n    \"ATXHeading4/...\": tags.heading4,\n    \"ATXHeading5/...\": tags.heading5,\n    \"ATXHeading6/...\": tags.heading6,\n    \"Comment CommentBlock\": tags.comment,\n    Escape: tags.escape,\n    Entity: tags.character,\n    \"Emphasis/...\": tags.emphasis,\n    \"StrongEmphasis/...\": tags.strong,\n    \"Link/... Image/...\": tags.link,\n    \"OrderedList/... BulletList/...\": tags.list,\n    \"BlockQuote/...\": tags.quote,\n    \"InlineCode CodeText\": tags.monospace,\n    URL: tags.url,\n    \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n    \"CodeInfo LinkLabel\": tags.labelName,\n    LinkTitle: tags.string,\n    Paragraph: tags.content\n});\n/// The default CommonMark parser.\nconst parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n    let ranges = [];\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n        let nextPos = n ? n.from : to;\n        if (nextPos > pos)\n            ranges.push({ from: pos, to: nextPos });\n        if (!n)\n            break;\n        pos = n.to;\n    }\n    return ranges;\n}\n/// Create a Markdown extension to enable nested parsing on code\n/// blocks and/or embedded HTML.\nfunction parseCode(config) {\n    let { codeParser, htmlParser } = config;\n    let wrap = parseMixed((node, input) => {\n        let id = node.type.id;\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n            let info = \"\";\n            if (id == Type.FencedCode) {\n                let infoNode = node.node.getChild(Type.CodeInfo);\n                if (infoNode)\n                    info = input.read(infoNode.from, infoNode.to);\n            }\n            let parser = codeParser(info);\n            if (parser)\n                return { parser, overlay: node => node.type.id == Type.CodeText };\n        }\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag)) {\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\n        }\n        return null;\n    });\n    return { wrap };\n}\n\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\n/// An extension that implements\n/// [GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\n/// Strikethrough syntax using `~~` delimiters.\nconst Strikethrough = {\n    defineNodes: [{\n            name: \"Strikethrough\",\n            style: { \"Strikethrough/...\": tags.strikethrough }\n        }, {\n            name: \"StrikethroughMark\",\n            style: tags.processingInstruction\n        }],\n    parseInline: [{\n            name: \"Strikethrough\",\n            parse(cx, next, pos) {\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)\n                    return -1;\n                let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);\n                let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n                let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));\n            },\n            after: \"Emphasis\"\n        }]\n};\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\n    let parseCell = () => {\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n    };\n    for (let i = startI; i < line.length; i++) {\n        let next = line.charCodeAt(i);\n        if (next == 124 /* '|' */ && !esc) {\n            if (!first || cellStart > -1)\n                count++;\n            first = false;\n            if (elts) {\n                if (cellStart > -1)\n                    parseCell();\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n            }\n            cellStart = cellEnd = -1;\n        }\n        else if (esc || next != 32 && next != 9) {\n            if (cellStart < 0)\n                cellStart = i;\n            cellEnd = i + 1;\n        }\n        esc = !esc && next == 92;\n    }\n    if (cellStart > -1) {\n        count++;\n        if (elts)\n            parseCell();\n    }\n    return count;\n}\nfunction hasPipe(str, start) {\n    for (let i = start; i < str.length; i++) {\n        let next = str.charCodeAt(i);\n        if (next == 124 /* '|' */)\n            return true;\n        if (next == 92 /* '\\\\' */)\n            i++;\n    }\n    return false;\n}\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nclass TableParser {\n    constructor() {\n        // Null means we haven't seen the second line yet, false means this\n        // isn't a table, and an array means this is a table and we've\n        // parsed the given rows so far.\n        this.rows = null;\n    }\n    nextLine(cx, line, leaf) {\n        if (this.rows == null) { // Second line\n            this.rows = false;\n            let lineText;\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n                if (firstCount == parseRow(cx, lineText, line.pos))\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n            }\n        }\n        else if (this.rows) { // Line after the second\n            let content = [];\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n        }\n        return false;\n    }\n    finish(cx, leaf) {\n        if (!this.rows)\n            return false;\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n        return true;\n    }\n}\n/// This extension provides\n/// [GFM-style](https://github.github.com/gfm/#tables-extension-)\n/// tables, using syntax like this:\n///\n/// ```\n/// | head 1 | head 2 |\n/// | ---    | ---    |\n/// | cell 1 | cell 2 |\n/// ```\nconst Table = {\n    defineNodes: [\n        { name: \"Table\", block: true },\n        { name: \"TableHeader\", style: { \"TableHeader/...\": tags.heading } },\n        \"TableRow\",\n        { name: \"TableCell\", style: tags.content },\n        { name: \"TableDelimiter\", style: tags.processingInstruction },\n    ],\n    parseBlock: [{\n            name: \"Table\",\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\n            endLeaf(cx, line, leaf) {\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\n                    return false;\n                let next = cx.scanLine(cx.absoluteLineEnd + 1).text;\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n            },\n            before: \"SetextHeading\"\n        }]\n};\nclass TaskParser {\n    nextLine() { return false; }\n    finish(cx, leaf) {\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\n        ]));\n        return true;\n    }\n}\n/// Extension providing\n/// [GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\n/// task list items, where list items can be prefixed with `[ ]` or\n/// `[x]` to add a checkbox.\nconst TaskList = {\n    defineNodes: [\n        { name: \"Task\", block: true, style: tags.list },\n        { name: \"TaskMarker\", style: tags.atom }\n    ],\n    parseBlock: [{\n            name: \"TaskList\",\n            leaf(cx, leaf) {\n                return /^\\[[ xX]\\][ \\t]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\n            },\n            after: \"SetextHeading\"\n        }]\n};\nconst autolinkRE = /(www\\.)|(https?:\\/\\/)|([\\w.+-]+@)|(mailto:|xmpp:)/gy;\nconst urlRE = /[\\w-]+(\\.\\w+(\\.\\w+)?)(\\/[^\\s<]*)?/gy;\nconst emailRE = /[\\w.+-]+@[\\w-]+\\.[\\w.-]+/gy;\nconst xmppResourceRE = /\\/[a-zA-Z\\d@.]+/gy;\nfunction count(str, from, to, ch) {\n    let result = 0;\n    for (let i = from; i < to; i++)\n        if (str[i] == ch)\n            result++;\n    return result;\n}\nfunction autolinkURLEnd(text, from) {\n    urlRE.lastIndex = from;\n    let m = urlRE.exec(text);\n    if (!m)\n        return -1;\n    let end = from + m[0].length;\n    for (;;) {\n        let last = text[end - 1], m;\n        if (/[?!.,:*_~]/.test(last) ||\n            last == \")\" && count(text, from, end, \")\") > count(text, from, end, \"(\"))\n            end--;\n        else if (last == \";\" && (m = /&(?:#\\d+|#x[a-f\\d]+|\\w+);$/.exec(text.slice(from, end))))\n            end = from + m.index;\n        else\n            break;\n    }\n    return end;\n}\nfunction autolinkEmailEnd(text, from) {\n    emailRE.lastIndex = from;\n    let m = emailRE.exec(text);\n    if (!m)\n        return -1;\n    let last = m[0][m[0].length - 1];\n    return last == \"_\" || last == \"-\" ? -1 : from + m[0].length - (last == \".\" ? 1 : 0);\n}\n/// Extension that implements autolinking for\n/// `www.`/`http://`/`https://`/`mailto:`/`xmpp:` URLs and email\n/// addresses.\nconst Autolink = {\n    parseInline: [{\n            name: \"Autolink\",\n            parse(cx, next, absPos) {\n                let pos = absPos - cx.offset;\n                autolinkRE.lastIndex = pos;\n                let m = autolinkRE.exec(cx.text), end = -1;\n                if (!m)\n                    return -1;\n                if (m[1] || m[2]) { // www., http://\n                    end = autolinkURLEnd(cx.text, pos + m[0].length);\n                }\n                else if (m[3]) { // email address\n                    end = autolinkEmailEnd(cx.text, pos);\n                }\n                else { // mailto:/xmpp:\n                    end = autolinkEmailEnd(cx.text, pos + m[0].length);\n                    if (end > -1 && m[0] == \"xmpp:\") {\n                        xmppResourceRE.lastIndex = end;\n                        m = xmppResourceRE.exec(cx.text);\n                        if (m)\n                            end = m.index + m[0].length;\n                    }\n                }\n                if (end < 0)\n                    return -1;\n                cx.addElement(cx.elt(\"URL\", absPos, end + cx.offset));\n                return end + cx.offset;\n            }\n        }]\n};\n/// Extension bundle containing [`Table`](#Table),\n/// [`TaskList`](#TaskList), [`Strikethrough`](#Strikethrough), and\n/// [`Autolink`](#Autolink).\nconst GFM = [Table, TaskList, Strikethrough, Autolink];\nfunction parseSubSuper(ch, node, mark) {\n    return (cx, next, pos) => {\n        if (next != ch || cx.char(pos + 1) == ch)\n            return -1;\n        let elts = [cx.elt(mark, pos, pos + 1)];\n        for (let i = pos + 1; i < cx.end; i++) {\n            let next = cx.char(i);\n            if (next == ch)\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n            if (next == 92 /* '\\\\' */)\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\n            if (space(next))\n                break;\n        }\n        return -1;\n    };\n}\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// superscript using `^` markers.\nconst Superscript = {\n    defineNodes: [\n        { name: \"Superscript\", style: tags.special(tags.content) },\n        { name: \"SuperscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Superscript\",\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n        }]\n};\n/// Extension providing\n/// [Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\n/// subscript using `~` markers.\nconst Subscript = {\n    defineNodes: [\n        { name: \"Subscript\", style: tags.special(tags.content) },\n        { name: \"SubscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Subscript\",\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n        }]\n};\n/// Extension that parses two colons with only letters, underscores,\n/// and numbers between them as `Emoji` nodes.\nconst Emoji = {\n    defineNodes: [{ name: \"Emoji\", style: tags.character }],\n    parseInline: [{\n            name: \"Emoji\",\n            parse(cx, next, pos) {\n                let match;\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\n                    return -1;\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n            }\n        }]\n};\n\nexport { Autolink, BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}