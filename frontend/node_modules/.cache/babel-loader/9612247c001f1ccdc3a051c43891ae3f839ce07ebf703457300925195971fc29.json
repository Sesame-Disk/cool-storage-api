{"ast":null,"code":"import _classCallCheck from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n//Const\nvar NOAH_ARK_CAPACITY = 3;\nexport var EntryType;\n(function (EntryType) {\n  EntryType[EntryType[\"Marker\"] = 0] = \"Marker\";\n  EntryType[EntryType[\"Element\"] = 1] = \"Element\";\n})(EntryType = EntryType || (EntryType = {}));\nvar MARKER = {\n  type: EntryType.Marker\n};\n//List of formatting elements\nexport var FormattingElementList = /*#__PURE__*/function () {\n  function FormattingElementList(treeAdapter) {\n    _classCallCheck(this, FormattingElementList);\n    this.treeAdapter = treeAdapter;\n    this.entries = [];\n    this.bookmark = null;\n  }\n  //Noah Ark's condition\n  //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n  //lightweight heuristics without thorough attributes check.\n  _createClass(FormattingElementList, [{\n    key: \"_getNoahArkConditionCandidates\",\n    value: function _getNoahArkConditionCandidates(newElement, neAttrs) {\n      var candidates = [];\n      var neAttrsLength = neAttrs.length;\n      var neTagName = this.treeAdapter.getTagName(newElement);\n      var neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n      for (var i = 0; i < this.entries.length; i++) {\n        var entry = this.entries[i];\n        if (entry.type === EntryType.Marker) {\n          break;\n        }\n        var element = entry.element;\n        if (this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {\n          var elementAttrs = this.treeAdapter.getAttrList(element);\n          if (elementAttrs.length === neAttrsLength) {\n            candidates.push({\n              idx: i,\n              attrs: elementAttrs\n            });\n          }\n        }\n      }\n      return candidates;\n    }\n  }, {\n    key: \"_ensureNoahArkCondition\",\n    value: function _ensureNoahArkCondition(newElement) {\n      if (this.entries.length < NOAH_ARK_CAPACITY) return;\n      var neAttrs = this.treeAdapter.getAttrList(newElement);\n      var candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);\n      if (candidates.length < NOAH_ARK_CAPACITY) return;\n      //NOTE: build attrs map for the new element, so we can perform fast lookups\n      var neAttrsMap = new Map(neAttrs.map(function (neAttr) {\n        return [neAttr.name, neAttr.value];\n      }));\n      var validCandidates = 0;\n      //NOTE: remove bottommost candidates, until Noah's Ark condition will not be met\n      for (var i = 0; i < candidates.length; i++) {\n        var candidate = candidates[i];\n        // We know that `candidate.attrs.length === neAttrs.length`\n        if (candidate.attrs.every(function (cAttr) {\n          return neAttrsMap.get(cAttr.name) === cAttr.value;\n        })) {\n          validCandidates += 1;\n          if (validCandidates >= NOAH_ARK_CAPACITY) {\n            this.entries.splice(candidate.idx, 1);\n          }\n        }\n      }\n    }\n    //Mutations\n  }, {\n    key: \"insertMarker\",\n    value: function insertMarker() {\n      this.entries.unshift(MARKER);\n    }\n  }, {\n    key: \"pushElement\",\n    value: function pushElement(element, token) {\n      this._ensureNoahArkCondition(element);\n      this.entries.unshift({\n        type: EntryType.Element,\n        element: element,\n        token: token\n      });\n    }\n  }, {\n    key: \"insertElementAfterBookmark\",\n    value: function insertElementAfterBookmark(element, token) {\n      var bookmarkIdx = this.entries.indexOf(this.bookmark);\n      this.entries.splice(bookmarkIdx, 0, {\n        type: EntryType.Element,\n        element: element,\n        token: token\n      });\n    }\n  }, {\n    key: \"removeEntry\",\n    value: function removeEntry(entry) {\n      var entryIndex = this.entries.indexOf(entry);\n      if (entryIndex >= 0) {\n        this.entries.splice(entryIndex, 1);\n      }\n    }\n    /**\n     * Clears the list of formatting elements up to the last marker.\n     *\n     * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker\n     */\n  }, {\n    key: \"clearToLastMarker\",\n    value: function clearToLastMarker() {\n      var markerIdx = this.entries.indexOf(MARKER);\n      if (markerIdx >= 0) {\n        this.entries.splice(0, markerIdx + 1);\n      } else {\n        this.entries.length = 0;\n      }\n    }\n    //Search\n  }, {\n    key: \"getElementEntryInScopeWithTagName\",\n    value: function getElementEntryInScopeWithTagName(tagName) {\n      var _this = this;\n      var entry = this.entries.find(function (entry) {\n        return entry.type === EntryType.Marker || _this.treeAdapter.getTagName(entry.element) === tagName;\n      });\n      return entry && entry.type === EntryType.Element ? entry : null;\n    }\n  }, {\n    key: \"getElementEntry\",\n    value: function getElementEntry(element) {\n      return this.entries.find(function (entry) {\n        return entry.type === EntryType.Element && entry.element === element;\n      });\n    }\n  }]);\n  return FormattingElementList;\n}();","map":{"version":3,"names":["NOAH_ARK_CAPACITY","EntryType","MARKER","type","Marker","FormattingElementList","treeAdapter","_classCallCheck","entries","bookmark","_createClass","key","value","_getNoahArkConditionCandidates","newElement","neAttrs","candidates","neAttrsLength","length","neTagName","getTagName","neNamespaceURI","getNamespaceURI","i","entry","element","elementAttrs","getAttrList","push","idx","attrs","_ensureNoahArkCondition","neAttrsMap","Map","map","neAttr","name","validCandidates","candidate","every","cAttr","get","splice","insertMarker","unshift","pushElement","token","Element","insertElementAfterBookmark","bookmarkIdx","indexOf","removeEntry","entryIndex","clearToLastMarker","markerIdx","getElementEntryInScopeWithTagName","tagName","_this","find","getElementEntry"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/hast-util-raw/node_modules/parse5/dist/parser/formatting-element-list.js"],"sourcesContent":["//Const\nconst NOAH_ARK_CAPACITY = 3;\nexport var EntryType;\n(function (EntryType) {\n    EntryType[EntryType[\"Marker\"] = 0] = \"Marker\";\n    EntryType[EntryType[\"Element\"] = 1] = \"Element\";\n})(EntryType = EntryType || (EntryType = {}));\nconst MARKER = { type: EntryType.Marker };\n//List of formatting elements\nexport class FormattingElementList {\n    constructor(treeAdapter) {\n        this.treeAdapter = treeAdapter;\n        this.entries = [];\n        this.bookmark = null;\n    }\n    //Noah Ark's condition\n    //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n    //lightweight heuristics without thorough attributes check.\n    _getNoahArkConditionCandidates(newElement, neAttrs) {\n        const candidates = [];\n        const neAttrsLength = neAttrs.length;\n        const neTagName = this.treeAdapter.getTagName(newElement);\n        const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n        for (let i = 0; i < this.entries.length; i++) {\n            const entry = this.entries[i];\n            if (entry.type === EntryType.Marker) {\n                break;\n            }\n            const { element } = entry;\n            if (this.treeAdapter.getTagName(element) === neTagName &&\n                this.treeAdapter.getNamespaceURI(element) === neNamespaceURI) {\n                const elementAttrs = this.treeAdapter.getAttrList(element);\n                if (elementAttrs.length === neAttrsLength) {\n                    candidates.push({ idx: i, attrs: elementAttrs });\n                }\n            }\n        }\n        return candidates;\n    }\n    _ensureNoahArkCondition(newElement) {\n        if (this.entries.length < NOAH_ARK_CAPACITY)\n            return;\n        const neAttrs = this.treeAdapter.getAttrList(newElement);\n        const candidates = this._getNoahArkConditionCandidates(newElement, neAttrs);\n        if (candidates.length < NOAH_ARK_CAPACITY)\n            return;\n        //NOTE: build attrs map for the new element, so we can perform fast lookups\n        const neAttrsMap = new Map(neAttrs.map((neAttr) => [neAttr.name, neAttr.value]));\n        let validCandidates = 0;\n        //NOTE: remove bottommost candidates, until Noah's Ark condition will not be met\n        for (let i = 0; i < candidates.length; i++) {\n            const candidate = candidates[i];\n            // We know that `candidate.attrs.length === neAttrs.length`\n            if (candidate.attrs.every((cAttr) => neAttrsMap.get(cAttr.name) === cAttr.value)) {\n                validCandidates += 1;\n                if (validCandidates >= NOAH_ARK_CAPACITY) {\n                    this.entries.splice(candidate.idx, 1);\n                }\n            }\n        }\n    }\n    //Mutations\n    insertMarker() {\n        this.entries.unshift(MARKER);\n    }\n    pushElement(element, token) {\n        this._ensureNoahArkCondition(element);\n        this.entries.unshift({\n            type: EntryType.Element,\n            element,\n            token,\n        });\n    }\n    insertElementAfterBookmark(element, token) {\n        const bookmarkIdx = this.entries.indexOf(this.bookmark);\n        this.entries.splice(bookmarkIdx, 0, {\n            type: EntryType.Element,\n            element,\n            token,\n        });\n    }\n    removeEntry(entry) {\n        const entryIndex = this.entries.indexOf(entry);\n        if (entryIndex >= 0) {\n            this.entries.splice(entryIndex, 1);\n        }\n    }\n    /**\n     * Clears the list of formatting elements up to the last marker.\n     *\n     * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker\n     */\n    clearToLastMarker() {\n        const markerIdx = this.entries.indexOf(MARKER);\n        if (markerIdx >= 0) {\n            this.entries.splice(0, markerIdx + 1);\n        }\n        else {\n            this.entries.length = 0;\n        }\n    }\n    //Search\n    getElementEntryInScopeWithTagName(tagName) {\n        const entry = this.entries.find((entry) => entry.type === EntryType.Marker || this.treeAdapter.getTagName(entry.element) === tagName);\n        return entry && entry.type === EntryType.Element ? entry : null;\n    }\n    getElementEntry(element) {\n        return this.entries.find((entry) => entry.type === EntryType.Element && entry.element === element);\n    }\n}\n//# sourceMappingURL=formatting-element-list.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}