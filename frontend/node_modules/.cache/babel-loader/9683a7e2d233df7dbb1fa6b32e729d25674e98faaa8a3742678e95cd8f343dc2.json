{"ast":null,"code":"import _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { Editor, Element, Node, Range, Text } from '@seafile/slate';\nimport { CHECK_LIST_ITEM, CODE_BLOCK, CODE_LINE, LIST_ITEM, PARAGRAPH, TABLE } from '../../constants';\nimport { toggleList } from './transforms';\nimport { getListTypes } from './queries';\nexport var isMenuDisabled = function isMenuDisabled(editor, readonly) {\n  if (readonly) return true;\n  if (editor.selection == null) return true;\n  var selectedElements = [];\n  var nodeEntries = Editor.nodes(editor, {\n    universal: true\n  });\n  var _iterator = _createForOfIteratorHelper(nodeEntries),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var nodeEntry = _step.value;\n      var _nodeEntry = _slicedToArray(nodeEntry, 1),\n        node = _nodeEntry[0];\n      if (Element.isElement(node)) selectedElements.push(node);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var notMatch = selectedElements.some(function (element) {\n    if (Editor.isVoid(editor, element) && Editor.isBlock(editor, element)) return true;\n    var type = element.type;\n    if ([CODE_LINE, CODE_BLOCK, TABLE, CHECK_LIST_ITEM].includes(type)) return true;\n    return false;\n  });\n  if (notMatch) return true;\n  return false;\n};\nexport var getListType = function getListType(editor, type) {\n  var selection = editor.selection;\n  if (!selection) return;\n  var selectedListNodeEntry;\n  if (Range.isCollapsed(selection)) {\n    var _Editor$nodes = Editor.nodes(editor, {\n        match: function match(node) {\n          return getListTypes().includes(node.type);\n        },\n        mode: 'lowest'\n      }),\n      _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n      nodeEntry = _Editor$nodes2[0];\n    selectedListNodeEntry = nodeEntry;\n  } else {\n    var anchor = selection.anchor,\n      focus = selection.focus;\n    var commonNodeEntry = Node.common(editor, anchor.path, focus.path);\n    //  Select condition:\n    // 1. Select in one list\n    // 2. Select in one list item\n    // 3. Select in one line\n    if (getListTypes().includes(commonNodeEntry[0].type)) {\n      // Select in one list\n      selectedListNodeEntry = commonNodeEntry;\n    } else if (commonNodeEntry[0].type === LIST_ITEM) {\n      // Select in one list item\n      selectedListNodeEntry = Editor.parent(editor, commonNodeEntry[1]);\n    } else if (Text.isText(commonNodeEntry[0])) {\n      // Select in one line\n      var _Editor$nodes3 = Editor.nodes(editor, {\n          at: commonNodeEntry[1],\n          match: function match(node) {\n            return getListTypes().includes(node.type);\n          },\n          mode: 'lowest'\n        }),\n        _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1),\n        _nodeEntry2 = _Editor$nodes4[0];\n      selectedListNodeEntry = _nodeEntry2;\n    }\n  }\n  return selectedListNodeEntry ? selectedListNodeEntry[0].type : PARAGRAPH;\n};\nexport var setListType = function setListType(editor, type) {\n  toggleList(editor, type);\n};\nexport var getBeforeText = function getBeforeText(editor) {\n  var selection = editor.selection;\n  if (selection == null) return {\n    beforeText: '',\n    range: null\n  };\n  var anchor = selection.anchor;\n  // Find the near text node above the current text\n  var _Editor$above = Editor.above(editor),\n    _Editor$above2 = _slicedToArray(_Editor$above, 2),\n    aboveNodePath = _Editor$above2[1];\n  var aboveNodeStartPoint = Editor.start(editor, aboveNodePath); // The starting position of the text node\n  var range = {\n    anchor: anchor,\n    focus: aboveNodeStartPoint\n  };\n  var beforeText = Editor.string(editor, range) || '';\n  return {\n    beforeText: beforeText,\n    range: range\n  };\n};","map":{"version":3,"names":["Editor","Element","Node","Range","Text","CHECK_LIST_ITEM","CODE_BLOCK","CODE_LINE","LIST_ITEM","PARAGRAPH","TABLE","toggleList","getListTypes","isMenuDisabled","editor","readonly","selection","selectedElements","nodeEntries","nodes","universal","_iterator","_createForOfIteratorHelper","_step","s","n","done","nodeEntry","value","_nodeEntry","_slicedToArray","node","isElement","push","err","e","f","notMatch","some","element","isVoid","isBlock","type","includes","getListType","selectedListNodeEntry","isCollapsed","_Editor$nodes","match","mode","_Editor$nodes2","anchor","focus","commonNodeEntry","common","path","parent","isText","_Editor$nodes3","at","_Editor$nodes4","setListType","getBeforeText","beforeText","range","_Editor$above","above","_Editor$above2","aboveNodePath","aboveNodeStartPoint","start","string"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/plugins/list/helpers.js"],"sourcesContent":["import { Editor, Element, Node, Range, Text } from '@seafile/slate';\nimport { CHECK_LIST_ITEM, CODE_BLOCK, CODE_LINE, LIST_ITEM, PARAGRAPH, TABLE } from '../../constants';\nimport { toggleList } from './transforms';\nimport { getListTypes } from './queries';\nexport const isMenuDisabled = (editor, readonly) => {\n  if (readonly) return true;\n  if (editor.selection == null) return true;\n  let selectedElements = [];\n  const nodeEntries = Editor.nodes(editor, {\n    universal: true\n  });\n  for (let nodeEntry of nodeEntries) {\n    const [node] = nodeEntry;\n    if (Element.isElement(node)) selectedElements.push(node);\n  }\n  const notMatch = selectedElements.some(element => {\n    if (Editor.isVoid(editor, element) && Editor.isBlock(editor, element)) return true;\n    const {\n      type\n    } = element;\n    if ([CODE_LINE, CODE_BLOCK, TABLE, CHECK_LIST_ITEM].includes(type)) return true;\n    return false;\n  });\n  if (notMatch) return true;\n  return false;\n};\nexport const getListType = (editor, type) => {\n  const {\n    selection\n  } = editor;\n  if (!selection) return;\n  let selectedListNodeEntry;\n  if (Range.isCollapsed(selection)) {\n    const [nodeEntry] = Editor.nodes(editor, {\n      match: node => getListTypes().includes(node.type),\n      mode: 'lowest'\n    });\n    selectedListNodeEntry = nodeEntry;\n  } else {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const commonNodeEntry = Node.common(editor, anchor.path, focus.path);\n    //  Select condition:\n    // 1. Select in one list\n    // 2. Select in one list item\n    // 3. Select in one line\n    if (getListTypes().includes(commonNodeEntry[0].type)) {\n      // Select in one list\n      selectedListNodeEntry = commonNodeEntry;\n    } else if (commonNodeEntry[0].type === LIST_ITEM) {\n      // Select in one list item\n      selectedListNodeEntry = Editor.parent(editor, commonNodeEntry[1]);\n    } else if (Text.isText(commonNodeEntry[0])) {\n      // Select in one line\n      const [nodeEntry] = Editor.nodes(editor, {\n        at: commonNodeEntry[1],\n        match: node => getListTypes().includes(node.type),\n        mode: 'lowest'\n      });\n      selectedListNodeEntry = nodeEntry;\n    }\n  }\n  return selectedListNodeEntry ? selectedListNodeEntry[0].type : PARAGRAPH;\n};\nexport const setListType = (editor, type) => {\n  toggleList(editor, type);\n};\nexport const getBeforeText = editor => {\n  const {\n    selection\n  } = editor;\n  if (selection == null) return {\n    beforeText: '',\n    range: null\n  };\n  const {\n    anchor\n  } = selection;\n  // Find the near text node above the current text\n  const [, aboveNodePath] = Editor.above(editor);\n  const aboveNodeStartPoint = Editor.start(editor, aboveNodePath); // The starting position of the text node\n  const range = {\n    anchor,\n    focus: aboveNodeStartPoint\n  };\n  const beforeText = Editor.string(editor, range) || '';\n  return {\n    beforeText,\n    range\n  };\n};"],"mappings":";;AAAA,SAASA,MAAM,EAAEC,OAAO,EAAEC,IAAI,EAAEC,KAAK,EAAEC,IAAI,QAAQ,gBAAgB;AACnE,SAASC,eAAe,EAAEC,UAAU,EAAEC,SAAS,EAAEC,SAAS,EAAEC,SAAS,EAAEC,KAAK,QAAQ,iBAAiB;AACrG,SAASC,UAAU,QAAQ,cAAc;AACzC,SAASC,YAAY,QAAQ,WAAW;AACxC,OAAO,IAAMC,cAAc,GAAG,SAAjBA,cAAcA,CAAIC,MAAM,EAAEC,QAAQ,EAAK;EAClD,IAAIA,QAAQ,EAAE,OAAO,IAAI;EACzB,IAAID,MAAM,CAACE,SAAS,IAAI,IAAI,EAAE,OAAO,IAAI;EACzC,IAAIC,gBAAgB,GAAG,EAAE;EACzB,IAAMC,WAAW,GAAGlB,MAAM,CAACmB,KAAK,CAACL,MAAM,EAAE;IACvCM,SAAS,EAAE;EACb,CAAC,CAAC;EAAC,IAAAC,SAAA,GAAAC,0BAAA,CACmBJ,WAAW;IAAAK,KAAA;EAAA;IAAjC,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAmC;MAAA,IAA1BC,SAAS,GAAAJ,KAAA,CAAAK,KAAA;MAChB,IAAAC,UAAA,GAAAC,cAAA,CAAeH,SAAS;QAAjBI,IAAI,GAAAF,UAAA;MACX,IAAI5B,OAAO,CAAC+B,SAAS,CAACD,IAAI,CAAC,EAAEd,gBAAgB,CAACgB,IAAI,CAACF,IAAI,CAAC;IAC1D;EAAC,SAAAG,GAAA;IAAAb,SAAA,CAAAc,CAAA,CAAAD,GAAA;EAAA;IAAAb,SAAA,CAAAe,CAAA;EAAA;EACD,IAAMC,QAAQ,GAAGpB,gBAAgB,CAACqB,IAAI,CAAC,UAAAC,OAAO,EAAI;IAChD,IAAIvC,MAAM,CAACwC,MAAM,CAAC1B,MAAM,EAAEyB,OAAO,CAAC,IAAIvC,MAAM,CAACyC,OAAO,CAAC3B,MAAM,EAAEyB,OAAO,CAAC,EAAE,OAAO,IAAI;IAClF,IACEG,IAAI,GACFH,OAAO,CADTG,IAAI;IAEN,IAAI,CAACnC,SAAS,EAAED,UAAU,EAAEI,KAAK,EAAEL,eAAe,CAAC,CAACsC,QAAQ,CAACD,IAAI,CAAC,EAAE,OAAO,IAAI;IAC/E,OAAO,KAAK;EACd,CAAC,CAAC;EACF,IAAIL,QAAQ,EAAE,OAAO,IAAI;EACzB,OAAO,KAAK;AACd,CAAC;AACD,OAAO,IAAMO,WAAW,GAAG,SAAdA,WAAWA,CAAI9B,MAAM,EAAE4B,IAAI,EAAK;EAC3C,IACE1B,SAAS,GACPF,MAAM,CADRE,SAAS;EAEX,IAAI,CAACA,SAAS,EAAE;EAChB,IAAI6B,qBAAqB;EACzB,IAAI1C,KAAK,CAAC2C,WAAW,CAAC9B,SAAS,CAAC,EAAE;IAChC,IAAA+B,aAAA,GAAoB/C,MAAM,CAACmB,KAAK,CAACL,MAAM,EAAE;QACvCkC,KAAK,EAAE,SAAAA,MAAAjB,IAAI;UAAA,OAAInB,YAAY,CAAC,CAAC,CAAC+B,QAAQ,CAACZ,IAAI,CAACW,IAAI,CAAC;QAAA;QACjDO,IAAI,EAAE;MACR,CAAC,CAAC;MAAAC,cAAA,GAAApB,cAAA,CAAAiB,aAAA;MAHKpB,SAAS,GAAAuB,cAAA;IAIhBL,qBAAqB,GAAGlB,SAAS;EACnC,CAAC,MAAM;IACL,IACEwB,MAAM,GAEJnC,SAAS,CAFXmC,MAAM;MACNC,KAAK,GACHpC,SAAS,CADXoC,KAAK;IAEP,IAAMC,eAAe,GAAGnD,IAAI,CAACoD,MAAM,CAACxC,MAAM,EAAEqC,MAAM,CAACI,IAAI,EAAEH,KAAK,CAACG,IAAI,CAAC;IACpE;IACA;IACA;IACA;IACA,IAAI3C,YAAY,CAAC,CAAC,CAAC+B,QAAQ,CAACU,eAAe,CAAC,CAAC,CAAC,CAACX,IAAI,CAAC,EAAE;MACpD;MACAG,qBAAqB,GAAGQ,eAAe;IACzC,CAAC,MAAM,IAAIA,eAAe,CAAC,CAAC,CAAC,CAACX,IAAI,KAAKlC,SAAS,EAAE;MAChD;MACAqC,qBAAqB,GAAG7C,MAAM,CAACwD,MAAM,CAAC1C,MAAM,EAAEuC,eAAe,CAAC,CAAC,CAAC,CAAC;IACnE,CAAC,MAAM,IAAIjD,IAAI,CAACqD,MAAM,CAACJ,eAAe,CAAC,CAAC,CAAC,CAAC,EAAE;MAC1C;MACA,IAAAK,cAAA,GAAoB1D,MAAM,CAACmB,KAAK,CAACL,MAAM,EAAE;UACvC6C,EAAE,EAAEN,eAAe,CAAC,CAAC,CAAC;UACtBL,KAAK,EAAE,SAAAA,MAAAjB,IAAI;YAAA,OAAInB,YAAY,CAAC,CAAC,CAAC+B,QAAQ,CAACZ,IAAI,CAACW,IAAI,CAAC;UAAA;UACjDO,IAAI,EAAE;QACR,CAAC,CAAC;QAAAW,cAAA,GAAA9B,cAAA,CAAA4B,cAAA;QAJK/B,WAAS,GAAAiC,cAAA;MAKhBf,qBAAqB,GAAGlB,WAAS;IACnC;EACF;EACA,OAAOkB,qBAAqB,GAAGA,qBAAqB,CAAC,CAAC,CAAC,CAACH,IAAI,GAAGjC,SAAS;AAC1E,CAAC;AACD,OAAO,IAAMoD,WAAW,GAAG,SAAdA,WAAWA,CAAI/C,MAAM,EAAE4B,IAAI,EAAK;EAC3C/B,UAAU,CAACG,MAAM,EAAE4B,IAAI,CAAC;AAC1B,CAAC;AACD,OAAO,IAAMoB,aAAa,GAAG,SAAhBA,aAAaA,CAAGhD,MAAM,EAAI;EACrC,IACEE,SAAS,GACPF,MAAM,CADRE,SAAS;EAEX,IAAIA,SAAS,IAAI,IAAI,EAAE,OAAO;IAC5B+C,UAAU,EAAE,EAAE;IACdC,KAAK,EAAE;EACT,CAAC;EACD,IACEb,MAAM,GACJnC,SAAS,CADXmC,MAAM;EAER;EACA,IAAAc,aAAA,GAA0BjE,MAAM,CAACkE,KAAK,CAACpD,MAAM,CAAC;IAAAqD,cAAA,GAAArC,cAAA,CAAAmC,aAAA;IAArCG,aAAa,GAAAD,cAAA;EACtB,IAAME,mBAAmB,GAAGrE,MAAM,CAACsE,KAAK,CAACxD,MAAM,EAAEsD,aAAa,CAAC,CAAC,CAAC;EACjE,IAAMJ,KAAK,GAAG;IACZb,MAAM,EAANA,MAAM;IACNC,KAAK,EAAEiB;EACT,CAAC;EACD,IAAMN,UAAU,GAAG/D,MAAM,CAACuE,MAAM,CAACzD,MAAM,EAAEkD,KAAK,CAAC,IAAI,EAAE;EACrD,OAAO;IACLD,UAAU,EAAVA,UAAU;IACVC,KAAK,EAALA;EACF,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}