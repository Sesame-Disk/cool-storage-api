{"ast":null,"code":"(function (Prism) {\n  /**\n   * Returns the placeholder for the given language id and index.\n   *\n   * @param {string} language\n   * @param {string|number} index\n   * @returns {string}\n   */\n  function getPlaceholder(language, index) {\n    return '___' + language.toUpperCase() + index + '___';\n  }\n  Object.defineProperties(Prism.languages['markup-templating'] = {}, {\n    buildPlaceholders: {\n      /**\n       * Tokenize all inline templating expressions matching `placeholderPattern`.\n       *\n       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n       * `true` will be replaced.\n       *\n       * @param {object} env The environment of the `before-tokenize` hook.\n       * @param {string} language The language id.\n       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n       * @param {(match: string) => boolean} [replaceFilter]\n       */\n      value: function value(env, language, placeholderPattern, replaceFilter) {\n        if (env.language !== language) {\n          return;\n        }\n        var tokenStack = env.tokenStack = [];\n        env.code = env.code.replace(placeholderPattern, function (match) {\n          if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n            return match;\n          }\n          var i = tokenStack.length;\n          var placeholder;\n\n          // Check for existing strings\n          while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {\n            ++i;\n          }\n\n          // Create a sparse array\n          tokenStack[i] = match;\n          return placeholder;\n        });\n\n        // Switch the grammar to markup\n        env.grammar = Prism.languages.markup;\n      }\n    },\n    tokenizePlaceholders: {\n      /**\n       * Replace placeholders with proper tokens after tokenizing.\n       *\n       * @param {object} env The environment of the `after-tokenize` hook.\n       * @param {string} language The language id.\n       */\n      value: function value(env, language) {\n        if (env.language !== language || !env.tokenStack) {\n          return;\n        }\n\n        // Switch the grammar back\n        env.grammar = Prism.languages[language];\n        var j = 0;\n        var keys = Object.keys(env.tokenStack);\n        function walkTokens(tokens) {\n          for (var i = 0; i < tokens.length; i++) {\n            // all placeholders are replaced already\n            if (j >= keys.length) {\n              break;\n            }\n            var token = tokens[i];\n            if (typeof token === 'string' || token.content && typeof token.content === 'string') {\n              var k = keys[j];\n              var t = env.tokenStack[k];\n              var s = typeof token === 'string' ? token : token.content;\n              var placeholder = getPlaceholder(language, k);\n              var index = s.indexOf(placeholder);\n              if (index > -1) {\n                ++j;\n                var before = s.substring(0, index);\n                var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n                var after = s.substring(index + placeholder.length);\n                var replacement = [];\n                if (before) {\n                  replacement.push.apply(replacement, walkTokens([before]));\n                }\n                replacement.push(middle);\n                if (after) {\n                  replacement.push.apply(replacement, walkTokens([after]));\n                }\n                if (typeof token === 'string') {\n                  tokens.splice.apply(tokens, [i, 1].concat(replacement));\n                } else {\n                  token.content = replacement;\n                }\n              }\n            } else if (token.content /* && typeof token.content !== 'string' */) {\n              walkTokens(token.content);\n            }\n          }\n          return tokens;\n        }\n        walkTokens(env.tokens);\n      }\n    }\n  });\n})(Prism);","map":{"version":3,"names":["Prism","getPlaceholder","language","index","toUpperCase","Object","defineProperties","languages","buildPlaceholders","value","env","placeholderPattern","replaceFilter","tokenStack","code","replace","match","i","length","placeholder","indexOf","grammar","markup","tokenizePlaceholders","j","keys","walkTokens","tokens","token","content","k","t","s","before","substring","middle","Token","tokenize","after","replacement","push","apply","splice","concat"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/seafile-editor/node_modules/prismjs/components/prism-markup-templating.js"],"sourcesContent":["(function (Prism) {\n\n\t/**\n\t * Returns the placeholder for the given language id and index.\n\t *\n\t * @param {string} language\n\t * @param {string|number} index\n\t * @returns {string}\n\t */\n\tfunction getPlaceholder(language, index) {\n\t\treturn '___' + language.toUpperCase() + index + '___';\n\t}\n\n\tObject.defineProperties(Prism.languages['markup-templating'] = {}, {\n\t\tbuildPlaceholders: {\n\t\t\t/**\n\t\t\t * Tokenize all inline templating expressions matching `placeholderPattern`.\n\t\t\t *\n\t\t\t * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n\t\t\t * `true` will be replaced.\n\t\t\t *\n\t\t\t * @param {object} env The environment of the `before-tokenize` hook.\n\t\t\t * @param {string} language The language id.\n\t\t\t * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n\t\t\t * @param {(match: string) => boolean} [replaceFilter]\n\t\t\t */\n\t\t\tvalue: function (env, language, placeholderPattern, replaceFilter) {\n\t\t\t\tif (env.language !== language) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar tokenStack = env.tokenStack = [];\n\n\t\t\t\tenv.code = env.code.replace(placeholderPattern, function (match) {\n\t\t\t\t\tif (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n\t\t\t\t\t\treturn match;\n\t\t\t\t\t}\n\t\t\t\t\tvar i = tokenStack.length;\n\t\t\t\t\tvar placeholder;\n\n\t\t\t\t\t// Check for existing strings\n\t\t\t\t\twhile (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {\n\t\t\t\t\t\t++i;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create a sparse array\n\t\t\t\t\ttokenStack[i] = match;\n\n\t\t\t\t\treturn placeholder;\n\t\t\t\t});\n\n\t\t\t\t// Switch the grammar to markup\n\t\t\t\tenv.grammar = Prism.languages.markup;\n\t\t\t}\n\t\t},\n\t\ttokenizePlaceholders: {\n\t\t\t/**\n\t\t\t * Replace placeholders with proper tokens after tokenizing.\n\t\t\t *\n\t\t\t * @param {object} env The environment of the `after-tokenize` hook.\n\t\t\t * @param {string} language The language id.\n\t\t\t */\n\t\t\tvalue: function (env, language) {\n\t\t\t\tif (env.language !== language || !env.tokenStack) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Switch the grammar back\n\t\t\t\tenv.grammar = Prism.languages[language];\n\n\t\t\t\tvar j = 0;\n\t\t\t\tvar keys = Object.keys(env.tokenStack);\n\n\t\t\t\tfunction walkTokens(tokens) {\n\t\t\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\t\t\t// all placeholders are replaced already\n\t\t\t\t\t\tif (j >= keys.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar token = tokens[i];\n\t\t\t\t\t\tif (typeof token === 'string' || (token.content && typeof token.content === 'string')) {\n\t\t\t\t\t\t\tvar k = keys[j];\n\t\t\t\t\t\t\tvar t = env.tokenStack[k];\n\t\t\t\t\t\t\tvar s = typeof token === 'string' ? token : token.content;\n\t\t\t\t\t\t\tvar placeholder = getPlaceholder(language, k);\n\n\t\t\t\t\t\t\tvar index = s.indexOf(placeholder);\n\t\t\t\t\t\t\tif (index > -1) {\n\t\t\t\t\t\t\t\t++j;\n\n\t\t\t\t\t\t\t\tvar before = s.substring(0, index);\n\t\t\t\t\t\t\t\tvar middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n\t\t\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);\n\n\t\t\t\t\t\t\t\tvar replacement = [];\n\t\t\t\t\t\t\t\tif (before) {\n\t\t\t\t\t\t\t\t\treplacement.push.apply(replacement, walkTokens([before]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treplacement.push(middle);\n\t\t\t\t\t\t\t\tif (after) {\n\t\t\t\t\t\t\t\t\treplacement.push.apply(replacement, walkTokens([after]));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (typeof token === 'string') {\n\t\t\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttoken.content = replacement;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (token.content /* && typeof token.content !== 'string' */) {\n\t\t\t\t\t\t\twalkTokens(token.content);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn tokens;\n\t\t\t\t}\n\n\t\t\t\twalkTokens(env.tokens);\n\t\t\t}\n\t\t}\n\t});\n\n}(Prism));\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}