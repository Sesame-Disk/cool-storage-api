{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\n/** @type {Construct} */\nexport var mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n};\n\n/** @type {Construct} */\nvar nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n};\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  var self = this;\n  var tail = self.events[self.events.length - 1];\n  var initialSize = tail && tail[1].type === 'linePrefix' ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  var sizeOpen = 0;\n  return start;\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('mathFlow');\n    effects.enter('mathFlowFence');\n    effects.enter('mathFlowFenceSequence');\n    return sequenceOpen(code);\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    if (sizeOpen < 2) {\n      return nok(code);\n    }\n    effects.exit('mathFlowFenceSequence');\n    return factorySpace(effects, metaBefore, 'whitespace')(code);\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return metaAfter(code);\n    }\n    effects.enter('mathFlowFenceMeta');\n    effects.enter('chunkString', {\n      contentType: 'string'\n    });\n    return meta(code);\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString');\n      effects.exit('mathFlowFenceMeta');\n      return metaAfter(code);\n    }\n    if (code === 36) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return meta;\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence');\n    if (self.interrupt) {\n      return ok(code);\n    }\n    return effects.attempt(nonLazyContinuation, beforeNonLazyContinuation, after)(code);\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt({\n      tokenize: tokenizeClosingFence,\n      partial: true\n    }, after, contentStart)(code);\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (initialSize ? factorySpace(effects, beforeContentChunk, 'linePrefix', initialSize + 1) : beforeContentChunk)(code);\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === null) {\n      return after(code);\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(nonLazyContinuation, beforeNonLazyContinuation, after)(code);\n    }\n    effects.enter('mathFlowValue');\n    return contentChunk(code);\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue');\n      return beforeContentChunk(code);\n    }\n    effects.consume(code);\n    return contentChunk;\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow');\n    return ok(code);\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    var size = 0;\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(effects, beforeSequenceClose, 'linePrefix', self.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4);\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence');\n      effects.enter('mathFlowFenceSequence');\n      return sequenceClose(code);\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === 36) {\n        size++;\n        effects.consume(code);\n        return sequenceClose;\n      }\n      if (size < sizeOpen) {\n        return nok(code);\n      }\n      effects.exit('mathFlowFenceSequence');\n      return factorySpace(effects, afterSequenceClose, 'whitespace')(code);\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence');\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  var self = this;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code);\n    }\n    effects.enter('lineEnding');\n    effects.consume(code);\n    effects.exit('lineEnding');\n    return lineStart;\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}","map":{"version":3,"names":["factorySpace","markdownLineEnding","mathFlow","tokenize","tokenizeMathFenced","concrete","nonLazyContinuation","tokenizeNonLazyContinuation","partial","effects","ok","nok","self","tail","events","length","initialSize","type","sliceSerialize","sizeOpen","start","code","enter","sequenceOpen","consume","exit","metaBefore","metaAfter","contentType","meta","interrupt","attempt","beforeNonLazyContinuation","after","tokenizeClosingFence","contentStart","beforeContentChunk","contentChunk","size","beforeSequenceClose","parser","constructs","disable","null","includes","undefined","sequenceClose","afterSequenceClose","lineStart","lazy","now","line"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/micromark-extension-math/lib/math-flow.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n}\n\n/** @type {Construct} */\nconst nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  const initialSize =\n    tail && tail[1].type === 'linePrefix'\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  return start\n\n  /**\n   * Start of math.\n   *\n   * ```markdown\n   * > | $$\n   *     ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function start(code) {\n    effects.enter('mathFlow')\n    effects.enter('mathFlowFence')\n    effects.enter('mathFlowFenceSequence')\n    return sequenceOpen(code)\n  }\n\n  /**\n   * In opening fence sequence.\n   *\n   * ```markdown\n   * > | $$\n   *      ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function sequenceOpen(code) {\n    if (code === 36) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n    if (sizeOpen < 2) {\n      return nok(code)\n    }\n    effects.exit('mathFlowFenceSequence')\n    return factorySpace(effects, metaBefore, 'whitespace')(code)\n  }\n\n  /**\n   * In opening fence, before meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *       ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n\n  function metaBefore(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return metaAfter(code)\n    }\n    effects.enter('mathFlowFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n\n  /**\n   * In meta.\n   *\n   * ```markdown\n   * > | $$asciimath\n   *        ^\n   *   | x < y\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('mathFlowFenceMeta')\n      return metaAfter(code)\n    }\n    if (code === 36) {\n      return nok(code)\n    }\n    effects.consume(code)\n    return meta\n  }\n\n  /**\n   * After meta.\n   *\n   * ```markdown\n   * > | $$\n   *       ^\n   *   | \\frac{1}{2}\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function metaAfter(code) {\n    // Guaranteed to be eol/eof.\n    effects.exit('mathFlowFence')\n    if (self.interrupt) {\n      return ok(code)\n    }\n    return effects.attempt(\n      nonLazyContinuation,\n      beforeNonLazyContinuation,\n      after\n    )(code)\n  }\n\n  /**\n   * After eol/eof in math, at a non-lazy closing fence or content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   * > | $$\n   *     ^\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt(\n      {\n        tokenize: tokenizeClosingFence,\n        partial: true\n      },\n      after,\n      contentStart\n    )(code)\n  }\n\n  /**\n   * Before math content, definitely not before a closing fence.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentStart(code) {\n    return (\n      initialSize\n        ? factorySpace(\n            effects,\n            beforeContentChunk,\n            'linePrefix',\n            initialSize + 1\n          )\n        : beforeContentChunk\n    )(code)\n  }\n\n  /**\n   * Before math content, after optional prefix.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *     ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function beforeContentChunk(code) {\n    if (code === null) {\n      return after(code)\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyContinuation,\n        beforeNonLazyContinuation,\n        after\n      )(code)\n    }\n    effects.enter('mathFlowValue')\n    return contentChunk(code)\n  }\n\n  /**\n   * In math content.\n   *\n   * ```markdown\n   *   | $$\n   * > | \\frac{1}{2}\n   *      ^\n   *   | $$\n   * ```\n   *\n   * @type {State}\n   */\n  function contentChunk(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue')\n      return beforeContentChunk(code)\n    }\n    effects.consume(code)\n    return contentChunk\n  }\n\n  /**\n   * After math (ha!).\n   *\n   * ```markdown\n   *   | $$\n   *   | \\frac{1}{2}\n   * > | $$\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    effects.exit('mathFlow')\n    return ok(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n    /**\n     * Before closing fence, at optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     */\n    return factorySpace(\n      effects,\n      beforeSequenceClose,\n      'linePrefix',\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : 4\n    )\n\n    /**\n     * In closing fence, after optional whitespace, at sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function beforeSequenceClose(code) {\n      effects.enter('mathFlowFence')\n      effects.enter('mathFlowFenceSequence')\n      return sequenceClose(code)\n    }\n\n    /**\n     * In closing fence sequence.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *      ^\n     * ```\n     *\n     * @type {State}\n     */\n    function sequenceClose(code) {\n      if (code === 36) {\n        size++\n        effects.consume(code)\n        return sequenceClose\n      }\n      if (size < sizeOpen) {\n        return nok(code)\n      }\n      effects.exit('mathFlowFenceSequence')\n      return factorySpace(effects, afterSequenceClose, 'whitespace')(code)\n    }\n\n    /**\n     * After closing fence sequence, after optional whitespace.\n     *\n     * ```markdown\n     *   | $$\n     *   | \\frac{1}{2}\n     * > | $$\n     *       ^\n     * ```\n     *\n     * @type {State}\n     */\n    function afterSequenceClose(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence')\n        return ok(code)\n      }\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\n  const self = this\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (code === null) {\n      return ok(code)\n    }\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return lineStart\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}