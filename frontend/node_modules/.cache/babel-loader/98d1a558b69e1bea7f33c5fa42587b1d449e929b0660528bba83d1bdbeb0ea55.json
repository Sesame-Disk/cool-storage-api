{"ast":null,"code":"import Prism from 'prismjs';\nimport 'prismjs/themes/prism.css';\n\n// languages\nimport 'prismjs/components/prism-javascript';\nimport 'prismjs/components/prism-typescript';\nimport 'prismjs/components/prism-markup';\nimport 'prismjs/components/prism-go';\nimport 'prismjs/components/prism-php';\nimport 'prismjs/components/prism-c';\nimport 'prismjs/components/prism-python';\nimport 'prismjs/components/prism-java';\nimport 'prismjs/components/prism-cpp';\nimport 'prismjs/components/prism-csharp';\nimport 'prismjs/components/prism-sql';\nimport 'prismjs/components/prism-ruby';\nimport 'prismjs/components/prism-swift';\nimport 'prismjs/components/prism-bash';\nimport 'prismjs/components/prism-lua';\nvar newlineRe = /\\r\\n|\\r|\\n/;\nexport var genCodeLangs = function genCodeLangs() {\n  return [{\n    text: 'Plain Text',\n    value: 'plaintext'\n  }, {\n    text: 'Bash',\n    value: 'bash'\n  }, {\n    text: 'CSS',\n    value: 'css'\n  }, {\n    text: 'C',\n    value: 'c'\n  }, {\n    text: 'C++',\n    value: 'c++'\n  }, {\n    text: 'C#',\n    value: 'c#'\n  }, {\n    text: 'Go',\n    value: 'go'\n  }, {\n    text: 'HTML',\n    value: 'html'\n  }, {\n    text: 'Javascript',\n    value: 'javascript'\n  }, {\n    text: 'Java',\n    value: 'java'\n  }, {\n    text: 'PHP',\n    value: 'php'\n  }, {\n    text: 'Python',\n    value: 'python'\n  }, {\n    text: 'Ruby',\n    value: 'ruby'\n  }, {\n    text: 'SQL',\n    value: 'sql'\n  }, {\n    text: 'Swift',\n    value: 'swift'\n  }, {\n    text: 'Typescript',\n    value: 'typescript'\n  }, {\n    text: 'XML',\n    value: 'xml'\n  }];\n};\nexport var normalizeTokensByLanguageType = {\n  'php': function php(tokens) {\n    tokens.forEach(function (token) {\n      if (['<?', '?>'].includes(token.content)) {\n        token.type = 'operator';\n        token.alias = '';\n      }\n    });\n    return tokens;\n  }\n};\nvar normalizeEmptyLines = function normalizeEmptyLines(line) {\n  if (line.length === 0) {\n    line.push({\n      types: ['plain'],\n      content: '\\n',\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === '') {\n    line[0].content = '\\n';\n    line[0].empty = true;\n  }\n};\nvar appendTypes = function appendTypes(types, add) {\n  var typesSize = types.length;\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n  return types.concat(add);\n};\nexport var normalizeTokens = function normalizeTokens(tokens) {\n  var typeArrStack = [[]];\n  var tokenArrStack = [tokens];\n  var tokenArrIndexStack = [0];\n  var tokenArrSizeStack = [tokens.length];\n  var i = 0;\n  var stackIndex = 0;\n  var currentLine = [];\n  var acc = [currentLine];\n  while (stackIndex > -1) {\n    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      var content = void 0;\n      var types = typeArrStack[stackIndex];\n      var tokenArr = tokenArrStack[stackIndex];\n      var token = tokenArr[i];\n\n      // Determine content and append type to types if necessary\n      if (typeof token === 'string') {\n        types = stackIndex > 0 ? types : ['plain'];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n        content = token.content;\n      }\n\n      // If token.content is an array, increase the stack depth and repeat this while-loop\n      if (typeof content !== 'string') {\n        stackIndex++;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        continue;\n      }\n\n      // Split by newlines\n      var splitByNewlines = content.split(newlineRe);\n      var newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types: types,\n        content: splitByNewlines[0]\n      });\n\n      // Create a new line for each string on a new line\n      for (var _i = 1; _i < newlineCount; _i++) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types: types,\n          content: splitByNewlines[_i]\n        });\n      }\n    }\n\n    // Decreate the stack depth\n    stackIndex--;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\nexport default Prism;","map":{"version":3,"names":["Prism","newlineRe","genCodeLangs","text","value","normalizeTokensByLanguageType","php","tokens","forEach","token","includes","content","type","alias","normalizeEmptyLines","line","length","push","types","empty","appendTypes","add","typesSize","concat","normalizeTokens","typeArrStack","tokenArrStack","tokenArrIndexStack","tokenArrSizeStack","i","stackIndex","currentLine","acc","tokenArr","splitByNewlines","split","newlineCount","pop"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/plugins/code-block/prismjs.js"],"sourcesContent":["import Prism from 'prismjs';\nimport 'prismjs/themes/prism.css';\n\n// languages\nimport 'prismjs/components/prism-javascript';\nimport 'prismjs/components/prism-typescript';\nimport 'prismjs/components/prism-markup';\nimport 'prismjs/components/prism-go';\nimport 'prismjs/components/prism-php';\nimport 'prismjs/components/prism-c';\nimport 'prismjs/components/prism-python';\nimport 'prismjs/components/prism-java';\nimport 'prismjs/components/prism-cpp';\nimport 'prismjs/components/prism-csharp';\nimport 'prismjs/components/prism-sql';\nimport 'prismjs/components/prism-ruby';\nimport 'prismjs/components/prism-swift';\nimport 'prismjs/components/prism-bash';\nimport 'prismjs/components/prism-lua';\nconst newlineRe = /\\r\\n|\\r|\\n/;\nexport const genCodeLangs = () => {\n  return [{\n    text: 'Plain Text',\n    value: 'plaintext'\n  }, {\n    text: 'Bash',\n    value: 'bash'\n  }, {\n    text: 'CSS',\n    value: 'css'\n  }, {\n    text: 'C',\n    value: 'c'\n  }, {\n    text: 'C++',\n    value: 'c++'\n  }, {\n    text: 'C#',\n    value: 'c#'\n  }, {\n    text: 'Go',\n    value: 'go'\n  }, {\n    text: 'HTML',\n    value: 'html'\n  }, {\n    text: 'Javascript',\n    value: 'javascript'\n  }, {\n    text: 'Java',\n    value: 'java'\n  }, {\n    text: 'PHP',\n    value: 'php'\n  }, {\n    text: 'Python',\n    value: 'python'\n  }, {\n    text: 'Ruby',\n    value: 'ruby'\n  }, {\n    text: 'SQL',\n    value: 'sql'\n  }, {\n    text: 'Swift',\n    value: 'swift'\n  }, {\n    text: 'Typescript',\n    value: 'typescript'\n  }, {\n    text: 'XML',\n    value: 'xml'\n  }];\n};\nexport const normalizeTokensByLanguageType = {\n  'php': tokens => {\n    tokens.forEach(token => {\n      if (['<?', '?>'].includes(token.content)) {\n        token.type = 'operator';\n        token.alias = '';\n      }\n    });\n    return tokens;\n  }\n};\nconst normalizeEmptyLines = line => {\n  if (line.length === 0) {\n    line.push({\n      types: ['plain'],\n      content: '\\n',\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === '') {\n    line[0].content = '\\n';\n    line[0].empty = true;\n  }\n};\nconst appendTypes = (types, add) => {\n  const typesSize = types.length;\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n  return types.concat(add);\n};\nexport const normalizeTokens = tokens => {\n  const typeArrStack = [[]];\n  const tokenArrStack = [tokens];\n  const tokenArrIndexStack = [0];\n  const tokenArrSizeStack = [tokens.length];\n  let i = 0;\n  let stackIndex = 0;\n  let currentLine = [];\n  const acc = [currentLine];\n  while (stackIndex > -1) {\n    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      let content;\n      let types = typeArrStack[stackIndex];\n      const tokenArr = tokenArrStack[stackIndex];\n      const token = tokenArr[i];\n\n      // Determine content and append type to types if necessary\n      if (typeof token === 'string') {\n        types = stackIndex > 0 ? types : ['plain'];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n        content = token.content;\n      }\n\n      // If token.content is an array, increase the stack depth and repeat this while-loop\n      if (typeof content !== 'string') {\n        stackIndex++;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        continue;\n      }\n\n      // Split by newlines\n      const splitByNewlines = content.split(newlineRe);\n      const newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types,\n        content: splitByNewlines[0]\n      });\n\n      // Create a new line for each string on a new line\n      for (let i = 1; i < newlineCount; i++) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types,\n          content: splitByNewlines[i]\n        });\n      }\n    }\n\n    // Decreate the stack depth\n    stackIndex--;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\nexport default Prism;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}