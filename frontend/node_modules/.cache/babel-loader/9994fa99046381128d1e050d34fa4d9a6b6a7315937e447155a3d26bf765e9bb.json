{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { VOID, PRIMITIVE, ARRAY, OBJECT, DATE, REGEXP, MAP, SET, ERROR, BIGINT } from './types.js';\nvar EMPTY = '';\nvar _ref = {},\n  toString = _ref.toString;\nvar keys = Object.keys;\nvar typeOf = function typeOf(value) {\n  var type = typeof value;\n  if (type !== 'object' || !value) return [PRIMITIVE, type];\n  var asString = toString.call(value).slice(8, -1);\n  switch (asString) {\n    case 'Array':\n      return [ARRAY, EMPTY];\n    case 'Object':\n      return [OBJECT, EMPTY];\n    case 'Date':\n      return [DATE, EMPTY];\n    case 'RegExp':\n      return [REGEXP, EMPTY];\n    case 'Map':\n      return [MAP, EMPTY];\n    case 'Set':\n      return [SET, EMPTY];\n  }\n  if (asString.includes('Array')) return [ARRAY, asString];\n  if (asString.includes('Error')) return [ERROR, asString];\n  return [OBJECT, asString];\n};\nvar shouldSkip = function shouldSkip(_ref2) {\n  var _ref3 = _slicedToArray(_ref2, 2),\n    TYPE = _ref3[0],\n    type = _ref3[1];\n  return TYPE === PRIMITIVE && (type === 'function' || type === 'symbol');\n};\nvar serializer = function serializer(strict, json, $, _) {\n  var as = function as(out, value) {\n    var index = _.push(out) - 1;\n    $.set(value, index);\n    return index;\n  };\n  var pair = function pair(value) {\n    if ($.has(value)) return $.get(value);\n    var _typeOf = typeOf(value),\n      _typeOf2 = _slicedToArray(_typeOf, 2),\n      TYPE = _typeOf2[0],\n      type = _typeOf2[1];\n    switch (TYPE) {\n      case PRIMITIVE:\n        {\n          var entry = value;\n          switch (type) {\n            case 'bigint':\n              TYPE = BIGINT;\n              entry = value.toString();\n              break;\n            case 'function':\n            case 'symbol':\n              if (strict) throw new TypeError('unable to serialize ' + type);\n              entry = null;\n              break;\n            case 'undefined':\n              return as([VOID], value);\n          }\n          return as([TYPE, entry], value);\n        }\n      case ARRAY:\n        {\n          if (type) return as([type, _toConsumableArray(value)], value);\n          var arr = [];\n          var index = as([TYPE, arr], value);\n          var _iterator = _createForOfIteratorHelper(value),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _entry = _step.value;\n              arr.push(pair(_entry));\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          return index;\n        }\n      case OBJECT:\n        {\n          if (type) {\n            switch (type) {\n              case 'BigInt':\n                return as([type, value.toString()], value);\n              case 'Boolean':\n              case 'Number':\n              case 'String':\n                return as([type, value.valueOf()], value);\n            }\n          }\n          if (json && 'toJSON' in value) return pair(value.toJSON());\n          var entries = [];\n          var _index = as([TYPE, entries], value);\n          var _iterator2 = _createForOfIteratorHelper(keys(value)),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var key = _step2.value;\n              if (strict || !shouldSkip(typeOf(value[key]))) entries.push([pair(key), pair(value[key])]);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          return _index;\n        }\n      case DATE:\n        return as([TYPE, value.toISOString()], value);\n      case REGEXP:\n        {\n          var source = value.source,\n            flags = value.flags;\n          return as([TYPE, {\n            source: source,\n            flags: flags\n          }], value);\n        }\n      case MAP:\n        {\n          var _entries = [];\n          var _index2 = as([TYPE, _entries], value);\n          var _iterator3 = _createForOfIteratorHelper(value),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _step3$value = _slicedToArray(_step3.value, 2),\n                _key = _step3$value[0],\n                _entry2 = _step3$value[1];\n              if (strict || !(shouldSkip(typeOf(_key)) || shouldSkip(typeOf(_entry2)))) _entries.push([pair(_key), pair(_entry2)]);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          return _index2;\n        }\n      case SET:\n        {\n          var _entries2 = [];\n          var _index3 = as([TYPE, _entries2], value);\n          var _iterator4 = _createForOfIteratorHelper(value),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _entry3 = _step4.value;\n              if (strict || !shouldSkip(typeOf(_entry3))) _entries2.push(pair(_entry3));\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n          return _index3;\n        }\n    }\n    var message = value.message;\n    return as([TYPE, {\n      name: type,\n      message: message\n    }], value);\n  };\n  return pair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} value a serializable value.\n * @param {{json?: boolean, lossy?: boolean}?} options an object with a `lossy` or `json` property that,\n *  if `true`, will not throw errors on incompatible types, and behave more\n *  like JSON stringify would behave. Symbol and Function will be discarded.\n * @returns {Record[]}\n */\nexport var serialize = function serialize(value) {\n  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    json = _ref4.json,\n    lossy = _ref4.lossy;\n  var _ = [];\n  return serializer(!(json || lossy), !!json, new Map(), _)(value), _;\n};","map":{"version":3,"names":["VOID","PRIMITIVE","ARRAY","OBJECT","DATE","REGEXP","MAP","SET","ERROR","BIGINT","EMPTY","_ref","toString","keys","Object","typeOf","value","type","asString","call","slice","includes","shouldSkip","_ref2","_ref3","_slicedToArray","TYPE","serializer","strict","json","$","_","as","out","index","push","set","pair","has","get","_typeOf","_typeOf2","entry","TypeError","_toConsumableArray","arr","_iterator","_createForOfIteratorHelper","_step","s","n","done","err","e","f","valueOf","toJSON","entries","_iterator2","_step2","key","toISOString","source","flags","_iterator3","_step3","_step3$value","_iterator4","_step4","message","name","serialize","_ref4","arguments","length","undefined","lossy","Map"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@ungap/structured-clone/esm/serialize.js"],"sourcesContent":["import {\n  VOID, PRIMITIVE,\n  ARRAY, OBJECT,\n  DATE, REGEXP, MAP, SET,\n  ERROR, BIGINT\n} from './types.js';\n\nconst EMPTY = '';\n\nconst {toString} = {};\nconst {keys} = Object;\n\nconst typeOf = value => {\n  const type = typeof value;\n  if (type !== 'object' || !value)\n    return [PRIMITIVE, type];\n\n  const asString = toString.call(value).slice(8, -1);\n  switch (asString) {\n    case 'Array':\n      return [ARRAY, EMPTY];\n    case 'Object':\n      return [OBJECT, EMPTY];\n    case 'Date':\n      return [DATE, EMPTY];\n    case 'RegExp':\n      return [REGEXP, EMPTY];\n    case 'Map':\n      return [MAP, EMPTY];\n    case 'Set':\n      return [SET, EMPTY];\n  }\n\n  if (asString.includes('Array'))\n    return [ARRAY, asString];\n\n  if (asString.includes('Error'))\n    return [ERROR, asString];\n\n  return [OBJECT, asString];\n};\n\nconst shouldSkip = ([TYPE, type]) => (\n  TYPE === PRIMITIVE &&\n  (type === 'function' || type === 'symbol')\n);\n\nconst serializer = (strict, json, $, _) => {\n\n  const as = (out, value) => {\n    const index = _.push(out) - 1;\n    $.set(value, index);\n    return index;\n  };\n\n  const pair = value => {\n    if ($.has(value))\n      return $.get(value);\n\n    let [TYPE, type] = typeOf(value);\n    switch (TYPE) {\n      case PRIMITIVE: {\n        let entry = value;\n        switch (type) {\n          case 'bigint':\n            TYPE = BIGINT;\n            entry = value.toString();\n            break;\n          case 'function':\n          case 'symbol':\n            if (strict)\n              throw new TypeError('unable to serialize ' + type);\n            entry = null;\n            break;\n          case 'undefined':\n            return as([VOID], value);\n        }\n        return as([TYPE, entry], value);\n      }\n      case ARRAY: {\n        if (type)\n          return as([type, [...value]], value);\n  \n        const arr = [];\n        const index = as([TYPE, arr], value);\n        for (const entry of value)\n          arr.push(pair(entry));\n        return index;\n      }\n      case OBJECT: {\n        if (type) {\n          switch (type) {\n            case 'BigInt':\n              return as([type, value.toString()], value);\n            case 'Boolean':\n            case 'Number':\n            case 'String':\n              return as([type, value.valueOf()], value);\n          }\n        }\n\n        if (json && ('toJSON' in value))\n          return pair(value.toJSON());\n\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const key of keys(value)) {\n          if (strict || !shouldSkip(typeOf(value[key])))\n            entries.push([pair(key), pair(value[key])]);\n        }\n        return index;\n      }\n      case DATE:\n        return as([TYPE, value.toISOString()], value);\n      case REGEXP: {\n        const {source, flags} = value;\n        return as([TYPE, {source, flags}], value);\n      }\n      case MAP: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const [key, entry] of value) {\n          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))\n            entries.push([pair(key), pair(entry)]);\n        }\n        return index;\n      }\n      case SET: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const entry of value) {\n          if (strict || !shouldSkip(typeOf(entry)))\n            entries.push(pair(entry));\n        }\n        return index;\n      }\n    }\n\n    const {message} = value;\n    return as([TYPE, {name: type, message}], value);\n  };\n\n  return pair;\n};\n\n/**\n * @typedef {Array<string,any>} Record a type representation\n */\n\n/**\n * Returns an array of serialized Records.\n * @param {any} value a serializable value.\n * @param {{json?: boolean, lossy?: boolean}?} options an object with a `lossy` or `json` property that,\n *  if `true`, will not throw errors on incompatible types, and behave more\n *  like JSON stringify would behave. Symbol and Function will be discarded.\n * @returns {Record[]}\n */\n export const serialize = (value, {json, lossy} = {}) => {\n  const _ = [];\n  return serializer(!(json || lossy), !!json, new Map, _)(value), _;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}