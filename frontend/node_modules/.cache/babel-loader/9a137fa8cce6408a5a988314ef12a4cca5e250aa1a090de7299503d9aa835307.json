{"ast":null,"code":"import _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { Editor, Element, Transforms, Node } from '@seafile/slate';\nimport { PARAGRAPH, HEADERS, LIST_TYPE_ARRAY, TITLE, SUBTITLE, HEADER } from '../../constants';\nimport { generateEmptyElement, getSelectedNodeByTypes } from '../../core';\nimport { isMenuDisabled, setHeaderType } from './helpers';\nimport isHotkey from 'is-hotkey';\nimport { MAC_HOTKEYS_EVENT, WIN_HOTKEYS } from '../../constants/keyboard';\nimport { isMac } from '../../../../utils';\nvar isSelectionAtLineEnd = function isSelectionAtLineEnd(editor, path) {\n  var selection = editor.selection;\n  if (!selection) return false;\n  var isAtLineEnd = Editor.isEnd(editor, selection.anchor, path) || Editor.isEnd(editor, selection.focus, path);\n  return isAtLineEnd;\n};\nvar withHeader = function withHeader(editor) {\n  var insertBreak = editor.insertBreak,\n    insertFragment = editor.insertFragment,\n    insertText = editor.insertText;\n  var newEditor = editor;\n\n  // Rewrite insertBreak - insert paragraph when carriage return at the end of header\n  newEditor.insertBreak = function () {\n    var _Editor$nodes = Editor.nodes(newEditor, {\n        match: function match(n) {\n          if (!Element.isElement(n)) return false;\n          if (!n.type) return false;\n          if (n.type.startsWith(HEADER)) return true;\n          if (n.type === TITLE) return true;\n          if (n.type === SUBTITLE) return true;\n          return false;\n        },\n        // Matches nodes whose node.type starts with header\n        universal: true\n      }),\n      _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n      match = _Editor$nodes2[0];\n    if (!match) {\n      insertBreak();\n      return;\n    }\n    var isAtLineEnd = isSelectionAtLineEnd(editor, match[1]);\n    var nextNode = Editor.next(editor, {\n      at: match[1]\n    });\n    if (isAtLineEnd && nextNode && editor.children.length === 2) {\n      var _nextNode = _slicedToArray(nextNode, 2),\n        node = _nextNode[0],\n        path = _nextNode[1];\n      if (node && node.children[0].text === '') {\n        Transforms.select(editor, path);\n        return;\n      }\n    }\n\n    // If an empty p is inserted at the end of the line, otherwise wrap normally\n    if (isAtLineEnd) {\n      var p = generateEmptyElement(PARAGRAPH);\n      Transforms.insertNodes(newEditor, p, {\n        mode: 'highest'\n      });\n    } else {\n      insertBreak();\n    }\n  };\n  newEditor.insertFragment = function (data) {\n    var _data$, _data$$children;\n    var headerNode = getSelectedNodeByTypes(editor, HEADERS);\n    var headerText = Node.string(headerNode || {\n      children: []\n    });\n    var isSingleListItem = data.length === 1 && ((_data$ = data[0]) === null || _data$ === void 0 ? void 0 : (_data$$children = _data$.children) === null || _data$$children === void 0 ? void 0 : _data$$children.length) === 1 && LIST_TYPE_ARRAY.includes(data[0].type);\n    // Insert a list item when the header is empty, insert only the text\n    if (headerNode && headerText.length === 0 && isSingleListItem) {\n      var text = Node.string(data[0]);\n      insertText(text);\n      return;\n    }\n    return insertFragment(data);\n  };\n  newEditor.onHotKeyDown = function (event) {\n    var HOT_KEYS = isMac() ? MAC_HOTKEYS_EVENT : WIN_HOTKEYS;\n    var hotEntries = Object.entries(HOT_KEYS);\n    var isHeaderEvent = false;\n    var headerType = '';\n    for (var index = 0; index < hotEntries.length; index++) {\n      var _hotEntries$index = _slicedToArray(hotEntries[index], 2),\n        key = _hotEntries$index[0],\n        value = _hotEntries$index[1];\n      isHeaderEvent = isHotkey(value, event);\n      if (isHeaderEvent) {\n        headerType = key;\n        break;\n      }\n    }\n    if (!isHeaderEvent) return false;\n    event.preventDefault();\n    if (isMenuDisabled(newEditor)) return true;\n    setHeaderType(newEditor, headerType);\n    return true;\n  };\n  return newEditor;\n};\nexport default withHeader;","map":{"version":3,"names":["Editor","Element","Transforms","Node","PARAGRAPH","HEADERS","LIST_TYPE_ARRAY","TITLE","SUBTITLE","HEADER","generateEmptyElement","getSelectedNodeByTypes","isMenuDisabled","setHeaderType","isHotkey","MAC_HOTKEYS_EVENT","WIN_HOTKEYS","isMac","isSelectionAtLineEnd","editor","path","selection","isAtLineEnd","isEnd","anchor","focus","withHeader","insertBreak","insertFragment","insertText","newEditor","_Editor$nodes","nodes","match","n","isElement","type","startsWith","universal","_Editor$nodes2","_slicedToArray","nextNode","next","at","children","length","_nextNode","node","text","select","p","insertNodes","mode","data","_data$","_data$$children","headerNode","headerText","string","isSingleListItem","includes","onHotKeyDown","event","HOT_KEYS","hotEntries","Object","entries","isHeaderEvent","headerType","index","_hotEntries$index","key","value","preventDefault"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/plugins/header/plugin.js"],"sourcesContent":["import { Editor, Element, Transforms, Node } from '@seafile/slate';\nimport { PARAGRAPH, HEADERS, LIST_TYPE_ARRAY, TITLE, SUBTITLE, HEADER } from '../../constants';\nimport { generateEmptyElement, getSelectedNodeByTypes } from '../../core';\nimport { isMenuDisabled, setHeaderType } from './helpers';\nimport isHotkey from 'is-hotkey';\nimport { MAC_HOTKEYS_EVENT, WIN_HOTKEYS } from '../../constants/keyboard';\nimport { isMac } from '../../../../utils';\nconst isSelectionAtLineEnd = (editor, path) => {\n  const {\n    selection\n  } = editor;\n  if (!selection) return false;\n  const isAtLineEnd = Editor.isEnd(editor, selection.anchor, path) || Editor.isEnd(editor, selection.focus, path);\n  return isAtLineEnd;\n};\nconst withHeader = editor => {\n  const {\n    insertBreak,\n    insertFragment,\n    insertText\n  } = editor;\n  const newEditor = editor;\n\n  // Rewrite insertBreak - insert paragraph when carriage return at the end of header\n  newEditor.insertBreak = () => {\n    const [match] = Editor.nodes(newEditor, {\n      match: n => {\n        if (!Element.isElement(n)) return false;\n        if (!n.type) return false;\n        if (n.type.startsWith(HEADER)) return true;\n        if (n.type === TITLE) return true;\n        if (n.type === SUBTITLE) return true;\n        return false;\n      },\n      // Matches nodes whose node.type starts with header\n      universal: true\n    });\n    if (!match) {\n      insertBreak();\n      return;\n    }\n    const isAtLineEnd = isSelectionAtLineEnd(editor, match[1]);\n    const nextNode = Editor.next(editor, {\n      at: match[1]\n    });\n    if (isAtLineEnd && nextNode && editor.children.length === 2) {\n      const [node, path] = nextNode;\n      if (node && node.children[0].text === '') {\n        Transforms.select(editor, path);\n        return;\n      }\n    }\n\n    // If an empty p is inserted at the end of the line, otherwise wrap normally\n    if (isAtLineEnd) {\n      const p = generateEmptyElement(PARAGRAPH);\n      Transforms.insertNodes(newEditor, p, {\n        mode: 'highest'\n      });\n    } else {\n      insertBreak();\n    }\n  };\n  newEditor.insertFragment = data => {\n    var _data$, _data$$children;\n    const headerNode = getSelectedNodeByTypes(editor, HEADERS);\n    const headerText = Node.string(headerNode || {\n      children: []\n    });\n    const isSingleListItem = data.length === 1 && ((_data$ = data[0]) === null || _data$ === void 0 ? void 0 : (_data$$children = _data$.children) === null || _data$$children === void 0 ? void 0 : _data$$children.length) === 1 && LIST_TYPE_ARRAY.includes(data[0].type);\n    // Insert a list item when the header is empty, insert only the text\n    if (headerNode && headerText.length === 0 && isSingleListItem) {\n      const text = Node.string(data[0]);\n      insertText(text);\n      return;\n    }\n    return insertFragment(data);\n  };\n  newEditor.onHotKeyDown = event => {\n    const HOT_KEYS = isMac() ? MAC_HOTKEYS_EVENT : WIN_HOTKEYS;\n    const hotEntries = Object.entries(HOT_KEYS);\n    let isHeaderEvent = false;\n    let headerType = '';\n    for (let index = 0; index < hotEntries.length; index++) {\n      const [key, value] = hotEntries[index];\n      isHeaderEvent = isHotkey(value, event);\n      if (isHeaderEvent) {\n        headerType = key;\n        break;\n      }\n    }\n    if (!isHeaderEvent) return false;\n    event.preventDefault();\n    if (isMenuDisabled(newEditor)) return true;\n    setHeaderType(newEditor, headerType);\n    return true;\n  };\n  return newEditor;\n};\nexport default withHeader;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}