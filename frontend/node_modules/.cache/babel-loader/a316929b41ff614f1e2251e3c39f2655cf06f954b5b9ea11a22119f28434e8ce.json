{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _slate = require(\"slate\");\nvar _core = require(\"../../core\");\nvar _elementTypes = require(\"../../constants/element-types\");\nvar _helpers = require(\"./helpers\");\nvar _constant = require(\"../list/constant\");\nvar getCurrentLineEntry = function getCurrentLineEntry(editor) {\n  // blockquote > paragraph\n  // blockquote > check_list_item\n  // blockquote > list > list_item > paragraph\n  var _slate$Editor$nodes = _slate.Editor.nodes(editor, {\n      match: function match(n) {\n        return _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n);\n      },\n      mode: 'lowest'\n    }),\n    _slate$Editor$nodes2 = _slicedToArray(_slate$Editor$nodes, 1),\n    currentLineEntry = _slate$Editor$nodes2[0];\n  if (!currentLineEntry) return null;\n  var type = currentLineEntry[0].type;\n  if (type === _elementTypes.PARAGRAPH) {\n    var parentPath = _slate.Path.parent(currentLineEntry[1]);\n    if (parentPath.length === 1) return currentLineEntry; // top level element\n    var _slate$Editor$nodes3 = _slate.Editor.nodes(editor, {\n        match: function match(n) {\n          return _slate.Element.isElement(n) && _constant.LIST_TYPES.includes(n.type);\n        },\n        mode: 'highest'\n      }),\n      _slate$Editor$nodes4 = _slicedToArray(_slate$Editor$nodes3, 1),\n      listEntry = _slate$Editor$nodes4[0];\n    return listEntry;\n  }\n  return currentLineEntry;\n};\nvar withBlockquote = function withBlockquote(editor) {\n  var insertBreak = editor.insertBreak,\n    deleteBackward = editor.deleteBackward,\n    insertFragment = editor.insertFragment;\n  var newEditor = editor;\n  newEditor.insertBreak = function () {\n    var selection = editor.selection;\n    if (selection == null) return insertBreak();\n    var _slate$Editor$nodes5 = _slate.Editor.nodes(editor, {\n        match: function match(n) {\n          return _slate.Element.isElement(n) && n.type === _elementTypes.BLOCKQUOTE;\n        },\n        universal: true\n      }),\n      _slate$Editor$nodes6 = _slicedToArray(_slate$Editor$nodes5, 1),\n      blockquoteEntry = _slate$Editor$nodes6[0];\n    if (!blockquoteEntry) return insertBreak();\n\n    // blockquote > paragraph\n    // blockquote > check_list_item\n    // blockquote > list > list_item\n    var currentLineEntry = getCurrentLineEntry(newEditor);\n    if (!currentLineEntry) return insertBreak();\n\n    // handle this case by list plugin\n    var currentLineType = currentLineEntry[0].type;\n    if (_constant.LIST_TYPES.includes(currentLineType) || currentLineType === _elementTypes.CHECK_LIST_ITEM) {\n      insertBreak();\n      return;\n    }\n    var isEmptyLine = _slate.Node.string(currentLineEntry[0]).length === 0;\n    var isFirst = (0, _core.isFirstChild)(blockquoteEntry, currentLineEntry[1]);\n    if (isEmptyLine && isFirst && blockquoteEntry[0].children.length === 1) {\n      _slate.Transforms.unwrapNodes(editor, {\n        mode: 'highest',\n        match: function match(n) {\n          return _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n);\n        }\n      });\n      return;\n    }\n    var isLast = (0, _core.isLastChild)(blockquoteEntry, currentLineEntry[1]);\n    if (isEmptyLine && isLast) {\n      var nextPath = _slate.Path.next(blockquoteEntry[1]);\n      _slate.Transforms.moveNodes(newEditor, {\n        at: currentLineEntry[1],\n        to: nextPath\n      });\n      return;\n    }\n\n    // In other cases, insert a newline\n    _slate.Transforms.insertNodes(newEditor, (0, _core.generateDefaultParagraph)(), {\n      at: newEditor.selection,\n      select: true\n    });\n  };\n  newEditor.deleteBackward = function (unit) {\n    var selection = newEditor.selection;\n    if (selection === null) {\n      deleteBackward(unit);\n      return;\n    }\n    var _slate$Editor$nodes7 = _slate.Editor.nodes(editor, {\n        match: function match(n) {\n          return _slate.Element.isElement(n) && n.type === _elementTypes.BLOCKQUOTE;\n        },\n        universal: true\n      }),\n      _slate$Editor$nodes8 = _slicedToArray(_slate$Editor$nodes7, 1),\n      blockquoteEntry = _slate$Editor$nodes8[0];\n    if (!blockquoteEntry) return deleteBackward(unit);\n\n    // blockquote > paragraph\n    // blockquote > check_list_item\n    // blockquote > list > list_item\n    var currentLineEntry = getCurrentLineEntry(editor);\n    if (!currentLineEntry) return deleteBackward(unit);\n\n    // handle this case by list plugin\n    var currentLineType = currentLineEntry[0].type;\n    if (_constant.LIST_TYPES.includes(currentLineType) || currentLineType === _elementTypes.CHECK_LIST_ITEM) {\n      deleteBackward(unit);\n      return;\n    }\n    var isEmptyLine = _slate.Node.string(currentLineEntry[0]).length === 0;\n    var isFirst = (0, _core.isFirstChild)(blockquoteEntry, currentLineEntry[1]);\n    if (isEmptyLine && isFirst && blockquoteEntry[0].children.length === 1) {\n      (0, _helpers.setBlockQuoteType)(editor, _elementTypes.PARAGRAPH);\n      return;\n    }\n    deleteBackward(unit);\n  };\n  newEditor.insertFragment = function (fragment) {\n    var selection = editor.selection;\n    if (selection == null) return insertFragment(fragment);\n    var _slate$Editor$nodes9 = _slate.Editor.nodes(editor, {\n        match: function match(n) {\n          return _slate.Element.isElement(n) && n.type === _elementTypes.BLOCKQUOTE;\n        },\n        universal: true\n      }),\n      _slate$Editor$nodes10 = _slicedToArray(_slate$Editor$nodes9, 1),\n      blockquoteEntry = _slate$Editor$nodes10[0];\n    if (!blockquoteEntry) return insertFragment(fragment);\n    var firstChild = fragment[0];\n    if (fragment.length === 1 && firstChild.type === _elementTypes.TABLE) {\n      // const nodeEntry = Editor.nodes(newEditor, { mode: 'highest' });\n      var nextPath = _slate.Path.next(blockquoteEntry[1]);\n      _slate.Transforms.insertNodes(newEditor, fragment, {\n        at: nextPath\n      });\n      return;\n    }\n    var insertData = fragment.map(function (node) {\n      if (node.type === _elementTypes.TABLE) {\n        var text = _slate.Node.string(node);\n        return (0, _core.generateElement)(_elementTypes.PARAGRAPH, {\n          childrenOrText: text\n        });\n      }\n      return node;\n    });\n    return insertFragment(insertData);\n  };\n  return newEditor;\n};\nvar _default = exports.default = withBlockquote;","map":{"version":3,"names":["_slicedToArray","require","default","Object","defineProperty","exports","value","_slate","_core","_elementTypes","_helpers","_constant","getCurrentLineEntry","editor","_slate$Editor$nodes","Editor","nodes","match","n","Element","isElement","isBlock","mode","_slate$Editor$nodes2","currentLineEntry","type","PARAGRAPH","parentPath","Path","parent","length","_slate$Editor$nodes3","LIST_TYPES","includes","_slate$Editor$nodes4","listEntry","withBlockquote","insertBreak","deleteBackward","insertFragment","newEditor","selection","_slate$Editor$nodes5","BLOCKQUOTE","universal","_slate$Editor$nodes6","blockquoteEntry","currentLineType","CHECK_LIST_ITEM","isEmptyLine","Node","string","isFirst","isFirstChild","children","Transforms","unwrapNodes","isLast","isLastChild","nextPath","next","moveNodes","at","to","insertNodes","generateDefaultParagraph","select","unit","_slate$Editor$nodes7","_slate$Editor$nodes8","setBlockQuoteType","fragment","_slate$Editor$nodes9","_slate$Editor$nodes10","firstChild","TABLE","insertData","map","node","text","generateElement","childrenOrText","_default"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/seafile-editor/dist/extension/plugins/blockquote/plugin.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _slate = require(\"slate\");\nvar _core = require(\"../../core\");\nvar _elementTypes = require(\"../../constants/element-types\");\nvar _helpers = require(\"./helpers\");\nvar _constant = require(\"../list/constant\");\nconst getCurrentLineEntry = editor => {\n  // blockquote > paragraph\n  // blockquote > check_list_item\n  // blockquote > list > list_item > paragraph\n  const [currentLineEntry] = _slate.Editor.nodes(editor, {\n    match: n => _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n),\n    mode: 'lowest'\n  });\n  if (!currentLineEntry) return null;\n  const type = currentLineEntry[0].type;\n  if (type === _elementTypes.PARAGRAPH) {\n    const parentPath = _slate.Path.parent(currentLineEntry[1]);\n    if (parentPath.length === 1) return currentLineEntry; // top level element\n    const [listEntry] = _slate.Editor.nodes(editor, {\n      match: n => _slate.Element.isElement(n) && _constant.LIST_TYPES.includes(n.type),\n      mode: 'highest'\n    });\n    return listEntry;\n  }\n  return currentLineEntry;\n};\nconst withBlockquote = editor => {\n  const {\n    insertBreak,\n    deleteBackward,\n    insertFragment\n  } = editor;\n  const newEditor = editor;\n  newEditor.insertBreak = () => {\n    const {\n      selection\n    } = editor;\n    if (selection == null) return insertBreak();\n    const [blockquoteEntry] = _slate.Editor.nodes(editor, {\n      match: n => _slate.Element.isElement(n) && n.type === _elementTypes.BLOCKQUOTE,\n      universal: true\n    });\n    if (!blockquoteEntry) return insertBreak();\n\n    // blockquote > paragraph\n    // blockquote > check_list_item\n    // blockquote > list > list_item\n    const currentLineEntry = getCurrentLineEntry(newEditor);\n    if (!currentLineEntry) return insertBreak();\n\n    // handle this case by list plugin\n    const currentLineType = currentLineEntry[0].type;\n    if (_constant.LIST_TYPES.includes(currentLineType) || currentLineType === _elementTypes.CHECK_LIST_ITEM) {\n      insertBreak();\n      return;\n    }\n    const isEmptyLine = _slate.Node.string(currentLineEntry[0]).length === 0;\n    const isFirst = (0, _core.isFirstChild)(blockquoteEntry, currentLineEntry[1]);\n    if (isEmptyLine && isFirst && blockquoteEntry[0].children.length === 1) {\n      _slate.Transforms.unwrapNodes(editor, {\n        mode: 'highest',\n        match: n => _slate.Element.isElement(n) && _slate.Editor.isBlock(editor, n)\n      });\n      return;\n    }\n    const isLast = (0, _core.isLastChild)(blockquoteEntry, currentLineEntry[1]);\n    if (isEmptyLine && isLast) {\n      const nextPath = _slate.Path.next(blockquoteEntry[1]);\n      _slate.Transforms.moveNodes(newEditor, {\n        at: currentLineEntry[1],\n        to: nextPath\n      });\n      return;\n    }\n\n    // In other cases, insert a newline\n    _slate.Transforms.insertNodes(newEditor, (0, _core.generateDefaultParagraph)(), {\n      at: newEditor.selection,\n      select: true\n    });\n  };\n  newEditor.deleteBackward = unit => {\n    const {\n      selection\n    } = newEditor;\n    if (selection === null) {\n      deleteBackward(unit);\n      return;\n    }\n    const [blockquoteEntry] = _slate.Editor.nodes(editor, {\n      match: n => _slate.Element.isElement(n) && n.type === _elementTypes.BLOCKQUOTE,\n      universal: true\n    });\n    if (!blockquoteEntry) return deleteBackward(unit);\n\n    // blockquote > paragraph\n    // blockquote > check_list_item\n    // blockquote > list > list_item\n    const currentLineEntry = getCurrentLineEntry(editor);\n    if (!currentLineEntry) return deleteBackward(unit);\n\n    // handle this case by list plugin\n    const currentLineType = currentLineEntry[0].type;\n    if (_constant.LIST_TYPES.includes(currentLineType) || currentLineType === _elementTypes.CHECK_LIST_ITEM) {\n      deleteBackward(unit);\n      return;\n    }\n    const isEmptyLine = _slate.Node.string(currentLineEntry[0]).length === 0;\n    const isFirst = (0, _core.isFirstChild)(blockquoteEntry, currentLineEntry[1]);\n    if (isEmptyLine && isFirst && blockquoteEntry[0].children.length === 1) {\n      (0, _helpers.setBlockQuoteType)(editor, _elementTypes.PARAGRAPH);\n      return;\n    }\n    deleteBackward(unit);\n  };\n  newEditor.insertFragment = fragment => {\n    const {\n      selection\n    } = editor;\n    if (selection == null) return insertFragment(fragment);\n    const [blockquoteEntry] = _slate.Editor.nodes(editor, {\n      match: n => _slate.Element.isElement(n) && n.type === _elementTypes.BLOCKQUOTE,\n      universal: true\n    });\n    if (!blockquoteEntry) return insertFragment(fragment);\n    const firstChild = fragment[0];\n    if (fragment.length === 1 && firstChild.type === _elementTypes.TABLE) {\n      // const nodeEntry = Editor.nodes(newEditor, { mode: 'highest' });\n      const nextPath = _slate.Path.next(blockquoteEntry[1]);\n      _slate.Transforms.insertNodes(newEditor, fragment, {\n        at: nextPath\n      });\n      return;\n    }\n    const insertData = fragment.map(node => {\n      if (node.type === _elementTypes.TABLE) {\n        const text = _slate.Node.string(node);\n        return (0, _core.generateElement)(_elementTypes.PARAGRAPH, {\n          childrenOrText: text\n        });\n      }\n      return node;\n    });\n    return insertFragment(insertData);\n  };\n  return newEditor;\n};\nvar _default = exports.default = withBlockquote;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}