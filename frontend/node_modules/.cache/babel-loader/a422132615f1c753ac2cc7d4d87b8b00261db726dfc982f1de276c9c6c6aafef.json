{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _slicedToArray = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _slate = require(\"slate\");\nvar _isHotkey = _interopRequireDefault(require(\"is-hotkey\"));\nvar _helper = require(\"./helper\");\nvar _constants = require(\"../../constants\");\nvar _setEventTransfer = _interopRequireDefault(require(\"../../../containers/custom/set-event-transfer\"));\nvar _elementTypes = require(\"../../constants/element-types\");\nvar _tableOperations = require(\"./table-operations\");\nvar _getEventTransfer = _interopRequireDefault(require(\"../../../containers/custom/get-event-transfer\"));\nvar _eventBus = _interopRequireDefault(require(\"../../../utils/event-bus\"));\nvar _eventTypes = require(\"../../../constants/event-types\");\nvar _core = require(\"../../core\");\n/**\n * @param {Editor} editor\n */\nvar withTable = function withTable(editor) {\n  var insertBreak = editor.insertBreak,\n    deleteBackward = editor.deleteBackward,\n    onHotKeyDown = editor.onHotKeyDown,\n    insertText = editor.insertText,\n    deleteForward = editor.deleteForward,\n    onCopy = editor.onCopy,\n    insertData = editor.insertData,\n    insertFragment = editor.insertFragment,\n    normalizeNode = editor.normalizeNode;\n  var newEditor = editor;\n  newEditor.insertBreak = function () {\n    var isTableActive = (0, _helper.isInTable)(newEditor);\n    if (!editor.selection || !isTableActive) return insertBreak && insertBreak();\n    (0, _tableOperations.insertRow)(newEditor);\n    var _slate$Editor$nodes = _slate.Editor.nodes(newEditor, {\n        match: function match(n) {\n          return _slate.Element.isElement(n) && n.type === _elementTypes.TABLE_ROW;\n        }\n      }),\n      _slate$Editor$nodes2 = _slicedToArray(_slate$Editor$nodes, 1),\n      nodeEntry = _slate$Editor$nodes2[0];\n    var path = _slate.Path.next(nodeEntry[1]);\n    var firstCellPath = path.concat(0);\n    _slate.Transforms.select(newEditor, firstCellPath);\n    return;\n  };\n  newEditor.insertText = function (text) {\n    var isTableActive = (0, _helper.isInTable)(newEditor);\n    if (!isTableActive) return insertText && insertText(text);\n    var selection = newEditor.selection;\n    // set element by markdown shortcut;\n    if (text === ' ' && selection && _slate.Range.isCollapsed(selection)) {\n      insertText(text);\n      return;\n    }\n    return insertText(text);\n  };\n  newEditor.insertData = function (data) {\n    var isTableActive = (0, _helper.isInTable)(newEditor);\n    if (!isTableActive) return insertData && insertData(data);\n    var _ref2 = (0, _getEventTransfer.default)(data),\n      type = _ref2.type;\n    if (type === 'file') {\n      return insertData(data);\n    }\n    return (0, _helper.pasteContentIntoTable)(newEditor, data);\n  };\n  newEditor.insertFragment = function (fragment) {\n    var isTableActive = (0, _helper.isInTable)(newEditor);\n    if (!isTableActive) return insertFragment && insertFragment(fragment);\n    if (!Array.isArray(fragment)) return;\n    var firstChild = fragment[0];\n    if (fragment.length === 1 && firstChild.type === _elementTypes.TABLE) {\n      var _ref3 = (0, _helper.getTableFocusingInfos)(editor),\n        tableEntry = _ref3.tableEntry,\n        rowEntry = _ref3.rowEntry;\n      var selectedInfo = (0, _helper.getSelectGrid)(editor);\n      if (!selectedInfo) {\n        var tableCellEntry = (0, _core.getSelectedNodeEntryByType)(editor, _elementTypes.TABLE_CELL);\n        if (!tableCellEntry) return;\n        var _tableCellEntry = _slicedToArray(tableCellEntry, 2),\n          path = _tableCellEntry[1];\n        var _startColIndex = path.pop();\n        var _startRowIndex = path.pop();\n        selectedInfo = {\n          startRowIndex: _startRowIndex,\n          startColIndex: _startColIndex\n        };\n      }\n      var _selectedInfo = selectedInfo,\n        startRowIndex = _selectedInfo.startRowIndex,\n        startColIndex = _selectedInfo.startColIndex;\n      var _tableEntry = _slicedToArray(tableEntry, 2),\n        tableNode = _tableEntry[0],\n        tablePath = _tableEntry[1];\n      var _rowEntry = _slicedToArray(rowEntry, 1),\n        rowNode = _rowEntry[0];\n      var tableWidth = rowNode.children.length;\n      var tableHeight = tableNode.children.length;\n      firstChild.children.forEach(function (clipRow, clipRowIndex) {\n        // Out of table\n        if (startRowIndex + clipRowIndex >= tableHeight) return true;\n\n        // rowPath = [...tablePath, rowIndex + clipRowIndex];\n        var currentRowPath = [].concat(_toConsumableArray(tablePath), [startRowIndex + clipRowIndex]);\n        clipRow.children.forEach(function (clipCol, clipColIndex) {\n          // Out of table\n          if (startColIndex + clipColIndex >= tableWidth) return true;\n\n          // cellPath = [...rowPath, columnIndex + clipColIndex];\n          var currentCellPath = [].concat(_toConsumableArray(currentRowPath), [startColIndex + clipColIndex]);\n          var currentCellChildPath = currentCellPath.concat(0);\n          _slate.Transforms.removeNodes(editor, {\n            at: currentCellChildPath\n          });\n          var otherBlockTypes = [].concat(_toConsumableArray(_constants.HEADERS), [_elementTypes.CHECK_LIST_ITEM, _elementTypes.PARAGRAPH]);\n          var newChildren = clipCol.children.map(function (item) {\n            if (otherBlockTypes.includes(item.type)) return item.children;\n            return item;\n          }).flat();\n          _slate.Transforms.insertNodes(editor, newChildren, {\n            at: currentCellChildPath\n          });\n          return false;\n        });\n        return false;\n      });\n      return;\n    }\n    var notSupportTypes = [_elementTypes.TABLE, _elementTypes.BLOCKQUOTE, _elementTypes.UNORDERED_LIST, _elementTypes.ORDERED_LIST, _elementTypes.CODE_BLOCK];\n    var isDataValid = fragment.some(function (item) {\n      return notSupportTypes.includes(item.type);\n    });\n    if (isDataValid) {\n      var strContent = fragment.reduce(function (ret, item) {\n        return ret + _slate.Node.string(item);\n      }, '');\n      _slate.Editor.insertText(newEditor, strContent);\n      return;\n    }\n    var otherBlockTypes = [].concat(_toConsumableArray(_constants.HEADERS), [_elementTypes.CHECK_LIST_ITEM, _elementTypes.PARAGRAPH]);\n    var newChildren = fragment.map(function (item) {\n      if (otherBlockTypes.includes(item.type)) return item.children;\n      return item;\n    }).flat();\n    insertFragment(newChildren);\n  };\n  newEditor.deleteBackward = function (unit) {\n    var isTableActive = (0, _helper.isInTable)(newEditor);\n    if (!isTableActive) return deleteBackward(unit);\n    var selection = newEditor.selection;\n    // If select range,prevent to delete\n    if (!_slate.Range.isRange(selection)) return;\n    var _slate$Editor$nodes3 = _slate.Editor.nodes(editor, {\n        match: function match(node) {\n          return node.type === _elementTypes.TABLE_CELL;\n        },\n        mode: 'lowest'\n      }),\n      _slate$Editor$nodes4 = _slicedToArray(_slate$Editor$nodes3, 1),\n      tableCellEntry = _slate$Editor$nodes4[0];\n    // If delete empty cell,prevent to delete\n    var isStartOfCellText = _slate.Editor.isStart(newEditor, selection.anchor, tableCellEntry[1]);\n    if (isStartOfCellText) return;\n    return deleteBackward && deleteBackward(unit);\n  };\n  newEditor.deleteForward = function (unit) {\n    var isTableActive = (0, _helper.isInTable)(newEditor);\n    if (!isTableActive) return deleteForward(unit);\n    var selection = newEditor.selection;\n    // If select range,prevent to delete\n    if (!_slate.Range.isRange(selection)) return;\n    var _slate$Editor$nodes5 = _slate.Editor.nodes(editor, {\n        match: function match(node) {\n          return node.type === _elementTypes.TABLE_CELL;\n        },\n        mode: 'lowest'\n      }),\n      _slate$Editor$nodes6 = _slicedToArray(_slate$Editor$nodes5, 1),\n      tableCellEntry = _slate$Editor$nodes6[0];\n    // If delete empty cell,prevent to delete\n    var isEndOfCellText = _slate.Editor.isEnd(newEditor, selection.anchor, tableCellEntry[1]);\n    if (isEndOfCellText) return;\n    return deleteForward(unit);\n  };\n  newEditor.onHotKeyDown = function (event) {\n    if (!(0, _helper.isInTable)(newEditor)) return onHotKeyDown && onHotKeyDown(event);\n    if ((0, _isHotkey.default)('tab', event)) {\n      event.preventDefault();\n      var _ref4 = (0, _helper.getTableFocusingInfos)(newEditor),\n        _ref4$tableEntry = _slicedToArray(_ref4.tableEntry, 1),\n        tableNode = _ref4$tableEntry[0],\n        _ref4$rowEntry = _slicedToArray(_ref4.rowEntry, 1),\n        rowNode = _ref4$rowEntry[0],\n        columnIndex = _ref4.columnIndex,\n        rowIndex = _ref4.rowIndex;\n      var nextColumnIndex;\n      var nextRowIndex;\n      // If focus not at end of columns\n      if (columnIndex < rowNode.children.length - 1) {\n        nextColumnIndex = columnIndex + 1;\n        nextRowIndex = rowIndex;\n      } else {\n        // If focus not at end of rows,add new row\n        var shouldAddNewRow = rowIndex === tableNode.children.length - 1;\n        nextColumnIndex = 0;\n        nextRowIndex = rowIndex + 1;\n        shouldAddNewRow && (0, _tableOperations.insertRow)(newEditor, _constants.INSERT_POSITION.AFTER);\n      }\n      (0, _helper.selectCellByGrid)(newEditor, nextRowIndex, nextColumnIndex);\n      return true;\n    }\n    if ((0, _isHotkey.default)('shift+tab', event)) {\n      event.preventDefault();\n      var _ref5 = (0, _helper.getTableFocusingInfos)(newEditor),\n        _ref5$rowEntry = _slicedToArray(_ref5.rowEntry, 1),\n        _rowNode = _ref5$rowEntry[0],\n        _columnIndex = _ref5.columnIndex,\n        _rowIndex = _ref5.rowIndex;\n      var previousColumnIndex;\n      var previousRowIndex;\n      // If focus not at start of columns\n      if (_columnIndex > 0) {\n        previousRowIndex = _rowIndex;\n        previousColumnIndex = _columnIndex - 1;\n      } else {\n        // If focus not at start of rows\n        if (_rowIndex > 0) {\n          previousRowIndex = _rowIndex - 1;\n          previousColumnIndex = _rowNode.children.length - 1;\n        } else {\n          previousRowIndex = 0;\n          previousColumnIndex = 0;\n        }\n      }\n      (0, _helper.selectCellByGrid)(newEditor, previousRowIndex, previousColumnIndex);\n      return true;\n    }\n    if ((0, _isHotkey.default)('mod+enter', event) || (0, _isHotkey.default)('shift+enter', event)) {\n      event.preventDefault();\n      (0, _helper.jumpOutTableInEditor)(newEditor);\n      return true;\n    }\n    if ((0, _isHotkey.default)('mod+a', event)) {\n      event.preventDefault();\n      var _ref6 = (0, _helper.getTableFocusingInfos)(newEditor),\n        _ref6$tableEntry = _slicedToArray(_ref6.tableEntry, 1),\n        _tableNode = _ref6$tableEntry[0],\n        _ref6$rowEntry = _slicedToArray(_ref6.rowEntry, 1),\n        _rowNode2 = _ref6$rowEntry[0];\n      var rowCount = _tableNode.children.length;\n      var colCount = _rowNode2.children.length;\n      (0, _helper.selectCellByGrid)(newEditor, rowCount - 1, colCount - 1);\n      var eventBus = _eventBus.default.getInstance();\n      eventBus.dispatch(_eventTypes.INTERNAL_EVENTS.ON_SELECT_ALL_CELL, _tableNode.id);\n      return true;\n    }\n    if ((0, _isHotkey.default)('delete', event) || (0, _isHotkey.default)('backspace', event)) {\n      var selectedInfo = (0, _helper.getSelectGrid)(newEditor);\n      if (!selectedInfo) return onHotKeyDown && onHotKeyDown(event);\n      var startRowIndex = selectedInfo.startRowIndex,\n        endRowIndex = selectedInfo.endRowIndex,\n        startColIndex = selectedInfo.startColIndex,\n        endColIndex = selectedInfo.endColIndex;\n      if (startRowIndex === -1 || endRowIndex === -1 || startColIndex === -1 || endColIndex === -1) return;\n      var _ref7 = (0, _helper.getTableEntry)(newEditor),\n        _ref8 = _slicedToArray(_ref7, 1),\n        tableEntry = _ref8[0];\n      var _tableEntry2 = _slicedToArray(tableEntry, 2),\n        tablePath = _tableEntry2[1];\n      for (var _rowIndex2 = startRowIndex; _rowIndex2 <= endRowIndex; _rowIndex2++) {\n        for (var colIndex = startColIndex; colIndex <= endColIndex; colIndex++) {\n          _slate.Transforms.insertText(newEditor, '', {\n            at: tablePath.concat(_rowIndex2, colIndex)\n          });\n        }\n      }\n      return true;\n    }\n    return onHotKeyDown && onHotKeyDown(event);\n  };\n  newEditor.onCopy = function (event) {\n    if (!(0, _helper.isInTable)(newEditor)) {\n      return onCopy && onCopy(event);\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    // selected multiple cells\n    var tableNode = (0, _helper.getSelectedTableCells)(newEditor);\n    if (tableNode) {\n      (0, _setEventTransfer.default)(event, 'fragment', tableNode);\n      return true;\n    }\n    // selected only one cell\n    var tableCell = (0, _core.getSelectedNodeByType)(newEditor, _elementTypes.TABLE_CELL);\n    if (tableCell) {\n      var selection = window.getSelection();\n      var selectedText = selection.toString();\n      var range = selection.getRangeAt(0);\n      var selectedContent = range.cloneContents();\n      var div = document.createElement('div');\n      // Unwrap image wrapper\n      selectedContent.childNodes.forEach(function (node) {\n        if (node.classList && node.classList.contains('sf-image-wrapper')) {\n          var img = node.querySelector('img');\n          div.appendChild(img.cloneNode(true));\n          return;\n        }\n        div.appendChild(node.cloneNode(true));\n      });\n      (0, _setEventTransfer.default)(event, 'text', selectedText);\n      (0, _setEventTransfer.default)(event, 'html', div.innerHTML.toString());\n      return true;\n    }\n    return false;\n  };\n  newEditor.normalizeNode = function (_ref) {\n    var _ref9 = _slicedToArray(_ref, 2),\n      node = _ref9[0],\n      path = _ref9[1];\n    if (node.type === _elementTypes.TABLE) {\n      var isLast = (0, _core.isLastNode)(newEditor, node);\n      if (isLast) {\n        var paragraph = (0, _core.generateEmptyElement)(_elementTypes.PARAGRAPH);\n        _slate.Transforms.insertNodes(newEditor, paragraph, {\n          at: [path[0] + 1]\n        });\n      }\n      var isFirst = (0, _core.isFirstNode)(newEditor, node);\n      if (isFirst) {\n        var _paragraph = (0, _core.generateEmptyElement)(_elementTypes.PARAGRAPH);\n        _slate.Transforms.insertNodes(newEditor, _paragraph, {\n          at: [path[0]]\n        });\n      }\n    }\n    if (node.type === _elementTypes.TABLE_ROW) {\n      var parentEntry = _slate.Editor.parent(editor, path);\n      if ((parentEntry === null || parentEntry === void 0 ? void 0 : parentEntry[0].type) !== _elementTypes.TABLE) {\n        (0, _slate.unwrapNodes)(editor, {\n          at: path\n        });\n        return;\n      }\n    }\n    if (node.type === _elementTypes.TABLE_CELL) {\n      var _parentEntry = _slate.Editor.parent(editor, path);\n      if ((_parentEntry === null || _parentEntry === void 0 ? void 0 : _parentEntry[0].type) !== _elementTypes.TABLE_ROW) {\n        (0, _slate.unwrapNodes)(editor, {\n          at: path\n        });\n        return;\n      }\n    }\n    return normalizeNode([node, path]);\n  };\n  return newEditor;\n};\nvar _default = exports.default = withTable;","map":{"version":3,"names":["_toConsumableArray","require","default","_slicedToArray","_interopRequireDefault","Object","defineProperty","exports","value","_slate","_isHotkey","_helper","_constants","_setEventTransfer","_elementTypes","_tableOperations","_getEventTransfer","_eventBus","_eventTypes","_core","withTable","editor","insertBreak","deleteBackward","onHotKeyDown","insertText","deleteForward","onCopy","insertData","insertFragment","normalizeNode","newEditor","isTableActive","isInTable","selection","insertRow","_slate$Editor$nodes","Editor","nodes","match","n","Element","isElement","type","TABLE_ROW","_slate$Editor$nodes2","nodeEntry","path","Path","next","firstCellPath","concat","Transforms","select","text","Range","isCollapsed","data","_ref2","pasteContentIntoTable","fragment","Array","isArray","firstChild","length","TABLE","_ref3","getTableFocusingInfos","tableEntry","rowEntry","selectedInfo","getSelectGrid","tableCellEntry","getSelectedNodeEntryByType","TABLE_CELL","_tableCellEntry","startColIndex","pop","startRowIndex","_selectedInfo","_tableEntry","tableNode","tablePath","_rowEntry","rowNode","tableWidth","children","tableHeight","forEach","clipRow","clipRowIndex","currentRowPath","clipCol","clipColIndex","currentCellPath","currentCellChildPath","removeNodes","at","otherBlockTypes","HEADERS","CHECK_LIST_ITEM","PARAGRAPH","newChildren","map","item","includes","flat","insertNodes","notSupportTypes","BLOCKQUOTE","UNORDERED_LIST","ORDERED_LIST","CODE_BLOCK","isDataValid","some","strContent","reduce","ret","Node","string","unit","isRange","_slate$Editor$nodes3","node","mode","_slate$Editor$nodes4","isStartOfCellText","isStart","anchor","_slate$Editor$nodes5","_slate$Editor$nodes6","isEndOfCellText","isEnd","event","preventDefault","_ref4","_ref4$tableEntry","_ref4$rowEntry","columnIndex","rowIndex","nextColumnIndex","nextRowIndex","shouldAddNewRow","INSERT_POSITION","AFTER","selectCellByGrid","_ref5","_ref5$rowEntry","previousColumnIndex","previousRowIndex","jumpOutTableInEditor","_ref6","_ref6$tableEntry","_ref6$rowEntry","rowCount","colCount","eventBus","getInstance","dispatch","INTERNAL_EVENTS","ON_SELECT_ALL_CELL","id","endRowIndex","endColIndex","_ref7","getTableEntry","_ref8","_tableEntry2","colIndex","stopPropagation","getSelectedTableCells","tableCell","getSelectedNodeByType","window","getSelection","selectedText","toString","range","getRangeAt","selectedContent","cloneContents","div","document","createElement","childNodes","classList","contains","img","querySelector","appendChild","cloneNode","innerHTML","_ref","_ref9","isLast","isLastNode","paragraph","generateEmptyElement","isFirst","isFirstNode","parentEntry","parent","unwrapNodes","_default"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/seafile-editor/dist/extension/plugins/table/plugin.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _slate = require(\"slate\");\nvar _isHotkey = _interopRequireDefault(require(\"is-hotkey\"));\nvar _helper = require(\"./helper\");\nvar _constants = require(\"../../constants\");\nvar _setEventTransfer = _interopRequireDefault(require(\"../../../containers/custom/set-event-transfer\"));\nvar _elementTypes = require(\"../../constants/element-types\");\nvar _tableOperations = require(\"./table-operations\");\nvar _getEventTransfer = _interopRequireDefault(require(\"../../../containers/custom/get-event-transfer\"));\nvar _eventBus = _interopRequireDefault(require(\"../../../utils/event-bus\"));\nvar _eventTypes = require(\"../../../constants/event-types\");\nvar _core = require(\"../../core\");\n/**\n * @param {Editor} editor\n */\nconst withTable = editor => {\n  const {\n    insertBreak,\n    deleteBackward,\n    onHotKeyDown,\n    insertText,\n    deleteForward,\n    onCopy,\n    insertData,\n    insertFragment,\n    normalizeNode\n  } = editor;\n  const newEditor = editor;\n  newEditor.insertBreak = () => {\n    const isTableActive = (0, _helper.isInTable)(newEditor);\n    if (!editor.selection || !isTableActive) return insertBreak && insertBreak();\n    (0, _tableOperations.insertRow)(newEditor);\n    const [nodeEntry] = _slate.Editor.nodes(newEditor, {\n      match: n => _slate.Element.isElement(n) && n.type === _elementTypes.TABLE_ROW\n    });\n    const path = _slate.Path.next(nodeEntry[1]);\n    const firstCellPath = path.concat(0);\n    _slate.Transforms.select(newEditor, firstCellPath);\n    return;\n  };\n  newEditor.insertText = text => {\n    const isTableActive = (0, _helper.isInTable)(newEditor);\n    if (!isTableActive) return insertText && insertText(text);\n    const {\n      selection\n    } = newEditor;\n    // set element by markdown shortcut;\n    if (text === ' ' && selection && _slate.Range.isCollapsed(selection)) {\n      insertText(text);\n      return;\n    }\n    return insertText(text);\n  };\n  newEditor.insertData = data => {\n    const isTableActive = (0, _helper.isInTable)(newEditor);\n    if (!isTableActive) return insertData && insertData(data);\n    const {\n      type\n    } = (0, _getEventTransfer.default)(data);\n    if (type === 'file') {\n      return insertData(data);\n    }\n    return (0, _helper.pasteContentIntoTable)(newEditor, data);\n  };\n  newEditor.insertFragment = fragment => {\n    const isTableActive = (0, _helper.isInTable)(newEditor);\n    if (!isTableActive) return insertFragment && insertFragment(fragment);\n    if (!Array.isArray(fragment)) return;\n    const firstChild = fragment[0];\n    if (fragment.length === 1 && firstChild.type === _elementTypes.TABLE) {\n      const {\n        tableEntry,\n        rowEntry\n      } = (0, _helper.getTableFocusingInfos)(editor);\n      let selectedInfo = (0, _helper.getSelectGrid)(editor);\n      if (!selectedInfo) {\n        const tableCellEntry = (0, _core.getSelectedNodeEntryByType)(editor, _elementTypes.TABLE_CELL);\n        if (!tableCellEntry) return;\n        const [, path] = tableCellEntry;\n        const startColIndex = path.pop();\n        const startRowIndex = path.pop();\n        selectedInfo = {\n          startRowIndex,\n          startColIndex\n        };\n      }\n      const {\n        startRowIndex,\n        startColIndex\n      } = selectedInfo;\n      const [tableNode, tablePath] = tableEntry;\n      const [rowNode] = rowEntry;\n      const tableWidth = rowNode.children.length;\n      const tableHeight = tableNode.children.length;\n      firstChild.children.forEach((clipRow, clipRowIndex) => {\n        // Out of table\n        if (startRowIndex + clipRowIndex >= tableHeight) return true;\n\n        // rowPath = [...tablePath, rowIndex + clipRowIndex];\n        const currentRowPath = [...tablePath, startRowIndex + clipRowIndex];\n        clipRow.children.forEach((clipCol, clipColIndex) => {\n          // Out of table\n          if (startColIndex + clipColIndex >= tableWidth) return true;\n\n          // cellPath = [...rowPath, columnIndex + clipColIndex];\n          const currentCellPath = [...currentRowPath, startColIndex + clipColIndex];\n          const currentCellChildPath = currentCellPath.concat(0);\n          _slate.Transforms.removeNodes(editor, {\n            at: currentCellChildPath\n          });\n          const otherBlockTypes = [..._constants.HEADERS, _elementTypes.CHECK_LIST_ITEM, _elementTypes.PARAGRAPH];\n          const newChildren = clipCol.children.map(item => {\n            if (otherBlockTypes.includes(item.type)) return item.children;\n            return item;\n          }).flat();\n          _slate.Transforms.insertNodes(editor, newChildren, {\n            at: currentCellChildPath\n          });\n          return false;\n        });\n        return false;\n      });\n      return;\n    }\n    const notSupportTypes = [_elementTypes.TABLE, _elementTypes.BLOCKQUOTE, _elementTypes.UNORDERED_LIST, _elementTypes.ORDERED_LIST, _elementTypes.CODE_BLOCK];\n    const isDataValid = fragment.some(item => notSupportTypes.includes(item.type));\n    if (isDataValid) {\n      const strContent = fragment.reduce((ret, item) => {\n        return ret + _slate.Node.string(item);\n      }, '');\n      _slate.Editor.insertText(newEditor, strContent);\n      return;\n    }\n    const otherBlockTypes = [..._constants.HEADERS, _elementTypes.CHECK_LIST_ITEM, _elementTypes.PARAGRAPH];\n    const newChildren = fragment.map(item => {\n      if (otherBlockTypes.includes(item.type)) return item.children;\n      return item;\n    }).flat();\n    insertFragment(newChildren);\n  };\n  newEditor.deleteBackward = unit => {\n    const isTableActive = (0, _helper.isInTable)(newEditor);\n    if (!isTableActive) return deleteBackward(unit);\n    const {\n      selection\n    } = newEditor;\n    // If select range,prevent to delete\n    if (!_slate.Range.isRange(selection)) return;\n    const [tableCellEntry] = _slate.Editor.nodes(editor, {\n      match: node => node.type === _elementTypes.TABLE_CELL,\n      mode: 'lowest'\n    });\n    // If delete empty cell,prevent to delete\n    const isStartOfCellText = _slate.Editor.isStart(newEditor, selection.anchor, tableCellEntry[1]);\n    if (isStartOfCellText) return;\n    return deleteBackward && deleteBackward(unit);\n  };\n  newEditor.deleteForward = unit => {\n    const isTableActive = (0, _helper.isInTable)(newEditor);\n    if (!isTableActive) return deleteForward(unit);\n    const {\n      selection\n    } = newEditor;\n    // If select range,prevent to delete\n    if (!_slate.Range.isRange(selection)) return;\n    const [tableCellEntry] = _slate.Editor.nodes(editor, {\n      match: node => node.type === _elementTypes.TABLE_CELL,\n      mode: 'lowest'\n    });\n    // If delete empty cell,prevent to delete\n    const isEndOfCellText = _slate.Editor.isEnd(newEditor, selection.anchor, tableCellEntry[1]);\n    if (isEndOfCellText) return;\n    return deleteForward(unit);\n  };\n  newEditor.onHotKeyDown = event => {\n    if (!(0, _helper.isInTable)(newEditor)) return onHotKeyDown && onHotKeyDown(event);\n    if ((0, _isHotkey.default)('tab', event)) {\n      event.preventDefault();\n      const {\n        tableEntry: [tableNode],\n        rowEntry: [rowNode],\n        columnIndex,\n        rowIndex\n      } = (0, _helper.getTableFocusingInfos)(newEditor);\n      let nextColumnIndex;\n      let nextRowIndex;\n      // If focus not at end of columns\n      if (columnIndex < rowNode.children.length - 1) {\n        nextColumnIndex = columnIndex + 1;\n        nextRowIndex = rowIndex;\n      } else {\n        // If focus not at end of rows,add new row\n        const shouldAddNewRow = rowIndex === tableNode.children.length - 1;\n        nextColumnIndex = 0;\n        nextRowIndex = rowIndex + 1;\n        shouldAddNewRow && (0, _tableOperations.insertRow)(newEditor, _constants.INSERT_POSITION.AFTER);\n      }\n      (0, _helper.selectCellByGrid)(newEditor, nextRowIndex, nextColumnIndex);\n      return true;\n    }\n    if ((0, _isHotkey.default)('shift+tab', event)) {\n      event.preventDefault();\n      const {\n        rowEntry: [rowNode],\n        columnIndex,\n        rowIndex\n      } = (0, _helper.getTableFocusingInfos)(newEditor);\n      let previousColumnIndex;\n      let previousRowIndex;\n      // If focus not at start of columns\n      if (columnIndex > 0) {\n        previousRowIndex = rowIndex;\n        previousColumnIndex = columnIndex - 1;\n      } else {\n        // If focus not at start of rows\n        if (rowIndex > 0) {\n          previousRowIndex = rowIndex - 1;\n          previousColumnIndex = rowNode.children.length - 1;\n        } else {\n          previousRowIndex = 0;\n          previousColumnIndex = 0;\n        }\n      }\n      (0, _helper.selectCellByGrid)(newEditor, previousRowIndex, previousColumnIndex);\n      return true;\n    }\n    if ((0, _isHotkey.default)('mod+enter', event) || (0, _isHotkey.default)('shift+enter', event)) {\n      event.preventDefault();\n      (0, _helper.jumpOutTableInEditor)(newEditor);\n      return true;\n    }\n    if ((0, _isHotkey.default)('mod+a', event)) {\n      event.preventDefault();\n      const {\n        tableEntry: [tableNode],\n        rowEntry: [rowNode]\n      } = (0, _helper.getTableFocusingInfos)(newEditor);\n      const rowCount = tableNode.children.length;\n      const colCount = rowNode.children.length;\n      (0, _helper.selectCellByGrid)(newEditor, rowCount - 1, colCount - 1);\n      const eventBus = _eventBus.default.getInstance();\n      eventBus.dispatch(_eventTypes.INTERNAL_EVENTS.ON_SELECT_ALL_CELL, tableNode.id);\n      return true;\n    }\n    if ((0, _isHotkey.default)('delete', event) || (0, _isHotkey.default)('backspace', event)) {\n      const selectedInfo = (0, _helper.getSelectGrid)(newEditor);\n      if (!selectedInfo) return onHotKeyDown && onHotKeyDown(event);\n      const {\n        startRowIndex,\n        endRowIndex,\n        startColIndex,\n        endColIndex\n      } = selectedInfo;\n      if (startRowIndex === -1 || endRowIndex === -1 || startColIndex === -1 || endColIndex === -1) return;\n      const [tableEntry] = (0, _helper.getTableEntry)(newEditor);\n      const [, tablePath] = tableEntry;\n      for (let rowIndex = startRowIndex; rowIndex <= endRowIndex; rowIndex++) {\n        for (let colIndex = startColIndex; colIndex <= endColIndex; colIndex++) {\n          _slate.Transforms.insertText(newEditor, '', {\n            at: tablePath.concat(rowIndex, colIndex)\n          });\n        }\n      }\n      return true;\n    }\n    return onHotKeyDown && onHotKeyDown(event);\n  };\n  newEditor.onCopy = event => {\n    if (!(0, _helper.isInTable)(newEditor)) {\n      return onCopy && onCopy(event);\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    // selected multiple cells\n    const tableNode = (0, _helper.getSelectedTableCells)(newEditor);\n    if (tableNode) {\n      (0, _setEventTransfer.default)(event, 'fragment', tableNode);\n      return true;\n    }\n    // selected only one cell\n    const tableCell = (0, _core.getSelectedNodeByType)(newEditor, _elementTypes.TABLE_CELL);\n    if (tableCell) {\n      const selection = window.getSelection();\n      const selectedText = selection.toString();\n      const range = selection.getRangeAt(0);\n      const selectedContent = range.cloneContents();\n      const div = document.createElement('div');\n      // Unwrap image wrapper\n      selectedContent.childNodes.forEach(node => {\n        if (node.classList && node.classList.contains('sf-image-wrapper')) {\n          const img = node.querySelector('img');\n          div.appendChild(img.cloneNode(true));\n          return;\n        }\n        div.appendChild(node.cloneNode(true));\n      });\n      (0, _setEventTransfer.default)(event, 'text', selectedText);\n      (0, _setEventTransfer.default)(event, 'html', div.innerHTML.toString());\n      return true;\n    }\n    return false;\n  };\n  newEditor.normalizeNode = _ref => {\n    let [node, path] = _ref;\n    if (node.type === _elementTypes.TABLE) {\n      const isLast = (0, _core.isLastNode)(newEditor, node);\n      if (isLast) {\n        const paragraph = (0, _core.generateEmptyElement)(_elementTypes.PARAGRAPH);\n        _slate.Transforms.insertNodes(newEditor, paragraph, {\n          at: [path[0] + 1]\n        });\n      }\n      const isFirst = (0, _core.isFirstNode)(newEditor, node);\n      if (isFirst) {\n        const paragraph = (0, _core.generateEmptyElement)(_elementTypes.PARAGRAPH);\n        _slate.Transforms.insertNodes(newEditor, paragraph, {\n          at: [path[0]]\n        });\n      }\n    }\n    if (node.type === _elementTypes.TABLE_ROW) {\n      const parentEntry = _slate.Editor.parent(editor, path);\n      if ((parentEntry === null || parentEntry === void 0 ? void 0 : parentEntry[0].type) !== _elementTypes.TABLE) {\n        (0, _slate.unwrapNodes)(editor, {\n          at: path\n        });\n        return;\n      }\n    }\n    if (node.type === _elementTypes.TABLE_CELL) {\n      const parentEntry = _slate.Editor.parent(editor, path);\n      if ((parentEntry === null || parentEntry === void 0 ? void 0 : parentEntry[0].type) !== _elementTypes.TABLE_ROW) {\n        (0, _slate.unwrapNodes)(editor, {\n          at: path\n        });\n        return;\n      }\n    }\n    return normalizeNode([node, path]);\n  };\n  return newEditor;\n};\nvar _default = exports.default = withTable;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}