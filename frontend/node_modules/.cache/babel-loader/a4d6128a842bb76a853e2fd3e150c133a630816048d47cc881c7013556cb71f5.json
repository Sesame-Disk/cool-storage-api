{"ast":null,"code":"/**\n * Module dependencies.\n */\n\nvar keys = require('./keys');\nvar hasBinary = require('has-binary2');\nvar sliceBuffer = require('arraybuffer.slice');\nvar after = require('after');\nvar utf8 = require('./utf8');\nvar base64encoder;\nif (typeof ArrayBuffer !== 'undefined') {\n  base64encoder = require('base64-arraybuffer');\n}\n\n/**\n * Check if we are running an android browser. That requires us to use\n * ArrayBuffer with polling transports...\n *\n * http://ghinda.net/jpeg-blob-ajax-android/\n */\n\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n\n/**\n * Check if we are running in PhantomJS.\n * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n * https://github.com/ariya/phantomjs/issues/11395\n * @type boolean\n */\nvar isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);\n\n/**\n * When true, avoids using Blobs to encode payloads.\n * @type boolean\n */\nvar dontSendBlobs = isAndroid || isPhantomJS;\n\n/**\n * Current protocol version.\n */\n\nexports.protocol = 3;\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n  open: 0 // non-ws\n  ,\n  close: 1 // non-ws\n  ,\n  ping: 2,\n  pong: 3,\n  message: 4,\n  upgrade: 5,\n  noop: 6\n};\nvar packetslist = keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = {\n  type: 'error',\n  data: 'parser error'\n};\n\n/**\n * Create a blob api even for blob builder when vendor prefixes exist\n */\n\nvar Blob = require('blob');\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = false;\n  }\n  if (typeof utf8encode === 'function') {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n  var data = packet.data === undefined ? undefined : packet.data.buffer || packet.data;\n  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {\n    return encodeArrayBuffer(packet, supportsBinary, callback);\n  } else if (typeof Blob !== 'undefined' && data instanceof Blob) {\n    return encodeBlob(packet, supportsBinary, callback);\n  }\n\n  // might be an object with { base64: true, data: dataAsBase64String }\n  if (data && data.base64) {\n    return encodeBase64Object(packet, callback);\n  }\n\n  // Sending data as a utf-8 string\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data), {\n      strict: false\n    }) : String(packet.data);\n  }\n  return callback('' + encoded);\n};\nfunction encodeBase64Object(packet, callback) {\n  // packet data is an object { base64: true, data: dataAsBase64String }\n  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n  return callback(message);\n}\n\n/**\n * Encode packet helpers for binary types\n */\n\nfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n  var data = packet.data;\n  var contentArray = new Uint8Array(data);\n  var resultBuffer = new Uint8Array(1 + data.byteLength);\n  resultBuffer[0] = packets[packet.type];\n  for (var i = 0; i < contentArray.length; i++) {\n    resultBuffer[i + 1] = contentArray[i];\n  }\n  return callback(resultBuffer.buffer);\n}\nfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n  var fr = new FileReader();\n  fr.onload = function () {\n    exports.encodePacket({\n      type: packet.type,\n      data: fr.result\n    }, supportsBinary, true, callback);\n  };\n  return fr.readAsArrayBuffer(packet.data);\n}\nfunction encodeBlob(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n  if (dontSendBlobs) {\n    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n  }\n  var length = new Uint8Array(1);\n  length[0] = packets[packet.type];\n  var blob = new Blob([length.buffer, packet.data]);\n  return callback(blob);\n}\n\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\nexports.encodeBase64Packet = function (packet, callback) {\n  var message = 'b' + exports.packets[packet.type];\n  if (typeof Blob !== 'undefined' && packet.data instanceof Blob) {\n    var fr = new FileReader();\n    fr.onload = function () {\n      var b64 = fr.result.split(',')[1];\n      callback(message + b64);\n    };\n    return fr.readAsDataURL(packet.data);\n  }\n  var b64data;\n  try {\n    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n  } catch (e) {\n    // iPhone Safari doesn't let you apply with typed arrays\n    var typed = new Uint8Array(packet.data);\n    var basic = new Array(typed.length);\n    for (var i = 0; i < typed.length; i++) {\n      basic[i] = typed[i];\n    }\n    b64data = String.fromCharCode.apply(null, basic);\n  }\n  message += btoa(b64data);\n  return callback(message);\n};\n\n/**\n * Decodes a packet. Changes format to Blob if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  }\n  // String data\n  if (typeof data === 'string') {\n    if (data.charAt(0) === 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n    if (utf8decode) {\n      data = tryDecode(data);\n      if (data === false) {\n        return err;\n      }\n    }\n    var type = data.charAt(0);\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n    if (data.length > 1) {\n      return {\n        type: packetslist[type],\n        data: data.substring(1)\n      };\n    } else {\n      return {\n        type: packetslist[type]\n      };\n    }\n  }\n  var asArray = new Uint8Array(data);\n  var type = asArray[0];\n  var rest = sliceBuffer(data, 1);\n  if (Blob && binaryType === 'blob') {\n    rest = new Blob([rest]);\n  }\n  return {\n    type: packetslist[type],\n    data: rest\n  };\n};\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data, {\n      strict: false\n    });\n  } catch (e) {\n    return false;\n  }\n  return data;\n}\n\n/**\n * Decodes a packet encoded in a base64 string\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\nexports.decodeBase64Packet = function (msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  if (!base64encoder) {\n    return {\n      type: type,\n      data: {\n        base64: true,\n        data: msg.substr(1)\n      }\n    };\n  }\n  var data = base64encoder.decode(msg.substr(1));\n  if (binaryType === 'blob' && Blob) {\n    data = new Blob([data]);\n  }\n  return {\n    type: type,\n    data: data\n  };\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n  var isBinary = hasBinary(packets);\n  if (supportsBinary && isBinary) {\n    if (Blob && !dontSendBlobs) {\n      return exports.encodePayloadAsBlob(packets, callback);\n    }\n    return exports.encodePayloadAsArrayBuffer(packets, callback);\n  }\n  if (!packets.length) {\n    return callback('0:');\n  }\n  function setLengthHeader(message) {\n    return message.length + ':' + message;\n  }\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function (message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n  map(packets, encodeOne, function (err, results) {\n    return callback(results.join(''));\n  });\n};\n\n/**\n * Async array map using after\n */\n\nfunction map(ary, each, done) {\n  var result = new Array(ary.length);\n  var next = after(ary.length, done);\n  var eachWithIndex = function eachWithIndex(i, el, cb) {\n    each(el, function (error, msg) {\n      result[i] = msg;\n      cb(error, result);\n    });\n  };\n  for (var i = 0; i < ary.length; i++) {\n    eachWithIndex(i, ary[i], next);\n  }\n}\n\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data !== 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n  var packet;\n  if (data === '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n  var length = '',\n    n,\n    msg;\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n    if (chr !== ':') {\n      length += chr;\n      continue;\n    }\n    if (length === '' || length != (n = Number(length))) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n    msg = data.substr(i + 1, n);\n    if (length != msg.length) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n    if (msg.length) {\n      packet = exports.decodePacket(msg, binaryType, false);\n      if (err.type === packet.type && err.data === packet.data) {\n        // parser error in individual packet - ignoring payload\n        return callback(err, 0, 1);\n      }\n      var ret = callback(packet, i + n, l);\n      if (false === ret) return;\n    }\n\n    // advance cursor\n    i += n;\n    length = '';\n  }\n  if (length !== '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n};\n\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {ArrayBuffer} encoded payload\n * @api private\n */\n\nexports.encodePayloadAsArrayBuffer = function (packets, callback) {\n  if (!packets.length) {\n    return callback(new ArrayBuffer(0));\n  }\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function (data) {\n      return doneCallback(null, data);\n    });\n  }\n  map(packets, encodeOne, function (err, encodedPackets) {\n    var totalLength = encodedPackets.reduce(function (acc, p) {\n      var len;\n      if (typeof p === 'string') {\n        len = p.length;\n      } else {\n        len = p.byteLength;\n      }\n      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n    }, 0);\n    var resultArray = new Uint8Array(totalLength);\n    var bufferIndex = 0;\n    encodedPackets.forEach(function (p) {\n      var isString = typeof p === 'string';\n      var ab = p;\n      if (isString) {\n        var view = new Uint8Array(p.length);\n        for (var i = 0; i < p.length; i++) {\n          view[i] = p.charCodeAt(i);\n        }\n        ab = view.buffer;\n      }\n      if (isString) {\n        // not true binary\n        resultArray[bufferIndex++] = 0;\n      } else {\n        // true binary\n        resultArray[bufferIndex++] = 1;\n      }\n      var lenStr = ab.byteLength.toString();\n      for (var i = 0; i < lenStr.length; i++) {\n        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n      }\n      resultArray[bufferIndex++] = 255;\n      var view = new Uint8Array(ab);\n      for (var i = 0; i < view.length; i++) {\n        resultArray[bufferIndex++] = view[i];\n      }\n    });\n    return callback(resultArray.buffer);\n  });\n};\n\n/**\n * Encode as Blob\n */\n\nexports.encodePayloadAsBlob = function (packets, callback) {\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function (encoded) {\n      var binaryIdentifier = new Uint8Array(1);\n      binaryIdentifier[0] = 1;\n      if (typeof encoded === 'string') {\n        var view = new Uint8Array(encoded.length);\n        for (var i = 0; i < encoded.length; i++) {\n          view[i] = encoded.charCodeAt(i);\n        }\n        encoded = view.buffer;\n        binaryIdentifier[0] = 0;\n      }\n      var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;\n      var lenStr = len.toString();\n      var lengthAry = new Uint8Array(lenStr.length + 1);\n      for (var i = 0; i < lenStr.length; i++) {\n        lengthAry[i] = parseInt(lenStr[i]);\n      }\n      lengthAry[lenStr.length] = 255;\n      if (Blob) {\n        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n        doneCallback(null, blob);\n      }\n    });\n  }\n  map(packets, encodeOne, function (err, results) {\n    return callback(new Blob(results));\n  });\n};\n\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n *\n * @param {ArrayBuffer} data, callback method\n * @api public\n */\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n  var bufferTail = data;\n  var buffers = [];\n  while (bufferTail.byteLength > 0) {\n    var tailArray = new Uint8Array(bufferTail);\n    var isString = tailArray[0] === 0;\n    var msgLength = '';\n    for (var i = 1;; i++) {\n      if (tailArray[i] === 255) break;\n\n      // 310 = char length of Number.MAX_VALUE\n      if (msgLength.length > 310) {\n        return callback(err, 0, 1);\n      }\n      msgLength += tailArray[i];\n    }\n    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n    msgLength = parseInt(msgLength);\n    var msg = sliceBuffer(bufferTail, 0, msgLength);\n    if (isString) {\n      try {\n        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n      } catch (e) {\n        // iPhone Safari doesn't let you apply to typed arrays\n        var typed = new Uint8Array(msg);\n        msg = '';\n        for (var i = 0; i < typed.length; i++) {\n          msg += String.fromCharCode(typed[i]);\n        }\n      }\n    }\n    buffers.push(msg);\n    bufferTail = sliceBuffer(bufferTail, msgLength);\n  }\n  var total = buffers.length;\n  buffers.forEach(function (buffer, i) {\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  });\n};","map":{"version":3,"names":["keys","require","hasBinary","sliceBuffer","after","utf8","base64encoder","ArrayBuffer","isAndroid","navigator","test","userAgent","isPhantomJS","dontSendBlobs","exports","protocol","packets","open","close","ping","pong","message","upgrade","noop","packetslist","err","type","data","Blob","encodePacket","packet","supportsBinary","utf8encode","callback","undefined","buffer","encodeArrayBuffer","encodeBlob","base64","encodeBase64Object","encoded","encode","String","strict","encodeBase64Packet","contentArray","Uint8Array","resultBuffer","byteLength","i","length","encodeBlobAsArrayBuffer","fr","FileReader","onload","result","readAsArrayBuffer","blob","b64","split","readAsDataURL","b64data","fromCharCode","apply","e","typed","basic","Array","btoa","decodePacket","binaryType","utf8decode","charAt","decodeBase64Packet","substr","tryDecode","Number","substring","asArray","rest","decode","msg","encodePayload","isBinary","encodePayloadAsBlob","encodePayloadAsArrayBuffer","setLengthHeader","encodeOne","doneCallback","map","results","join","ary","each","done","next","eachWithIndex","el","cb","error","decodePayload","decodePayloadAsBinary","n","l","chr","ret","encodedPackets","totalLength","reduce","acc","p","len","toString","resultArray","bufferIndex","forEach","isString","ab","view","charCodeAt","lenStr","parseInt","binaryIdentifier","size","lengthAry","bufferTail","buffers","tailArray","msgLength","push","total"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/engine.io-parser/lib/browser.js"],"sourcesContent":["/**\n * Module dependencies.\n */\n\nvar keys = require('./keys');\nvar hasBinary = require('has-binary2');\nvar sliceBuffer = require('arraybuffer.slice');\nvar after = require('after');\nvar utf8 = require('./utf8');\n\nvar base64encoder;\nif (typeof ArrayBuffer !== 'undefined') {\n  base64encoder = require('base64-arraybuffer');\n}\n\n/**\n * Check if we are running an android browser. That requires us to use\n * ArrayBuffer with polling transports...\n *\n * http://ghinda.net/jpeg-blob-ajax-android/\n */\n\nvar isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\n\n/**\n * Check if we are running in PhantomJS.\n * Uploading a Blob with PhantomJS does not work correctly, as reported here:\n * https://github.com/ariya/phantomjs/issues/11395\n * @type boolean\n */\nvar isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);\n\n/**\n * When true, avoids using Blobs to encode payloads.\n * @type boolean\n */\nvar dontSendBlobs = isAndroid || isPhantomJS;\n\n/**\n * Current protocol version.\n */\n\nexports.protocol = 3;\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n    open:     0    // non-ws\n  , close:    1    // non-ws\n  , ping:     2\n  , pong:     3\n  , message:  4\n  , upgrade:  5\n  , noop:     6\n};\n\nvar packetslist = keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = { type: 'error', data: 'parser error' };\n\n/**\n * Create a blob api even for blob builder when vendor prefixes exist\n */\n\nvar Blob = require('blob');\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ <data> ]\n *\n * Example:\n *\n *     5hello world\n *     3\n *     4\n *\n * Binary is encoded in an identical principle\n *\n * @api private\n */\n\nexports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = false;\n  }\n\n  if (typeof utf8encode === 'function') {\n    callback = utf8encode;\n    utf8encode = null;\n  }\n\n  var data = (packet.data === undefined)\n    ? undefined\n    : packet.data.buffer || packet.data;\n\n  if (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer) {\n    return encodeArrayBuffer(packet, supportsBinary, callback);\n  } else if (typeof Blob !== 'undefined' && data instanceof Blob) {\n    return encodeBlob(packet, supportsBinary, callback);\n  }\n\n  // might be an object with { base64: true, data: dataAsBase64String }\n  if (data && data.base64) {\n    return encodeBase64Object(packet, callback);\n  }\n\n  // Sending data as a utf-8 string\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);\n  }\n\n  return callback('' + encoded);\n\n};\n\nfunction encodeBase64Object(packet, callback) {\n  // packet data is an object { base64: true, data: dataAsBase64String }\n  var message = 'b' + exports.packets[packet.type] + packet.data.data;\n  return callback(message);\n}\n\n/**\n * Encode packet helpers for binary types\n */\n\nfunction encodeArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var data = packet.data;\n  var contentArray = new Uint8Array(data);\n  var resultBuffer = new Uint8Array(1 + data.byteLength);\n\n  resultBuffer[0] = packets[packet.type];\n  for (var i = 0; i < contentArray.length; i++) {\n    resultBuffer[i+1] = contentArray[i];\n  }\n\n  return callback(resultBuffer.buffer);\n}\n\nfunction encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  var fr = new FileReader();\n  fr.onload = function() {\n    exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);\n  };\n  return fr.readAsArrayBuffer(packet.data);\n}\n\nfunction encodeBlob(packet, supportsBinary, callback) {\n  if (!supportsBinary) {\n    return exports.encodeBase64Packet(packet, callback);\n  }\n\n  if (dontSendBlobs) {\n    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);\n  }\n\n  var length = new Uint8Array(1);\n  length[0] = packets[packet.type];\n  var blob = new Blob([length.buffer, packet.data]);\n\n  return callback(blob);\n}\n\n/**\n * Encodes a packet with binary data in a base64 string\n *\n * @param {Object} packet, has `type` and `data`\n * @return {String} base64 encoded message\n */\n\nexports.encodeBase64Packet = function(packet, callback) {\n  var message = 'b' + exports.packets[packet.type];\n  if (typeof Blob !== 'undefined' && packet.data instanceof Blob) {\n    var fr = new FileReader();\n    fr.onload = function() {\n      var b64 = fr.result.split(',')[1];\n      callback(message + b64);\n    };\n    return fr.readAsDataURL(packet.data);\n  }\n\n  var b64data;\n  try {\n    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));\n  } catch (e) {\n    // iPhone Safari doesn't let you apply with typed arrays\n    var typed = new Uint8Array(packet.data);\n    var basic = new Array(typed.length);\n    for (var i = 0; i < typed.length; i++) {\n      basic[i] = typed[i];\n    }\n    b64data = String.fromCharCode.apply(null, basic);\n  }\n  message += btoa(b64data);\n  return callback(message);\n};\n\n/**\n * Decodes a packet. Changes format to Blob if requested.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data, binaryType, utf8decode) {\n  if (data === undefined) {\n    return err;\n  }\n  // String data\n  if (typeof data === 'string') {\n    if (data.charAt(0) === 'b') {\n      return exports.decodeBase64Packet(data.substr(1), binaryType);\n    }\n\n    if (utf8decode) {\n      data = tryDecode(data);\n      if (data === false) {\n        return err;\n      }\n    }\n    var type = data.charAt(0);\n\n    if (Number(type) != type || !packetslist[type]) {\n      return err;\n    }\n\n    if (data.length > 1) {\n      return { type: packetslist[type], data: data.substring(1) };\n    } else {\n      return { type: packetslist[type] };\n    }\n  }\n\n  var asArray = new Uint8Array(data);\n  var type = asArray[0];\n  var rest = sliceBuffer(data, 1);\n  if (Blob && binaryType === 'blob') {\n    rest = new Blob([rest]);\n  }\n  return { type: packetslist[type], data: rest };\n};\n\nfunction tryDecode(data) {\n  try {\n    data = utf8.decode(data, { strict: false });\n  } catch (e) {\n    return false;\n  }\n  return data;\n}\n\n/**\n * Decodes a packet encoded in a base64 string\n *\n * @param {String} base64 encoded message\n * @return {Object} with `type` and `data` (if any)\n */\n\nexports.decodeBase64Packet = function(msg, binaryType) {\n  var type = packetslist[msg.charAt(0)];\n  if (!base64encoder) {\n    return { type: type, data: { base64: true, data: msg.substr(1) } };\n  }\n\n  var data = base64encoder.decode(msg.substr(1));\n\n  if (binaryType === 'blob' && Blob) {\n    data = new Blob([data]);\n  }\n\n  return { type: type, data: data };\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * If any contents are binary, they will be encoded as base64 strings. Base64\n * encoded strings are marked with a b before the length specifier\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets, supportsBinary, callback) {\n  if (typeof supportsBinary === 'function') {\n    callback = supportsBinary;\n    supportsBinary = null;\n  }\n\n  var isBinary = hasBinary(packets);\n\n  if (supportsBinary && isBinary) {\n    if (Blob && !dontSendBlobs) {\n      return exports.encodePayloadAsBlob(packets, callback);\n    }\n\n    return exports.encodePayloadAsArrayBuffer(packets, callback);\n  }\n\n  if (!packets.length) {\n    return callback('0:');\n  }\n\n  function setLengthHeader(message) {\n    return message.length + ':' + message;\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {\n      doneCallback(null, setLengthHeader(message));\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(results.join(''));\n  });\n};\n\n/**\n * Async array map using after\n */\n\nfunction map(ary, each, done) {\n  var result = new Array(ary.length);\n  var next = after(ary.length, done);\n\n  var eachWithIndex = function(i, el, cb) {\n    each(el, function(error, msg) {\n      result[i] = msg;\n      cb(error, result);\n    });\n  };\n\n  for (var i = 0; i < ary.length; i++) {\n    eachWithIndex(i, ary[i], next);\n  }\n}\n\n/*\n * Decodes data when a payload is maybe expected. Possible binary contents are\n * decoded from their base64 representation\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, binaryType, callback) {\n  if (typeof data !== 'string') {\n    return exports.decodePayloadAsBinary(data, binaryType, callback);\n  }\n\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var packet;\n  if (data === '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = '', n, msg;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (chr !== ':') {\n      length += chr;\n      continue;\n    }\n\n    if (length === '' || (length != (n = Number(length)))) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    msg = data.substr(i + 1, n);\n\n    if (length != msg.length) {\n      // parser error - ignoring payload\n      return callback(err, 0, 1);\n    }\n\n    if (msg.length) {\n      packet = exports.decodePacket(msg, binaryType, false);\n\n      if (err.type === packet.type && err.data === packet.data) {\n        // parser error in individual packet - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      var ret = callback(packet, i + n, l);\n      if (false === ret) return;\n    }\n\n    // advance cursor\n    i += n;\n    length = '';\n  }\n\n  if (length !== '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n};\n\n/**\n * Encodes multiple messages (payload) as binary.\n *\n * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number\n * 255><data>\n *\n * Example:\n * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers\n *\n * @param {Array} packets\n * @return {ArrayBuffer} encoded payload\n * @api private\n */\n\nexports.encodePayloadAsArrayBuffer = function(packets, callback) {\n  if (!packets.length) {\n    return callback(new ArrayBuffer(0));\n  }\n\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(data) {\n      return doneCallback(null, data);\n    });\n  }\n\n  map(packets, encodeOne, function(err, encodedPackets) {\n    var totalLength = encodedPackets.reduce(function(acc, p) {\n      var len;\n      if (typeof p === 'string'){\n        len = p.length;\n      } else {\n        len = p.byteLength;\n      }\n      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2\n    }, 0);\n\n    var resultArray = new Uint8Array(totalLength);\n\n    var bufferIndex = 0;\n    encodedPackets.forEach(function(p) {\n      var isString = typeof p === 'string';\n      var ab = p;\n      if (isString) {\n        var view = new Uint8Array(p.length);\n        for (var i = 0; i < p.length; i++) {\n          view[i] = p.charCodeAt(i);\n        }\n        ab = view.buffer;\n      }\n\n      if (isString) { // not true binary\n        resultArray[bufferIndex++] = 0;\n      } else { // true binary\n        resultArray[bufferIndex++] = 1;\n      }\n\n      var lenStr = ab.byteLength.toString();\n      for (var i = 0; i < lenStr.length; i++) {\n        resultArray[bufferIndex++] = parseInt(lenStr[i]);\n      }\n      resultArray[bufferIndex++] = 255;\n\n      var view = new Uint8Array(ab);\n      for (var i = 0; i < view.length; i++) {\n        resultArray[bufferIndex++] = view[i];\n      }\n    });\n\n    return callback(resultArray.buffer);\n  });\n};\n\n/**\n * Encode as Blob\n */\n\nexports.encodePayloadAsBlob = function(packets, callback) {\n  function encodeOne(packet, doneCallback) {\n    exports.encodePacket(packet, true, true, function(encoded) {\n      var binaryIdentifier = new Uint8Array(1);\n      binaryIdentifier[0] = 1;\n      if (typeof encoded === 'string') {\n        var view = new Uint8Array(encoded.length);\n        for (var i = 0; i < encoded.length; i++) {\n          view[i] = encoded.charCodeAt(i);\n        }\n        encoded = view.buffer;\n        binaryIdentifier[0] = 0;\n      }\n\n      var len = (encoded instanceof ArrayBuffer)\n        ? encoded.byteLength\n        : encoded.size;\n\n      var lenStr = len.toString();\n      var lengthAry = new Uint8Array(lenStr.length + 1);\n      for (var i = 0; i < lenStr.length; i++) {\n        lengthAry[i] = parseInt(lenStr[i]);\n      }\n      lengthAry[lenStr.length] = 255;\n\n      if (Blob) {\n        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);\n        doneCallback(null, blob);\n      }\n    });\n  }\n\n  map(packets, encodeOne, function(err, results) {\n    return callback(new Blob(results));\n  });\n};\n\n/*\n * Decodes data when a payload is maybe expected. Strings are decoded by\n * interpreting each byte as a key code for entries marked to start with 0. See\n * description of encodePayloadAsBinary\n *\n * @param {ArrayBuffer} data, callback method\n * @api public\n */\n\nexports.decodePayloadAsBinary = function (data, binaryType, callback) {\n  if (typeof binaryType === 'function') {\n    callback = binaryType;\n    binaryType = null;\n  }\n\n  var bufferTail = data;\n  var buffers = [];\n\n  while (bufferTail.byteLength > 0) {\n    var tailArray = new Uint8Array(bufferTail);\n    var isString = tailArray[0] === 0;\n    var msgLength = '';\n\n    for (var i = 1; ; i++) {\n      if (tailArray[i] === 255) break;\n\n      // 310 = char length of Number.MAX_VALUE\n      if (msgLength.length > 310) {\n        return callback(err, 0, 1);\n      }\n\n      msgLength += tailArray[i];\n    }\n\n    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);\n    msgLength = parseInt(msgLength);\n\n    var msg = sliceBuffer(bufferTail, 0, msgLength);\n    if (isString) {\n      try {\n        msg = String.fromCharCode.apply(null, new Uint8Array(msg));\n      } catch (e) {\n        // iPhone Safari doesn't let you apply to typed arrays\n        var typed = new Uint8Array(msg);\n        msg = '';\n        for (var i = 0; i < typed.length; i++) {\n          msg += String.fromCharCode(typed[i]);\n        }\n      }\n    }\n\n    buffers.push(msg);\n    bufferTail = sliceBuffer(bufferTail, msgLength);\n  }\n\n  var total = buffers.length;\n  buffers.forEach(function(buffer, i) {\n    callback(exports.decodePacket(buffer, binaryType, true), i, total);\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}