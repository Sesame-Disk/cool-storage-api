{"ast":null,"code":"import _classCallCheck from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { EditorSelection, countColumn, Prec, EditorState } from '@codemirror/state';\nimport { keymap } from '@codemirror/view';\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, foldService, syntaxTree, Language, LanguageDescription, ParseContext, indentUnit, LanguageSupport } from '@codemirror/language';\nimport { CompletionContext } from '@codemirror/autocomplete';\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\nimport { html, htmlCompletionSource } from '@codemirror/lang-html';\nimport { NodeProp } from '@lezer/common';\nvar data = /*@__PURE__*/defineLanguageFacet({\n  commentTokens: {\n    block: {\n      open: \"<!--\",\n      close: \"-->\"\n    }\n  }\n});\nvar headingProp = /*@__PURE__*/new NodeProp();\nvar commonmark = /*@__PURE__*/parser.configure({\n  props: [/*@__PURE__*/foldNodeProp.add(function (type) {\n    return !type.is(\"Block\") || type.is(\"Document\") || isHeading(type) != null ? undefined : function (tree, state) {\n      return {\n        from: state.doc.lineAt(tree.from).to,\n        to: tree.to\n      };\n    };\n  }), /*@__PURE__*/headingProp.add(isHeading), /*@__PURE__*/indentNodeProp.add({\n    Document: function Document() {\n      return null;\n    }\n  }), /*@__PURE__*/languageDataProp.add({\n    Document: data\n  })]\n});\nfunction isHeading(type) {\n  var match = /^(?:ATX|Setext)Heading(\\d)$/.exec(type.name);\n  return match ? +match[1] : undefined;\n}\nfunction findSectionEnd(headerNode, level) {\n  var last = headerNode;\n  for (;;) {\n    var next = last.nextSibling,\n      heading = void 0;\n    if (!next || (heading = isHeading(next.type)) != null && heading <= level) break;\n    last = next;\n  }\n  return last.to;\n}\nvar headerIndent = /*@__PURE__*/foldService.of(function (state, start, end) {\n  for (var node = syntaxTree(state).resolveInner(end, -1); node; node = node.parent) {\n    if (node.from < start) break;\n    var heading = node.type.prop(headingProp);\n    if (heading == null) continue;\n    var upto = findSectionEnd(node, heading);\n    if (upto > end) return {\n      from: end,\n      to: upto\n    };\n  }\n  return null;\n});\nfunction mkLang(parser) {\n  return new Language(data, parser, [headerIndent], \"markdown\");\n}\n/**\nLanguage support for strict CommonMark.\n*/\nvar commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nvar extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji, {\n  props: [/*@__PURE__*/foldNodeProp.add({\n    Table: function Table(tree, state) {\n      return {\n        from: state.doc.lineAt(tree.from).to,\n        to: tree.to\n      };\n    }\n  })]\n}]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\nvar markdownLanguage = /*@__PURE__*/mkLang(extended);\nfunction getCodeParser(languages, defaultLanguage) {\n  return function (info) {\n    if (info && languages) {\n      var found = null;\n      // Strip anything after whitespace\n      info = /\\S*/.exec(info)[0];\n      if (typeof languages == \"function\") found = languages(info);else found = LanguageDescription.matchLanguageName(languages, info, true);\n      if (found instanceof LanguageDescription) return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());else if (found) return found.parser;\n    }\n    return defaultLanguage ? defaultLanguage.parser : null;\n  };\n}\nvar Context = /*#__PURE__*/function () {\n  function Context(node, from, to, spaceBefore, spaceAfter, type, item) {\n    _classCallCheck(this, Context);\n    this.node = node;\n    this.from = from;\n    this.to = to;\n    this.spaceBefore = spaceBefore;\n    this.spaceAfter = spaceAfter;\n    this.type = type;\n    this.item = item;\n  }\n  _createClass(Context, [{\n    key: \"blank\",\n    value: function blank(maxWidth) {\n      var trailing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var result = this.spaceBefore + (this.node.name == \"Blockquote\" ? \">\" : \"\");\n      if (maxWidth != null) {\n        while (result.length < maxWidth) result += \" \";\n        return result;\n      } else {\n        for (var i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--) result += \" \";\n        return result + (trailing ? this.spaceAfter : \"\");\n      }\n    }\n  }, {\n    key: \"marker\",\n    value: function marker(doc, add) {\n      var number = this.node.name == \"OrderedList\" ? String(+itemNumber(this.item, doc)[2] + add) : \"\";\n      return this.spaceBefore + number + this.type + this.spaceAfter;\n    }\n  }]);\n  return Context;\n}();\nfunction getContext(node, doc) {\n  var nodes = [];\n  for (var cur = node; cur && cur.name != \"Document\"; cur = cur.parent) {\n    if (cur.name == \"ListItem\" || cur.name == \"Blockquote\" || cur.name == \"FencedCode\") nodes.push(cur);\n  }\n  var context = [];\n  for (var i = nodes.length - 1; i >= 0; i--) {\n    var _node = nodes[i],\n      match = void 0;\n    var line = doc.lineAt(_node.from),\n      startPos = _node.from - line.from;\n    if (_node.name == \"FencedCode\") {\n      context.push(new Context(_node, startPos, startPos, \"\", \"\", \"\", null));\n    } else if (_node.name == \"Blockquote\" && (match = /^ *>( ?)/.exec(line.text.slice(startPos)))) {\n      context.push(new Context(_node, startPos, startPos + match[0].length, \"\", match[1], \">\", null));\n    } else if (_node.name == \"ListItem\" && _node.parent.name == \"OrderedList\" && (match = /^( *)\\d+([.)])( *)/.exec(line.text.slice(startPos)))) {\n      var after = match[3],\n        len = match[0].length;\n      if (after.length >= 4) {\n        after = after.slice(0, after.length - 4);\n        len -= 4;\n      }\n      context.push(new Context(_node.parent, startPos, startPos + len, match[1], after, match[2], _node));\n    } else if (_node.name == \"ListItem\" && _node.parent.name == \"BulletList\" && (match = /^( *)([-+*])( {1,4}\\[[ xX]\\])?( +)/.exec(line.text.slice(startPos)))) {\n      var _after = match[4],\n        _len = match[0].length;\n      if (_after.length > 4) {\n        _after = _after.slice(0, _after.length - 4);\n        _len -= 4;\n      }\n      var type = match[2];\n      if (match[3]) type += match[3].replace(/[xX]/, ' ');\n      context.push(new Context(_node.parent, startPos, startPos + _len, match[1], _after, type, _node));\n    }\n  }\n  return context;\n}\nfunction itemNumber(item, doc) {\n  return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\nfunction renumberList(after, doc, changes) {\n  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  for (var prev = -1, node = after;;) {\n    if (node.name == \"ListItem\") {\n      var m = itemNumber(node, doc);\n      var number = +m[2];\n      if (prev >= 0) {\n        if (number != prev + 1) return;\n        changes.push({\n          from: node.from + m[1].length,\n          to: node.from + m[0].length,\n          insert: String(prev + 2 + offset)\n        });\n      }\n      prev = number;\n    }\n    var next = node.nextSibling;\n    if (!next) break;\n    node = next;\n  }\n}\nfunction normalizeIndent(content, state) {\n  var blank = /^[ \\t]*/.exec(content)[0].length;\n  if (!blank || state.facet(indentUnit) != \"\\t\") return content;\n  var col = countColumn(content, 4, blank);\n  var space = \"\";\n  for (var i = col; i > 0;) {\n    if (i >= 4) {\n      space += \"\\t\";\n      i -= 4;\n    } else {\n      space += \" \";\n      i--;\n    }\n  }\n  return space + content.slice(blank);\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\nvar insertNewlineContinueMarkup = function insertNewlineContinueMarkup(_ref) {\n  var state = _ref.state,\n    dispatch = _ref.dispatch;\n  var tree = syntaxTree(state),\n    doc = state.doc;\n  var dont = null,\n    changes = state.changeByRange(function (range) {\n      if (!range.empty || !markdownLanguage.isActiveAt(state, range.from)) return dont = {\n        range: range\n      };\n      var pos = range.from,\n        line = doc.lineAt(pos);\n      var context = getContext(tree.resolveInner(pos, -1), doc);\n      while (context.length && context[context.length - 1].from > pos - line.from) context.pop();\n      if (!context.length) return dont = {\n        range: range\n      };\n      var inner = context[context.length - 1];\n      if (inner.to - inner.spaceAfter.length > pos - line.from) return dont = {\n        range: range\n      };\n      var emptyLine = pos >= inner.to - inner.spaceAfter.length && !/\\S/.test(line.text.slice(inner.to));\n      // Empty line in list\n      if (inner.item && emptyLine) {\n        // First list item or blank line before: delete a level of markup\n        if (inner.node.firstChild.to >= pos || line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n          var next = context.length > 1 ? context[context.length - 2] : null;\n          var delTo,\n            _insert = \"\";\n          if (next && next.item) {\n            // Re-add marker for the list at the next level\n            delTo = line.from + next.from;\n            _insert = next.marker(doc, 1);\n          } else {\n            delTo = line.from + (next ? next.to : 0);\n          }\n          var _changes = [{\n            from: delTo,\n            to: pos,\n            insert: _insert\n          }];\n          if (inner.node.name == \"OrderedList\") renumberList(inner.item, doc, _changes, -2);\n          if (next && next.node.name == \"OrderedList\") renumberList(next.item, doc, _changes);\n          return {\n            range: EditorSelection.cursor(delTo + _insert.length),\n            changes: _changes\n          };\n        } else {\n          // Move this line down\n          var _insert2 = \"\";\n          for (var i = 0, e = context.length - 2; i <= e; i++) {\n            _insert2 += context[i].blank(i < e ? countColumn(line.text, 4, context[i + 1].from) - _insert2.length : null, i < e);\n          }\n          _insert2 = normalizeIndent(_insert2, state);\n          return {\n            range: EditorSelection.cursor(pos + _insert2.length + 1),\n            changes: {\n              from: line.from,\n              insert: _insert2 + state.lineBreak\n            }\n          };\n        }\n      }\n      if (inner.node.name == \"Blockquote\" && emptyLine && line.from) {\n        var prevLine = doc.lineAt(line.from - 1),\n          quoted = />\\s*$/.exec(prevLine.text);\n        // Two aligned empty quoted lines in a row\n        if (quoted && quoted.index == inner.from) {\n          var _changes2 = state.changes([{\n            from: prevLine.from + quoted.index,\n            to: prevLine.to\n          }, {\n            from: line.from + inner.from,\n            to: line.to\n          }]);\n          return {\n            range: range.map(_changes2),\n            changes: _changes2\n          };\n        }\n      }\n      var changes = [];\n      if (inner.node.name == \"OrderedList\") renumberList(inner.item, doc, changes);\n      var continued = inner.item && inner.item.from < line.from;\n      var insert = \"\";\n      // If not dedented\n      if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n        for (var _i = 0, _e = context.length - 1; _i <= _e; _i++) {\n          insert += _i == _e && !continued ? context[_i].marker(doc, 1) : context[_i].blank(_i < _e ? countColumn(line.text, 4, context[_i + 1].from) - insert.length : null);\n        }\n      }\n      var from = pos;\n      while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1))) from--;\n      insert = normalizeIndent(insert, state);\n      changes.push({\n        from: from,\n        to: pos,\n        insert: state.lineBreak + insert\n      });\n      return {\n        range: EditorSelection.cursor(from + insert.length + 1),\n        changes: changes\n      };\n    });\n  if (dont) return false;\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\nfunction isMark(node) {\n  return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\nfunction contextNodeForDelete(tree, pos) {\n  var node = tree.resolveInner(pos, -1),\n    scan = pos;\n  if (isMark(node)) {\n    scan = node.from;\n    node = node.parent;\n  }\n  for (var prev; prev = node.childBefore(scan);) {\n    if (isMark(prev)) {\n      scan = prev.from;\n    } else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n      node = prev.lastChild;\n      scan = node.to;\n    } else {\n      break;\n    }\n  }\n  return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\nvar deleteMarkupBackward = function deleteMarkupBackward(_ref2) {\n  var state = _ref2.state,\n    dispatch = _ref2.dispatch;\n  var tree = syntaxTree(state);\n  var dont = null,\n    changes = state.changeByRange(function (range) {\n      var pos = range.from,\n        doc = state.doc;\n      if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n        var line = doc.lineAt(pos);\n        var context = getContext(contextNodeForDelete(tree, pos), doc);\n        if (context.length) {\n          var inner = context[context.length - 1];\n          var spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\n          // Delete extra trailing space after markup\n          if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from))) return {\n            range: EditorSelection.cursor(line.from + spaceEnd),\n            changes: {\n              from: line.from + spaceEnd,\n              to: pos\n            }\n          };\n          if (pos - line.from == spaceEnd && (\n          // Only apply this if we're on the line that has the\n          // construct's syntax, or there's only indentation in the\n          // target range\n          !inner.item || line.from <= inner.item.from || !/\\S/.test(line.text.slice(0, inner.to)))) {\n            var start = line.from + inner.from;\n            // Replace a list item marker with blank space\n            if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to))) {\n              var insert = inner.blank(countColumn(line.text, 4, inner.to) - countColumn(line.text, 4, inner.from));\n              if (start == line.from) insert = normalizeIndent(insert, state);\n              return {\n                range: EditorSelection.cursor(start + insert.length),\n                changes: {\n                  from: start,\n                  to: line.from + inner.to,\n                  insert: insert\n                }\n              };\n            }\n            // Delete one level of indentation\n            if (start < pos) return {\n              range: EditorSelection.cursor(start),\n              changes: {\n                from: start,\n                to: pos\n              }\n            };\n          }\n        }\n      }\n      return dont = {\n        range: range\n      };\n    });\n  if (dont) return false;\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"delete\"\n  }));\n  return true;\n};\n\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\nvar markdownKeymap = [{\n  key: \"Enter\",\n  run: insertNewlineContinueMarkup\n}, {\n  key: \"Backspace\",\n  run: deleteMarkupBackward\n}];\nvar htmlNoMatch = /*@__PURE__*/html({\n  matchClosingTags: false\n});\n/**\nMarkdown language support.\n*/\nfunction markdown() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var codeLanguages = config.codeLanguages,\n    defaultCodeLanguage = config.defaultCodeLanguage,\n    _config$addKeymap = config.addKeymap,\n    addKeymap = _config$addKeymap === void 0 ? true : _config$addKeymap,\n    _config$base = config.base,\n    _config$base2 = _config$base === void 0 ? commonmarkLanguage : _config$base,\n    parser = _config$base2.parser,\n    _config$completeHTMLT = config.completeHTMLTags,\n    completeHTMLTags = _config$completeHTMLT === void 0 ? true : _config$completeHTMLT;\n  if (!(parser instanceof MarkdownParser)) throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n  var extensions = config.extensions ? [config.extensions] : [];\n  var support = [htmlNoMatch.support],\n    defaultCode;\n  if (defaultCodeLanguage instanceof LanguageSupport) {\n    support.push(defaultCodeLanguage.support);\n    defaultCode = defaultCodeLanguage.language;\n  } else if (defaultCodeLanguage) {\n    defaultCode = defaultCodeLanguage;\n  }\n  var codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;\n  extensions.push(parseCode({\n    codeParser: codeParser,\n    htmlParser: htmlNoMatch.language.parser\n  }));\n  if (addKeymap) support.push(Prec.high(keymap.of(markdownKeymap)));\n  var lang = mkLang(parser.configure(extensions));\n  if (completeHTMLTags) support.push(lang.data.of({\n    autocomplete: htmlTagCompletion\n  }));\n  return new LanguageSupport(lang, support);\n}\nfunction htmlTagCompletion(context) {\n  var state = context.state,\n    pos = context.pos,\n    m = /<[:\\-\\.\\w\\u00b7-\\uffff]*$/.exec(state.sliceDoc(pos - 25, pos));\n  if (!m) return null;\n  var tree = syntaxTree(state).resolveInner(pos, -1);\n  while (tree && !tree.type.isTop) {\n    if (tree.name == \"CodeBlock\" || tree.name == \"FencedCode\" || tree.name == \"ProcessingInstructionBlock\" || tree.name == \"CommentBlock\" || tree.name == \"Link\" || tree.name == \"Image\") return null;\n    tree = tree.parent;\n  }\n  return {\n    from: pos - m[0].length,\n    to: pos,\n    options: htmlTagCompletions(),\n    validFor: /^<[:\\-\\.\\w\\u00b7-\\uffff]*$/\n  };\n}\nvar _tagCompletions = null;\nfunction htmlTagCompletions() {\n  if (_tagCompletions) return _tagCompletions;\n  var result = htmlCompletionSource(new CompletionContext(EditorState.create({\n    extensions: htmlNoMatch\n  }), 0, true));\n  return _tagCompletions = result ? result.options : [];\n}\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };","map":{"version":3,"names":["EditorSelection","countColumn","Prec","EditorState","keymap","defineLanguageFacet","foldNodeProp","indentNodeProp","languageDataProp","foldService","syntaxTree","Language","LanguageDescription","ParseContext","indentUnit","LanguageSupport","CompletionContext","parser","GFM","Subscript","Superscript","Emoji","MarkdownParser","parseCode","html","htmlCompletionSource","NodeProp","data","commentTokens","block","open","close","headingProp","commonmark","configure","props","add","type","is","isHeading","undefined","tree","state","from","doc","lineAt","to","Document","match","exec","name","findSectionEnd","headerNode","level","last","next","nextSibling","heading","headerIndent","of","start","end","node","resolveInner","parent","prop","upto","mkLang","commonmarkLanguage","extended","Table","markdownLanguage","getCodeParser","languages","defaultLanguage","info","found","matchLanguageName","support","language","getSkippingParser","load","Context","spaceBefore","spaceAfter","item","_classCallCheck","_createClass","key","value","blank","maxWidth","trailing","arguments","length","result","i","marker","number","String","itemNumber","getContext","nodes","cur","push","context","line","startPos","text","slice","after","len","replace","sliceString","renumberList","changes","offset","prev","m","insert","normalizeIndent","content","facet","col","space","insertNewlineContinueMarkup","_ref","dispatch","dont","changeByRange","range","empty","isActiveAt","pos","pop","inner","emptyLine","test","firstChild","delTo","cursor","e","lineBreak","prevLine","quoted","index","map","continued","charAt","update","scrollIntoView","userEvent","isMark","contextNodeForDelete","scan","childBefore","lastChild","deleteMarkupBackward","_ref2","spaceEnd","markdownKeymap","run","htmlNoMatch","matchClosingTags","markdown","config","codeLanguages","defaultCodeLanguage","_config$addKeymap","addKeymap","_config$base","base","_config$base2","_config$completeHTMLT","completeHTMLTags","RangeError","extensions","defaultCode","codeParser","htmlParser","high","lang","autocomplete","htmlTagCompletion","sliceDoc","isTop","options","htmlTagCompletions","validFor","_tagCompletions","create"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@codemirror/lang-markdown/dist/index.js"],"sourcesContent":["import { EditorSelection, countColumn, Prec, EditorState } from '@codemirror/state';\nimport { keymap } from '@codemirror/view';\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, foldService, syntaxTree, Language, LanguageDescription, ParseContext, indentUnit, LanguageSupport } from '@codemirror/language';\nimport { CompletionContext } from '@codemirror/autocomplete';\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\nimport { html, htmlCompletionSource } from '@codemirror/lang-html';\nimport { NodeProp } from '@lezer/common';\n\nconst data = /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: \"<!--\", close: \"-->\" } } });\nconst headingProp = /*@__PURE__*/new NodeProp();\nconst commonmark = /*@__PURE__*/parser.configure({\n    props: [\n        /*@__PURE__*/foldNodeProp.add(type => {\n            return !type.is(\"Block\") || type.is(\"Document\") || isHeading(type) != null ? undefined\n                : (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });\n        }),\n        /*@__PURE__*/headingProp.add(isHeading),\n        /*@__PURE__*/indentNodeProp.add({\n            Document: () => null\n        }),\n        /*@__PURE__*/languageDataProp.add({\n            Document: data\n        })\n    ]\n});\nfunction isHeading(type) {\n    let match = /^(?:ATX|Setext)Heading(\\d)$/.exec(type.name);\n    return match ? +match[1] : undefined;\n}\nfunction findSectionEnd(headerNode, level) {\n    let last = headerNode;\n    for (;;) {\n        let next = last.nextSibling, heading;\n        if (!next || (heading = isHeading(next.type)) != null && heading <= level)\n            break;\n        last = next;\n    }\n    return last.to;\n}\nconst headerIndent = /*@__PURE__*/foldService.of((state, start, end) => {\n    for (let node = syntaxTree(state).resolveInner(end, -1); node; node = node.parent) {\n        if (node.from < start)\n            break;\n        let heading = node.type.prop(headingProp);\n        if (heading == null)\n            continue;\n        let upto = findSectionEnd(node, heading);\n        if (upto > end)\n            return { from: end, to: upto };\n    }\n    return null;\n});\nfunction mkLang(parser) {\n    return new Language(data, parser, [headerIndent], \"markdown\");\n}\n/**\nLanguage support for strict CommonMark.\n*/\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nconst extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji, {\n        props: [\n            /*@__PURE__*/foldNodeProp.add({\n                Table: (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to })\n            })\n        ]\n    }]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\nfunction getCodeParser(languages, defaultLanguage) {\n    return (info) => {\n        if (info && languages) {\n            let found = null;\n            // Strip anything after whitespace\n            info = /\\S*/.exec(info)[0];\n            if (typeof languages == \"function\")\n                found = languages(info);\n            else\n                found = LanguageDescription.matchLanguageName(languages, info, true);\n            if (found instanceof LanguageDescription)\n                return found.support ? found.support.language.parser : ParseContext.getSkippingParser(found.load());\n            else if (found)\n                return found.parser;\n        }\n        return defaultLanguage ? defaultLanguage.parser : null;\n    };\n}\n\nclass Context {\n    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\n        this.node = node;\n        this.from = from;\n        this.to = to;\n        this.spaceBefore = spaceBefore;\n        this.spaceAfter = spaceAfter;\n        this.type = type;\n        this.item = item;\n    }\n    blank(maxWidth, trailing = true) {\n        let result = this.spaceBefore + (this.node.name == \"Blockquote\" ? \">\" : \"\");\n        if (maxWidth != null) {\n            while (result.length < maxWidth)\n                result += \" \";\n            return result;\n        }\n        else {\n            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)\n                result += \" \";\n            return result + (trailing ? this.spaceAfter : \"\");\n        }\n    }\n    marker(doc, add) {\n        let number = this.node.name == \"OrderedList\" ? String((+itemNumber(this.item, doc)[2] + add)) : \"\";\n        return this.spaceBefore + number + this.type + this.spaceAfter;\n    }\n}\nfunction getContext(node, doc) {\n    let nodes = [];\n    for (let cur = node; cur && cur.name != \"Document\"; cur = cur.parent) {\n        if (cur.name == \"ListItem\" || cur.name == \"Blockquote\" || cur.name == \"FencedCode\")\n            nodes.push(cur);\n    }\n    let context = [];\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        let node = nodes[i], match;\n        let line = doc.lineAt(node.from), startPos = node.from - line.from;\n        if (node.name == \"FencedCode\") {\n            context.push(new Context(node, startPos, startPos, \"\", \"\", \"\", null));\n        }\n        else if (node.name == \"Blockquote\" && (match = /^ *>( ?)/.exec(line.text.slice(startPos)))) {\n            context.push(new Context(node, startPos, startPos + match[0].length, \"\", match[1], \">\", null));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" &&\n            (match = /^( *)\\d+([.)])( *)/.exec(line.text.slice(startPos)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length >= 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, match[2], node));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" &&\n            (match = /^( *)([-+*])( {1,4}\\[[ xX]\\])?( +)/.exec(line.text.slice(startPos)))) {\n            let after = match[4], len = match[0].length;\n            if (after.length > 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            let type = match[2];\n            if (match[3])\n                type += match[3].replace(/[xX]/, ' ');\n            context.push(new Context(node.parent, startPos, startPos + len, match[1], after, type, node));\n        }\n    }\n    return context;\n}\nfunction itemNumber(item, doc) {\n    return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\nfunction renumberList(after, doc, changes, offset = 0) {\n    for (let prev = -1, node = after;;) {\n        if (node.name == \"ListItem\") {\n            let m = itemNumber(node, doc);\n            let number = +m[2];\n            if (prev >= 0) {\n                if (number != prev + 1)\n                    return;\n                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });\n            }\n            prev = number;\n        }\n        let next = node.nextSibling;\n        if (!next)\n            break;\n        node = next;\n    }\n}\nfunction normalizeIndent(content, state) {\n    let blank = /^[ \\t]*/.exec(content)[0].length;\n    if (!blank || state.facet(indentUnit) != \"\\t\")\n        return content;\n    let col = countColumn(content, 4, blank);\n    let space = \"\";\n    for (let i = col; i > 0;) {\n        if (i >= 4) {\n            space += \"\\t\";\n            i -= 4;\n        }\n        else {\n            space += \" \";\n            i--;\n        }\n    }\n    return space + content.slice(blank);\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\nconst insertNewlineContinueMarkup = ({ state, dispatch }) => {\n    let tree = syntaxTree(state), { doc } = state;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from))\n            return dont = { range };\n        let pos = range.from, line = doc.lineAt(pos);\n        let context = getContext(tree.resolveInner(pos, -1), doc);\n        while (context.length && context[context.length - 1].from > pos - line.from)\n            context.pop();\n        if (!context.length)\n            return dont = { range };\n        let inner = context[context.length - 1];\n        if (inner.to - inner.spaceAfter.length > pos - line.from)\n            return dont = { range };\n        let emptyLine = pos >= (inner.to - inner.spaceAfter.length) && !/\\S/.test(line.text.slice(inner.to));\n        // Empty line in list\n        if (inner.item && emptyLine) {\n            // First list item or blank line before: delete a level of markup\n            if (inner.node.firstChild.to >= pos ||\n                line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n                let next = context.length > 1 ? context[context.length - 2] : null;\n                let delTo, insert = \"\";\n                if (next && next.item) { // Re-add marker for the list at the next level\n                    delTo = line.from + next.from;\n                    insert = next.marker(doc, 1);\n                }\n                else {\n                    delTo = line.from + (next ? next.to : 0);\n                }\n                let changes = [{ from: delTo, to: pos, insert }];\n                if (inner.node.name == \"OrderedList\")\n                    renumberList(inner.item, doc, changes, -2);\n                if (next && next.node.name == \"OrderedList\")\n                    renumberList(next.item, doc, changes);\n                return { range: EditorSelection.cursor(delTo + insert.length), changes };\n            }\n            else { // Move this line down\n                let insert = \"\";\n                for (let i = 0, e = context.length - 2; i <= e; i++) {\n                    insert += context[i].blank(i < e ? countColumn(line.text, 4, context[i + 1].from) - insert.length : null, i < e);\n                }\n                insert = normalizeIndent(insert, state);\n                return { range: EditorSelection.cursor(pos + insert.length + 1),\n                    changes: { from: line.from, insert: insert + state.lineBreak } };\n            }\n        }\n        if (inner.node.name == \"Blockquote\" && emptyLine && line.from) {\n            let prevLine = doc.lineAt(line.from - 1), quoted = />\\s*$/.exec(prevLine.text);\n            // Two aligned empty quoted lines in a row\n            if (quoted && quoted.index == inner.from) {\n                let changes = state.changes([{ from: prevLine.from + quoted.index, to: prevLine.to },\n                    { from: line.from + inner.from, to: line.to }]);\n                return { range: range.map(changes), changes };\n            }\n        }\n        let changes = [];\n        if (inner.node.name == \"OrderedList\")\n            renumberList(inner.item, doc, changes);\n        let continued = inner.item && inner.item.from < line.from;\n        let insert = \"\";\n        // If not dedented\n        if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n            for (let i = 0, e = context.length - 1; i <= e; i++) {\n                insert += i == e && !continued ? context[i].marker(doc, 1)\n                    : context[i].blank(i < e ? countColumn(line.text, 4, context[i + 1].from) - insert.length : null);\n            }\n        }\n        let from = pos;\n        while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1)))\n            from--;\n        insert = normalizeIndent(insert, state);\n        changes.push({ from, to: pos, insert: state.lineBreak + insert });\n        return { range: EditorSelection.cursor(from + insert.length + 1), changes };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isMark(node) {\n    return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\nfunction contextNodeForDelete(tree, pos) {\n    let node = tree.resolveInner(pos, -1), scan = pos;\n    if (isMark(node)) {\n        scan = node.from;\n        node = node.parent;\n    }\n    for (let prev; prev = node.childBefore(scan);) {\n        if (isMark(prev)) {\n            scan = prev.from;\n        }\n        else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n            node = prev.lastChild;\n            scan = node.to;\n        }\n        else {\n            break;\n        }\n    }\n    return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\nconst deleteMarkupBackward = ({ state, dispatch }) => {\n    let tree = syntaxTree(state);\n    let dont = null, changes = state.changeByRange(range => {\n        let pos = range.from, { doc } = state;\n        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n            let line = doc.lineAt(pos);\n            let context = getContext(contextNodeForDelete(tree, pos), doc);\n            if (context.length) {\n                let inner = context[context.length - 1];\n                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\n                // Delete extra trailing space after markup\n                if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from)))\n                    return { range: EditorSelection.cursor(line.from + spaceEnd),\n                        changes: { from: line.from + spaceEnd, to: pos } };\n                if (pos - line.from == spaceEnd &&\n                    // Only apply this if we're on the line that has the\n                    // construct's syntax, or there's only indentation in the\n                    // target range\n                    (!inner.item || line.from <= inner.item.from || !/\\S/.test(line.text.slice(0, inner.to)))) {\n                    let start = line.from + inner.from;\n                    // Replace a list item marker with blank space\n                    if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to))) {\n                        let insert = inner.blank(countColumn(line.text, 4, inner.to) - countColumn(line.text, 4, inner.from));\n                        if (start == line.from)\n                            insert = normalizeIndent(insert, state);\n                        return { range: EditorSelection.cursor(start + insert.length),\n                            changes: { from: start, to: line.from + inner.to, insert } };\n                    }\n                    // Delete one level of indentation\n                    if (start < pos)\n                        return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };\n                }\n            }\n        }\n        return dont = { range };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete\" }));\n    return true;\n};\n\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\nconst markdownKeymap = [\n    { key: \"Enter\", run: insertNewlineContinueMarkup },\n    { key: \"Backspace\", run: deleteMarkupBackward }\n];\nconst htmlNoMatch = /*@__PURE__*/html({ matchClosingTags: false });\n/**\nMarkdown language support.\n*/\nfunction markdown(config = {}) {\n    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage, completeHTMLTags = true } = config;\n    if (!(parser instanceof MarkdownParser))\n        throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n    let extensions = config.extensions ? [config.extensions] : [];\n    let support = [htmlNoMatch.support], defaultCode;\n    if (defaultCodeLanguage instanceof LanguageSupport) {\n        support.push(defaultCodeLanguage.support);\n        defaultCode = defaultCodeLanguage.language;\n    }\n    else if (defaultCodeLanguage) {\n        defaultCode = defaultCodeLanguage;\n    }\n    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages, defaultCode) : undefined;\n    extensions.push(parseCode({ codeParser, htmlParser: htmlNoMatch.language.parser }));\n    if (addKeymap)\n        support.push(Prec.high(keymap.of(markdownKeymap)));\n    let lang = mkLang(parser.configure(extensions));\n    if (completeHTMLTags)\n        support.push(lang.data.of({ autocomplete: htmlTagCompletion }));\n    return new LanguageSupport(lang, support);\n}\nfunction htmlTagCompletion(context) {\n    let { state, pos } = context, m = /<[:\\-\\.\\w\\u00b7-\\uffff]*$/.exec(state.sliceDoc(pos - 25, pos));\n    if (!m)\n        return null;\n    let tree = syntaxTree(state).resolveInner(pos, -1);\n    while (tree && !tree.type.isTop) {\n        if (tree.name == \"CodeBlock\" || tree.name == \"FencedCode\" || tree.name == \"ProcessingInstructionBlock\" ||\n            tree.name == \"CommentBlock\" || tree.name == \"Link\" || tree.name == \"Image\")\n            return null;\n        tree = tree.parent;\n    }\n    return {\n        from: pos - m[0].length, to: pos,\n        options: htmlTagCompletions(),\n        validFor: /^<[:\\-\\.\\w\\u00b7-\\uffff]*$/\n    };\n}\nlet _tagCompletions = null;\nfunction htmlTagCompletions() {\n    if (_tagCompletions)\n        return _tagCompletions;\n    let result = htmlCompletionSource(new CompletionContext(EditorState.create({ extensions: htmlNoMatch }), 0, true));\n    return _tagCompletions = result ? result.options : [];\n}\n\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}