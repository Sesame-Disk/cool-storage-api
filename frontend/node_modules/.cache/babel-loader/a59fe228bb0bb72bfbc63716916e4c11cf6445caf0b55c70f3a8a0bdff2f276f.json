{"ast":null,"code":"import slugid from 'slugid';\nimport { CODE_BLOCK, CODE_LINE } from '../constants';\nimport { genCodeLangs } from '../helper';\nvar codeBlockRule = function codeBlockRule(element, parseChild) {\n  var nodeName = element.nodeName,\n    childNodes = element.childNodes;\n  if (nodeName === 'PRE') {\n    var children = Array.from(childNodes).filter(function (item) {\n      return item.nodeName === 'CODE';\n    });\n    var codeChild = children[0];\n    if (codeChild) {\n      var lang = codeChild.getAttribute('lang');\n      lang = genCodeLangs().find(function (item) {\n        return item.value === lang;\n      }) || 'plaintext';\n      return {\n        id: slugid.nice(),\n        language: lang,\n        type: CODE_BLOCK,\n        children: parseChild(children)\n      };\n    } else {\n      var _lang = 'plaintext';\n      var content = childNodes[0].textContent;\n      var textArr = content.split('\\n').filter(Boolean);\n      var _children = textArr.map(function (text) {\n        return {\n          id: slugid.nice(),\n          type: CODE_LINE,\n          children: [{\n            id: slugid.nice(),\n            text: text\n          }]\n        };\n      });\n      return {\n        id: slugid.nice(),\n        language: _lang,\n        type: CODE_BLOCK,\n        children: _children\n      };\n    }\n  }\n  if (nodeName === 'CODE' && element.parentElement.nodeName === 'PRE') {\n    var childIsP = Array.from(childNodes).every(function (n) {\n      return n.nodeName === 'P';\n    });\n    if (childIsP) {\n      return Array.from(childNodes).map(function (n) {\n        return {\n          id: slugid.nice(),\n          type: CODE_LINE,\n          children: [{\n            id: slugid.nice(),\n            text: n.textContent\n          }]\n        };\n      });\n    }\n    var _content = element.textContent;\n    var hasNewLine = _content.indexOf('\\n') > -1;\n    if (!hasNewLine) {\n      return {\n        id: slugid.nice(),\n        type: CODE_LINE,\n        children: [{\n          id: slugid.nice(),\n          text: element.textContent\n        }]\n      };\n    }\n    var codes = _content.slugid('\\n').filter(Boolean);\n    return codes.map(function (item) {\n      return {\n        id: slugid.nice(),\n        type: CODE_LINE,\n        children: [{\n          id: slugid.nice(),\n          text: item\n        }]\n      };\n    });\n  }\n  return;\n};\nexport default codeBlockRule;","map":{"version":3,"names":["slugid","CODE_BLOCK","CODE_LINE","genCodeLangs","codeBlockRule","element","parseChild","nodeName","childNodes","children","Array","from","filter","item","codeChild","lang","getAttribute","find","value","id","nice","language","type","content","textContent","textArr","split","Boolean","map","text","parentElement","childIsP","every","n","hasNewLine","indexOf","codes"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/slate-convert/html-to-slate/rules/code-block.js"],"sourcesContent":["import slugid from 'slugid';\nimport { CODE_BLOCK, CODE_LINE } from '../constants';\nimport { genCodeLangs } from '../helper';\nconst codeBlockRule = (element, parseChild) => {\n  const {\n    nodeName,\n    childNodes\n  } = element;\n  if (nodeName === 'PRE') {\n    const children = Array.from(childNodes).filter(item => item.nodeName === 'CODE');\n    let codeChild = children[0];\n    if (codeChild) {\n      let lang = codeChild.getAttribute('lang');\n      lang = genCodeLangs().find(item => item.value === lang) || 'plaintext';\n      return {\n        id: slugid.nice(),\n        language: lang,\n        type: CODE_BLOCK,\n        children: parseChild(children)\n      };\n    } else {\n      const lang = 'plaintext';\n      const content = childNodes[0].textContent;\n      const textArr = content.split('\\n').filter(Boolean);\n      const children = textArr.map(text => {\n        return {\n          id: slugid.nice(),\n          type: CODE_LINE,\n          children: [{\n            id: slugid.nice(),\n            text: text\n          }]\n        };\n      });\n      return {\n        id: slugid.nice(),\n        language: lang,\n        type: CODE_BLOCK,\n        children: children\n      };\n    }\n  }\n  if (nodeName === 'CODE' && element.parentElement.nodeName === 'PRE') {\n    const childIsP = Array.from(childNodes).every(n => n.nodeName === 'P');\n    if (childIsP) {\n      return Array.from(childNodes).map(n => {\n        return {\n          id: slugid.nice(),\n          type: CODE_LINE,\n          children: [{\n            id: slugid.nice(),\n            text: n.textContent\n          }]\n        };\n      });\n    }\n    const content = element.textContent;\n    const hasNewLine = content.indexOf('\\n') > -1;\n    if (!hasNewLine) {\n      return {\n        id: slugid.nice(),\n        type: CODE_LINE,\n        children: [{\n          id: slugid.nice(),\n          text: element.textContent\n        }]\n      };\n    }\n    const codes = content.slugid('\\n').filter(Boolean);\n    return codes.map(item => {\n      return {\n        id: slugid.nice(),\n        type: CODE_LINE,\n        children: [{\n          id: slugid.nice(),\n          text: item\n        }]\n      };\n    });\n  }\n  return;\n};\nexport default codeBlockRule;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}