{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { isPlainObject } from 'is-plain-object';\nimport { Operation, Editor, Transforms, Path } from '@seafile/slate';\nvar History = {\n  /**\r\n   * Check if a value is a `History` object.\r\n   */\n  isHistory: function isHistory(value) {\n    return isPlainObject(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || Operation.isOperationList(value.redos[0].operations)) && (value.undos.length === 0 || Operation.isOperationList(value.undos[0].operations));\n  }\n};\n\n/**\r\n * Weakmaps for attaching state to the editor.\r\n */\n\nvar HISTORY = new WeakMap();\nvar SAVING = new WeakMap();\nvar MERGING = new WeakMap(); // eslint-disable-next-line no-redeclare\n\nvar HistoryEditor = {\n  /**\r\n   * Check if a value is a `HistoryEditor` object.\r\n   */\n  isHistoryEditor: function isHistoryEditor(value) {\n    return History.isHistory(value.history) && Editor.isEditor(value);\n  },\n  /**\r\n   * Get the merge flag's current value.\r\n   */\n  isMerging: function isMerging(editor) {\n    return MERGING.get(editor);\n  },\n  /**\r\n   * Get the saving flag's current value.\r\n   */\n  isSaving: function isSaving(editor) {\n    return SAVING.get(editor);\n  },\n  /**\r\n   * Redo to the previous saved state.\r\n   */\n  redo: function redo(editor) {\n    editor.redo();\n  },\n  /**\r\n   * Undo to the previous saved state.\r\n   */\n  undo: function undo(editor) {\n    editor.undo();\n  },\n  /**\r\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\r\n   * the new operations into previous save point in the history.\r\n   */\n  withoutMerging: function withoutMerging(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, false);\n    fn();\n    MERGING.set(editor, prev);\n  },\n  /**\r\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\r\n   * their operations into the history.\r\n   */\n  withoutSaving: function withoutSaving(editor, fn) {\n    var prev = HistoryEditor.isSaving(editor);\n    SAVING.set(editor, false);\n    fn();\n    SAVING.set(editor, prev);\n  }\n};\n\n/**\r\n * The `withHistory` plugin keeps track of the operation history of a Slate\r\n * editor as operations are applied to it, using undo and redo stacks.\r\n *\r\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\r\n * this plugin.\r\n *\r\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\r\n */\n\nvar withHistory = function withHistory(editor) {\n  var e = editor;\n  var apply = e.apply;\n  e.history = {\n    undos: [],\n    redos: []\n  };\n  e.redo = function () {\n    var history = e.history;\n    var redos = history.redos;\n    if (redos.length > 0) {\n      var batch = redos[redos.length - 1];\n      if (batch.selectionBefore) {\n        Transforms.setSelection(e, batch.selectionBefore);\n      }\n      HistoryEditor.withoutSaving(e, function () {\n        Editor.withoutNormalizing(e, function () {\n          var _iterator = _createForOfIteratorHelper(batch.operations),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var op = _step.value;\n              e.apply(op);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        });\n      });\n      history.redos.pop();\n      history.undos.push(batch);\n    }\n  };\n  e.undo = function () {\n    var history = e.history;\n    var undos = history.undos;\n    if (undos.length > 0) {\n      var batch = undos[undos.length - 1];\n      HistoryEditor.withoutSaving(e, function () {\n        Editor.withoutNormalizing(e, function () {\n          var inverseOps = batch.operations.map(Operation.inverse).reverse();\n          var _iterator2 = _createForOfIteratorHelper(inverseOps),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var op = _step2.value;\n              e.apply(op);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          if (batch.selectionBefore) {\n            Transforms.setSelection(e, batch.selectionBefore);\n          }\n        });\n      });\n      history.redos.push(batch);\n      history.undos.pop();\n    }\n  };\n  e.apply = function (op) {\n    var operations = e.operations,\n      history = e.history;\n    var undos = history.undos;\n    var lastBatch = undos[undos.length - 1];\n    var lastOp = lastBatch && lastBatch.operations[lastBatch.operations.length - 1];\n    var save = HistoryEditor.isSaving(e);\n    var merge = HistoryEditor.isMerging(e);\n    if (save == null) {\n      save = shouldSave(op);\n    }\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false;\n        } else if (operations.length !== 0) {\n          merge = true;\n        } else {\n          merge = shouldMerge(op, lastOp);\n        }\n      }\n      if (lastBatch && merge) {\n        lastBatch.operations.push(op);\n      } else {\n        var batch = {\n          operations: [op],\n          selectionBefore: e.selection\n        };\n        undos.push(batch);\n      }\n      while (undos.length > 100) {\n        undos.shift();\n      }\n      history.redos = [];\n    }\n    apply(op);\n  };\n  return e;\n};\n/**\r\n * Check whether to merge an operation into the previous operation.\r\n */\n\nvar shouldMerge = function shouldMerge(op, prev) {\n  if (prev && op.type === 'insert_text' && prev.type === 'insert_text' && op.offset === prev.offset + prev.text.length && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n  if (prev && op.type === 'remove_text' && prev.type === 'remove_text' && op.offset + op.text.length === prev.offset && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n  return false;\n};\n/**\r\n * Check whether an operation needs to be saved to the history.\r\n */\n\nvar shouldSave = function shouldSave(op, prev) {\n  if (op.type === 'set_selection') {\n    return false;\n  }\n  return true;\n};\nexport { HISTORY, History, HistoryEditor, MERGING, SAVING, withHistory };","map":{"version":3,"names":["History","isHistory","value","isPlainObject","Array","isArray","redos","undos","length","Operation","isOperationList","operations","HISTORY","WeakMap","SAVING","MERGING","HistoryEditor","isHistoryEditor","history","Editor","isEditor","isMerging","editor","get","isSaving","redo","undo","withoutMerging","fn","prev","set","withoutSaving","withHistory","e","apply","batch","selectionBefore","Transforms","setSelection","withoutNormalizing","_iterator","_createForOfIteratorHelper","_step","s","n","done","op","err","f","pop","push","inverseOps","map","inverse","reverse","_iterator2","_step2","lastBatch","lastOp","save","merge","shouldSave","shouldMerge","selection","shift","type","offset","text","Path","equals","path"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-history/src/history.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-history/src/history-editor.ts","/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/slate-history/src/with-history.ts"],"sourcesContent":["import { isPlainObject } from 'is-plain-object'\nimport { Operation, Range } from '@seafile/slate'\n\ninterface Batch {\n  operations: Operation[]\n  selectionBefore: Range | null\n}\n\n/**\n * `History` objects hold all of the operations that are applied to a value, so\n * they can be undone or redone as necessary.\n */\n\nexport interface History {\n  redos: Batch[]\n  undos: Batch[]\n}\n\n// eslint-disable-next-line no-redeclare\nexport const History = {\n  /**\n   * Check if a value is a `History` object.\n   */\n\n  isHistory(value: any): value is History {\n    return (\n      isPlainObject(value) &&\n      Array.isArray(value.redos) &&\n      Array.isArray(value.undos) &&\n      (value.redos.length === 0 ||\n        Operation.isOperationList(value.redos[0].operations)) &&\n      (value.undos.length === 0 ||\n        Operation.isOperationList(value.undos[0].operations))\n    )\n  },\n}\n","import { BaseEditor, Editor } from '@seafile/slate'\nimport { History } from './history'\n\n/**\n * Weakmaps for attaching state to the editor.\n */\n\nexport const HISTORY = new WeakMap<Editor, History>()\nexport const SAVING = new WeakMap<Editor, boolean | undefined>()\nexport const MERGING = new WeakMap<Editor, boolean | undefined>()\n\n/**\n * `HistoryEditor` contains helpers for history-enabled editors.\n */\n\nexport interface HistoryEditor extends BaseEditor {\n  history: History\n  undo: () => void\n  redo: () => void\n}\n\n// eslint-disable-next-line no-redeclare\nexport const HistoryEditor = {\n  /**\n   * Check if a value is a `HistoryEditor` object.\n   */\n\n  isHistoryEditor(value: any): value is HistoryEditor {\n    return History.isHistory(value.history) && Editor.isEditor(value)\n  },\n\n  /**\n   * Get the merge flag's current value.\n   */\n\n  isMerging(editor: HistoryEditor): boolean | undefined {\n    return MERGING.get(editor)\n  },\n\n  /**\n   * Get the saving flag's current value.\n   */\n\n  isSaving(editor: HistoryEditor): boolean | undefined {\n    return SAVING.get(editor)\n  },\n\n  /**\n   * Redo to the previous saved state.\n   */\n\n  redo(editor: HistoryEditor): void {\n    editor.redo()\n  },\n\n  /**\n   * Undo to the previous saved state.\n   */\n\n  undo(editor: HistoryEditor): void {\n    editor.undo()\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\n   * the new operations into previous save point in the history.\n   */\n\n  withoutMerging(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isMerging(editor)\n    MERGING.set(editor, false)\n    fn()\n    MERGING.set(editor, prev)\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\n   * their operations into the history.\n   */\n\n  withoutSaving(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isSaving(editor)\n    SAVING.set(editor, false)\n    fn()\n    SAVING.set(editor, prev)\n  },\n}\n","import { Editor, Operation, Path, Range, Transforms } from '@seafile/slate'\n\nimport { HistoryEditor } from './history-editor'\n\n/**\n * The `withHistory` plugin keeps track of the operation history of a Slate\n * editor as operations are applied to it, using undo and redo stacks.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\n\nexport const withHistory = <T extends Editor>(editor: T) => {\n  const e = editor as T & HistoryEditor\n  const { apply } = e\n  e.history = { undos: [], redos: [] }\n\n  e.redo = () => {\n    const { history } = e\n    const { redos } = history\n\n    if (redos.length > 0) {\n      const batch = redos[redos.length - 1]\n\n      if (batch.selectionBefore) {\n        Transforms.setSelection(e, batch.selectionBefore)\n      }\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          for (const op of batch.operations) {\n            e.apply(op)\n          }\n        })\n      })\n\n      history.redos.pop()\n      history.undos.push(batch)\n    }\n  }\n\n  e.undo = () => {\n    const { history } = e\n    const { undos } = history\n\n    if (undos.length > 0) {\n      const batch = undos[undos.length - 1]\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          const inverseOps = batch.operations.map(Operation.inverse).reverse()\n\n          for (const op of inverseOps) {\n            e.apply(op)\n          }\n          if (batch.selectionBefore) {\n            Transforms.setSelection(e, batch.selectionBefore)\n          }\n        })\n      })\n\n      history.redos.push(batch)\n      history.undos.pop()\n    }\n  }\n\n  e.apply = (op: Operation) => {\n    const { operations, history } = e\n    const { undos } = history\n    const lastBatch = undos[undos.length - 1]\n    const lastOp =\n      lastBatch && lastBatch.operations[lastBatch.operations.length - 1]\n    let save = HistoryEditor.isSaving(e)\n    let merge = HistoryEditor.isMerging(e)\n\n    if (save == null) {\n      save = shouldSave(op, lastOp)\n    }\n\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false\n        } else if (operations.length !== 0) {\n          merge = true\n        } else {\n          merge = shouldMerge(op, lastOp)\n        }\n      }\n\n      if (lastBatch && merge) {\n        lastBatch.operations.push(op)\n      } else {\n        const batch = {\n          operations: [op],\n          selectionBefore: e.selection,\n        }\n        undos.push(batch)\n      }\n\n      while (undos.length > 100) {\n        undos.shift()\n      }\n\n      history.redos = []\n    }\n\n    apply(op)\n  }\n\n  return e\n}\n\n/**\n * Check whether to merge an operation into the previous operation.\n */\n\nconst shouldMerge = (op: Operation, prev: Operation | undefined): boolean => {\n  if (\n    prev &&\n    op.type === 'insert_text' &&\n    prev.type === 'insert_text' &&\n    op.offset === prev.offset + prev.text.length &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  if (\n    prev &&\n    op.type === 'remove_text' &&\n    prev.type === 'remove_text' &&\n    op.offset + op.text.length === prev.offset &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check whether an operation needs to be saved to the history.\n */\n\nconst shouldSave = (op: Operation, prev: Operation | undefined): boolean => {\n  if (op.type === 'set_selection') {\n    return false\n  }\n\n  return true\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}