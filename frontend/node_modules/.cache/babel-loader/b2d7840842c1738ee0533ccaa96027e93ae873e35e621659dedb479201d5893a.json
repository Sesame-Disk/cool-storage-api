{"ast":null,"code":"import _toConsumableArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nvar _excluded = [\"at\"];\nimport { Editor, Text, Path, Span, Element, Node, Range } from '@seafile/slate';\nimport { ReactEditor } from '@seafile/slate-react';\nimport { match } from '../utils';\nimport ObjectUtils from '../../../utils/object-utils';\nimport { CODE_LINE } from '../../constants';\n\n// options\nexport var getQueryOptions = function getQueryOptions(editor, options) {\n  var _match = options.match,\n    block = options.block;\n  var newMatch = undefined;\n  if (_match || block) {\n    newMatch = function newMatch(n, path) {\n      return match(n, path, _match) && (!block || Editor.isBlock(editor, n));\n    };\n  }\n  return _objectSpread(_objectSpread({}, options), {}, {\n    match: newMatch\n  });\n};\nexport var findPath = function findPath(editor, node, defaultPath) {\n  try {\n    return ReactEditor.findPath(editor, node);\n  } catch (_unused) {\n    return defaultPath;\n  }\n};\n\n// get node\nexport var getNode = function getNode(editor, path) {\n  var node = null;\n  try {\n    node = Node.get(editor, path);\n  } catch (err) {\n    node = null;\n  }\n  return node;\n};\nexport var getNodeType = function getNodeType(node) {\n  return Element.isElement(node) ? node.type : '';\n};\nexport var getNodeById = function getNodeById(nodes, nodeId) {\n  var node;\n  for (var i = 0; i < nodes.length; i++) {\n    var currentNode = nodes[i];\n    if (currentNode.id === nodeId) {\n      node = currentNode;\n      break;\n    }\n    var childrenNodes = currentNode.children;\n    if (!Array.isArray(childrenNodes)) continue;\n    var childNode = childrenNodes.find(function (node) {\n      return node.id === nodeId;\n    });\n    if (childNode) {\n      node = childNode;\n      break;\n    }\n    childNode = getNodeById(childrenNodes, nodeId);\n    if (!childNode) continue;\n    node = childNode;\n    break;\n  }\n  return node;\n};\nexport var isTextNode = function isTextNode(node) {\n  if (!node) return false;\n  if (!ObjectUtils.hasProperty(node, 'children') && ObjectUtils.hasProperty(node, 'text')) return true;\n};\nexport var getParentNode = function getParentNode(nodes, nodeId) {\n  var parentNode;\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var childrenNodes = node.children;\n    if (!Array.isArray(childrenNodes)) continue;\n    if (childrenNodes.find(function (node) {\n      return node.id === nodeId;\n    })) {\n      parentNode = node;\n    } else {\n      parentNode = getParentNode(childrenNodes, nodeId);\n    }\n    if (!parentNode) continue;\n    break;\n  }\n  return parentNode;\n};\nexport var getNodes = function getNodes(node, options) {\n  return Node.nodes(node, options);\n};\nexport var getCommonNode = function getCommonNode(root, path, ancestor) {\n  return Node.common(root, path, ancestor);\n};\nexport var getSelectedNodeByType = function getSelectedNodeByType(editor, type) {\n  var match = function match(n) {\n    return getNodeType(n) === type;\n  };\n  var _Editor$nodes = Editor.nodes(editor, {\n      match: match,\n      universal: true\n    }),\n    _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n    nodeEntry = _Editor$nodes2[0];\n  return nodeEntry ? nodeEntry[0] : null;\n};\nexport var getSelectedNodeByTypes = function getSelectedNodeByTypes(editor, types) {\n  var match = function match(n) {\n    return types.includes(getNodeType(n));\n  };\n  var _Editor$nodes3 = Editor.nodes(editor, {\n      match: match,\n      universal: true\n    }),\n    _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1),\n    nodeEntry = _Editor$nodes4[0];\n  return nodeEntry ? nodeEntry[0] : null;\n};\nexport var getSelectedNodeEntryByType = function getSelectedNodeEntryByType(editor, type) {\n  var match = function match(n) {\n    return getNodeType(n) === type;\n  };\n  var _Editor$nodes5 = Editor.nodes(editor, {\n      match: match,\n      universal: false\n    }),\n    _Editor$nodes6 = _slicedToArray(_Editor$nodes5, 1),\n    nodeEntry = _Editor$nodes6[0];\n  return nodeEntry ? nodeEntry : null;\n};\nexport var getNodeEntries = function getNodeEntries(editor, options) {\n  return Editor.nodes(editor, getQueryOptions(editor, options));\n};\nexport var getEditorString = function getEditorString(editor, at, options) {\n  if (!at) return '';\n  try {\n    return Editor.string(editor, at, options);\n  } catch (error) {\n    return '';\n  }\n};\n\n// children & child\nexport var getChildren = function getChildren(nodeEntry) {\n  var _nodeEntry = _slicedToArray(nodeEntry, 2),\n    node = _nodeEntry[0],\n    path = _nodeEntry[1];\n  if (Element.isAncestor(node)) {\n    var children = node.children;\n    return children.map(function (child, index) {\n      var childPath = path.concat([index]);\n      return [child, childPath];\n    });\n  }\n  return [];\n};\nexport var getLastChild = function getLastChild(nodeEntry) {\n  var _nodeEntry2 = _slicedToArray(nodeEntry, 2),\n    node = _nodeEntry2[0],\n    path = _nodeEntry2[1];\n  if (Text.isText(node)) return null;\n  if (!node.children.length) return null;\n  var children = node.children;\n  return [children[children.length - 1], path.concat([children.length - 1])];\n};\nexport var getDeepInlineChildren = function getDeepInlineChildren(editor, _ref) {\n  var children = _ref.children;\n  var inlineChildren = [];\n  var _iterator = _createForOfIteratorHelper(children),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var child = _step.value;\n      if (Editor.isBlock(editor, child[0])) {\n        inlineChildren.push.apply(inlineChildren, _toConsumableArray(getDeepInlineChildren(editor, {\n          children: getChildren(child)\n        })));\n      } else {\n        inlineChildren.push(child);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return inlineChildren;\n};\nexport var getLastChildPath = function getLastChildPath(nodeEntry) {\n  var lastChild = getLastChild(nodeEntry);\n  if (!lastChild) return nodeEntry[1].concat([-1]);\n  return lastChild[1];\n};\nexport var getPreviousPath = function getPreviousPath(path) {\n  if (path.length === 0) return;\n  var last = path[path.length - 1];\n  if (last <= 0) return;\n  return path.slice(0, -1).concat(last - 1);\n};\nexport var isLastChild = function isLastChild(nodeEntry, childPath) {\n  var lastChildPath = getLastChildPath(nodeEntry);\n  return Path.equals(lastChildPath, childPath);\n};\nexport var getSelectedElems = function getSelectedElems(editor) {\n  var elems = [];\n  var nodeEntries = Editor.nodes(editor, {\n    universal: true\n  });\n  var _iterator2 = _createForOfIteratorHelper(nodeEntries),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var nodeEntry = _step2.value;\n      var _nodeEntry3 = _slicedToArray(nodeEntry, 1),\n        node = _nodeEntry3[0];\n      if (Element.isElement(node)) elems.push(node);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return elems;\n};\n\n// siblings\nexport var getNextSiblingNodes = function getNextSiblingNodes(ancestorEntry, path) {\n  var _ancestorEntry = _slicedToArray(ancestorEntry, 2),\n    ancestor = _ancestorEntry[0],\n    ancestorPath = _ancestorEntry[1];\n  var leafIndex = path[ancestorPath.length];\n  var siblings = [];\n  var ancestorChildren = ancestor.children;\n  if (leafIndex + 1 < ancestor.children.length) {\n    for (var i = leafIndex + 1; i < ancestor.children.length; i++) {\n      siblings.push(ancestorChildren[i]);\n    }\n  }\n  return siblings;\n};\n\n// parent\nexport var getAboveNode = function getAboveNode(editor, options) {\n  return Editor.above(editor, getQueryOptions(editor, options));\n};\nexport var getAboveBlockNode = function getAboveBlockNode(editor, options) {\n  return getAboveNode(editor, _objectSpread(_objectSpread({}, options), {}, {\n    block: true\n  }));\n};\nexport var getPrevNode = function getPrevNode(editor) {\n  var lowerNodeEntry = getAboveNode(editor, {\n    mode: 'lowest',\n    match: function match(n) {\n      return Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n  });\n  var highNodeEntry = getAboveNode(editor, {\n    mode: 'highest',\n    match: function match(n) {\n      return Element.isElement(n) && Editor.isBlock(editor, n);\n    }\n  });\n  if (!lowerNodeEntry || !highNodeEntry) return null;\n  var _highNodeEntry = _slicedToArray(highNodeEntry, 2),\n    heightNode = _highNodeEntry[0],\n    heightPath = _highNodeEntry[1];\n  var _lowerNodeEntry = _slicedToArray(lowerNodeEntry, 2),\n    lowerNode = _lowerNodeEntry[0],\n    lowerPath = _lowerNodeEntry[1];\n  var prevNode = null;\n  try {\n    prevNode = Editor.previous(editor, {\n      at: lowerPath,\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    });\n  } catch (error) {\n    prevNode = null;\n  }\n  if (lowerNode.id !== heightNode.id && !prevNode) {\n    try {\n      prevNode = Editor.previous(editor, {\n        at: heightPath,\n        match: function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n      });\n    } catch (error) {\n      prevNode = null;\n    }\n  }\n  return prevNode;\n};\nexport var getCurrentNode = function getCurrentNode(editor) {\n  if (!editor.selection) return null;\n  var _Editor$nodes7 = Editor.nodes(editor, {\n      at: editor.selection,\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      },\n      mode: 'lowest'\n    }),\n    _Editor$nodes8 = _slicedToArray(_Editor$nodes7, 1),\n    nodeEntry = _Editor$nodes8[0];\n  return nodeEntry || null;\n};\nexport var getNextNode = function getNextNode(editor) {\n  var _getAboveNode = getAboveNode(editor, {\n      mode: 'lowest',\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    }),\n    _getAboveNode2 = _slicedToArray(_getAboveNode, 2),\n    lowerNode = _getAboveNode2[0],\n    lowerPath = _getAboveNode2[1];\n  var _getAboveNode3 = getAboveNode(editor, {\n      mode: 'highest',\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    }),\n    _getAboveNode4 = _slicedToArray(_getAboveNode3, 2),\n    heightNode = _getAboveNode4[0],\n    heightPath = _getAboveNode4[1];\n  var nextNode = null;\n  try {\n    nextNode = Editor.next(editor, {\n      at: lowerPath,\n      match: function match(n) {\n        return Element.isElement(n) && Editor.isBlock(editor, n);\n      }\n    });\n  } catch (error) {\n    nextNode = null;\n  }\n  if (lowerNode.id !== heightNode.id && !nextNode) {\n    try {\n      nextNode = Editor.next(editor, {\n        at: heightPath,\n        match: function match(n) {\n          return Element.isElement(n) && Editor.isBlock(editor, n);\n        }\n      });\n    } catch (error) {\n      nextNode = null;\n    }\n  }\n  return nextNode;\n};\n\n// find node\nexport var findNode = function findNode(editor, options) {\n  var nodeEntries = Editor.nodes(editor, _objectSpread({\n    at: editor.selection || []\n  }, getQueryOptions(editor, options)));\n  var _nodeEntries = Array.from(nodeEntries);\n  if (_nodeEntries[0]) {\n    return _nodeEntries[0];\n  }\n  return undefined;\n};\nexport var findDescendant = function findDescendant(editor, options) {\n  var _options$at = options.at,\n    at = _options$at === void 0 ? editor.selection : _options$at,\n    _options$reverse = options.reverse,\n    reverse = _options$reverse === void 0 ? false : _options$reverse,\n    _options$voids = options.voids,\n    voids = _options$voids === void 0 ? false : _options$voids,\n    _match = options.match;\n  if (!at) return;\n  var from;\n  var to;\n  if (Span.isSpan(at)) {\n    var _at = _slicedToArray(at, 2);\n    from = _at[0];\n    to = _at[1];\n  } else if (Range.isRange(at)) {\n    var first = Editor.first(editor, at);\n    var last = Editor.last(editor, at);\n    from = reverse ? last : first;\n    to = reverse ? first : last;\n  }\n  var root = [editor, []];\n  if (Path.isPath(at)) {\n    root = Editor.node(editor, at);\n  }\n  var nodeEntries = Node.descendants(root[0], {\n    from: from,\n    to: to,\n    reverse: reverse,\n    pass: function pass(_ref2) {\n      var _ref4 = _slicedToArray(_ref2, 1),\n        n = _ref4[0];\n      return voids ? false : Editor.isVoid(editor, n);\n    }\n  });\n  var _iterator3 = _createForOfIteratorHelper(nodeEntries),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _step3$value = _slicedToArray(_step3.value, 2),\n        node = _step3$value[0],\n        path = _step3$value[1];\n      if (match(node, path, _match)) {\n        return [node, at.concat(path)];\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return undefined;\n};\n\n// is\nexport var isStartPoint = function isStartPoint(editor, point, at) {\n  return !!point && Editor.isStart(editor, point, at);\n};\nexport var isEndPoint = function isEndPoint(editor, point, at) {\n  return !!point && Editor.isEnd(editor, point, at);\n};\nexport var isBlockTextEmptyAfterSelection = function isBlockTextEmptyAfterSelection(editor) {\n  if (!editor.selection) return false;\n  var blockAbove = Editor.above(editor, {\n    block: true\n  });\n  if (!blockAbove) return false;\n  var cursor = editor.selection.focus;\n  var selectionParentEntry = Editor.parent(editor, editor.selection);\n  if (!selectionParentEntry) return false;\n  var _selectionParentEntry = _slicedToArray(selectionParentEntry, 2),\n    selectionParentPath = _selectionParentEntry[1];\n  if (!isEndPoint(editor, cursor, selectionParentPath)) return false;\n  var siblingNodes = getNextSiblingNodes(blockAbove, cursor.path);\n  if (siblingNodes.length) {\n    // 子节点包含 文本节点\n    var _iterator4 = _createForOfIteratorHelper(siblingNodes),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var siblingNode = _step4.value;\n        if (Text.isText(siblingNode) && siblingNode.text) {\n          return false;\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  } else {\n    return isEndPoint(editor, cursor, blockAbove[1]);\n  }\n  return true;\n};\nexport var isRangeAcrossBlocks = function isRangeAcrossBlocks(editor) {\n  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var at = _ref3.at,\n    options = _objectWithoutProperties(_ref3, _excluded);\n  if (!at) at = editor.selection;\n  if (!at) return;\n  var _Range$edges = Range.edges(at),\n    _Range$edges2 = _slicedToArray(_Range$edges, 2),\n    start = _Range$edges2[0],\n    end = _Range$edges2[1];\n  var startBlock = getAboveBlockNode(editor, _objectSpread({\n    at: start\n  }, options));\n  var endBlock = getAboveBlockNode(editor, _objectSpread({\n    at: end\n  }, options));\n  if (!startBlock && !endBlock) return;\n  if (!startBlock || !endBlock) return true;\n  return !Path.equals(startBlock[1], endBlock[1]);\n};\nexport var isAncestorEmpty = function isAncestorEmpty(editor, node) {\n  return !Node.string(node) && !node.children.some(function (n) {\n    return Editor.isInline(editor, n);\n  });\n};\nexport var isBlockAboveEmpty = function isBlockAboveEmpty(editor) {\n  var _getAboveBlockNode;\n  var block = (_getAboveBlockNode = getAboveBlockNode(editor)) === null || _getAboveBlockNode === void 0 ? void 0 : _getAboveBlockNode[0];\n  if (!block) return false;\n  return isAncestorEmpty(editor, block);\n};\nexport var isSelectionAtBlockStart = function isSelectionAtBlockStart(editor, options) {\n  var selection = editor.selection;\n  if (!selection) return false;\n  var nodeEntry = getAboveBlockNode(editor, options);\n  var path = nodeEntry === null || nodeEntry === void 0 ? void 0 : nodeEntry[1];\n  if ((nodeEntry === null || nodeEntry === void 0 ? void 0 : nodeEntry[0].type) === CODE_LINE) {\n    path = [path[0]];\n  }\n  if (!path) return false;\n  return isStartPoint(editor, selection.focus, path) || Range.isExpanded(editor.selection) && isStartPoint(editor, selection.anchor, path);\n};\nexport var isSelectionAtBlockEnd = function isSelectionAtBlockEnd(editor, options) {\n  var _getAboveBlockNode2, _editor$selection;\n  var path = (_getAboveBlockNode2 = getAboveBlockNode(editor, options)) === null || _getAboveBlockNode2 === void 0 ? void 0 : _getAboveBlockNode2[1];\n  return !!path && isEndPoint(editor, (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.focus, path);\n};\nexport var isLastNode = function isLastNode(editor, node) {\n  var editorChildren = editor.children || [];\n  var editorChildrenLength = editorChildren.length;\n  return editorChildren[editorChildrenLength - 1] === node;\n};\nexport var isHasImg = function isHasImg(editor) {\n  var hasImg = false;\n  var _iterator5 = _createForOfIteratorHelper(Editor.nodes(editor, {\n      at: editor.selection\n    })),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var _step5$value = _slicedToArray(_step5.value, 1),\n        node = _step5$value[0];\n      if ((node === null || node === void 0 ? void 0 : node.type) === 'image') {\n        hasImg = true;\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  return hasImg;\n};\nexport var isCurrentLineEmpty = function isCurrentLineEmpty(editor) {\n  var selection = editor.selection;\n  if (!selection || !ReactEditor.isFocused(editor)) return false;\n  var _Editor$node = Editor.node(editor, selection.focus.path.slice(0, -1)),\n    _Editor$node2 = _slicedToArray(_Editor$node, 1),\n    node = _Editor$node2[0];\n  if (Element.isElement(node)) {\n    return node.children.every(function (child) {\n      return Element.isElement(child) ? false : Node.string(child) === '';\n    });\n  }\n  return true;\n};\nexport var isCurrentLineHasText = function isCurrentLineHasText(node) {\n  return Node.string(node).trim() !== '';\n};","map":{"version":3,"names":["_objectWithoutProperties","_objectSpread","_excluded","Editor","Text","Path","Span","Element","Node","Range","ReactEditor","match","ObjectUtils","CODE_LINE","getQueryOptions","editor","options","_match","block","newMatch","undefined","n","path","isBlock","findPath","node","defaultPath","_unused","getNode","get","err","getNodeType","isElement","type","getNodeById","nodes","nodeId","i","length","currentNode","id","childrenNodes","children","Array","isArray","childNode","find","isTextNode","hasProperty","getParentNode","parentNode","getNodes","getCommonNode","root","ancestor","common","getSelectedNodeByType","_Editor$nodes","universal","_Editor$nodes2","_slicedToArray","nodeEntry","getSelectedNodeByTypes","types","includes","_Editor$nodes3","_Editor$nodes4","getSelectedNodeEntryByType","_Editor$nodes5","_Editor$nodes6","getNodeEntries","getEditorString","at","string","error","getChildren","_nodeEntry","isAncestor","map","child","index","childPath","concat","getLastChild","_nodeEntry2","isText","getDeepInlineChildren","_ref","inlineChildren","_iterator","_createForOfIteratorHelper","_step","s","done","value","push","apply","_toConsumableArray","e","f","getLastChildPath","lastChild","getPreviousPath","last","slice","isLastChild","lastChildPath","equals","getSelectedElems","elems","nodeEntries","_iterator2","_step2","_nodeEntry3","getNextSiblingNodes","ancestorEntry","_ancestorEntry","ancestorPath","leafIndex","siblings","ancestorChildren","getAboveNode","above","getAboveBlockNode","getPrevNode","lowerNodeEntry","mode","highNodeEntry","_highNodeEntry","heightNode","heightPath","_lowerNodeEntry","lowerNode","lowerPath","prevNode","previous","getCurrentNode","selection","_Editor$nodes7","_Editor$nodes8","getNextNode","_getAboveNode","_getAboveNode2","_getAboveNode3","_getAboveNode4","nextNode","next","findNode","_nodeEntries","from","findDescendant","_options$at","_options$reverse","reverse","_options$voids","voids","to","isSpan","_at","isRange","first","isPath","descendants","pass","_ref2","_ref4","isVoid","_iterator3","_step3","_step3$value","isStartPoint","point","isStart","isEndPoint","isEnd","isBlockTextEmptyAfterSelection","blockAbove","cursor","focus","selectionParentEntry","parent","_selectionParentEntry","selectionParentPath","siblingNodes","_iterator4","_step4","siblingNode","text","isRangeAcrossBlocks","_ref3","arguments","_Range$edges","edges","_Range$edges2","start","end","startBlock","endBlock","isAncestorEmpty","some","isInline","isBlockAboveEmpty","_getAboveBlockNode","isSelectionAtBlockStart","isExpanded","anchor","isSelectionAtBlockEnd","_getAboveBlockNode2","_editor$selection","isLastNode","editorChildren","editorChildrenLength","isHasImg","hasImg","_iterator5","_step5","_step5$value","isCurrentLineEmpty","isFocused","_Editor$node","_Editor$node2","every","isCurrentLineHasText","trim"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/core/queries/index.js"],"sourcesContent":["import _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nconst _excluded = [\"at\"];\nimport { Editor, Text, Path, Span, Element, Node, Range } from '@seafile/slate';\nimport { ReactEditor } from '@seafile/slate-react';\nimport { match } from '../utils';\nimport ObjectUtils from '../../../utils/object-utils';\nimport { CODE_LINE } from '../../constants';\n\n// options\nexport const getQueryOptions = (editor, options) => {\n  const {\n    match: _match,\n    block\n  } = options;\n  let newMatch = undefined;\n  if (_match || block) {\n    newMatch = (n, path) => match(n, path, _match) && (!block || Editor.isBlock(editor, n));\n  }\n  return _objectSpread(_objectSpread({}, options), {}, {\n    match: newMatch\n  });\n};\nexport const findPath = (editor, node, defaultPath) => {\n  try {\n    return ReactEditor.findPath(editor, node);\n  } catch {\n    return defaultPath;\n  }\n};\n\n// get node\nexport const getNode = (editor, path) => {\n  let node = null;\n  try {\n    node = Node.get(editor, path);\n  } catch (err) {\n    node = null;\n  }\n  return node;\n};\nexport const getNodeType = node => {\n  return Element.isElement(node) ? node.type : '';\n};\nexport const getNodeById = (nodes, nodeId) => {\n  let node;\n  for (let i = 0; i < nodes.length; i++) {\n    const currentNode = nodes[i];\n    if (currentNode.id === nodeId) {\n      node = currentNode;\n      break;\n    }\n    const {\n      children: childrenNodes\n    } = currentNode;\n    if (!Array.isArray(childrenNodes)) continue;\n    let childNode = childrenNodes.find(node => node.id === nodeId);\n    if (childNode) {\n      node = childNode;\n      break;\n    }\n    childNode = getNodeById(childrenNodes, nodeId);\n    if (!childNode) continue;\n    node = childNode;\n    break;\n  }\n  return node;\n};\nexport const isTextNode = node => {\n  if (!node) return false;\n  if (!ObjectUtils.hasProperty(node, 'children') && ObjectUtils.hasProperty(node, 'text')) return true;\n};\nexport const getParentNode = (nodes, nodeId) => {\n  let parentNode;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const {\n      children: childrenNodes\n    } = node;\n    if (!Array.isArray(childrenNodes)) continue;\n    if (childrenNodes.find(node => node.id === nodeId)) {\n      parentNode = node;\n    } else {\n      parentNode = getParentNode(childrenNodes, nodeId);\n    }\n    if (!parentNode) continue;\n    break;\n  }\n  return parentNode;\n};\nexport const getNodes = (node, options) => {\n  return Node.nodes(node, options);\n};\nexport const getCommonNode = (root, path, ancestor) => {\n  return Node.common(root, path, ancestor);\n};\nexport const getSelectedNodeByType = (editor, type) => {\n  const match = n => getNodeType(n) === type;\n  const [nodeEntry] = Editor.nodes(editor, {\n    match,\n    universal: true\n  });\n  return nodeEntry ? nodeEntry[0] : null;\n};\nexport const getSelectedNodeByTypes = (editor, types) => {\n  const match = n => types.includes(getNodeType(n));\n  const [nodeEntry] = Editor.nodes(editor, {\n    match,\n    universal: true\n  });\n  return nodeEntry ? nodeEntry[0] : null;\n};\nexport const getSelectedNodeEntryByType = (editor, type) => {\n  const match = n => getNodeType(n) === type;\n  const [nodeEntry] = Editor.nodes(editor, {\n    match,\n    universal: false\n  });\n  return nodeEntry ? nodeEntry : null;\n};\nexport const getNodeEntries = (editor, options) => {\n  return Editor.nodes(editor, getQueryOptions(editor, options));\n};\nexport const getEditorString = (editor, at, options) => {\n  if (!at) return '';\n  try {\n    return Editor.string(editor, at, options);\n  } catch (error) {\n    return '';\n  }\n};\n\n// children & child\nexport const getChildren = nodeEntry => {\n  const [node, path] = nodeEntry;\n  if (Element.isAncestor(node)) {\n    const {\n      children\n    } = node;\n    return children.map((child, index) => {\n      const childPath = path.concat([index]);\n      return [child, childPath];\n    });\n  }\n  return [];\n};\nexport const getLastChild = nodeEntry => {\n  const [node, path] = nodeEntry;\n  if (Text.isText(node)) return null;\n  if (!node.children.length) return null;\n  const children = node.children;\n  return [children[children.length - 1], path.concat([children.length - 1])];\n};\nexport const getDeepInlineChildren = (editor, _ref) => {\n  let {\n    children\n  } = _ref;\n  const inlineChildren = [];\n  for (let child of children) {\n    if (Editor.isBlock(editor, child[0])) {\n      inlineChildren.push(...getDeepInlineChildren(editor, {\n        children: getChildren(child)\n      }));\n    } else {\n      inlineChildren.push(child);\n    }\n  }\n  return inlineChildren;\n};\nexport const getLastChildPath = nodeEntry => {\n  const lastChild = getLastChild(nodeEntry);\n  if (!lastChild) return nodeEntry[1].concat([-1]);\n  return lastChild[1];\n};\nexport const getPreviousPath = path => {\n  if (path.length === 0) return;\n  const last = path[path.length - 1];\n  if (last <= 0) return;\n  return path.slice(0, -1).concat(last - 1);\n};\nexport const isLastChild = (nodeEntry, childPath) => {\n  const lastChildPath = getLastChildPath(nodeEntry);\n  return Path.equals(lastChildPath, childPath);\n};\nexport const getSelectedElems = editor => {\n  const elems = [];\n  const nodeEntries = Editor.nodes(editor, {\n    universal: true\n  });\n  for (let nodeEntry of nodeEntries) {\n    const [node] = nodeEntry;\n    if (Element.isElement(node)) elems.push(node);\n  }\n  return elems;\n};\n\n// siblings\nexport const getNextSiblingNodes = (ancestorEntry, path) => {\n  const [ancestor, ancestorPath] = ancestorEntry;\n  const leafIndex = path[ancestorPath.length];\n  const siblings = [];\n  const ancestorChildren = ancestor.children;\n  if (leafIndex + 1 < ancestor.children.length) {\n    for (let i = leafIndex + 1; i < ancestor.children.length; i++) {\n      siblings.push(ancestorChildren[i]);\n    }\n  }\n  return siblings;\n};\n\n// parent\nexport const getAboveNode = (editor, options) => {\n  return Editor.above(editor, getQueryOptions(editor, options));\n};\nexport const getAboveBlockNode = (editor, options) => {\n  return getAboveNode(editor, _objectSpread(_objectSpread({}, options), {}, {\n    block: true\n  }));\n};\nexport const getPrevNode = editor => {\n  const lowerNodeEntry = getAboveNode(editor, {\n    mode: 'lowest',\n    match: n => Element.isElement(n) && Editor.isBlock(editor, n)\n  });\n  const highNodeEntry = getAboveNode(editor, {\n    mode: 'highest',\n    match: n => Element.isElement(n) && Editor.isBlock(editor, n)\n  });\n  if (!lowerNodeEntry || !highNodeEntry) return null;\n  const [heightNode, heightPath] = highNodeEntry;\n  const [lowerNode, lowerPath] = lowerNodeEntry;\n  let prevNode = null;\n  try {\n    prevNode = Editor.previous(editor, {\n      at: lowerPath,\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n)\n    });\n  } catch (error) {\n    prevNode = null;\n  }\n  if (lowerNode.id !== heightNode.id && !prevNode) {\n    try {\n      prevNode = Editor.previous(editor, {\n        at: heightPath,\n        match: n => Element.isElement(n) && Editor.isBlock(editor, n)\n      });\n    } catch (error) {\n      prevNode = null;\n    }\n  }\n  return prevNode;\n};\nexport const getCurrentNode = editor => {\n  if (!editor.selection) return null;\n  const [nodeEntry] = Editor.nodes(editor, {\n    at: editor.selection,\n    match: n => Element.isElement(n) && Editor.isBlock(editor, n),\n    mode: 'lowest'\n  });\n  return nodeEntry || null;\n};\nexport const getNextNode = editor => {\n  const [lowerNode, lowerPath] = getAboveNode(editor, {\n    mode: 'lowest',\n    match: n => Element.isElement(n) && Editor.isBlock(editor, n)\n  });\n  const [heightNode, heightPath] = getAboveNode(editor, {\n    mode: 'highest',\n    match: n => Element.isElement(n) && Editor.isBlock(editor, n)\n  });\n  let nextNode = null;\n  try {\n    nextNode = Editor.next(editor, {\n      at: lowerPath,\n      match: n => Element.isElement(n) && Editor.isBlock(editor, n)\n    });\n  } catch (error) {\n    nextNode = null;\n  }\n  if (lowerNode.id !== heightNode.id && !nextNode) {\n    try {\n      nextNode = Editor.next(editor, {\n        at: heightPath,\n        match: n => Element.isElement(n) && Editor.isBlock(editor, n)\n      });\n    } catch (error) {\n      nextNode = null;\n    }\n  }\n  return nextNode;\n};\n\n// find node\nexport const findNode = (editor, options) => {\n  const nodeEntries = Editor.nodes(editor, _objectSpread({\n    at: editor.selection || []\n  }, getQueryOptions(editor, options)));\n  const _nodeEntries = Array.from(nodeEntries);\n  if (_nodeEntries[0]) {\n    return _nodeEntries[0];\n  }\n  return undefined;\n};\nexport const findDescendant = (editor, options) => {\n  const {\n    at = editor.selection,\n    reverse = false,\n    voids = false,\n    match: _match\n  } = options;\n  if (!at) return;\n  let from;\n  let to;\n  if (Span.isSpan(at)) {\n    [from, to] = at;\n  } else if (Range.isRange(at)) {\n    const first = Editor.first(editor, at);\n    const last = Editor.last(editor, at);\n    from = reverse ? last : first;\n    to = reverse ? first : last;\n  }\n  let root = [editor, []];\n  if (Path.isPath(at)) {\n    root = Editor.node(editor, at);\n  }\n  const nodeEntries = Node.descendants(root[0], {\n    from,\n    to,\n    reverse,\n    pass: _ref2 => {\n      let [n] = _ref2;\n      return voids ? false : Editor.isVoid(editor, n);\n    }\n  });\n  for (const [node, path] of nodeEntries) {\n    if (match(node, path, _match)) {\n      return [node, at.concat(path)];\n    }\n  }\n  return undefined;\n};\n\n// is\nexport const isStartPoint = (editor, point, at) => {\n  return !!point && Editor.isStart(editor, point, at);\n};\nexport const isEndPoint = (editor, point, at) => {\n  return !!point && Editor.isEnd(editor, point, at);\n};\nexport const isBlockTextEmptyAfterSelection = editor => {\n  if (!editor.selection) return false;\n  const blockAbove = Editor.above(editor, {\n    block: true\n  });\n  if (!blockAbove) return false;\n  const cursor = editor.selection.focus;\n  const selectionParentEntry = Editor.parent(editor, editor.selection);\n  if (!selectionParentEntry) return false;\n  const [, selectionParentPath] = selectionParentEntry;\n  if (!isEndPoint(editor, cursor, selectionParentPath)) return false;\n  const siblingNodes = getNextSiblingNodes(blockAbove, cursor.path);\n  if (siblingNodes.length) {\n    // 子节点包含 文本节点\n    for (const siblingNode of siblingNodes) {\n      if (Text.isText(siblingNode) && siblingNode.text) {\n        return false;\n      }\n    }\n  } else {\n    return isEndPoint(editor, cursor, blockAbove[1]);\n  }\n  return true;\n};\nexport const isRangeAcrossBlocks = function (editor) {\n  let _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let {\n      at\n    } = _ref3,\n    options = _objectWithoutProperties(_ref3, _excluded);\n  if (!at) at = editor.selection;\n  if (!at) return;\n  const [start, end] = Range.edges(at);\n  const startBlock = getAboveBlockNode(editor, _objectSpread({\n    at: start\n  }, options));\n  const endBlock = getAboveBlockNode(editor, _objectSpread({\n    at: end\n  }, options));\n  if (!startBlock && !endBlock) return;\n  if (!startBlock || !endBlock) return true;\n  return !Path.equals(startBlock[1], endBlock[1]);\n};\nexport const isAncestorEmpty = (editor, node) => {\n  return !Node.string(node) && !node.children.some(n => Editor.isInline(editor, n));\n};\nexport const isBlockAboveEmpty = editor => {\n  var _getAboveBlockNode;\n  const block = (_getAboveBlockNode = getAboveBlockNode(editor)) === null || _getAboveBlockNode === void 0 ? void 0 : _getAboveBlockNode[0];\n  if (!block) return false;\n  return isAncestorEmpty(editor, block);\n};\nexport const isSelectionAtBlockStart = (editor, options) => {\n  const {\n    selection\n  } = editor;\n  if (!selection) return false;\n  const nodeEntry = getAboveBlockNode(editor, options);\n  let path = nodeEntry === null || nodeEntry === void 0 ? void 0 : nodeEntry[1];\n  if ((nodeEntry === null || nodeEntry === void 0 ? void 0 : nodeEntry[0].type) === CODE_LINE) {\n    path = [path[0]];\n  }\n  if (!path) return false;\n  return isStartPoint(editor, selection.focus, path) || Range.isExpanded(editor.selection) && isStartPoint(editor, selection.anchor, path);\n};\nexport const isSelectionAtBlockEnd = (editor, options) => {\n  var _getAboveBlockNode2, _editor$selection;\n  const path = (_getAboveBlockNode2 = getAboveBlockNode(editor, options)) === null || _getAboveBlockNode2 === void 0 ? void 0 : _getAboveBlockNode2[1];\n  return !!path && isEndPoint(editor, (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.focus, path);\n};\nexport const isLastNode = (editor, node) => {\n  const editorChildren = editor.children || [];\n  const editorChildrenLength = editorChildren.length;\n  return editorChildren[editorChildrenLength - 1] === node;\n};\nexport const isHasImg = editor => {\n  let hasImg = false;\n  for (const [node] of Editor.nodes(editor, {\n    at: editor.selection\n  })) {\n    if ((node === null || node === void 0 ? void 0 : node.type) === 'image') {\n      hasImg = true;\n    }\n  }\n  return hasImg;\n};\nexport const isCurrentLineEmpty = editor => {\n  const {\n    selection\n  } = editor;\n  if (!selection || !ReactEditor.isFocused(editor)) return false;\n  const [node] = Editor.node(editor, selection.focus.path.slice(0, -1));\n  if (Element.isElement(node)) {\n    return node.children.every(child => Element.isElement(child) ? false : Node.string(child) === '');\n  }\n  return true;\n};\nexport const isCurrentLineHasText = node => {\n  return Node.string(node).trim() !== '';\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}