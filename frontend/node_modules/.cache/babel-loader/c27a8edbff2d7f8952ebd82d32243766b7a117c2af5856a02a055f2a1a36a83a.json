{"ast":null,"code":"import _classCallCheck from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { CODE_POINTS as $, getSurrogatePairCodePoint, isControlCodePoint, isSurrogate, isSurrogatePair, isUndefinedCodePoint } from '../common/unicode.js';\nimport { ERR } from '../common/error-codes.js';\n//Const\nvar DEFAULT_BUFFER_WATERLINE = 1 << 16;\n//Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\nexport var Preprocessor = /*#__PURE__*/function () {\n  function Preprocessor(handler) {\n    _classCallCheck(this, Preprocessor);\n    this.handler = handler;\n    this.html = '';\n    this.pos = -1;\n    // NOTE: Initial `lastGapPos` is -2, to ensure `col` on initialisation is 0\n    this.lastGapPos = -2;\n    this.gapStack = [];\n    this.skipNextNewLine = false;\n    this.lastChunkWritten = false;\n    this.endOfChunkHit = false;\n    this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n    this.isEol = false;\n    this.lineStartPos = 0;\n    this.droppedBufferSize = 0;\n    this.line = 1;\n    //NOTE: avoid reporting errors twice on advance/retreat\n    this.lastErrOffset = -1;\n  }\n  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */\n  _createClass(Preprocessor, [{\n    key: \"col\",\n    get: function get() {\n      return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);\n    }\n  }, {\n    key: \"offset\",\n    get: function get() {\n      return this.droppedBufferSize + this.pos;\n    }\n  }, {\n    key: \"getError\",\n    value: function getError(code) {\n      var line = this.line,\n        col = this.col,\n        offset = this.offset;\n      return {\n        code: code,\n        startLine: line,\n        endLine: line,\n        startCol: col,\n        endCol: col,\n        startOffset: offset,\n        endOffset: offset\n      };\n    }\n  }, {\n    key: \"_err\",\n    value: function _err(code) {\n      if (this.handler.onParseError && this.lastErrOffset !== this.offset) {\n        this.lastErrOffset = this.offset;\n        this.handler.onParseError(this.getError(code));\n      }\n    }\n  }, {\n    key: \"_addGap\",\n    value: function _addGap() {\n      this.gapStack.push(this.lastGapPos);\n      this.lastGapPos = this.pos;\n    }\n  }, {\n    key: \"_processSurrogate\",\n    value: function _processSurrogate(cp) {\n      //NOTE: try to peek a surrogate pair\n      if (this.pos !== this.html.length - 1) {\n        var nextCp = this.html.charCodeAt(this.pos + 1);\n        if (isSurrogatePair(nextCp)) {\n          //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n          this.pos++;\n          //NOTE: add a gap that should be avoided during retreat\n          this._addGap();\n          return getSurrogatePairCodePoint(cp, nextCp);\n        }\n      }\n      //NOTE: we are at the end of a chunk, therefore we can't infer the surrogate pair yet.\n      else if (!this.lastChunkWritten) {\n        this.endOfChunkHit = true;\n        return $.EOF;\n      }\n      //NOTE: isolated surrogate\n      this._err(ERR.surrogateInInputStream);\n      return cp;\n    }\n  }, {\n    key: \"willDropParsedChunk\",\n    value: function willDropParsedChunk() {\n      return this.pos > this.bufferWaterline;\n    }\n  }, {\n    key: \"dropParsedChunk\",\n    value: function dropParsedChunk() {\n      if (this.willDropParsedChunk()) {\n        this.html = this.html.substring(this.pos);\n        this.lineStartPos -= this.pos;\n        this.droppedBufferSize += this.pos;\n        this.pos = 0;\n        this.lastGapPos = -2;\n        this.gapStack.length = 0;\n      }\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk, isLastChunk) {\n      if (this.html.length > 0) {\n        this.html += chunk;\n      } else {\n        this.html = chunk;\n      }\n      this.endOfChunkHit = false;\n      this.lastChunkWritten = isLastChunk;\n    }\n  }, {\n    key: \"insertHtmlAtCurrentPos\",\n    value: function insertHtmlAtCurrentPos(chunk) {\n      this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);\n      this.endOfChunkHit = false;\n    }\n  }, {\n    key: \"startsWith\",\n    value: function startsWith(pattern, caseSensitive) {\n      // Check if our buffer has enough characters\n      if (this.pos + pattern.length > this.html.length) {\n        this.endOfChunkHit = !this.lastChunkWritten;\n        return false;\n      }\n      if (caseSensitive) {\n        return this.html.startsWith(pattern, this.pos);\n      }\n      for (var i = 0; i < pattern.length; i++) {\n        var cp = this.html.charCodeAt(this.pos + i) | 0x20;\n        if (cp !== pattern.charCodeAt(i)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"peek\",\n    value: function peek(offset) {\n      var pos = this.pos + offset;\n      if (pos >= this.html.length) {\n        this.endOfChunkHit = !this.lastChunkWritten;\n        return $.EOF;\n      }\n      var code = this.html.charCodeAt(pos);\n      return code === $.CARRIAGE_RETURN ? $.LINE_FEED : code;\n    }\n  }, {\n    key: \"advance\",\n    value: function advance() {\n      this.pos++;\n      //NOTE: LF should be in the last column of the line\n      if (this.isEol) {\n        this.isEol = false;\n        this.line++;\n        this.lineStartPos = this.pos;\n      }\n      if (this.pos >= this.html.length) {\n        this.endOfChunkHit = !this.lastChunkWritten;\n        return $.EOF;\n      }\n      var cp = this.html.charCodeAt(this.pos);\n      //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n      if (cp === $.CARRIAGE_RETURN) {\n        this.isEol = true;\n        this.skipNextNewLine = true;\n        return $.LINE_FEED;\n      }\n      //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n      //must be ignored.\n      if (cp === $.LINE_FEED) {\n        this.isEol = true;\n        if (this.skipNextNewLine) {\n          // `line` will be bumped again in the recursive call.\n          this.line--;\n          this.skipNextNewLine = false;\n          this._addGap();\n          return this.advance();\n        }\n      }\n      this.skipNextNewLine = false;\n      if (isSurrogate(cp)) {\n        cp = this._processSurrogate(cp);\n      }\n      //OPTIMIZATION: first check if code point is in the common allowed\n      //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\n      //before going into detailed performance cost validation.\n      var isCommonValidRange = this.handler.onParseError === null || cp > 0x1f && cp < 0x7f || cp === $.LINE_FEED || cp === $.CARRIAGE_RETURN || cp > 0x9f && cp < 64976;\n      if (!isCommonValidRange) {\n        this._checkForProblematicCharacters(cp);\n      }\n      return cp;\n    }\n  }, {\n    key: \"_checkForProblematicCharacters\",\n    value: function _checkForProblematicCharacters(cp) {\n      if (isControlCodePoint(cp)) {\n        this._err(ERR.controlCharacterInInputStream);\n      } else if (isUndefinedCodePoint(cp)) {\n        this._err(ERR.noncharacterInInputStream);\n      }\n    }\n  }, {\n    key: \"retreat\",\n    value: function retreat(count) {\n      this.pos -= count;\n      while (this.pos < this.lastGapPos) {\n        this.lastGapPos = this.gapStack.pop();\n        this.pos--;\n      }\n      this.isEol = false;\n    }\n  }]);\n  return Preprocessor;\n}();","map":{"version":3,"names":["CODE_POINTS","$","getSurrogatePairCodePoint","isControlCodePoint","isSurrogate","isSurrogatePair","isUndefinedCodePoint","ERR","DEFAULT_BUFFER_WATERLINE","Preprocessor","handler","_classCallCheck","html","pos","lastGapPos","gapStack","skipNextNewLine","lastChunkWritten","endOfChunkHit","bufferWaterline","isEol","lineStartPos","droppedBufferSize","line","lastErrOffset","_createClass","key","get","Number","value","getError","code","col","offset","startLine","endLine","startCol","endCol","startOffset","endOffset","_err","onParseError","_addGap","push","_processSurrogate","cp","length","nextCp","charCodeAt","EOF","surrogateInInputStream","willDropParsedChunk","dropParsedChunk","substring","write","chunk","isLastChunk","insertHtmlAtCurrentPos","startsWith","pattern","caseSensitive","i","peek","CARRIAGE_RETURN","LINE_FEED","advance","isCommonValidRange","_checkForProblematicCharacters","controlCharacterInInputStream","noncharacterInInputStream","retreat","count","pop"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/hast-util-raw/node_modules/parse5/dist/tokenizer/preprocessor.js"],"sourcesContent":["import { CODE_POINTS as $, getSurrogatePairCodePoint, isControlCodePoint, isSurrogate, isSurrogatePair, isUndefinedCodePoint, } from '../common/unicode.js';\nimport { ERR } from '../common/error-codes.js';\n//Const\nconst DEFAULT_BUFFER_WATERLINE = 1 << 16;\n//Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\nexport class Preprocessor {\n    constructor(handler) {\n        this.handler = handler;\n        this.html = '';\n        this.pos = -1;\n        // NOTE: Initial `lastGapPos` is -2, to ensure `col` on initialisation is 0\n        this.lastGapPos = -2;\n        this.gapStack = [];\n        this.skipNextNewLine = false;\n        this.lastChunkWritten = false;\n        this.endOfChunkHit = false;\n        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n        this.isEol = false;\n        this.lineStartPos = 0;\n        this.droppedBufferSize = 0;\n        this.line = 1;\n        //NOTE: avoid reporting errors twice on advance/retreat\n        this.lastErrOffset = -1;\n    }\n    /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */\n    get col() {\n        return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);\n    }\n    get offset() {\n        return this.droppedBufferSize + this.pos;\n    }\n    getError(code) {\n        const { line, col, offset } = this;\n        return {\n            code,\n            startLine: line,\n            endLine: line,\n            startCol: col,\n            endCol: col,\n            startOffset: offset,\n            endOffset: offset,\n        };\n    }\n    _err(code) {\n        if (this.handler.onParseError && this.lastErrOffset !== this.offset) {\n            this.lastErrOffset = this.offset;\n            this.handler.onParseError(this.getError(code));\n        }\n    }\n    _addGap() {\n        this.gapStack.push(this.lastGapPos);\n        this.lastGapPos = this.pos;\n    }\n    _processSurrogate(cp) {\n        //NOTE: try to peek a surrogate pair\n        if (this.pos !== this.html.length - 1) {\n            const nextCp = this.html.charCodeAt(this.pos + 1);\n            if (isSurrogatePair(nextCp)) {\n                //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n                this.pos++;\n                //NOTE: add a gap that should be avoided during retreat\n                this._addGap();\n                return getSurrogatePairCodePoint(cp, nextCp);\n            }\n        }\n        //NOTE: we are at the end of a chunk, therefore we can't infer the surrogate pair yet.\n        else if (!this.lastChunkWritten) {\n            this.endOfChunkHit = true;\n            return $.EOF;\n        }\n        //NOTE: isolated surrogate\n        this._err(ERR.surrogateInInputStream);\n        return cp;\n    }\n    willDropParsedChunk() {\n        return this.pos > this.bufferWaterline;\n    }\n    dropParsedChunk() {\n        if (this.willDropParsedChunk()) {\n            this.html = this.html.substring(this.pos);\n            this.lineStartPos -= this.pos;\n            this.droppedBufferSize += this.pos;\n            this.pos = 0;\n            this.lastGapPos = -2;\n            this.gapStack.length = 0;\n        }\n    }\n    write(chunk, isLastChunk) {\n        if (this.html.length > 0) {\n            this.html += chunk;\n        }\n        else {\n            this.html = chunk;\n        }\n        this.endOfChunkHit = false;\n        this.lastChunkWritten = isLastChunk;\n    }\n    insertHtmlAtCurrentPos(chunk) {\n        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);\n        this.endOfChunkHit = false;\n    }\n    startsWith(pattern, caseSensitive) {\n        // Check if our buffer has enough characters\n        if (this.pos + pattern.length > this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return false;\n        }\n        if (caseSensitive) {\n            return this.html.startsWith(pattern, this.pos);\n        }\n        for (let i = 0; i < pattern.length; i++) {\n            const cp = this.html.charCodeAt(this.pos + i) | 0x20;\n            if (cp !== pattern.charCodeAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    peek(offset) {\n        const pos = this.pos + offset;\n        if (pos >= this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return $.EOF;\n        }\n        const code = this.html.charCodeAt(pos);\n        return code === $.CARRIAGE_RETURN ? $.LINE_FEED : code;\n    }\n    advance() {\n        this.pos++;\n        //NOTE: LF should be in the last column of the line\n        if (this.isEol) {\n            this.isEol = false;\n            this.line++;\n            this.lineStartPos = this.pos;\n        }\n        if (this.pos >= this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return $.EOF;\n        }\n        let cp = this.html.charCodeAt(this.pos);\n        //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n        if (cp === $.CARRIAGE_RETURN) {\n            this.isEol = true;\n            this.skipNextNewLine = true;\n            return $.LINE_FEED;\n        }\n        //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n        //must be ignored.\n        if (cp === $.LINE_FEED) {\n            this.isEol = true;\n            if (this.skipNextNewLine) {\n                // `line` will be bumped again in the recursive call.\n                this.line--;\n                this.skipNextNewLine = false;\n                this._addGap();\n                return this.advance();\n            }\n        }\n        this.skipNextNewLine = false;\n        if (isSurrogate(cp)) {\n            cp = this._processSurrogate(cp);\n        }\n        //OPTIMIZATION: first check if code point is in the common allowed\n        //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\n        //before going into detailed performance cost validation.\n        const isCommonValidRange = this.handler.onParseError === null ||\n            (cp > 0x1f && cp < 0x7f) ||\n            cp === $.LINE_FEED ||\n            cp === $.CARRIAGE_RETURN ||\n            (cp > 0x9f && cp < 64976);\n        if (!isCommonValidRange) {\n            this._checkForProblematicCharacters(cp);\n        }\n        return cp;\n    }\n    _checkForProblematicCharacters(cp) {\n        if (isControlCodePoint(cp)) {\n            this._err(ERR.controlCharacterInInputStream);\n        }\n        else if (isUndefinedCodePoint(cp)) {\n            this._err(ERR.noncharacterInInputStream);\n        }\n    }\n    retreat(count) {\n        this.pos -= count;\n        while (this.pos < this.lastGapPos) {\n            this.lastGapPos = this.gapStack.pop();\n            this.pos--;\n        }\n        this.isEol = false;\n    }\n}\n//# sourceMappingURL=preprocessor.js.map"],"mappings":";;AAAA,SAASA,WAAW,IAAIC,CAAC,EAAEC,yBAAyB,EAAEC,kBAAkB,EAAEC,WAAW,EAAEC,eAAe,EAAEC,oBAAoB,QAAS,sBAAsB;AAC3J,SAASC,GAAG,QAAQ,0BAA0B;AAC9C;AACA,IAAMC,wBAAwB,GAAG,CAAC,IAAI,EAAE;AACxC;AACA;AACA;AACA,WAAaC,YAAY;EACrB,SAAAA,aAAYC,OAAO,EAAE;IAAAC,eAAA,OAAAF,YAAA;IACjB,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACE,IAAI,GAAG,EAAE;IACd,IAAI,CAACC,GAAG,GAAG,CAAC,CAAC;IACb;IACA,IAAI,CAACC,UAAU,GAAG,CAAC,CAAC;IACpB,IAAI,CAACC,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B,IAAI,CAACC,gBAAgB,GAAG,KAAK;IAC7B,IAAI,CAACC,aAAa,GAAG,KAAK;IAC1B,IAAI,CAACC,eAAe,GAAGX,wBAAwB;IAC/C,IAAI,CAACY,KAAK,GAAG,KAAK;IAClB,IAAI,CAACC,YAAY,GAAG,CAAC;IACrB,IAAI,CAACC,iBAAiB,GAAG,CAAC;IAC1B,IAAI,CAACC,IAAI,GAAG,CAAC;IACb;IACA,IAAI,CAACC,aAAa,GAAG,CAAC,CAAC;EAC3B;EACA;EAAAC,YAAA,CAAAhB,YAAA;IAAAiB,GAAA;IAAAC,GAAA,EACA,SAAAA,IAAA,EAAU;MACN,OAAO,IAAI,CAACd,GAAG,GAAG,IAAI,CAACQ,YAAY,GAAGO,MAAM,CAAC,IAAI,CAACd,UAAU,KAAK,IAAI,CAACD,GAAG,CAAC;IAC9E;EAAC;IAAAa,GAAA;IAAAC,GAAA,EACD,SAAAA,IAAA,EAAa;MACT,OAAO,IAAI,CAACL,iBAAiB,GAAG,IAAI,CAACT,GAAG;IAC5C;EAAC;IAAAa,GAAA;IAAAG,KAAA,EACD,SAAAC,SAASC,IAAI,EAAE;MACX,IAAQR,IAAI,GAAkB,IAAI,CAA1BA,IAAI;QAAES,GAAG,GAAa,IAAI,CAApBA,GAAG;QAAEC,MAAM,GAAK,IAAI,CAAfA,MAAM;MACzB,OAAO;QACHF,IAAI,EAAJA,IAAI;QACJG,SAAS,EAAEX,IAAI;QACfY,OAAO,EAAEZ,IAAI;QACba,QAAQ,EAAEJ,GAAG;QACbK,MAAM,EAAEL,GAAG;QACXM,WAAW,EAAEL,MAAM;QACnBM,SAAS,EAAEN;MACf,CAAC;IACL;EAAC;IAAAP,GAAA;IAAAG,KAAA,EACD,SAAAW,KAAKT,IAAI,EAAE;MACP,IAAI,IAAI,CAACrB,OAAO,CAAC+B,YAAY,IAAI,IAAI,CAACjB,aAAa,KAAK,IAAI,CAACS,MAAM,EAAE;QACjE,IAAI,CAACT,aAAa,GAAG,IAAI,CAACS,MAAM;QAChC,IAAI,CAACvB,OAAO,CAAC+B,YAAY,CAAC,IAAI,CAACX,QAAQ,CAACC,IAAI,CAAC,CAAC;MAClD;IACJ;EAAC;IAAAL,GAAA;IAAAG,KAAA,EACD,SAAAa,QAAA,EAAU;MACN,IAAI,CAAC3B,QAAQ,CAAC4B,IAAI,CAAC,IAAI,CAAC7B,UAAU,CAAC;MACnC,IAAI,CAACA,UAAU,GAAG,IAAI,CAACD,GAAG;IAC9B;EAAC;IAAAa,GAAA;IAAAG,KAAA,EACD,SAAAe,kBAAkBC,EAAE,EAAE;MAClB;MACA,IAAI,IAAI,CAAChC,GAAG,KAAK,IAAI,CAACD,IAAI,CAACkC,MAAM,GAAG,CAAC,EAAE;QACnC,IAAMC,MAAM,GAAG,IAAI,CAACnC,IAAI,CAACoC,UAAU,CAAC,IAAI,CAACnC,GAAG,GAAG,CAAC,CAAC;QACjD,IAAIR,eAAe,CAAC0C,MAAM,CAAC,EAAE;UACzB;UACA,IAAI,CAAClC,GAAG,EAAE;UACV;UACA,IAAI,CAAC6B,OAAO,CAAC,CAAC;UACd,OAAOxC,yBAAyB,CAAC2C,EAAE,EAAEE,MAAM,CAAC;QAChD;MACJ;MACA;MAAA,KACK,IAAI,CAAC,IAAI,CAAC9B,gBAAgB,EAAE;QAC7B,IAAI,CAACC,aAAa,GAAG,IAAI;QACzB,OAAOjB,CAAC,CAACgD,GAAG;MAChB;MACA;MACA,IAAI,CAACT,IAAI,CAACjC,GAAG,CAAC2C,sBAAsB,CAAC;MACrC,OAAOL,EAAE;IACb;EAAC;IAAAnB,GAAA;IAAAG,KAAA,EACD,SAAAsB,oBAAA,EAAsB;MAClB,OAAO,IAAI,CAACtC,GAAG,GAAG,IAAI,CAACM,eAAe;IAC1C;EAAC;IAAAO,GAAA;IAAAG,KAAA,EACD,SAAAuB,gBAAA,EAAkB;MACd,IAAI,IAAI,CAACD,mBAAmB,CAAC,CAAC,EAAE;QAC5B,IAAI,CAACvC,IAAI,GAAG,IAAI,CAACA,IAAI,CAACyC,SAAS,CAAC,IAAI,CAACxC,GAAG,CAAC;QACzC,IAAI,CAACQ,YAAY,IAAI,IAAI,CAACR,GAAG;QAC7B,IAAI,CAACS,iBAAiB,IAAI,IAAI,CAACT,GAAG;QAClC,IAAI,CAACA,GAAG,GAAG,CAAC;QACZ,IAAI,CAACC,UAAU,GAAG,CAAC,CAAC;QACpB,IAAI,CAACC,QAAQ,CAAC+B,MAAM,GAAG,CAAC;MAC5B;IACJ;EAAC;IAAApB,GAAA;IAAAG,KAAA,EACD,SAAAyB,MAAMC,KAAK,EAAEC,WAAW,EAAE;MACtB,IAAI,IAAI,CAAC5C,IAAI,CAACkC,MAAM,GAAG,CAAC,EAAE;QACtB,IAAI,CAAClC,IAAI,IAAI2C,KAAK;MACtB,CAAC,MACI;QACD,IAAI,CAAC3C,IAAI,GAAG2C,KAAK;MACrB;MACA,IAAI,CAACrC,aAAa,GAAG,KAAK;MAC1B,IAAI,CAACD,gBAAgB,GAAGuC,WAAW;IACvC;EAAC;IAAA9B,GAAA;IAAAG,KAAA,EACD,SAAA4B,uBAAuBF,KAAK,EAAE;MAC1B,IAAI,CAAC3C,IAAI,GAAG,IAAI,CAACA,IAAI,CAACyC,SAAS,CAAC,CAAC,EAAE,IAAI,CAACxC,GAAG,GAAG,CAAC,CAAC,GAAG0C,KAAK,GAAG,IAAI,CAAC3C,IAAI,CAACyC,SAAS,CAAC,IAAI,CAACxC,GAAG,GAAG,CAAC,CAAC;MAC5F,IAAI,CAACK,aAAa,GAAG,KAAK;IAC9B;EAAC;IAAAQ,GAAA;IAAAG,KAAA,EACD,SAAA6B,WAAWC,OAAO,EAAEC,aAAa,EAAE;MAC/B;MACA,IAAI,IAAI,CAAC/C,GAAG,GAAG8C,OAAO,CAACb,MAAM,GAAG,IAAI,CAAClC,IAAI,CAACkC,MAAM,EAAE;QAC9C,IAAI,CAAC5B,aAAa,GAAG,CAAC,IAAI,CAACD,gBAAgB;QAC3C,OAAO,KAAK;MAChB;MACA,IAAI2C,aAAa,EAAE;QACf,OAAO,IAAI,CAAChD,IAAI,CAAC8C,UAAU,CAACC,OAAO,EAAE,IAAI,CAAC9C,GAAG,CAAC;MAClD;MACA,KAAK,IAAIgD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,OAAO,CAACb,MAAM,EAAEe,CAAC,EAAE,EAAE;QACrC,IAAMhB,EAAE,GAAG,IAAI,CAACjC,IAAI,CAACoC,UAAU,CAAC,IAAI,CAACnC,GAAG,GAAGgD,CAAC,CAAC,GAAG,IAAI;QACpD,IAAIhB,EAAE,KAAKc,OAAO,CAACX,UAAU,CAACa,CAAC,CAAC,EAAE;UAC9B,OAAO,KAAK;QAChB;MACJ;MACA,OAAO,IAAI;IACf;EAAC;IAAAnC,GAAA;IAAAG,KAAA,EACD,SAAAiC,KAAK7B,MAAM,EAAE;MACT,IAAMpB,GAAG,GAAG,IAAI,CAACA,GAAG,GAAGoB,MAAM;MAC7B,IAAIpB,GAAG,IAAI,IAAI,CAACD,IAAI,CAACkC,MAAM,EAAE;QACzB,IAAI,CAAC5B,aAAa,GAAG,CAAC,IAAI,CAACD,gBAAgB;QAC3C,OAAOhB,CAAC,CAACgD,GAAG;MAChB;MACA,IAAMlB,IAAI,GAAG,IAAI,CAACnB,IAAI,CAACoC,UAAU,CAACnC,GAAG,CAAC;MACtC,OAAOkB,IAAI,KAAK9B,CAAC,CAAC8D,eAAe,GAAG9D,CAAC,CAAC+D,SAAS,GAAGjC,IAAI;IAC1D;EAAC;IAAAL,GAAA;IAAAG,KAAA,EACD,SAAAoC,QAAA,EAAU;MACN,IAAI,CAACpD,GAAG,EAAE;MACV;MACA,IAAI,IAAI,CAACO,KAAK,EAAE;QACZ,IAAI,CAACA,KAAK,GAAG,KAAK;QAClB,IAAI,CAACG,IAAI,EAAE;QACX,IAAI,CAACF,YAAY,GAAG,IAAI,CAACR,GAAG;MAChC;MACA,IAAI,IAAI,CAACA,GAAG,IAAI,IAAI,CAACD,IAAI,CAACkC,MAAM,EAAE;QAC9B,IAAI,CAAC5B,aAAa,GAAG,CAAC,IAAI,CAACD,gBAAgB;QAC3C,OAAOhB,CAAC,CAACgD,GAAG;MAChB;MACA,IAAIJ,EAAE,GAAG,IAAI,CAACjC,IAAI,CAACoC,UAAU,CAAC,IAAI,CAACnC,GAAG,CAAC;MACvC;MACA,IAAIgC,EAAE,KAAK5C,CAAC,CAAC8D,eAAe,EAAE;QAC1B,IAAI,CAAC3C,KAAK,GAAG,IAAI;QACjB,IAAI,CAACJ,eAAe,GAAG,IAAI;QAC3B,OAAOf,CAAC,CAAC+D,SAAS;MACtB;MACA;MACA;MACA,IAAInB,EAAE,KAAK5C,CAAC,CAAC+D,SAAS,EAAE;QACpB,IAAI,CAAC5C,KAAK,GAAG,IAAI;QACjB,IAAI,IAAI,CAACJ,eAAe,EAAE;UACtB;UACA,IAAI,CAACO,IAAI,EAAE;UACX,IAAI,CAACP,eAAe,GAAG,KAAK;UAC5B,IAAI,CAAC0B,OAAO,CAAC,CAAC;UACd,OAAO,IAAI,CAACuB,OAAO,CAAC,CAAC;QACzB;MACJ;MACA,IAAI,CAACjD,eAAe,GAAG,KAAK;MAC5B,IAAIZ,WAAW,CAACyC,EAAE,CAAC,EAAE;QACjBA,EAAE,GAAG,IAAI,CAACD,iBAAiB,CAACC,EAAE,CAAC;MACnC;MACA;MACA;MACA;MACA,IAAMqB,kBAAkB,GAAG,IAAI,CAACxD,OAAO,CAAC+B,YAAY,KAAK,IAAI,IACxDI,EAAE,GAAG,IAAI,IAAIA,EAAE,GAAG,IAAK,IACxBA,EAAE,KAAK5C,CAAC,CAAC+D,SAAS,IAClBnB,EAAE,KAAK5C,CAAC,CAAC8D,eAAe,IACvBlB,EAAE,GAAG,IAAI,IAAIA,EAAE,GAAG,KAAM;MAC7B,IAAI,CAACqB,kBAAkB,EAAE;QACrB,IAAI,CAACC,8BAA8B,CAACtB,EAAE,CAAC;MAC3C;MACA,OAAOA,EAAE;IACb;EAAC;IAAAnB,GAAA;IAAAG,KAAA,EACD,SAAAsC,+BAA+BtB,EAAE,EAAE;MAC/B,IAAI1C,kBAAkB,CAAC0C,EAAE,CAAC,EAAE;QACxB,IAAI,CAACL,IAAI,CAACjC,GAAG,CAAC6D,6BAA6B,CAAC;MAChD,CAAC,MACI,IAAI9D,oBAAoB,CAACuC,EAAE,CAAC,EAAE;QAC/B,IAAI,CAACL,IAAI,CAACjC,GAAG,CAAC8D,yBAAyB,CAAC;MAC5C;IACJ;EAAC;IAAA3C,GAAA;IAAAG,KAAA,EACD,SAAAyC,QAAQC,KAAK,EAAE;MACX,IAAI,CAAC1D,GAAG,IAAI0D,KAAK;MACjB,OAAO,IAAI,CAAC1D,GAAG,GAAG,IAAI,CAACC,UAAU,EAAE;QAC/B,IAAI,CAACA,UAAU,GAAG,IAAI,CAACC,QAAQ,CAACyD,GAAG,CAAC,CAAC;QACrC,IAAI,CAAC3D,GAAG,EAAE;MACd;MACA,IAAI,CAACO,KAAK,GAAG,KAAK;IACtB;EAAC;EAAA,OAAAX,YAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}