{"ast":null,"code":"/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('socket.io-parser');\nvar Emitter = require('component-emitter');\nvar binary = require('./binary');\nvar isArray = require('isarray');\nvar isBuf = require('./is-buffer');\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = 4;\n\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'ACK', 'ERROR', 'BINARY_EVENT', 'BINARY_ACK'];\n\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\nvar ERROR_PACKET = exports.ERROR + '\"encode error\"';\n\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\nEncoder.prototype.encode = function (obj, callback) {\n  debug('encoding packet %j', obj);\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    encodeAsBinary(obj, callback);\n  } else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\nfunction encodeAsString(obj) {\n  // first is type\n  var str = '' + obj.type;\n\n  // attachments if we have them\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    str += obj.attachments + '-';\n  }\n\n  // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n  if (obj.nsp && '/' !== obj.nsp) {\n    str += obj.nsp + ',';\n  }\n\n  // immediately followed by the id\n  if (null != obj.id) {\n    str += obj.id;\n  }\n\n  // json data\n  if (null != obj.data) {\n    var payload = tryStringify(obj.data);\n    if (payload !== false) {\n      str += payload;\n    } else {\n      return ERROR_PACKET;\n    }\n  }\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\nfunction tryStringify(str) {\n  try {\n    return JSON.stringify(str);\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\nfunction encodeAsBinary(obj, callback) {\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n    buffers.unshift(pack); // add packet info to beginning of data list\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n\n/**\n * Mix in `Emitter` with Decoder.\n */\n\nEmitter(Decoder.prototype);\n\n/**\n * Decodes an encoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function (obj) {\n  var packet;\n  if (typeof obj === 'string') {\n    if (this.reconstructor) {\n      throw new Error(\"got plaintext data when reconstructing a packet\");\n    }\n    packet = decodeString(obj);\n    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) {\n      // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet);\n\n      // no attachments, labeled binary but no binary data to follow\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else {\n      // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  } else if (isBuf(obj) || obj.base64) {\n    // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n      if (packet) {\n        // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  } else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\nfunction decodeString(str) {\n  var i = 0;\n  // look up type\n  var p = {\n    type: Number(str.charAt(0))\n  };\n  if (null == exports.types[p.type]) {\n    return error('unknown packet type ' + p.type);\n  }\n\n  // look up attachments if type binary\n  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {\n    var start = i + 1;\n    while (str.charAt(++i) !== '-' && i != str.length) {}\n    var buf = str.substring(start, i);\n    if (buf != Number(buf) || str.charAt(i) !== '-') {\n      throw new Error('Illegal attachments');\n    }\n    p.attachments = Number(buf);\n  }\n\n  // look up namespace (if any)\n  if ('/' === str.charAt(i + 1)) {\n    var start = i + 1;\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' === c) break;\n      if (i === str.length) break;\n    }\n    p.nsp = str.substring(start, i);\n  } else {\n    p.nsp = '/';\n  }\n\n  // look up id\n  var next = str.charAt(i + 1);\n  if ('' !== next && Number(next) == next) {\n    var start = i + 1;\n    while (++i) {\n      var c = str.charAt(i);\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n      if (i === str.length) break;\n    }\n    p.id = Number(str.substring(start, i + 1));\n  }\n\n  // look up json data\n  if (str.charAt(++i)) {\n    var payload = tryParse(str.substr(i));\n    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));\n    if (isPayloadValid) {\n      p.data = payload;\n    } else {\n      return error('invalid payload');\n    }\n  }\n  debug('decoded %s as %j', str, p);\n  return p;\n}\nfunction tryParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\nDecoder.prototype.destroy = function () {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\nBinaryReconstructor.prototype.takeBinaryData = function (binData) {\n  this.buffers.push(binData);\n  if (this.buffers.length === this.reconPack.attachments) {\n    // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n  return null;\n};\n\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\nBinaryReconstructor.prototype.finishedReconstruction = function () {\n  this.reconPack = null;\n  this.buffers = [];\n};\nfunction error(msg) {\n  return {\n    type: exports.ERROR,\n    data: 'parser error: ' + msg\n  };\n}","map":{"version":3,"names":["debug","require","Emitter","binary","isArray","isBuf","exports","protocol","types","CONNECT","DISCONNECT","EVENT","ACK","ERROR","BINARY_EVENT","BINARY_ACK","Encoder","Decoder","ERROR_PACKET","prototype","encode","obj","callback","type","encodeAsBinary","encoding","encodeAsString","str","attachments","nsp","id","data","payload","tryStringify","JSON","stringify","e","writeEncoding","bloblessData","deconstruction","deconstructPacket","pack","packet","buffers","unshift","removeBlobs","reconstructor","add","Error","decodeString","BinaryReconstructor","reconPack","emit","base64","takeBinaryData","i","p","Number","charAt","error","start","length","buf","substring","c","next","tryParse","substr","isPayloadValid","parse","destroy","finishedReconstruction","binData","push","reconstructPacket","msg"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/socket.io-parser/index.js"],"sourcesContent":["\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('socket.io-parser');\nvar Emitter = require('component-emitter');\nvar binary = require('./binary');\nvar isArray = require('isarray');\nvar isBuf = require('./is-buffer');\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nexports.protocol = 4;\n\n/**\n * Packet types.\n *\n * @api public\n */\n\nexports.types = [\n  'CONNECT',\n  'DISCONNECT',\n  'EVENT',\n  'ACK',\n  'ERROR',\n  'BINARY_EVENT',\n  'BINARY_ACK'\n];\n\n/**\n * Packet type `connect`.\n *\n * @api public\n */\n\nexports.CONNECT = 0;\n\n/**\n * Packet type `disconnect`.\n *\n * @api public\n */\n\nexports.DISCONNECT = 1;\n\n/**\n * Packet type `event`.\n *\n * @api public\n */\n\nexports.EVENT = 2;\n\n/**\n * Packet type `ack`.\n *\n * @api public\n */\n\nexports.ACK = 3;\n\n/**\n * Packet type `error`.\n *\n * @api public\n */\n\nexports.ERROR = 4;\n\n/**\n * Packet type 'binary event'\n *\n * @api public\n */\n\nexports.BINARY_EVENT = 5;\n\n/**\n * Packet type `binary ack`. For acks with binary arguments.\n *\n * @api public\n */\n\nexports.BINARY_ACK = 6;\n\n/**\n * Encoder constructor.\n *\n * @api public\n */\n\nexports.Encoder = Encoder;\n\n/**\n * Decoder constructor.\n *\n * @api public\n */\n\nexports.Decoder = Decoder;\n\n/**\n * A socket.io Encoder instance\n *\n * @api public\n */\n\nfunction Encoder() {}\n\nvar ERROR_PACKET = exports.ERROR + '\"encode error\"';\n\n/**\n * Encode a packet as a single string if non-binary, or as a\n * buffer sequence, depending on packet type.\n *\n * @param {Object} obj - packet object\n * @param {Function} callback - function to handle encodings (likely engine.write)\n * @return Calls callback with Array of encodings\n * @api public\n */\n\nEncoder.prototype.encode = function(obj, callback){\n  debug('encoding packet %j', obj);\n\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    encodeAsBinary(obj, callback);\n  } else {\n    var encoding = encodeAsString(obj);\n    callback([encoding]);\n  }\n};\n\n/**\n * Encode packet as string.\n *\n * @param {Object} packet\n * @return {String} encoded\n * @api private\n */\n\nfunction encodeAsString(obj) {\n\n  // first is type\n  var str = '' + obj.type;\n\n  // attachments if we have them\n  if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {\n    str += obj.attachments + '-';\n  }\n\n  // if we have a namespace other than `/`\n  // we append it followed by a comma `,`\n  if (obj.nsp && '/' !== obj.nsp) {\n    str += obj.nsp + ',';\n  }\n\n  // immediately followed by the id\n  if (null != obj.id) {\n    str += obj.id;\n  }\n\n  // json data\n  if (null != obj.data) {\n    var payload = tryStringify(obj.data);\n    if (payload !== false) {\n      str += payload;\n    } else {\n      return ERROR_PACKET;\n    }\n  }\n\n  debug('encoded %j as %s', obj, str);\n  return str;\n}\n\nfunction tryStringify(str) {\n  try {\n    return JSON.stringify(str);\n  } catch(e){\n    return false;\n  }\n}\n\n/**\n * Encode packet as 'buffer sequence' by removing blobs, and\n * deconstructing packet into object with placeholders and\n * a list of buffers.\n *\n * @param {Object} packet\n * @return {Buffer} encoded\n * @api private\n */\n\nfunction encodeAsBinary(obj, callback) {\n\n  function writeEncoding(bloblessData) {\n    var deconstruction = binary.deconstructPacket(bloblessData);\n    var pack = encodeAsString(deconstruction.packet);\n    var buffers = deconstruction.buffers;\n\n    buffers.unshift(pack); // add packet info to beginning of data list\n    callback(buffers); // write all the buffers\n  }\n\n  binary.removeBlobs(obj, writeEncoding);\n}\n\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n * @api public\n */\n\nfunction Decoder() {\n  this.reconstructor = null;\n}\n\n/**\n * Mix in `Emitter` with Decoder.\n */\n\nEmitter(Decoder.prototype);\n\n/**\n * Decodes an encoded packet string into packet JSON.\n *\n * @param {String} obj - encoded packet\n * @return {Object} packet\n * @api public\n */\n\nDecoder.prototype.add = function(obj) {\n  var packet;\n  if (typeof obj === 'string') {\n    if (this.reconstructor) {\n      throw new Error(\"got plaintext data when reconstructing a packet\");\n    }\n    packet = decodeString(obj);\n    if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) { // binary packet's json\n      this.reconstructor = new BinaryReconstructor(packet);\n\n      // no attachments, labeled binary but no binary data to follow\n      if (this.reconstructor.reconPack.attachments === 0) {\n        this.emit('decoded', packet);\n      }\n    } else { // non-binary full packet\n      this.emit('decoded', packet);\n    }\n  } else if (isBuf(obj) || obj.base64) { // raw binary data\n    if (!this.reconstructor) {\n      throw new Error('got binary data when not reconstructing a packet');\n    } else {\n      packet = this.reconstructor.takeBinaryData(obj);\n      if (packet) { // received final buffer\n        this.reconstructor = null;\n        this.emit('decoded', packet);\n      }\n    }\n  } else {\n    throw new Error('Unknown type: ' + obj);\n  }\n};\n\n/**\n * Decode a packet String (JSON data)\n *\n * @param {String} str\n * @return {Object} packet\n * @api private\n */\n\nfunction decodeString(str) {\n  var i = 0;\n  // look up type\n  var p = {\n    type: Number(str.charAt(0))\n  };\n\n  if (null == exports.types[p.type]) {\n    return error('unknown packet type ' + p.type);\n  }\n\n  // look up attachments if type binary\n  if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {\n    var start = i + 1;\n    while (str.charAt(++i) !== '-' && i != str.length) {}\n    var buf = str.substring(start, i);\n    if (buf != Number(buf) || str.charAt(i) !== '-') {\n      throw new Error('Illegal attachments');\n    }\n    p.attachments = Number(buf);\n  }\n\n  // look up namespace (if any)\n  if ('/' === str.charAt(i + 1)) {\n    var start = i + 1;\n    while (++i) {\n      var c = str.charAt(i);\n      if (',' === c) break;\n      if (i === str.length) break;\n    }\n    p.nsp = str.substring(start, i);\n  } else {\n    p.nsp = '/';\n  }\n\n  // look up id\n  var next = str.charAt(i + 1);\n  if ('' !== next && Number(next) == next) {\n    var start = i + 1;\n    while (++i) {\n      var c = str.charAt(i);\n      if (null == c || Number(c) != c) {\n        --i;\n        break;\n      }\n      if (i === str.length) break;\n    }\n    p.id = Number(str.substring(start, i + 1));\n  }\n\n  // look up json data\n  if (str.charAt(++i)) {\n    var payload = tryParse(str.substr(i));\n    var isPayloadValid = payload !== false && (p.type === exports.ERROR || isArray(payload));\n    if (isPayloadValid) {\n      p.data = payload;\n    } else {\n      return error('invalid payload');\n    }\n  }\n\n  debug('decoded %s as %j', str, p);\n  return p;\n}\n\nfunction tryParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch(e){\n    return false;\n  }\n}\n\n/**\n * Deallocates a parser's resources\n *\n * @api public\n */\n\nDecoder.prototype.destroy = function() {\n  if (this.reconstructor) {\n    this.reconstructor.finishedReconstruction();\n  }\n};\n\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n * @api private\n */\n\nfunction BinaryReconstructor(packet) {\n  this.reconPack = packet;\n  this.buffers = [];\n}\n\n/**\n * Method to be called when binary data received from connection\n * after a BINARY_EVENT packet.\n *\n * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n * @return {null | Object} returns null if more binary data is expected or\n *   a reconstructed packet object if all buffers have been received.\n * @api private\n */\n\nBinaryReconstructor.prototype.takeBinaryData = function(binData) {\n  this.buffers.push(binData);\n  if (this.buffers.length === this.reconPack.attachments) { // done with buffer list\n    var packet = binary.reconstructPacket(this.reconPack, this.buffers);\n    this.finishedReconstruction();\n    return packet;\n  }\n  return null;\n};\n\n/**\n * Cleans up binary packet reconstruction variables.\n *\n * @api private\n */\n\nBinaryReconstructor.prototype.finishedReconstruction = function() {\n  this.reconPack = null;\n  this.buffers = [];\n};\n\nfunction error(msg) {\n  return {\n    type: exports.ERROR,\n    data: 'parser error: ' + msg\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}