{"ast":null,"code":"import _toArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _toConsumableArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n/**\n * @typedef {import('trough').Pipeline} Pipeline\n *\n * @typedef {import('unist').Node} Node\n *\n * @typedef {import('vfile').Compatible} Compatible\n * @typedef {import('vfile').Value} Value\n *\n * @typedef {import('../index.js').CompileResultMap} CompileResultMap\n * @typedef {import('../index.js').Data} Data\n * @typedef {import('../index.js').Settings} Settings\n */\n\n/**\n * @typedef {CompileResultMap[keyof CompileResultMap]} CompileResults\n *   Acceptable results from compilers.\n *\n *   To register custom results, add them to\n *   {@link CompileResultMap `CompileResultMap`}.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   The node that the compiler receives (default: `Node`).\n * @template {CompileResults} [Result=CompileResults]\n *   The thing that the compiler yields (default: `CompileResults`).\n * @callback Compiler\n *   A **compiler** handles the compiling of a syntax tree to something else\n *   (in most cases, text) (TypeScript type).\n *\n *   It is used in the stringify phase and called with a {@link Node `Node`}\n *   and {@link VFile `VFile`} representation of the document to compile.\n *   It should return the textual representation of the given tree (typically\n *   `string`).\n *\n *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most compilers\n *   > return `string` (or `Uint8Array`).\n *   > Some compilers, such as the one configured with\n *   > [`rehype-react`][rehype-react], return other values (in this case, a\n *   > React tree).\n *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\n *   > result values.\n *   >\n *   > To register custom results in TypeScript, add them to\n *   > {@link CompileResultMap `CompileResultMap`}.\n *\n *   [rehype-react]: https://github.com/rehypejs/rehype-react\n * @param {Tree} tree\n *   Tree to compile.\n * @param {VFile} file\n *   File associated with `tree`.\n * @returns {Result}\n *   New content: compiled text (`string` or `Uint8Array`, for `file.value`) or\n *   something else (for `file.result`).\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   The node that the parser yields (default: `Node`)\n * @callback Parser\n *   A **parser** handles the parsing of text to a syntax tree.\n *\n *   It is used in the parse phase and is called with a `string` and\n *   {@link VFile `VFile`} of the document to parse.\n *   It must return the syntax tree representation of the given file\n *   ({@link Node `Node`}).\n * @param {string} document\n *   Document to parse.\n * @param {VFile} file\n *   File associated with `document`.\n * @returns {Tree}\n *   Node representing the given file.\n */\n\n/**\n * @typedef {(\n *   Plugin<Array<any>, any, any> |\n *   PluginTuple<Array<any>, any, any> |\n *   Preset\n * )} Pluggable\n *   Union of the different ways to add plugins and settings.\n */\n\n/**\n * @typedef {Array<Pluggable>} PluggableList\n *   List of plugins and presets.\n */\n\n// Note: we canâ€™t use `callback` yet as it messes up `this`:\n//  <https://github.com/microsoft/TypeScript/issues/55197>.\n/**\n * @template {Array<unknown>} [PluginParameters=[]]\n *   Arguments passed to the plugin (default: `[]`, the empty tuple).\n * @template {Node | string | undefined} [Input=Node]\n *   Value that is expected as input (default: `Node`).\n *\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\n *       should be the node it expects.\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be\n *       `string`.\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be the\n *       node it expects.\n * @template [Output=Input]\n *   Value that is yielded as output (default: `Input`).\n *\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\n *       should be the node that that yields.\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be the\n *       node that it yields.\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be\n *       result it yields.\n * @typedef {(\n *   (this: Processor, ...parameters: PluginParameters) =>\n *     Input extends string ? // Parser.\n *        Output extends Node | undefined ? undefined | void : never :\n *     Output extends CompileResults ? // Compiler.\n *        Input extends Node | undefined ? undefined | void : never :\n *     Transformer<\n *       Input extends Node ? Input : Node,\n *       Output extends Node ? Output : Node\n *     > | undefined | void\n * )} Plugin\n *   Single plugin.\n *\n *   Plugins configure the processors they are applied on in the following\n *   ways:\n *\n *   *   they change the processor, such as the parser, the compiler, or by\n *       configuring data\n *   *   they specify how to handle trees and files\n *\n *   In practice, they are functions that can receive options and configure the\n *   processor (`this`).\n *\n *   > ðŸ‘‰ **Note**: plugins are called when the processor is *frozen*, not when\n *   > they are applied.\n */\n\n/**\n * Tuple of a plugin and its configuration.\n *\n * The first item is a plugin, the rest are its parameters.\n *\n * @template {Array<unknown>} [TupleParameters=[]]\n *   Arguments passed to the plugin (default: `[]`, the empty tuple).\n * @template {Node | string | undefined} [Input=undefined]\n *   Value that is expected as input (optional).\n *\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\n *       should be the node it expects.\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be\n *       `string`.\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be the\n *       node it expects.\n * @template [Output=undefined] (optional).\n *   Value that is yielded as output.\n *\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\n *       should be the node that that yields.\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be the\n *       node that it yields.\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be\n *       result it yields.\n * @typedef {(\n *   [\n *     plugin: Plugin<TupleParameters, Input, Output>,\n *     ...parameters: TupleParameters\n *   ]\n * )} PluginTuple\n */\n\n/**\n * @typedef Preset\n *   Sharable configuration.\n *\n *   They can contain plugins and settings.\n * @property {PluggableList | undefined} [plugins]\n *   List of plugins and presets (optional).\n * @property {Settings | undefined} [settings]\n *   Shared settings for parsers and compilers (optional).\n */\n\n/**\n * @template {VFile} [File=VFile]\n *   The file that the callback receives (default: `VFile`).\n * @callback ProcessCallback\n *   Callback called when the process is done.\n *\n *   Called with either an error or a result.\n * @param {Error | undefined} [error]\n *   Fatal error (optional).\n * @param {File | undefined} [file]\n *   Processed file (optional).\n * @returns {undefined}\n *   Nothing.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   The tree that the callback receives (default: `Node`).\n * @callback RunCallback\n *   Callback called when transformers are done.\n *\n *   Called with either an error or results.\n * @param {Error | undefined} [error]\n *   Fatal error (optional).\n * @param {Tree | undefined} [tree]\n *   Transformed tree (optional).\n * @param {VFile | undefined} [file]\n *   File (optional).\n * @returns {undefined}\n *   Nothing.\n */\n\n/**\n * @template {Node} [Output=Node]\n *   Node type that the transformer yields (default: `Node`).\n * @callback TransformCallback\n *   Callback passed to transforms.\n *\n *   If the signature of a `transformer` accepts a third argument, the\n *   transformer may perform asynchronous operations, and must call it.\n * @param {Error | undefined} [error]\n *   Fatal error to stop the process (optional).\n * @param {Output | undefined} [tree]\n *   New, changed, tree (optional).\n * @param {VFile | undefined} [file]\n *   New, changed, file (optional).\n * @returns {undefined}\n *   Nothing.\n */\n\n/**\n * @template {Node} [Input=Node]\n *   Node type that the transformer expects (default: `Node`).\n * @template {Node} [Output=Input]\n *   Node type that the transformer yields (default: `Input`).\n * @callback Transformer\n *   Transformers handle syntax trees and files.\n *\n *   They are functions that are called each time a syntax tree and file are\n *   passed through the run phase.\n *   When an error occurs in them (either because itâ€™s thrown, returned,\n *   rejected, or passed to `next`), the process stops.\n *\n *   The run phase is handled by [`trough`][trough], see its documentation for\n *   the exact semantics of these functions.\n *\n *   > ðŸ‘‰ **Note**: you should likely ignore `next`: donâ€™t accept it.\n *   > it supports callback-style async work.\n *   > But promises are likely easier to reason about.\n *\n *   [trough]: https://github.com/wooorm/trough#function-fninput-next\n * @param {Input} tree\n *   Tree to handle.\n * @param {VFile} file\n *   File to handle.\n * @param {TransformCallback<Output>} next\n *   Callback.\n * @returns {(\n *   Promise<Output | undefined | void> |\n *   Promise<never> | // For some reason this is needed separately.\n *   Output |\n *   Error |\n *   undefined |\n *   void\n * )}\n *   If you accept `next`, nothing.\n *   Otherwise:\n *\n *   *   `Error` â€” fatal error to stop the process\n *   *   `Promise<undefined>` or `undefined` â€” the next transformer keeps using\n *       same tree\n *   *   `Promise<Node>` or `Node` â€” new, changed, tree\n */\n\n/**\n * @template {Node | undefined} ParseTree\n *   Output of `parse`.\n * @template {Node | undefined} HeadTree\n *   Input for `run`.\n * @template {Node | undefined} TailTree\n *   Output for `run`.\n * @template {Node | undefined} CompileTree\n *   Input of `stringify`.\n * @template {CompileResults | undefined} CompileResult\n *   Output of `stringify`.\n * @template {Node | string | undefined} Input\n *   Input of plugin.\n * @template Output\n *   Output of plugin (optional).\n * @typedef {(\n *   Input extends string\n *     ? Output extends Node | undefined\n *       ? // Parser.\n *         Processor<\n *           Output extends undefined ? ParseTree : Output,\n *           HeadTree,\n *           TailTree,\n *           CompileTree,\n *           CompileResult\n *         >\n *       : // Unknown.\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n *     : Output extends CompileResults\n *     ? Input extends Node | undefined\n *       ? // Compiler.\n *         Processor<\n *           ParseTree,\n *           HeadTree,\n *           TailTree,\n *           Input extends undefined ? CompileTree : Input,\n *           Output extends undefined ? CompileResult : Output\n *         >\n *       : // Unknown.\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n *     : Input extends Node | undefined\n *     ? Output extends Node | undefined\n *       ? // Transform.\n *         Processor<\n *           ParseTree,\n *           HeadTree extends undefined ? Input : HeadTree,\n *           Output extends undefined ? TailTree : Output,\n *           CompileTree,\n *           CompileResult\n *         >\n *       : // Unknown.\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n *     : // Unknown.\n *       Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n * )} UsePlugin\n *   Create a processor based on the input/output of a {@link Plugin plugin}.\n */\n\n/**\n * @template {CompileResults | undefined} Result\n *   Node type that the transformer yields.\n * @typedef {(\n *   Result extends Value | undefined ?\n *     VFile :\n *     VFile & {result: Result}\n *   )} VFileWithOutput\n *   Type to generate a {@link VFile `VFile`} corresponding to a compiler result.\n *\n *   If a result that is not acceptable on a `VFile` is used, that will\n *   be stored on the `result` field of {@link VFile `VFile`}.\n */\n\nimport { bail } from 'bail';\nimport extend from 'extend';\nimport { ok as assert } from 'devlop';\nimport isPlainObj from 'is-plain-obj';\nimport { trough } from 'trough';\nimport { VFile } from 'vfile';\nimport { CallableInstance } from './callable-instance.js';\n\n// To do: next major: drop `Compiler`, `Parser`: prefer lowercase.\n\n// To do: we could start yielding `never` in TS when a parser is missing and\n// `parse` is called.\n// Currently, we allow directly setting `processor.parser`, which is untyped.\n\nvar own = {}.hasOwnProperty;\n\n/**\n * @template {Node | undefined} [ParseTree=undefined]\n *   Output of `parse` (optional).\n * @template {Node | undefined} [HeadTree=undefined]\n *   Input for `run` (optional).\n * @template {Node | undefined} [TailTree=undefined]\n *   Output for `run` (optional).\n * @template {Node | undefined} [CompileTree=undefined]\n *   Input of `stringify` (optional).\n * @template {CompileResults | undefined} [CompileResult=undefined]\n *   Output of `stringify` (optional).\n * @extends {CallableInstance<[], Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>>}\n */\nexport var Processor = /*#__PURE__*/function (_CallableInstance) {\n  _inherits(Processor, _CallableInstance);\n  var _super = _createSuper(Processor);\n  /**\n   * Create a processor.\n   */\n  function Processor() {\n    var _this;\n    _classCallCheck(this, Processor);\n    // If `Processor()` is called (w/o new), `copy` is called instead.\n    _this = _super.call(this, 'copy');\n\n    /**\n     * Compiler to use (deprecated).\n     *\n     * @deprecated\n     *   Use `compiler` instead.\n     * @type {(\n     *   Compiler<\n     *     CompileTree extends undefined ? Node : CompileTree,\n     *     CompileResult extends undefined ? CompileResults : CompileResult\n     *   > |\n     *   undefined\n     * )}\n     */\n    _this.Compiler = undefined;\n\n    /**\n     * Parser to use (deprecated).\n     *\n     * @deprecated\n     *   Use `parser` instead.\n     * @type {(\n     *   Parser<ParseTree extends undefined ? Node : ParseTree> |\n     *   undefined\n     * )}\n     */\n    _this.Parser = undefined;\n\n    // Note: the following fields are considered private.\n    // However, they are needed for tests, and TSC generates an untyped\n    // `private freezeIndex` field for, which trips `type-coverage` up.\n    // Instead, we use `@deprecated` to visualize that they shouldnâ€™t be used.\n    /**\n     * Internal list of configured plugins.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {Array<PluginTuple<Array<unknown>>>}\n     */\n    _this.attachers = [];\n\n    /**\n     * Compiler to use.\n     *\n     * @type {(\n     *   Compiler<\n     *     CompileTree extends undefined ? Node : CompileTree,\n     *     CompileResult extends undefined ? CompileResults : CompileResult\n     *   > |\n     *   undefined\n     * )}\n     */\n    _this.compiler = undefined;\n\n    /**\n     * Internal state to track where we are while freezing.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {number}\n     */\n    _this.freezeIndex = -1;\n\n    /**\n     * Internal state to track whether weâ€™re frozen.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {boolean | undefined}\n     */\n    _this.frozen = undefined;\n\n    /**\n     * Internal state.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {Data}\n     */\n    _this.namespace = {};\n\n    /**\n     * Parser to use.\n     *\n     * @type {(\n     *   Parser<ParseTree extends undefined ? Node : ParseTree> |\n     *   undefined\n     * )}\n     */\n    _this.parser = undefined;\n\n    /**\n     * Internal list of configured transformers.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {Pipeline}\n     */\n    _this.transformers = trough();\n    return _this;\n  }\n\n  /**\n   * Copy a processor.\n   *\n   * @deprecated\n   *   This is a private internal method and should not be used.\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *   New *unfrozen* processor ({@link Processor `Processor`}) that is\n   *   configured to work the same as its ancestor.\n   *   When the descendant processor is configured in the future it does not\n   *   affect the ancestral processor.\n   */\n  _createClass(Processor, [{\n    key: \"copy\",\n    value: function copy() {\n      // Cast as the type parameters will be the same after attaching.\n      var destination = /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */\n      new Processor();\n      var index = -1;\n      while (++index < this.attachers.length) {\n        var attacher = this.attachers[index];\n        destination.use.apply(destination, _toConsumableArray(attacher));\n      }\n      destination.data(extend(true, {}, this.namespace));\n      return destination;\n    }\n\n    /**\n     * Configure the processor with info available to all plugins.\n     * Information is stored in an object.\n     *\n     * Typically, options can be given to a specific plugin, but sometimes it\n     * makes sense to have information shared with several plugins.\n     * For example, a list of HTML elements that are self-closing, which is\n     * needed during all phases.\n     *\n     * > ðŸ‘‰ **Note**: setting information cannot occur on *frozen* processors.\n     * > Call the processor first to create a new unfrozen processor.\n     *\n     * > ðŸ‘‰ **Note**: to register custom data in TypeScript, augment the\n     * > {@link Data `Data`} interface.\n     *\n     * @example\n     *   This example show how to get and set info:\n     *\n     *   ```js\n     *   import {unified} from 'unified'\n     *\n     *   const processor = unified().data('alpha', 'bravo')\n     *\n     *   processor.data('alpha') // => 'bravo'\n     *\n     *   processor.data() // => {alpha: 'bravo'}\n     *\n     *   processor.data({charlie: 'delta'})\n     *\n     *   processor.data() // => {charlie: 'delta'}\n     *   ```\n     *\n     * @template {keyof Data} Key\n     *\n     * @overload\n     * @returns {Data}\n     *\n     * @overload\n     * @param {Data} dataset\n     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n     *\n     * @overload\n     * @param {Key} key\n     * @returns {Data[Key]}\n     *\n     * @overload\n     * @param {Key} key\n     * @param {Data[Key]} value\n     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n     *\n     * @param {Data | Key} [key]\n     *   Key to get or set, or entire dataset to set, or nothing to get the\n     *   entire dataset (optional).\n     * @param {Data[Key]} [value]\n     *   Value to set (optional).\n     * @returns {unknown}\n     *   The current processor when setting, the value at `key` when getting, or\n     *   the entire dataset when getting without key.\n     */\n  }, {\n    key: \"data\",\n    value: function data(key, value) {\n      if (typeof key === 'string') {\n        // Set `key`.\n        if (arguments.length === 2) {\n          assertUnfrozen('data', this.frozen);\n          this.namespace[key] = value;\n          return this;\n        }\n\n        // Get `key`.\n        return own.call(this.namespace, key) && this.namespace[key] || undefined;\n      }\n\n      // Set space.\n      if (key) {\n        assertUnfrozen('data', this.frozen);\n        this.namespace = key;\n        return this;\n      }\n\n      // Get space.\n      return this.namespace;\n    }\n\n    /**\n     * Freeze a processor.\n     *\n     * Frozen processors are meant to be extended and not to be configured\n     * directly.\n     *\n     * When a processor is frozen it cannot be unfrozen.\n     * New processors working the same way can be created by calling the\n     * processor.\n     *\n     * Itâ€™s possible to freeze processors explicitly by calling `.freeze()`.\n     * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,\n     * `.stringify()`, `.process()`, or `.processSync()` are called.\n     *\n     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n     *   The current processor.\n     */\n  }, {\n    key: \"freeze\",\n    value: function freeze() {\n      if (this.frozen) {\n        return this;\n      }\n\n      // Cast so that we can type plugins easier.\n      // Plugins are supposed to be usable on different processors, not just on\n      // this exact processor.\n      var self = /** @type {Processor} */ /** @type {unknown} */this;\n      while (++this.freezeIndex < this.attachers.length) {\n        var _this$attachers$this$ = _toArray(this.attachers[this.freezeIndex]),\n          attacher = _this$attachers$this$[0],\n          options = _this$attachers$this$.slice(1);\n        if (options[0] === false) {\n          continue;\n        }\n        if (options[0] === true) {\n          options[0] = undefined;\n        }\n        var transformer = attacher.call.apply(attacher, [self].concat(_toConsumableArray(options)));\n        if (typeof transformer === 'function') {\n          this.transformers.use(transformer);\n        }\n      }\n      this.frozen = true;\n      this.freezeIndex = Number.POSITIVE_INFINITY;\n      return this;\n    }\n\n    /**\n     * Parse text to a syntax tree.\n     *\n     * > ðŸ‘‰ **Note**: `parse` freezes the processor if not already *frozen*.\n     *\n     * > ðŸ‘‰ **Note**: `parse` performs the parse phase, not the run phase or other\n     * > phases.\n     *\n     * @param {Compatible | undefined} [file]\n     *   file to parse (optional); typically `string` or `VFile`; any value\n     *   accepted as `x` in `new VFile(x)`.\n     * @returns {ParseTree extends undefined ? Node : ParseTree}\n     *   Syntax tree representing `file`.\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(file) {\n      this.freeze();\n      var realFile = vfile(file);\n      var parser = this.parser || this.Parser;\n      assertParser('parse', parser);\n      return parser(String(realFile), realFile);\n    }\n\n    /**\n     * Process the given file as configured on the processor.\n     *\n     * > ðŸ‘‰ **Note**: `process` freezes the processor if not already *frozen*.\n     *\n     * > ðŸ‘‰ **Note**: `process` performs the parse, run, and stringify phases.\n     *\n     * @overload\n     * @param {Compatible | undefined} file\n     * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done\n     * @returns {undefined}\n     *\n     * @overload\n     * @param {Compatible | undefined} [file]\n     * @returns {Promise<VFileWithOutput<CompileResult>>}\n     *\n     * @param {Compatible | undefined} [file]\n     *   File (optional); typically `string` or `VFile`]; any value accepted as\n     *   `x` in `new VFile(x)`.\n     * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]\n     *   Callback (optional).\n     * @returns {Promise<VFile> | undefined}\n     *   Nothing if `done` is given.\n     *   Otherwise a promise, rejected with a fatal error or resolved with the\n     *   processed file.\n     *\n     *   The parsed, transformed, and compiled value is available at\n     *   `file.value` (see note).\n     *\n     *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most\n     *   > compilers return `string` (or `Uint8Array`).\n     *   > Some compilers, such as the one configured with\n     *   > [`rehype-react`][rehype-react], return other values (in this case, a\n     *   > React tree).\n     *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\n     *   > result values.\n     *   >\n     *   > To register custom results in TypeScript, add them to\n     *   > {@link CompileResultMap `CompileResultMap`}.\n     *\n     *   [rehype-react]: https://github.com/rehypejs/rehype-react\n     */\n  }, {\n    key: \"process\",\n    value: function process(file, done) {\n      var self = this;\n      this.freeze();\n      assertParser('process', this.parser || this.Parser);\n      assertCompiler('process', this.compiler || this.Compiler);\n      return done ? executor(undefined, done) : new Promise(executor);\n\n      // Note: `void`s needed for TS.\n      /**\n       * @param {((file: VFileWithOutput<CompileResult>) => undefined | void) | undefined} resolve\n       * @param {(error: Error | undefined) => undefined | void} reject\n       * @returns {undefined}\n       */\n      function executor(resolve, reject) {\n        var realFile = vfile(file);\n        // Assume `ParseTree` (the result of the parser) matches `HeadTree` (the\n        // input of the first transform).\n        var parseTree = /** @type {HeadTree extends undefined ? Node : HeadTree} */\n        /** @type {unknown} */self.parse(realFile);\n        self.run(parseTree, realFile, function (error, tree, file) {\n          if (error || !tree || !file) {\n            return realDone(error);\n          }\n\n          // Assume `TailTree` (the output of the last transform) matches\n          // `CompileTree` (the input of the compiler).\n          var compileTree = /** @type {CompileTree extends undefined ? Node : CompileTree} */\n          /** @type {unknown} */tree;\n          var compileResult = self.stringify(compileTree, file);\n          if (looksLikeAValue(compileResult)) {\n            file.value = compileResult;\n          } else {\n            file.result = compileResult;\n          }\n          realDone(error, /** @type {VFileWithOutput<CompileResult>} */file);\n        });\n\n        /**\n         * @param {Error | undefined} error\n         * @param {VFileWithOutput<CompileResult> | undefined} [file]\n         * @returns {undefined}\n         */\n        function realDone(error, file) {\n          if (error || !file) {\n            reject(error);\n          } else if (resolve) {\n            resolve(file);\n          } else {\n            assert(done, '`done` is defined if `resolve` is not');\n            done(undefined, file);\n          }\n        }\n      }\n    }\n\n    /**\n     * Process the given file as configured on the processor.\n     *\n     * An error is thrown if asynchronous transforms are configured.\n     *\n     * > ðŸ‘‰ **Note**: `processSync` freezes the processor if not already *frozen*.\n     *\n     * > ðŸ‘‰ **Note**: `processSync` performs the parse, run, and stringify phases.\n     *\n     * @param {Compatible | undefined} [file]\n     *   File (optional); typically `string` or `VFile`; any value accepted as\n     *   `x` in `new VFile(x)`.\n     * @returns {VFileWithOutput<CompileResult>}\n     *   The processed file.\n     *\n     *   The parsed, transformed, and compiled value is available at\n     *   `file.value` (see note).\n     *\n     *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most\n     *   > compilers return `string` (or `Uint8Array`).\n     *   > Some compilers, such as the one configured with\n     *   > [`rehype-react`][rehype-react], return other values (in this case, a\n     *   > React tree).\n     *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\n     *   > result values.\n     *   >\n     *   > To register custom results in TypeScript, add them to\n     *   > {@link CompileResultMap `CompileResultMap`}.\n     *\n     *   [rehype-react]: https://github.com/rehypejs/rehype-react\n     */\n  }, {\n    key: \"processSync\",\n    value: function processSync(file) {\n      /** @type {boolean} */\n      var complete = false;\n      /** @type {VFileWithOutput<CompileResult> | undefined} */\n      var result;\n      this.freeze();\n      assertParser('processSync', this.parser || this.Parser);\n      assertCompiler('processSync', this.compiler || this.Compiler);\n      this.process(file, realDone);\n      assertDone('processSync', 'process', complete);\n      assert(result, 'we either bailed on an error or have a tree');\n      return result;\n\n      /**\n       * @type {ProcessCallback<VFileWithOutput<CompileResult>>}\n       */\n      function realDone(error, file) {\n        complete = true;\n        bail(error);\n        result = file;\n      }\n    }\n\n    /**\n     * Run *transformers* on a syntax tree.\n     *\n     * > ðŸ‘‰ **Note**: `run` freezes the processor if not already *frozen*.\n     *\n     * > ðŸ‘‰ **Note**: `run` performs the run phase, not other phases.\n     *\n     * @overload\n     * @param {HeadTree extends undefined ? Node : HeadTree} tree\n     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done\n     * @returns {undefined}\n     *\n     * @overload\n     * @param {HeadTree extends undefined ? Node : HeadTree} tree\n     * @param {Compatible | undefined} file\n     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done\n     * @returns {undefined}\n     *\n     * @overload\n     * @param {HeadTree extends undefined ? Node : HeadTree} tree\n     * @param {Compatible | undefined} [file]\n     * @returns {Promise<TailTree extends undefined ? Node : TailTree>}\n     *\n     * @param {HeadTree extends undefined ? Node : HeadTree} tree\n     *   Tree to transform and inspect.\n     * @param {(\n     *   RunCallback<TailTree extends undefined ? Node : TailTree> |\n     *   Compatible\n     * )} [file]\n     *   File associated with `node` (optional); any value accepted as `x` in\n     *   `new VFile(x)`.\n     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]\n     *   Callback (optional).\n     * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}\n     *   Nothing if `done` is given.\n     *   Otherwise, a promise rejected with a fatal error or resolved with the\n     *   transformed tree.\n     */\n  }, {\n    key: \"run\",\n    value: function run(tree, file, done) {\n      assertNode(tree);\n      this.freeze();\n      var transformers = this.transformers;\n      if (!done && typeof file === 'function') {\n        done = file;\n        file = undefined;\n      }\n      return done ? executor(undefined, done) : new Promise(executor);\n\n      // Note: `void`s needed for TS.\n      /**\n       * @param {(\n       *   ((tree: TailTree extends undefined ? Node : TailTree) => undefined | void) |\n       *   undefined\n       * )} resolve\n       * @param {(error: Error) => undefined | void} reject\n       * @returns {undefined}\n       */\n      function executor(resolve, reject) {\n        assert(typeof file !== 'function', '`file` canâ€™t be a `done` anymore, we checked');\n        var realFile = vfile(file);\n        transformers.run(tree, realFile, realDone);\n\n        /**\n         * @param {Error | undefined} error\n         * @param {Node} outputTree\n         * @param {VFile} file\n         * @returns {undefined}\n         */\n        function realDone(error, outputTree, file) {\n          var resultingTree = /** @type {TailTree extends undefined ? Node : TailTree} */\n          outputTree || tree;\n          if (error) {\n            reject(error);\n          } else if (resolve) {\n            resolve(resultingTree);\n          } else {\n            assert(done, '`done` is defined if `resolve` is not');\n            done(undefined, resultingTree, file);\n          }\n        }\n      }\n    }\n\n    /**\n     * Run *transformers* on a syntax tree.\n     *\n     * An error is thrown if asynchronous transforms are configured.\n     *\n     * > ðŸ‘‰ **Note**: `runSync` freezes the processor if not already *frozen*.\n     *\n     * > ðŸ‘‰ **Note**: `runSync` performs the run phase, not other phases.\n     *\n     * @param {HeadTree extends undefined ? Node : HeadTree} tree\n     *   Tree to transform and inspect.\n     * @param {Compatible | undefined} [file]\n     *   File associated with `node` (optional); any value accepted as `x` in\n     *   `new VFile(x)`.\n     * @returns {TailTree extends undefined ? Node : TailTree}\n     *   Transformed tree.\n     */\n  }, {\n    key: \"runSync\",\n    value: function runSync(tree, file) {\n      /** @type {boolean} */\n      var complete = false;\n      /** @type {(TailTree extends undefined ? Node : TailTree) | undefined} */\n      var result;\n      this.run(tree, file, realDone);\n      assertDone('runSync', 'run', complete);\n      assert(result, 'we either bailed on an error or have a tree');\n      return result;\n\n      /**\n       * @type {RunCallback<TailTree extends undefined ? Node : TailTree>}\n       */\n      function realDone(error, tree) {\n        bail(error);\n        result = tree;\n        complete = true;\n      }\n    }\n\n    /**\n     * Compile a syntax tree.\n     *\n     * > ðŸ‘‰ **Note**: `stringify` freezes the processor if not already *frozen*.\n     *\n     * > ðŸ‘‰ **Note**: `stringify` performs the stringify phase, not the run phase\n     * > or other phases.\n     *\n     * @param {CompileTree extends undefined ? Node : CompileTree} tree\n     *   Tree to compile.\n     * @param {Compatible | undefined} [file]\n     *   File associated with `node` (optional); any value accepted as `x` in\n     *   `new VFile(x)`.\n     * @returns {CompileResult extends undefined ? Value : CompileResult}\n     *   Textual representation of the tree (see note).\n     *\n     *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most compilers\n     *   > return `string` (or `Uint8Array`).\n     *   > Some compilers, such as the one configured with\n     *   > [`rehype-react`][rehype-react], return other values (in this case, a\n     *   > React tree).\n     *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\n     *   > result values.\n     *   >\n     *   > To register custom results in TypeScript, add them to\n     *   > {@link CompileResultMap `CompileResultMap`}.\n     *\n     *   [rehype-react]: https://github.com/rehypejs/rehype-react\n     */\n  }, {\n    key: \"stringify\",\n    value: function stringify(tree, file) {\n      this.freeze();\n      var realFile = vfile(file);\n      var compiler = this.compiler || this.Compiler;\n      assertCompiler('stringify', compiler);\n      assertNode(tree);\n      return compiler(tree, realFile);\n    }\n\n    /**\n     * Configure the processor to use a plugin, a list of usable values, or a\n     * preset.\n     *\n     * If the processor is already using a plugin, the previous plugin\n     * configuration is changed based on the options that are passed in.\n     * In other words, the plugin is not added a second time.\n     *\n     * > ðŸ‘‰ **Note**: `use` cannot be called on *frozen* processors.\n     * > Call the processor first to create a new unfrozen processor.\n     *\n     * @example\n     *   There are many ways to pass plugins to `.use()`.\n     *   This example gives an overview:\n     *\n     *   ```js\n     *   import {unified} from 'unified'\n     *\n     *   unified()\n     *     // Plugin with options:\n     *     .use(pluginA, {x: true, y: true})\n     *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n     *     .use(pluginA, {y: false, z: true})\n     *     // Plugins:\n     *     .use([pluginB, pluginC])\n     *     // Two plugins, the second with options:\n     *     .use([pluginD, [pluginE, {}]])\n     *     // Preset with plugins and settings:\n     *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n     *     // Settings only:\n     *     .use({settings: {position: false}})\n     *   ```\n     *\n     * @template {Array<unknown>} [Parameters=[]]\n     * @template {Node | string | undefined} [Input=undefined]\n     * @template [Output=Input]\n     *\n     * @overload\n     * @param {Preset | null | undefined} [preset]\n     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n     *\n     * @overload\n     * @param {PluggableList} list\n     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n     *\n     * @overload\n     * @param {Plugin<Parameters, Input, Output>} plugin\n     * @param {...(Parameters | [boolean])} parameters\n     * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}\n     *\n     * @param {PluggableList | Plugin | Preset | null | undefined} value\n     *   Usable value.\n     * @param {...unknown} parameters\n     *   Parameters, when a plugin is given as a usable value.\n     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n     *   Current processor.\n     */\n  }, {\n    key: \"use\",\n    value: function use(value) {\n      var attachers = this.attachers;\n      var namespace = this.namespace;\n      assertUnfrozen('use', this.frozen);\n      if (value === null || value === undefined) {\n        // Empty.\n      } else if (typeof value === 'function') {\n        for (var _len = arguments.length, parameters = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          parameters[_key - 1] = arguments[_key];\n        }\n        addPlugin(value, parameters);\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          addList(value);\n        } else {\n          addPreset(value);\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`');\n      }\n      return this;\n\n      /**\n       * @param {Pluggable} value\n       * @returns {undefined}\n       */\n      function add(value) {\n        if (typeof value === 'function') {\n          addPlugin(value, []);\n        } else if (typeof value === 'object') {\n          if (Array.isArray(value)) {\n            var _value = _toArray( /** @type {PluginTuple<Array<unknown>>} */value),\n              plugin = _value[0],\n              _parameters = _value.slice(1);\n            addPlugin(plugin, _parameters);\n          } else {\n            addPreset(value);\n          }\n        } else {\n          throw new TypeError('Expected usable value, not `' + value + '`');\n        }\n      }\n\n      /**\n       * @param {Preset} result\n       * @returns {undefined}\n       */\n      function addPreset(result) {\n        if (!('plugins' in result) && !('settings' in result)) {\n          throw new Error('Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither');\n        }\n        addList(result.plugins);\n        if (result.settings) {\n          namespace.settings = extend(true, namespace.settings, result.settings);\n        }\n      }\n\n      /**\n       * @param {PluggableList | null | undefined} plugins\n       * @returns {undefined}\n       */\n      function addList(plugins) {\n        var index = -1;\n        if (plugins === null || plugins === undefined) {\n          // Empty.\n        } else if (Array.isArray(plugins)) {\n          while (++index < plugins.length) {\n            var thing = plugins[index];\n            add(thing);\n          }\n        } else {\n          throw new TypeError('Expected a list of plugins, not `' + plugins + '`');\n        }\n      }\n\n      /**\n       * @param {Plugin} plugin\n       * @param {Array<unknown>} parameters\n       * @returns {undefined}\n       */\n      function addPlugin(plugin, parameters) {\n        var index = -1;\n        var entryIndex = -1;\n        while (++index < attachers.length) {\n          if (attachers[index][0] === plugin) {\n            entryIndex = index;\n            break;\n          }\n        }\n        if (entryIndex === -1) {\n          attachers.push([plugin].concat(_toConsumableArray(parameters)));\n        }\n        // Only set if there was at least a `primary` value, otherwise weâ€™d change\n        // `arguments.length`.\n        else if (parameters.length > 0) {\n          var _parameters2 = _toArray(parameters),\n            primary = _parameters2[0],\n            rest = _parameters2.slice(1);\n          var currentPrimary = attachers[entryIndex][1];\n          if (isPlainObj(currentPrimary) && isPlainObj(primary)) {\n            primary = extend(true, currentPrimary, primary);\n          }\n          attachers[entryIndex] = [plugin, primary].concat(_toConsumableArray(rest));\n        }\n      }\n    }\n  }]);\n  return Processor;\n}(CallableInstance);\n\n// Note: this returns a *callable* instance.\n// Thatâ€™s why itâ€™s documented as a function.\n/**\n * Create a new processor.\n *\n * @example\n *   This example shows how a new processor can be created (from `remark`) and linked\n *   to **stdin**(4) and **stdout**(4).\n *\n *   ```js\n *   import process from 'node:process'\n *   import concatStream from 'concat-stream'\n *   import {remark} from 'remark'\n *\n *   process.stdin.pipe(\n *     concatStream(function (buf) {\n *       process.stdout.write(String(remark().processSync(buf)))\n *     })\n *   )\n *   ```\n *\n * @returns\n *   New *unfrozen* processor (`processor`).\n *\n *   This processor is configured to work the same as its ancestor.\n *   When the descendant processor is configured in the future it does not\n *   affect the ancestral processor.\n */\nexport var unified = new Processor().freeze();\n\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `parser`');\n  }\n}\n\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `compiler`');\n  }\n}\n\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error('Cannot call `' + name + '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.');\n  }\n}\n\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`');\n    // Fine.\n  }\n}\n\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');\n  }\n}\n\n/**\n * @param {Compatible | undefined} [value]\n * @returns {VFile}\n */\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new VFile(value);\n}\n\n/**\n * @param {Compatible | undefined} [value]\n * @returns {value is VFile}\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(value && typeof value === 'object' && 'message' in value && 'messages' in value);\n}\n\n/**\n * @param {unknown} [value]\n * @returns {value is Value}\n */\nfunction looksLikeAValue(value) {\n  return typeof value === 'string' || isUint8Array(value);\n}\n\n/**\n * Assert `value` is an `Uint8Array`.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Uint8Array}\n *   Whether `value` is an `Uint8Array`.\n */\nfunction isUint8Array(value) {\n  return Boolean(value && typeof value === 'object' && 'byteLength' in value && 'byteOffset' in value);\n}","map":{"version":3,"names":["bail","extend","ok","assert","isPlainObj","trough","VFile","CallableInstance","own","hasOwnProperty","Processor","_CallableInstance","_inherits","_super","_createSuper","_this","_classCallCheck","call","Compiler","undefined","Parser","attachers","compiler","freezeIndex","frozen","namespace","parser","transformers","_createClass","key","value","copy","destination","index","length","attacher","use","apply","_toConsumableArray","data","arguments","assertUnfrozen","freeze","self","_this$attachers$this$","_toArray","options","slice","transformer","concat","Number","POSITIVE_INFINITY","parse","file","realFile","vfile","assertParser","String","process","done","assertCompiler","executor","Promise","resolve","reject","parseTree","run","error","tree","realDone","compileTree","compileResult","stringify","looksLikeAValue","result","processSync","complete","assertDone","assertNode","outputTree","resultingTree","runSync","_len","parameters","Array","_key","addPlugin","isArray","addList","addPreset","TypeError","add","_value","plugin","Error","plugins","settings","thing","entryIndex","push","_parameters2","primary","rest","currentPrimary","unified","name","node","type","asyncName","looksLikeAVFile","Boolean","isUint8Array"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/seafile-editor/node_modules/unified/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('trough').Pipeline} Pipeline\n *\n * @typedef {import('unist').Node} Node\n *\n * @typedef {import('vfile').Compatible} Compatible\n * @typedef {import('vfile').Value} Value\n *\n * @typedef {import('../index.js').CompileResultMap} CompileResultMap\n * @typedef {import('../index.js').Data} Data\n * @typedef {import('../index.js').Settings} Settings\n */\n\n/**\n * @typedef {CompileResultMap[keyof CompileResultMap]} CompileResults\n *   Acceptable results from compilers.\n *\n *   To register custom results, add them to\n *   {@link CompileResultMap `CompileResultMap`}.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   The node that the compiler receives (default: `Node`).\n * @template {CompileResults} [Result=CompileResults]\n *   The thing that the compiler yields (default: `CompileResults`).\n * @callback Compiler\n *   A **compiler** handles the compiling of a syntax tree to something else\n *   (in most cases, text) (TypeScript type).\n *\n *   It is used in the stringify phase and called with a {@link Node `Node`}\n *   and {@link VFile `VFile`} representation of the document to compile.\n *   It should return the textual representation of the given tree (typically\n *   `string`).\n *\n *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most compilers\n *   > return `string` (or `Uint8Array`).\n *   > Some compilers, such as the one configured with\n *   > [`rehype-react`][rehype-react], return other values (in this case, a\n *   > React tree).\n *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\n *   > result values.\n *   >\n *   > To register custom results in TypeScript, add them to\n *   > {@link CompileResultMap `CompileResultMap`}.\n *\n *   [rehype-react]: https://github.com/rehypejs/rehype-react\n * @param {Tree} tree\n *   Tree to compile.\n * @param {VFile} file\n *   File associated with `tree`.\n * @returns {Result}\n *   New content: compiled text (`string` or `Uint8Array`, for `file.value`) or\n *   something else (for `file.result`).\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   The node that the parser yields (default: `Node`)\n * @callback Parser\n *   A **parser** handles the parsing of text to a syntax tree.\n *\n *   It is used in the parse phase and is called with a `string` and\n *   {@link VFile `VFile`} of the document to parse.\n *   It must return the syntax tree representation of the given file\n *   ({@link Node `Node`}).\n * @param {string} document\n *   Document to parse.\n * @param {VFile} file\n *   File associated with `document`.\n * @returns {Tree}\n *   Node representing the given file.\n */\n\n/**\n * @typedef {(\n *   Plugin<Array<any>, any, any> |\n *   PluginTuple<Array<any>, any, any> |\n *   Preset\n * )} Pluggable\n *   Union of the different ways to add plugins and settings.\n */\n\n/**\n * @typedef {Array<Pluggable>} PluggableList\n *   List of plugins and presets.\n */\n\n// Note: we canâ€™t use `callback` yet as it messes up `this`:\n//  <https://github.com/microsoft/TypeScript/issues/55197>.\n/**\n * @template {Array<unknown>} [PluginParameters=[]]\n *   Arguments passed to the plugin (default: `[]`, the empty tuple).\n * @template {Node | string | undefined} [Input=Node]\n *   Value that is expected as input (default: `Node`).\n *\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\n *       should be the node it expects.\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be\n *       `string`.\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be the\n *       node it expects.\n * @template [Output=Input]\n *   Value that is yielded as output (default: `Input`).\n *\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\n *       should be the node that that yields.\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be the\n *       node that it yields.\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be\n *       result it yields.\n * @typedef {(\n *   (this: Processor, ...parameters: PluginParameters) =>\n *     Input extends string ? // Parser.\n *        Output extends Node | undefined ? undefined | void : never :\n *     Output extends CompileResults ? // Compiler.\n *        Input extends Node | undefined ? undefined | void : never :\n *     Transformer<\n *       Input extends Node ? Input : Node,\n *       Output extends Node ? Output : Node\n *     > | undefined | void\n * )} Plugin\n *   Single plugin.\n *\n *   Plugins configure the processors they are applied on in the following\n *   ways:\n *\n *   *   they change the processor, such as the parser, the compiler, or by\n *       configuring data\n *   *   they specify how to handle trees and files\n *\n *   In practice, they are functions that can receive options and configure the\n *   processor (`this`).\n *\n *   > ðŸ‘‰ **Note**: plugins are called when the processor is *frozen*, not when\n *   > they are applied.\n */\n\n/**\n * Tuple of a plugin and its configuration.\n *\n * The first item is a plugin, the rest are its parameters.\n *\n * @template {Array<unknown>} [TupleParameters=[]]\n *   Arguments passed to the plugin (default: `[]`, the empty tuple).\n * @template {Node | string | undefined} [Input=undefined]\n *   Value that is expected as input (optional).\n *\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\n *       should be the node it expects.\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be\n *       `string`.\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be the\n *       node it expects.\n * @template [Output=undefined] (optional).\n *   Value that is yielded as output.\n *\n *   *   If the plugin returns a {@link Transformer `Transformer`}, this\n *       should be the node that that yields.\n *   *   If the plugin sets a {@link Parser `Parser`}, this should be the\n *       node that it yields.\n *   *   If the plugin sets a {@link Compiler `Compiler`}, this should be\n *       result it yields.\n * @typedef {(\n *   [\n *     plugin: Plugin<TupleParameters, Input, Output>,\n *     ...parameters: TupleParameters\n *   ]\n * )} PluginTuple\n */\n\n/**\n * @typedef Preset\n *   Sharable configuration.\n *\n *   They can contain plugins and settings.\n * @property {PluggableList | undefined} [plugins]\n *   List of plugins and presets (optional).\n * @property {Settings | undefined} [settings]\n *   Shared settings for parsers and compilers (optional).\n */\n\n/**\n * @template {VFile} [File=VFile]\n *   The file that the callback receives (default: `VFile`).\n * @callback ProcessCallback\n *   Callback called when the process is done.\n *\n *   Called with either an error or a result.\n * @param {Error | undefined} [error]\n *   Fatal error (optional).\n * @param {File | undefined} [file]\n *   Processed file (optional).\n * @returns {undefined}\n *   Nothing.\n */\n\n/**\n * @template {Node} [Tree=Node]\n *   The tree that the callback receives (default: `Node`).\n * @callback RunCallback\n *   Callback called when transformers are done.\n *\n *   Called with either an error or results.\n * @param {Error | undefined} [error]\n *   Fatal error (optional).\n * @param {Tree | undefined} [tree]\n *   Transformed tree (optional).\n * @param {VFile | undefined} [file]\n *   File (optional).\n * @returns {undefined}\n *   Nothing.\n */\n\n/**\n * @template {Node} [Output=Node]\n *   Node type that the transformer yields (default: `Node`).\n * @callback TransformCallback\n *   Callback passed to transforms.\n *\n *   If the signature of a `transformer` accepts a third argument, the\n *   transformer may perform asynchronous operations, and must call it.\n * @param {Error | undefined} [error]\n *   Fatal error to stop the process (optional).\n * @param {Output | undefined} [tree]\n *   New, changed, tree (optional).\n * @param {VFile | undefined} [file]\n *   New, changed, file (optional).\n * @returns {undefined}\n *   Nothing.\n */\n\n/**\n * @template {Node} [Input=Node]\n *   Node type that the transformer expects (default: `Node`).\n * @template {Node} [Output=Input]\n *   Node type that the transformer yields (default: `Input`).\n * @callback Transformer\n *   Transformers handle syntax trees and files.\n *\n *   They are functions that are called each time a syntax tree and file are\n *   passed through the run phase.\n *   When an error occurs in them (either because itâ€™s thrown, returned,\n *   rejected, or passed to `next`), the process stops.\n *\n *   The run phase is handled by [`trough`][trough], see its documentation for\n *   the exact semantics of these functions.\n *\n *   > ðŸ‘‰ **Note**: you should likely ignore `next`: donâ€™t accept it.\n *   > it supports callback-style async work.\n *   > But promises are likely easier to reason about.\n *\n *   [trough]: https://github.com/wooorm/trough#function-fninput-next\n * @param {Input} tree\n *   Tree to handle.\n * @param {VFile} file\n *   File to handle.\n * @param {TransformCallback<Output>} next\n *   Callback.\n * @returns {(\n *   Promise<Output | undefined | void> |\n *   Promise<never> | // For some reason this is needed separately.\n *   Output |\n *   Error |\n *   undefined |\n *   void\n * )}\n *   If you accept `next`, nothing.\n *   Otherwise:\n *\n *   *   `Error` â€” fatal error to stop the process\n *   *   `Promise<undefined>` or `undefined` â€” the next transformer keeps using\n *       same tree\n *   *   `Promise<Node>` or `Node` â€” new, changed, tree\n */\n\n/**\n * @template {Node | undefined} ParseTree\n *   Output of `parse`.\n * @template {Node | undefined} HeadTree\n *   Input for `run`.\n * @template {Node | undefined} TailTree\n *   Output for `run`.\n * @template {Node | undefined} CompileTree\n *   Input of `stringify`.\n * @template {CompileResults | undefined} CompileResult\n *   Output of `stringify`.\n * @template {Node | string | undefined} Input\n *   Input of plugin.\n * @template Output\n *   Output of plugin (optional).\n * @typedef {(\n *   Input extends string\n *     ? Output extends Node | undefined\n *       ? // Parser.\n *         Processor<\n *           Output extends undefined ? ParseTree : Output,\n *           HeadTree,\n *           TailTree,\n *           CompileTree,\n *           CompileResult\n *         >\n *       : // Unknown.\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n *     : Output extends CompileResults\n *     ? Input extends Node | undefined\n *       ? // Compiler.\n *         Processor<\n *           ParseTree,\n *           HeadTree,\n *           TailTree,\n *           Input extends undefined ? CompileTree : Input,\n *           Output extends undefined ? CompileResult : Output\n *         >\n *       : // Unknown.\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n *     : Input extends Node | undefined\n *     ? Output extends Node | undefined\n *       ? // Transform.\n *         Processor<\n *           ParseTree,\n *           HeadTree extends undefined ? Input : HeadTree,\n *           Output extends undefined ? TailTree : Output,\n *           CompileTree,\n *           CompileResult\n *         >\n *       : // Unknown.\n *         Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n *     : // Unknown.\n *       Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>\n * )} UsePlugin\n *   Create a processor based on the input/output of a {@link Plugin plugin}.\n */\n\n/**\n * @template {CompileResults | undefined} Result\n *   Node type that the transformer yields.\n * @typedef {(\n *   Result extends Value | undefined ?\n *     VFile :\n *     VFile & {result: Result}\n *   )} VFileWithOutput\n *   Type to generate a {@link VFile `VFile`} corresponding to a compiler result.\n *\n *   If a result that is not acceptable on a `VFile` is used, that will\n *   be stored on the `result` field of {@link VFile `VFile`}.\n */\n\nimport {bail} from 'bail'\nimport extend from 'extend'\nimport {ok as assert} from 'devlop'\nimport isPlainObj from 'is-plain-obj'\nimport {trough} from 'trough'\nimport {VFile} from 'vfile'\nimport {CallableInstance} from './callable-instance.js'\n\n// To do: next major: drop `Compiler`, `Parser`: prefer lowercase.\n\n// To do: we could start yielding `never` in TS when a parser is missing and\n// `parse` is called.\n// Currently, we allow directly setting `processor.parser`, which is untyped.\n\nconst own = {}.hasOwnProperty\n\n/**\n * @template {Node | undefined} [ParseTree=undefined]\n *   Output of `parse` (optional).\n * @template {Node | undefined} [HeadTree=undefined]\n *   Input for `run` (optional).\n * @template {Node | undefined} [TailTree=undefined]\n *   Output for `run` (optional).\n * @template {Node | undefined} [CompileTree=undefined]\n *   Input of `stringify` (optional).\n * @template {CompileResults | undefined} [CompileResult=undefined]\n *   Output of `stringify` (optional).\n * @extends {CallableInstance<[], Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>>}\n */\nexport class Processor extends CallableInstance {\n  /**\n   * Create a processor.\n   */\n  constructor() {\n    // If `Processor()` is called (w/o new), `copy` is called instead.\n    super('copy')\n\n    /**\n     * Compiler to use (deprecated).\n     *\n     * @deprecated\n     *   Use `compiler` instead.\n     * @type {(\n     *   Compiler<\n     *     CompileTree extends undefined ? Node : CompileTree,\n     *     CompileResult extends undefined ? CompileResults : CompileResult\n     *   > |\n     *   undefined\n     * )}\n     */\n    this.Compiler = undefined\n\n    /**\n     * Parser to use (deprecated).\n     *\n     * @deprecated\n     *   Use `parser` instead.\n     * @type {(\n     *   Parser<ParseTree extends undefined ? Node : ParseTree> |\n     *   undefined\n     * )}\n     */\n    this.Parser = undefined\n\n    // Note: the following fields are considered private.\n    // However, they are needed for tests, and TSC generates an untyped\n    // `private freezeIndex` field for, which trips `type-coverage` up.\n    // Instead, we use `@deprecated` to visualize that they shouldnâ€™t be used.\n    /**\n     * Internal list of configured plugins.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {Array<PluginTuple<Array<unknown>>>}\n     */\n    this.attachers = []\n\n    /**\n     * Compiler to use.\n     *\n     * @type {(\n     *   Compiler<\n     *     CompileTree extends undefined ? Node : CompileTree,\n     *     CompileResult extends undefined ? CompileResults : CompileResult\n     *   > |\n     *   undefined\n     * )}\n     */\n    this.compiler = undefined\n\n    /**\n     * Internal state to track where we are while freezing.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {number}\n     */\n    this.freezeIndex = -1\n\n    /**\n     * Internal state to track whether weâ€™re frozen.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {boolean | undefined}\n     */\n    this.frozen = undefined\n\n    /**\n     * Internal state.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {Data}\n     */\n    this.namespace = {}\n\n    /**\n     * Parser to use.\n     *\n     * @type {(\n     *   Parser<ParseTree extends undefined ? Node : ParseTree> |\n     *   undefined\n     * )}\n     */\n    this.parser = undefined\n\n    /**\n     * Internal list of configured transformers.\n     *\n     * @deprecated\n     *   This is a private internal property and should not be used.\n     * @type {Pipeline}\n     */\n    this.transformers = trough()\n  }\n\n  /**\n   * Copy a processor.\n   *\n   * @deprecated\n   *   This is a private internal method and should not be used.\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *   New *unfrozen* processor ({@link Processor `Processor`}) that is\n   *   configured to work the same as its ancestor.\n   *   When the descendant processor is configured in the future it does not\n   *   affect the ancestral processor.\n   */\n  copy() {\n    // Cast as the type parameters will be the same after attaching.\n    const destination =\n      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */ (\n        new Processor()\n      )\n    let index = -1\n\n    while (++index < this.attachers.length) {\n      const attacher = this.attachers[index]\n      destination.use(...attacher)\n    }\n\n    destination.data(extend(true, {}, this.namespace))\n\n    return destination\n  }\n\n  /**\n   * Configure the processor with info available to all plugins.\n   * Information is stored in an object.\n   *\n   * Typically, options can be given to a specific plugin, but sometimes it\n   * makes sense to have information shared with several plugins.\n   * For example, a list of HTML elements that are self-closing, which is\n   * needed during all phases.\n   *\n   * > ðŸ‘‰ **Note**: setting information cannot occur on *frozen* processors.\n   * > Call the processor first to create a new unfrozen processor.\n   *\n   * > ðŸ‘‰ **Note**: to register custom data in TypeScript, augment the\n   * > {@link Data `Data`} interface.\n   *\n   * @example\n   *   This example show how to get and set info:\n   *\n   *   ```js\n   *   import {unified} from 'unified'\n   *\n   *   const processor = unified().data('alpha', 'bravo')\n   *\n   *   processor.data('alpha') // => 'bravo'\n   *\n   *   processor.data() // => {alpha: 'bravo'}\n   *\n   *   processor.data({charlie: 'delta'})\n   *\n   *   processor.data() // => {charlie: 'delta'}\n   *   ```\n   *\n   * @template {keyof Data} Key\n   *\n   * @overload\n   * @returns {Data}\n   *\n   * @overload\n   * @param {Data} dataset\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *\n   * @overload\n   * @param {Key} key\n   * @returns {Data[Key]}\n   *\n   * @overload\n   * @param {Key} key\n   * @param {Data[Key]} value\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *\n   * @param {Data | Key} [key]\n   *   Key to get or set, or entire dataset to set, or nothing to get the\n   *   entire dataset (optional).\n   * @param {Data[Key]} [value]\n   *   Value to set (optional).\n   * @returns {unknown}\n   *   The current processor when setting, the value at `key` when getting, or\n   *   the entire dataset when getting without key.\n   */\n  data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', this.frozen)\n        this.namespace[key] = value\n        return this\n      }\n\n      // Get `key`.\n      return (own.call(this.namespace, key) && this.namespace[key]) || undefined\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', this.frozen)\n      this.namespace = key\n      return this\n    }\n\n    // Get space.\n    return this.namespace\n  }\n\n  /**\n   * Freeze a processor.\n   *\n   * Frozen processors are meant to be extended and not to be configured\n   * directly.\n   *\n   * When a processor is frozen it cannot be unfrozen.\n   * New processors working the same way can be created by calling the\n   * processor.\n   *\n   * Itâ€™s possible to freeze processors explicitly by calling `.freeze()`.\n   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,\n   * `.stringify()`, `.process()`, or `.processSync()` are called.\n   *\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *   The current processor.\n   */\n  freeze() {\n    if (this.frozen) {\n      return this\n    }\n\n    // Cast so that we can type plugins easier.\n    // Plugins are supposed to be usable on different processors, not just on\n    // this exact processor.\n    const self = /** @type {Processor} */ (/** @type {unknown} */ (this))\n\n    while (++this.freezeIndex < this.attachers.length) {\n      const [attacher, ...options] = this.attachers[this.freezeIndex]\n\n      if (options[0] === false) {\n        continue\n      }\n\n      if (options[0] === true) {\n        options[0] = undefined\n      }\n\n      const transformer = attacher.call(self, ...options)\n\n      if (typeof transformer === 'function') {\n        this.transformers.use(transformer)\n      }\n    }\n\n    this.frozen = true\n    this.freezeIndex = Number.POSITIVE_INFINITY\n\n    return this\n  }\n\n  /**\n   * Parse text to a syntax tree.\n   *\n   * > ðŸ‘‰ **Note**: `parse` freezes the processor if not already *frozen*.\n   *\n   * > ðŸ‘‰ **Note**: `parse` performs the parse phase, not the run phase or other\n   * > phases.\n   *\n   * @param {Compatible | undefined} [file]\n   *   file to parse (optional); typically `string` or `VFile`; any value\n   *   accepted as `x` in `new VFile(x)`.\n   * @returns {ParseTree extends undefined ? Node : ParseTree}\n   *   Syntax tree representing `file`.\n   */\n  parse(file) {\n    this.freeze()\n    const realFile = vfile(file)\n    const parser = this.parser || this.Parser\n    assertParser('parse', parser)\n    return parser(String(realFile), realFile)\n  }\n\n  /**\n   * Process the given file as configured on the processor.\n   *\n   * > ðŸ‘‰ **Note**: `process` freezes the processor if not already *frozen*.\n   *\n   * > ðŸ‘‰ **Note**: `process` performs the parse, run, and stringify phases.\n   *\n   * @overload\n   * @param {Compatible | undefined} file\n   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done\n   * @returns {undefined}\n   *\n   * @overload\n   * @param {Compatible | undefined} [file]\n   * @returns {Promise<VFileWithOutput<CompileResult>>}\n   *\n   * @param {Compatible | undefined} [file]\n   *   File (optional); typically `string` or `VFile`]; any value accepted as\n   *   `x` in `new VFile(x)`.\n   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]\n   *   Callback (optional).\n   * @returns {Promise<VFile> | undefined}\n   *   Nothing if `done` is given.\n   *   Otherwise a promise, rejected with a fatal error or resolved with the\n   *   processed file.\n   *\n   *   The parsed, transformed, and compiled value is available at\n   *   `file.value` (see note).\n   *\n   *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most\n   *   > compilers return `string` (or `Uint8Array`).\n   *   > Some compilers, such as the one configured with\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\n   *   > React tree).\n   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\n   *   > result values.\n   *   >\n   *   > To register custom results in TypeScript, add them to\n   *   > {@link CompileResultMap `CompileResultMap`}.\n   *\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\n   */\n  process(file, done) {\n    const self = this\n\n    this.freeze()\n    assertParser('process', this.parser || this.Parser)\n    assertCompiler('process', this.compiler || this.Compiler)\n\n    return done ? executor(undefined, done) : new Promise(executor)\n\n    // Note: `void`s needed for TS.\n    /**\n     * @param {((file: VFileWithOutput<CompileResult>) => undefined | void) | undefined} resolve\n     * @param {(error: Error | undefined) => undefined | void} reject\n     * @returns {undefined}\n     */\n    function executor(resolve, reject) {\n      const realFile = vfile(file)\n      // Assume `ParseTree` (the result of the parser) matches `HeadTree` (the\n      // input of the first transform).\n      const parseTree =\n        /** @type {HeadTree extends undefined ? Node : HeadTree} */ (\n          /** @type {unknown} */ (self.parse(realFile))\n        )\n\n      self.run(parseTree, realFile, function (error, tree, file) {\n        if (error || !tree || !file) {\n          return realDone(error)\n        }\n\n        // Assume `TailTree` (the output of the last transform) matches\n        // `CompileTree` (the input of the compiler).\n        const compileTree =\n          /** @type {CompileTree extends undefined ? Node : CompileTree} */ (\n            /** @type {unknown} */ (tree)\n          )\n\n        const compileResult = self.stringify(compileTree, file)\n\n        if (looksLikeAValue(compileResult)) {\n          file.value = compileResult\n        } else {\n          file.result = compileResult\n        }\n\n        realDone(error, /** @type {VFileWithOutput<CompileResult>} */ (file))\n      })\n\n      /**\n       * @param {Error | undefined} error\n       * @param {VFileWithOutput<CompileResult> | undefined} [file]\n       * @returns {undefined}\n       */\n      function realDone(error, file) {\n        if (error || !file) {\n          reject(error)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          assert(done, '`done` is defined if `resolve` is not')\n          done(undefined, file)\n        }\n      }\n    }\n  }\n\n  /**\n   * Process the given file as configured on the processor.\n   *\n   * An error is thrown if asynchronous transforms are configured.\n   *\n   * > ðŸ‘‰ **Note**: `processSync` freezes the processor if not already *frozen*.\n   *\n   * > ðŸ‘‰ **Note**: `processSync` performs the parse, run, and stringify phases.\n   *\n   * @param {Compatible | undefined} [file]\n   *   File (optional); typically `string` or `VFile`; any value accepted as\n   *   `x` in `new VFile(x)`.\n   * @returns {VFileWithOutput<CompileResult>}\n   *   The processed file.\n   *\n   *   The parsed, transformed, and compiled value is available at\n   *   `file.value` (see note).\n   *\n   *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most\n   *   > compilers return `string` (or `Uint8Array`).\n   *   > Some compilers, such as the one configured with\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\n   *   > React tree).\n   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\n   *   > result values.\n   *   >\n   *   > To register custom results in TypeScript, add them to\n   *   > {@link CompileResultMap `CompileResultMap`}.\n   *\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\n   */\n  processSync(file) {\n    /** @type {boolean} */\n    let complete = false\n    /** @type {VFileWithOutput<CompileResult> | undefined} */\n    let result\n\n    this.freeze()\n    assertParser('processSync', this.parser || this.Parser)\n    assertCompiler('processSync', this.compiler || this.Compiler)\n\n    this.process(file, realDone)\n    assertDone('processSync', 'process', complete)\n    assert(result, 'we either bailed on an error or have a tree')\n\n    return result\n\n    /**\n     * @type {ProcessCallback<VFileWithOutput<CompileResult>>}\n     */\n    function realDone(error, file) {\n      complete = true\n      bail(error)\n      result = file\n    }\n  }\n\n  /**\n   * Run *transformers* on a syntax tree.\n   *\n   * > ðŸ‘‰ **Note**: `run` freezes the processor if not already *frozen*.\n   *\n   * > ðŸ‘‰ **Note**: `run` performs the run phase, not other phases.\n   *\n   * @overload\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done\n   * @returns {undefined}\n   *\n   * @overload\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   * @param {Compatible | undefined} file\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done\n   * @returns {undefined}\n   *\n   * @overload\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   * @param {Compatible | undefined} [file]\n   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}\n   *\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   *   Tree to transform and inspect.\n   * @param {(\n   *   RunCallback<TailTree extends undefined ? Node : TailTree> |\n   *   Compatible\n   * )} [file]\n   *   File associated with `node` (optional); any value accepted as `x` in\n   *   `new VFile(x)`.\n   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]\n   *   Callback (optional).\n   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}\n   *   Nothing if `done` is given.\n   *   Otherwise, a promise rejected with a fatal error or resolved with the\n   *   transformed tree.\n   */\n  run(tree, file, done) {\n    assertNode(tree)\n    this.freeze()\n\n    const transformers = this.transformers\n\n    if (!done && typeof file === 'function') {\n      done = file\n      file = undefined\n    }\n\n    return done ? executor(undefined, done) : new Promise(executor)\n\n    // Note: `void`s needed for TS.\n    /**\n     * @param {(\n     *   ((tree: TailTree extends undefined ? Node : TailTree) => undefined | void) |\n     *   undefined\n     * )} resolve\n     * @param {(error: Error) => undefined | void} reject\n     * @returns {undefined}\n     */\n    function executor(resolve, reject) {\n      assert(\n        typeof file !== 'function',\n        '`file` canâ€™t be a `done` anymore, we checked'\n      )\n      const realFile = vfile(file)\n      transformers.run(tree, realFile, realDone)\n\n      /**\n       * @param {Error | undefined} error\n       * @param {Node} outputTree\n       * @param {VFile} file\n       * @returns {undefined}\n       */\n      function realDone(error, outputTree, file) {\n        const resultingTree =\n          /** @type {TailTree extends undefined ? Node : TailTree} */ (\n            outputTree || tree\n          )\n\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(resultingTree)\n        } else {\n          assert(done, '`done` is defined if `resolve` is not')\n          done(undefined, resultingTree, file)\n        }\n      }\n    }\n  }\n\n  /**\n   * Run *transformers* on a syntax tree.\n   *\n   * An error is thrown if asynchronous transforms are configured.\n   *\n   * > ðŸ‘‰ **Note**: `runSync` freezes the processor if not already *frozen*.\n   *\n   * > ðŸ‘‰ **Note**: `runSync` performs the run phase, not other phases.\n   *\n   * @param {HeadTree extends undefined ? Node : HeadTree} tree\n   *   Tree to transform and inspect.\n   * @param {Compatible | undefined} [file]\n   *   File associated with `node` (optional); any value accepted as `x` in\n   *   `new VFile(x)`.\n   * @returns {TailTree extends undefined ? Node : TailTree}\n   *   Transformed tree.\n   */\n  runSync(tree, file) {\n    /** @type {boolean} */\n    let complete = false\n    /** @type {(TailTree extends undefined ? Node : TailTree) | undefined} */\n    let result\n\n    this.run(tree, file, realDone)\n\n    assertDone('runSync', 'run', complete)\n    assert(result, 'we either bailed on an error or have a tree')\n    return result\n\n    /**\n     * @type {RunCallback<TailTree extends undefined ? Node : TailTree>}\n     */\n    function realDone(error, tree) {\n      bail(error)\n      result = tree\n      complete = true\n    }\n  }\n\n  /**\n   * Compile a syntax tree.\n   *\n   * > ðŸ‘‰ **Note**: `stringify` freezes the processor if not already *frozen*.\n   *\n   * > ðŸ‘‰ **Note**: `stringify` performs the stringify phase, not the run phase\n   * > or other phases.\n   *\n   * @param {CompileTree extends undefined ? Node : CompileTree} tree\n   *   Tree to compile.\n   * @param {Compatible | undefined} [file]\n   *   File associated with `node` (optional); any value accepted as `x` in\n   *   `new VFile(x)`.\n   * @returns {CompileResult extends undefined ? Value : CompileResult}\n   *   Textual representation of the tree (see note).\n   *\n   *   > ðŸ‘‰ **Note**: unified typically compiles by serializing: most compilers\n   *   > return `string` (or `Uint8Array`).\n   *   > Some compilers, such as the one configured with\n   *   > [`rehype-react`][rehype-react], return other values (in this case, a\n   *   > React tree).\n   *   > If youâ€™re using a compiler that doesnâ€™t serialize, expect different\n   *   > result values.\n   *   >\n   *   > To register custom results in TypeScript, add them to\n   *   > {@link CompileResultMap `CompileResultMap`}.\n   *\n   *   [rehype-react]: https://github.com/rehypejs/rehype-react\n   */\n  stringify(tree, file) {\n    this.freeze()\n    const realFile = vfile(file)\n    const compiler = this.compiler || this.Compiler\n    assertCompiler('stringify', compiler)\n    assertNode(tree)\n\n    return compiler(tree, realFile)\n  }\n\n  /**\n   * Configure the processor to use a plugin, a list of usable values, or a\n   * preset.\n   *\n   * If the processor is already using a plugin, the previous plugin\n   * configuration is changed based on the options that are passed in.\n   * In other words, the plugin is not added a second time.\n   *\n   * > ðŸ‘‰ **Note**: `use` cannot be called on *frozen* processors.\n   * > Call the processor first to create a new unfrozen processor.\n   *\n   * @example\n   *   There are many ways to pass plugins to `.use()`.\n   *   This example gives an overview:\n   *\n   *   ```js\n   *   import {unified} from 'unified'\n   *\n   *   unified()\n   *     // Plugin with options:\n   *     .use(pluginA, {x: true, y: true})\n   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):\n   *     .use(pluginA, {y: false, z: true})\n   *     // Plugins:\n   *     .use([pluginB, pluginC])\n   *     // Two plugins, the second with options:\n   *     .use([pluginD, [pluginE, {}]])\n   *     // Preset with plugins and settings:\n   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})\n   *     // Settings only:\n   *     .use({settings: {position: false}})\n   *   ```\n   *\n   * @template {Array<unknown>} [Parameters=[]]\n   * @template {Node | string | undefined} [Input=undefined]\n   * @template [Output=Input]\n   *\n   * @overload\n   * @param {Preset | null | undefined} [preset]\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *\n   * @overload\n   * @param {PluggableList} list\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *\n   * @overload\n   * @param {Plugin<Parameters, Input, Output>} plugin\n   * @param {...(Parameters | [boolean])} parameters\n   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}\n   *\n   * @param {PluggableList | Plugin | Preset | null | undefined} value\n   *   Usable value.\n   * @param {...unknown} parameters\n   *   Parameters, when a plugin is given as a usable value.\n   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}\n   *   Current processor.\n   */\n  use(value, ...parameters) {\n    const attachers = this.attachers\n    const namespace = this.namespace\n\n    assertUnfrozen('use', this.frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin(value, parameters)\n    } else if (typeof value === 'object') {\n      if (Array.isArray(value)) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new TypeError('Expected usable value, not `' + value + '`')\n    }\n\n    return this\n\n    /**\n     * @param {Pluggable} value\n     * @returns {undefined}\n     */\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value, [])\n      } else if (typeof value === 'object') {\n        if (Array.isArray(value)) {\n          const [plugin, ...parameters] =\n            /** @type {PluginTuple<Array<unknown>>} */ (value)\n          addPlugin(plugin, parameters)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new TypeError('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    /**\n     * @param {Preset} result\n     * @returns {undefined}\n     */\n    function addPreset(result) {\n      if (!('plugins' in result) && !('settings' in result)) {\n        throw new Error(\n          'Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither'\n        )\n      }\n\n      addList(result.plugins)\n\n      if (result.settings) {\n        namespace.settings = extend(true, namespace.settings, result.settings)\n      }\n    }\n\n    /**\n     * @param {PluggableList | null | undefined} plugins\n     * @returns {undefined}\n     */\n    function addList(plugins) {\n      let index = -1\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (Array.isArray(plugins)) {\n        while (++index < plugins.length) {\n          const thing = plugins[index]\n          add(thing)\n        }\n      } else {\n        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    /**\n     * @param {Plugin} plugin\n     * @param {Array<unknown>} parameters\n     * @returns {undefined}\n     */\n    function addPlugin(plugin, parameters) {\n      let index = -1\n      let entryIndex = -1\n\n      while (++index < attachers.length) {\n        if (attachers[index][0] === plugin) {\n          entryIndex = index\n          break\n        }\n      }\n\n      if (entryIndex === -1) {\n        attachers.push([plugin, ...parameters])\n      }\n      // Only set if there was at least a `primary` value, otherwise weâ€™d change\n      // `arguments.length`.\n      else if (parameters.length > 0) {\n        let [primary, ...rest] = parameters\n        const currentPrimary = attachers[entryIndex][1]\n        if (isPlainObj(currentPrimary) && isPlainObj(primary)) {\n          primary = extend(true, currentPrimary, primary)\n        }\n\n        attachers[entryIndex] = [plugin, primary, ...rest]\n      }\n    }\n  }\n}\n\n// Note: this returns a *callable* instance.\n// Thatâ€™s why itâ€™s documented as a function.\n/**\n * Create a new processor.\n *\n * @example\n *   This example shows how a new processor can be created (from `remark`) and linked\n *   to **stdin**(4) and **stdout**(4).\n *\n *   ```js\n *   import process from 'node:process'\n *   import concatStream from 'concat-stream'\n *   import {remark} from 'remark'\n *\n *   process.stdin.pipe(\n *     concatStream(function (buf) {\n *       process.stdout.write(String(remark().processSync(buf)))\n *     })\n *   )\n *   ```\n *\n * @returns\n *   New *unfrozen* processor (`processor`).\n *\n *   This processor is configured to work the same as its ancestor.\n *   When the descendant processor is configured in the future it does not\n *   affect the ancestral processor.\n */\nexport const unified = new Processor().freeze()\n\n/**\n * Assert a parser is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Parser}\n */\nfunction assertParser(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `parser`')\n  }\n}\n\n/**\n * Assert a compiler is available.\n *\n * @param {string} name\n * @param {unknown} value\n * @returns {asserts value is Compiler}\n */\nfunction assertCompiler(name, value) {\n  if (typeof value !== 'function') {\n    throw new TypeError('Cannot `' + name + '` without `compiler`')\n  }\n}\n\n/**\n * Assert the processor is not frozen.\n *\n * @param {string} name\n * @param {unknown} frozen\n * @returns {asserts frozen is false}\n */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot call `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n/**\n * Assert `node` is a unist node.\n *\n * @param {unknown} node\n * @returns {asserts node is Node}\n */\nfunction assertNode(node) {\n  // `isPlainObj` unfortunately uses `any` instead of `unknown`.\n  // type-coverage:ignore-next-line\n  if (!isPlainObj(node) || typeof node.type !== 'string') {\n    throw new TypeError('Expected node, got `' + node + '`')\n    // Fine.\n  }\n}\n\n/**\n * Assert that `complete` is `true`.\n *\n * @param {string} name\n * @param {string} asyncName\n * @param {unknown} complete\n * @returns {asserts complete is true}\n */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n\n/**\n * @param {Compatible | undefined} [value]\n * @returns {VFile}\n */\nfunction vfile(value) {\n  return looksLikeAVFile(value) ? value : new VFile(value)\n}\n\n/**\n * @param {Compatible | undefined} [value]\n * @returns {value is VFile}\n */\nfunction looksLikeAVFile(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'message' in value &&\n      'messages' in value\n  )\n}\n\n/**\n * @param {unknown} [value]\n * @returns {value is Value}\n */\nfunction looksLikeAValue(value) {\n  return typeof value === 'string' || isUint8Array(value)\n}\n\n/**\n * Assert `value` is an `Uint8Array`.\n *\n * @param {unknown} value\n *   thing.\n * @returns {value is Uint8Array}\n *   Whether `value` is an `Uint8Array`.\n */\nfunction isUint8Array(value) {\n  return Boolean(\n    value &&\n      typeof value === 'object' &&\n      'byteLength' in value &&\n      'byteOffset' in value\n  )\n}\n"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,IAAI,QAAO,MAAM;AACzB,OAAOC,MAAM,MAAM,QAAQ;AAC3B,SAAQC,EAAE,IAAIC,MAAM,QAAO,QAAQ;AACnC,OAAOC,UAAU,MAAM,cAAc;AACrC,SAAQC,MAAM,QAAO,QAAQ;AAC7B,SAAQC,KAAK,QAAO,OAAO;AAC3B,SAAQC,gBAAgB,QAAO,wBAAwB;;AAEvD;;AAEA;AACA;AACA;;AAEA,IAAMC,GAAG,GAAG,CAAC,CAAC,CAACC,cAAc;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAaC,SAAS,0BAAAC,iBAAA;EAAAC,SAAA,CAAAF,SAAA,EAAAC,iBAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,SAAA;EACpB;AACF;AACA;EACE,SAAAA,UAAA,EAAc;IAAA,IAAAK,KAAA;IAAAC,eAAA,OAAAN,SAAA;IACZ;IACAK,KAAA,GAAAF,MAAA,CAAAI,IAAA,OAAM,MAAM;;IAEZ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACIF,KAAA,CAAKG,QAAQ,GAAGC,SAAS;;IAEzB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IAC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"},"metadata":{},"sourceType":"module","externalDependencies":[]}