{"ast":null,"code":"/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n */\n\n/**\n * @template {string} SimpleSelector\n *   Selector type.\n * @template {string} DefaultTagName\n *   Default tag name.\n * @typedef {(\n *   SimpleSelector extends ''\n *     ? DefaultTagName\n *     : SimpleSelector extends `${infer TagName}.${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends `${infer TagName}#${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends string\n *     ? SimpleSelector\n *     : DefaultTagName\n * )} ExtractTagName\n *   Extract tag name from a simple selector.\n */\n\nvar search = /[#.]/g;\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @template {string} Selector\n *   Type of selector.\n * @template {string} [DefaultTagName='div']\n *   Type of default tag name (default: `'div'`).\n * @param {Selector | null | undefined} [selector]\n *   Simple CSS selector (optional).\n *\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\n * @returns {Element & {tagName: ExtractTagName<Selector, DefaultTagName>}}\n *   Built element.\n */\nexport function parseSelector(selector, defaultTagName) {\n  var value = selector || '';\n  /** @type {Properties} */\n  var props = {};\n  var start = 0;\n  /** @type {string | undefined} */\n  var previous;\n  /** @type {string | undefined} */\n  var tagName;\n  while (start < value.length) {\n    search.lastIndex = start;\n    var match = search.exec(value);\n    var subvalue = value.slice(start, match ? match.index : value.length);\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue;\n      } else if (previous === '#') {\n        props.id = subvalue;\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue);\n      } else {\n        props.className = [subvalue];\n      }\n      start += subvalue.length;\n    }\n    if (match) {\n      previous = match[0];\n      start++;\n    }\n  }\n  return {\n    type: 'element',\n    // @ts-expect-error: tag name is parsed.\n    tagName: tagName || defaultTagName || 'div',\n    properties: props,\n    children: []\n  };\n}","map":{"version":3,"names":["search","parseSelector","selector","defaultTagName","value","props","start","previous","tagName","length","lastIndex","match","exec","subvalue","slice","index","id","Array","isArray","className","push","type","properties","children"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/hast-util-parse-selector/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n */\n\n/**\n * @template {string} SimpleSelector\n *   Selector type.\n * @template {string} DefaultTagName\n *   Default tag name.\n * @typedef {(\n *   SimpleSelector extends ''\n *     ? DefaultTagName\n *     : SimpleSelector extends `${infer TagName}.${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends `${infer TagName}#${infer Rest}`\n *     ? ExtractTagName<TagName, DefaultTagName>\n *     : SimpleSelector extends string\n *     ? SimpleSelector\n *     : DefaultTagName\n * )} ExtractTagName\n *   Extract tag name from a simple selector.\n */\n\nconst search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @template {string} Selector\n *   Type of selector.\n * @template {string} [DefaultTagName='div']\n *   Type of default tag name (default: `'div'`).\n * @param {Selector | null | undefined} [selector]\n *   Simple CSS selector (optional).\n *\n *   Can contain a tag name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param {DefaultTagName | null | undefined} [defaultTagName='div']\n *   Tag name to use if `selector` does not specify one (default: `'div'`).\n * @returns {Element & {tagName: ExtractTagName<Selector, DefaultTagName>}}\n *   Built element.\n */\nexport function parseSelector(selector, defaultTagName) {\n  const value = selector || ''\n  /** @type {Properties} */\n  const props = {}\n  let start = 0\n  /** @type {string | undefined} */\n  let previous\n  /** @type {string | undefined} */\n  let tagName\n\n  while (start < value.length) {\n    search.lastIndex = start\n    const match = search.exec(value)\n    const subvalue = value.slice(start, match ? match.index : value.length)\n\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue\n      } else if (previous === '#') {\n        props.id = subvalue\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue)\n      } else {\n        props.className = [subvalue]\n      }\n\n      start += subvalue.length\n    }\n\n    if (match) {\n      previous = match[0]\n      start++\n    }\n  }\n\n  return {\n    type: 'element',\n    // @ts-expect-error: tag name is parsed.\n    tagName: tagName || defaultTagName || 'div',\n    properties: props,\n    children: []\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAMA,MAAM,GAAG,OAAO;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAaA,CAACC,QAAQ,EAAEC,cAAc,EAAE;EACtD,IAAMC,KAAK,GAAGF,QAAQ,IAAI,EAAE;EAC5B;EACA,IAAMG,KAAK,GAAG,CAAC,CAAC;EAChB,IAAIC,KAAK,GAAG,CAAC;EACb;EACA,IAAIC,QAAQ;EACZ;EACA,IAAIC,OAAO;EAEX,OAAOF,KAAK,GAAGF,KAAK,CAACK,MAAM,EAAE;IAC3BT,MAAM,CAACU,SAAS,GAAGJ,KAAK;IACxB,IAAMK,KAAK,GAAGX,MAAM,CAACY,IAAI,CAACR,KAAK,CAAC;IAChC,IAAMS,QAAQ,GAAGT,KAAK,CAACU,KAAK,CAACR,KAAK,EAAEK,KAAK,GAAGA,KAAK,CAACI,KAAK,GAAGX,KAAK,CAACK,MAAM,CAAC;IAEvE,IAAII,QAAQ,EAAE;MACZ,IAAI,CAACN,QAAQ,EAAE;QACbC,OAAO,GAAGK,QAAQ;MACpB,CAAC,MAAM,IAAIN,QAAQ,KAAK,GAAG,EAAE;QAC3BF,KAAK,CAACW,EAAE,GAAGH,QAAQ;MACrB,CAAC,MAAM,IAAII,KAAK,CAACC,OAAO,CAACb,KAAK,CAACc,SAAS,CAAC,EAAE;QACzCd,KAAK,CAACc,SAAS,CAACC,IAAI,CAACP,QAAQ,CAAC;MAChC,CAAC,MAAM;QACLR,KAAK,CAACc,SAAS,GAAG,CAACN,QAAQ,CAAC;MAC9B;MAEAP,KAAK,IAAIO,QAAQ,CAACJ,MAAM;IAC1B;IAEA,IAAIE,KAAK,EAAE;MACTJ,QAAQ,GAAGI,KAAK,CAAC,CAAC,CAAC;MACnBL,KAAK,EAAE;IACT;EACF;EAEA,OAAO;IACLe,IAAI,EAAE,SAAS;IACf;IACAb,OAAO,EAAEA,OAAO,IAAIL,cAAc,IAAI,KAAK;IAC3CmB,UAAU,EAAEjB,KAAK;IACjBkB,QAAQ,EAAE;EACZ,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}