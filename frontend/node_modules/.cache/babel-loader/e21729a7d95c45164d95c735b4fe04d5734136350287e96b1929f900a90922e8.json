{"ast":null,"code":"function switchState(source, setState, f) {\n  setState(f);\n  return f(source, setState);\n}\n\n// These should all be Unicode extended, as per the Haskell 2010 report\nvar smallRE = /[a-z_]/;\nvar largeRE = /[A-Z]/;\nvar digitRE = /\\d/;\nvar hexitRE = /[0-9A-Fa-f]/;\nvar octitRE = /[0-7]/;\nvar idRE = /[a-z_A-Z0-9'\\xa1-\\uffff]/;\nvar symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:]/;\nvar specialRE = /[(),;[\\]`{}]/;\nvar whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\n\nfunction normal(source, setState) {\n  if (source.eatWhile(whiteCharRE)) {\n    return null;\n  }\n  var ch = source.next();\n  if (specialRE.test(ch)) {\n    if (ch == '{' && source.eat('-')) {\n      var t = \"comment\";\n      if (source.eat('#')) {\n        t = \"meta\";\n      }\n      return switchState(source, setState, ncomment(t, 1));\n    }\n    return null;\n  }\n  if (ch == '\\'') {\n    if (source.eat('\\\\')) {\n      source.next(); // should handle other escapes here\n    } else {\n      source.next();\n    }\n    if (source.eat('\\'')) {\n      return \"string\";\n    }\n    return \"error\";\n  }\n  if (ch == '\"') {\n    return switchState(source, setState, stringLiteral);\n  }\n  if (largeRE.test(ch)) {\n    source.eatWhile(idRE);\n    if (source.eat('.')) {\n      return \"qualifier\";\n    }\n    return \"type\";\n  }\n  if (smallRE.test(ch)) {\n    source.eatWhile(idRE);\n    return \"variable\";\n  }\n  if (digitRE.test(ch)) {\n    if (ch == '0') {\n      if (source.eat(/[xX]/)) {\n        source.eatWhile(hexitRE); // should require at least 1\n        return \"integer\";\n      }\n      if (source.eat(/[oO]/)) {\n        source.eatWhile(octitRE); // should require at least 1\n        return \"number\";\n      }\n    }\n    source.eatWhile(digitRE);\n    var t = \"number\";\n    if (source.match(/^\\.\\d+/)) {\n      t = \"number\";\n    }\n    if (source.eat(/[eE]/)) {\n      t = \"number\";\n      source.eat(/[-+]/);\n      source.eatWhile(digitRE); // should require at least 1\n    }\n\n    return t;\n  }\n  if (ch == \".\" && source.eat(\".\")) return \"keyword\";\n  if (symbolRE.test(ch)) {\n    if (ch == '-' && source.eat(/-/)) {\n      source.eatWhile(/-/);\n      if (!source.eat(symbolRE)) {\n        source.skipToEnd();\n        return \"comment\";\n      }\n    }\n    source.eatWhile(symbolRE);\n    return \"variable\";\n  }\n  return \"error\";\n}\nfunction ncomment(type, nest) {\n  if (nest == 0) {\n    return normal;\n  }\n  return function (source, setState) {\n    var currNest = nest;\n    while (!source.eol()) {\n      var ch = source.next();\n      if (ch == '{' && source.eat('-')) {\n        ++currNest;\n      } else if (ch == '-' && source.eat('}')) {\n        --currNest;\n        if (currNest == 0) {\n          setState(normal);\n          return type;\n        }\n      }\n    }\n    setState(ncomment(type, currNest));\n    return type;\n  };\n}\nfunction stringLiteral(source, setState) {\n  while (!source.eol()) {\n    var ch = source.next();\n    if (ch == '\"') {\n      setState(normal);\n      return \"string\";\n    }\n    if (ch == '\\\\') {\n      if (source.eol() || source.eat(whiteCharRE)) {\n        setState(stringGap);\n        return \"string\";\n      }\n      if (source.eat('&')) {} else {\n        source.next(); // should handle other escapes here\n      }\n    }\n  }\n\n  setState(normal);\n  return \"error\";\n}\nfunction stringGap(source, setState) {\n  if (source.eat('\\\\')) {\n    return switchState(source, setState, stringLiteral);\n  }\n  source.next();\n  setState(normal);\n  return \"error\";\n}\nvar wellKnownWords = function () {\n  var wkw = {};\n  function setType(t) {\n    return function () {\n      for (var i = 0; i < arguments.length; i++) wkw[arguments[i]] = t;\n    };\n  }\n  setType(\"keyword\")(\"case\", \"class\", \"data\", \"default\", \"deriving\", \"do\", \"else\", \"foreign\", \"if\", \"import\", \"in\", \"infix\", \"infixl\", \"infixr\", \"instance\", \"let\", \"module\", \"newtype\", \"of\", \"then\", \"type\", \"where\", \"_\");\n  setType(\"keyword\")(\"\\.\\.\", \":\", \"::\", \"=\", \"\\\\\", \"<-\", \"->\", \"@\", \"~\", \"=>\");\n  setType(\"builtin\")(\"!!\", \"$!\", \"$\", \"&&\", \"+\", \"++\", \"-\", \".\", \"/\", \"/=\", \"<\", \"<*\", \"<=\", \"<$>\", \"<*>\", \"=<<\", \"==\", \">\", \">=\", \">>\", \">>=\", \"^\", \"^^\", \"||\", \"*\", \"*>\", \"**\");\n  setType(\"builtin\")(\"Applicative\", \"Bool\", \"Bounded\", \"Char\", \"Double\", \"EQ\", \"Either\", \"Enum\", \"Eq\", \"False\", \"FilePath\", \"Float\", \"Floating\", \"Fractional\", \"Functor\", \"GT\", \"IO\", \"IOError\", \"Int\", \"Integer\", \"Integral\", \"Just\", \"LT\", \"Left\", \"Maybe\", \"Monad\", \"Nothing\", \"Num\", \"Ord\", \"Ordering\", \"Rational\", \"Read\", \"ReadS\", \"Real\", \"RealFloat\", \"RealFrac\", \"Right\", \"Show\", \"ShowS\", \"String\", \"True\");\n  setType(\"builtin\")(\"abs\", \"acos\", \"acosh\", \"all\", \"and\", \"any\", \"appendFile\", \"asTypeOf\", \"asin\", \"asinh\", \"atan\", \"atan2\", \"atanh\", \"break\", \"catch\", \"ceiling\", \"compare\", \"concat\", \"concatMap\", \"const\", \"cos\", \"cosh\", \"curry\", \"cycle\", \"decodeFloat\", \"div\", \"divMod\", \"drop\", \"dropWhile\", \"either\", \"elem\", \"encodeFloat\", \"enumFrom\", \"enumFromThen\", \"enumFromThenTo\", \"enumFromTo\", \"error\", \"even\", \"exp\", \"exponent\", \"fail\", \"filter\", \"flip\", \"floatDigits\", \"floatRadix\", \"floatRange\", \"floor\", \"fmap\", \"foldl\", \"foldl1\", \"foldr\", \"foldr1\", \"fromEnum\", \"fromInteger\", \"fromIntegral\", \"fromRational\", \"fst\", \"gcd\", \"getChar\", \"getContents\", \"getLine\", \"head\", \"id\", \"init\", \"interact\", \"ioError\", \"isDenormalized\", \"isIEEE\", \"isInfinite\", \"isNaN\", \"isNegativeZero\", \"iterate\", \"last\", \"lcm\", \"length\", \"lex\", \"lines\", \"log\", \"logBase\", \"lookup\", \"map\", \"mapM\", \"mapM_\", \"max\", \"maxBound\", \"maximum\", \"maybe\", \"min\", \"minBound\", \"minimum\", \"mod\", \"negate\", \"not\", \"notElem\", \"null\", \"odd\", \"or\", \"otherwise\", \"pi\", \"pred\", \"print\", \"product\", \"properFraction\", \"pure\", \"putChar\", \"putStr\", \"putStrLn\", \"quot\", \"quotRem\", \"read\", \"readFile\", \"readIO\", \"readList\", \"readLn\", \"readParen\", \"reads\", \"readsPrec\", \"realToFrac\", \"recip\", \"rem\", \"repeat\", \"replicate\", \"return\", \"reverse\", \"round\", \"scaleFloat\", \"scanl\", \"scanl1\", \"scanr\", \"scanr1\", \"seq\", \"sequence\", \"sequence_\", \"show\", \"showChar\", \"showList\", \"showParen\", \"showString\", \"shows\", \"showsPrec\", \"significand\", \"signum\", \"sin\", \"sinh\", \"snd\", \"span\", \"splitAt\", \"sqrt\", \"subtract\", \"succ\", \"sum\", \"tail\", \"take\", \"takeWhile\", \"tan\", \"tanh\", \"toEnum\", \"toInteger\", \"toRational\", \"truncate\", \"uncurry\", \"undefined\", \"unlines\", \"until\", \"unwords\", \"unzip\", \"unzip3\", \"userError\", \"words\", \"writeFile\", \"zip\", \"zip3\", \"zipWith\", \"zipWith3\");\n  return wkw;\n}();\nexport var haskell = {\n  name: \"haskell\",\n  startState: function startState() {\n    return {\n      f: normal\n    };\n  },\n  copyState: function copyState(s) {\n    return {\n      f: s.f\n    };\n  },\n  token: function token(stream, state) {\n    var t = state.f(stream, function (s) {\n      state.f = s;\n    });\n    var w = stream.current();\n    return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;\n  },\n  languageData: {\n    commentTokens: {\n      line: \"--\",\n      block: {\n        open: \"{-\",\n        close: \"-}\"\n      }\n    }\n  }\n};","map":{"version":3,"names":["switchState","source","setState","f","smallRE","largeRE","digitRE","hexitRE","octitRE","idRE","symbolRE","specialRE","whiteCharRE","normal","eatWhile","ch","next","test","eat","t","ncomment","stringLiteral","match","skipToEnd","type","nest","currNest","eol","stringGap","wellKnownWords","wkw","setType","i","arguments","length","haskell","name","startState","copyState","s","token","stream","state","w","current","hasOwnProperty","languageData","commentTokens","line","block","open","close"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@codemirror/legacy-modes/mode/haskell.js"],"sourcesContent":["function switchState(source, setState, f) {\n  setState(f);\n  return f(source, setState);\n}\n\n// These should all be Unicode extended, as per the Haskell 2010 report\nvar smallRE = /[a-z_]/;\nvar largeRE = /[A-Z]/;\nvar digitRE = /\\d/;\nvar hexitRE = /[0-9A-Fa-f]/;\nvar octitRE = /[0-7]/;\nvar idRE = /[a-z_A-Z0-9'\\xa1-\\uffff]/;\nvar symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:]/;\nvar specialRE = /[(),;[\\]`{}]/;\nvar whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\n\nfunction normal(source, setState) {\n  if (source.eatWhile(whiteCharRE)) {\n    return null;\n  }\n\n  var ch = source.next();\n  if (specialRE.test(ch)) {\n    if (ch == '{' && source.eat('-')) {\n      var t = \"comment\";\n      if (source.eat('#')) {\n        t = \"meta\";\n      }\n      return switchState(source, setState, ncomment(t, 1));\n    }\n    return null;\n  }\n\n  if (ch == '\\'') {\n    if (source.eat('\\\\')) {\n      source.next();  // should handle other escapes here\n    }\n    else {\n      source.next();\n    }\n    if (source.eat('\\'')) {\n      return \"string\";\n    }\n    return \"error\";\n  }\n\n  if (ch == '\"') {\n    return switchState(source, setState, stringLiteral);\n  }\n\n  if (largeRE.test(ch)) {\n    source.eatWhile(idRE);\n    if (source.eat('.')) {\n      return \"qualifier\";\n    }\n    return \"type\";\n  }\n\n  if (smallRE.test(ch)) {\n    source.eatWhile(idRE);\n    return \"variable\";\n  }\n\n  if (digitRE.test(ch)) {\n    if (ch == '0') {\n      if (source.eat(/[xX]/)) {\n        source.eatWhile(hexitRE); // should require at least 1\n        return \"integer\";\n      }\n      if (source.eat(/[oO]/)) {\n        source.eatWhile(octitRE); // should require at least 1\n        return \"number\";\n      }\n    }\n    source.eatWhile(digitRE);\n    var t = \"number\";\n    if (source.match(/^\\.\\d+/)) {\n      t = \"number\";\n    }\n    if (source.eat(/[eE]/)) {\n      t = \"number\";\n      source.eat(/[-+]/);\n      source.eatWhile(digitRE); // should require at least 1\n    }\n    return t;\n  }\n\n  if (ch == \".\" && source.eat(\".\"))\n    return \"keyword\";\n\n  if (symbolRE.test(ch)) {\n    if (ch == '-' && source.eat(/-/)) {\n      source.eatWhile(/-/);\n      if (!source.eat(symbolRE)) {\n        source.skipToEnd();\n        return \"comment\";\n      }\n    }\n    source.eatWhile(symbolRE);\n    return \"variable\"\n  }\n\n  return \"error\";\n}\n\nfunction ncomment(type, nest) {\n  if (nest == 0) {\n    return normal;\n  }\n  return function(source, setState) {\n    var currNest = nest;\n    while (!source.eol()) {\n      var ch = source.next();\n      if (ch == '{' && source.eat('-')) {\n        ++currNest;\n      }\n      else if (ch == '-' && source.eat('}')) {\n        --currNest;\n        if (currNest == 0) {\n          setState(normal);\n          return type;\n        }\n      }\n    }\n    setState(ncomment(type, currNest));\n    return type;\n  };\n}\n\nfunction stringLiteral(source, setState) {\n  while (!source.eol()) {\n    var ch = source.next();\n    if (ch == '\"') {\n      setState(normal);\n      return \"string\";\n    }\n    if (ch == '\\\\') {\n      if (source.eol() || source.eat(whiteCharRE)) {\n        setState(stringGap);\n        return \"string\";\n      }\n      if (source.eat('&')) {\n      }\n      else {\n        source.next(); // should handle other escapes here\n      }\n    }\n  }\n  setState(normal);\n  return \"error\";\n}\n\nfunction stringGap(source, setState) {\n  if (source.eat('\\\\')) {\n    return switchState(source, setState, stringLiteral);\n  }\n  source.next();\n  setState(normal);\n  return \"error\";\n}\n\n\nvar wellKnownWords = (function() {\n  var wkw = {};\n  function setType(t) {\n    return function () {\n      for (var i = 0; i < arguments.length; i++)\n        wkw[arguments[i]] = t;\n    };\n  }\n\n  setType(\"keyword\")(\n    \"case\", \"class\", \"data\", \"default\", \"deriving\", \"do\", \"else\", \"foreign\",\n    \"if\", \"import\", \"in\", \"infix\", \"infixl\", \"infixr\", \"instance\", \"let\",\n    \"module\", \"newtype\", \"of\", \"then\", \"type\", \"where\", \"_\");\n\n  setType(\"keyword\")(\n    \"\\.\\.\", \":\", \"::\", \"=\", \"\\\\\", \"<-\", \"->\", \"@\", \"~\", \"=>\");\n\n  setType(\"builtin\")(\n    \"!!\", \"$!\", \"$\", \"&&\", \"+\", \"++\", \"-\", \".\", \"/\", \"/=\", \"<\", \"<*\", \"<=\",\n    \"<$>\", \"<*>\", \"=<<\", \"==\", \">\", \">=\", \">>\", \">>=\", \"^\", \"^^\", \"||\", \"*\",\n    \"*>\", \"**\");\n\n  setType(\"builtin\")(\n    \"Applicative\", \"Bool\", \"Bounded\", \"Char\", \"Double\", \"EQ\", \"Either\", \"Enum\",\n    \"Eq\", \"False\", \"FilePath\", \"Float\", \"Floating\", \"Fractional\", \"Functor\",\n    \"GT\", \"IO\", \"IOError\", \"Int\", \"Integer\", \"Integral\", \"Just\", \"LT\", \"Left\",\n    \"Maybe\", \"Monad\", \"Nothing\", \"Num\", \"Ord\", \"Ordering\", \"Rational\", \"Read\",\n    \"ReadS\", \"Real\", \"RealFloat\", \"RealFrac\", \"Right\", \"Show\", \"ShowS\",\n    \"String\", \"True\");\n\n  setType(\"builtin\")(\n    \"abs\", \"acos\", \"acosh\", \"all\", \"and\", \"any\", \"appendFile\", \"asTypeOf\",\n    \"asin\", \"asinh\", \"atan\", \"atan2\", \"atanh\", \"break\", \"catch\", \"ceiling\",\n    \"compare\", \"concat\", \"concatMap\", \"const\", \"cos\", \"cosh\", \"curry\",\n    \"cycle\", \"decodeFloat\", \"div\", \"divMod\", \"drop\", \"dropWhile\", \"either\",\n    \"elem\", \"encodeFloat\", \"enumFrom\", \"enumFromThen\", \"enumFromThenTo\",\n    \"enumFromTo\", \"error\", \"even\", \"exp\", \"exponent\", \"fail\", \"filter\",\n    \"flip\", \"floatDigits\", \"floatRadix\", \"floatRange\", \"floor\", \"fmap\",\n    \"foldl\", \"foldl1\", \"foldr\", \"foldr1\", \"fromEnum\", \"fromInteger\",\n    \"fromIntegral\", \"fromRational\", \"fst\", \"gcd\", \"getChar\", \"getContents\",\n    \"getLine\", \"head\", \"id\", \"init\", \"interact\", \"ioError\", \"isDenormalized\",\n    \"isIEEE\", \"isInfinite\", \"isNaN\", \"isNegativeZero\", \"iterate\", \"last\",\n    \"lcm\", \"length\", \"lex\", \"lines\", \"log\", \"logBase\", \"lookup\", \"map\",\n    \"mapM\", \"mapM_\", \"max\", \"maxBound\", \"maximum\", \"maybe\", \"min\", \"minBound\",\n    \"minimum\", \"mod\", \"negate\", \"not\", \"notElem\", \"null\", \"odd\", \"or\",\n    \"otherwise\", \"pi\", \"pred\", \"print\", \"product\", \"properFraction\", \"pure\",\n    \"putChar\", \"putStr\", \"putStrLn\", \"quot\", \"quotRem\", \"read\", \"readFile\",\n    \"readIO\", \"readList\", \"readLn\", \"readParen\", \"reads\", \"readsPrec\",\n    \"realToFrac\", \"recip\", \"rem\", \"repeat\", \"replicate\", \"return\", \"reverse\",\n    \"round\", \"scaleFloat\", \"scanl\", \"scanl1\", \"scanr\", \"scanr1\", \"seq\",\n    \"sequence\", \"sequence_\", \"show\", \"showChar\", \"showList\", \"showParen\",\n    \"showString\", \"shows\", \"showsPrec\", \"significand\", \"signum\", \"sin\",\n    \"sinh\", \"snd\", \"span\", \"splitAt\", \"sqrt\", \"subtract\", \"succ\", \"sum\",\n    \"tail\", \"take\", \"takeWhile\", \"tan\", \"tanh\", \"toEnum\", \"toInteger\",\n    \"toRational\", \"truncate\", \"uncurry\", \"undefined\", \"unlines\", \"until\",\n    \"unwords\", \"unzip\", \"unzip3\", \"userError\", \"words\", \"writeFile\", \"zip\",\n    \"zip3\", \"zipWith\", \"zipWith3\");\n\n  return wkw;\n})();\n\nexport const haskell = {\n  name: \"haskell\",\n  startState: function ()  { return { f: normal }; },\n  copyState:  function (s) { return { f: s.f }; },\n\n  token: function(stream, state) {\n    var t = state.f(stream, function(s) { state.f = s; });\n    var w = stream.current();\n    return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;\n  },\n\n  languageData: {\n    commentTokens: {line: \"--\", block: {open: \"{-\", close: \"-}\"}}\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}