{"ast":null,"code":"import _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { Editor, Node, Range, Transforms } from '@seafile/slate';\nimport { QUICK_INSERT } from '../../../constants';\nimport { getBeforeText } from '../../list/helpers';\nimport { genQuickInsert, getQuickInsertEntity, transformToText } from '../helper';\nimport { focusEditor } from '../../../core';\nimport { KeyCodes } from '../../../../../constants';\nvar withQuickInsert = function withQuickInsert(editor) {\n  var insertText = editor.insertText,\n    onHotKeyDown = editor.onHotKeyDown,\n    isInline = editor.isInline,\n    deleteBackward = editor.deleteBackward,\n    deleteForward = editor.deleteForward;\n  var newEditor = editor;\n  newEditor.insertText = function (text) {\n    if (text === '/') {\n      // Avoid triggering quick insert when the cursor is in the quick insert\n      var isInQuickInsert = getQuickInsertEntity(editor);\n      if (isInQuickInsert) return insertText(text);\n      var _getBeforeText = getBeforeText(editor),\n        beforeText = _getBeforeText.beforeText;\n      // If the previous text ends with a number, do not trigger the quick insert\n      var isEndWithNumber = beforeText.match(/\\d+$/);\n      if (isEndWithNumber) return insertText(text);\n      var quickInsert = genQuickInsert();\n      return Transforms.insertNodes(editor, quickInsert);\n    }\n    return insertText(text);\n  };\n  newEditor.deleteBackward = function (unit) {\n    var quickInsertEntry = getQuickInsertEntity(editor);\n    if (quickInsertEntry) {\n      var selection = editor.selection;\n      if (selection && Range.isCollapsed(selection)) {\n        var _quickInsertEntry = _slicedToArray(quickInsertEntry, 2),\n          node = _quickInsertEntry[0],\n          path = _quickInsertEntry[1];\n        var contentString = Node.string(node);\n        if (!contentString) {\n          return Transforms.delete(editor, {\n            at: path\n          });\n        }\n\n        // Transform to text when delete shortcut prefix\n        var isAtStart = Editor.isStart(editor, selection.focus, quickInsertEntry[1]);\n        if (isAtStart) {\n          var _Editor$next = Editor.next(editor, {\n              at: path\n            }),\n            _Editor$next2 = _slicedToArray(_Editor$next, 2),\n            insertPath = _Editor$next2[1];\n          var insertPoint = Editor.start(editor, insertPath);\n          var _insertText = Node.string(quickInsertEntry[0]);\n          Transforms.insertText(editor, _insertText, {\n            at: insertPoint\n          });\n          Transforms.removeNodes(editor, {\n            at: path\n          });\n          return;\n        }\n      }\n    }\n    return deleteBackward(unit);\n  };\n  newEditor.deleteForward = function (unit) {\n    var quickInsertEntry = getQuickInsertEntity(editor);\n    if (quickInsertEntry) {\n      var selection = editor.selection;\n      var isAtEnd = Editor.isEnd(editor, selection.focus, quickInsertEntry[1]);\n      if (isAtEnd) {\n        deleteForward(unit);\n        focusEditor(editor, Editor.end(newEditor, quickInsertEntry[1]));\n        return;\n      }\n    }\n    return deleteForward(unit);\n  };\n  newEditor.onHotKeyDown = function (event) {\n    var quickInsertEntry = getQuickInsertEntity(editor);\n    if (quickInsertEntry) {\n      var _quickInsertEntry2 = _slicedToArray(quickInsertEntry, 2),\n        quickInsertNode = _quickInsertEntry2[0],\n        quickInsertPath = _quickInsertEntry2[1];\n      var Esc = KeyCodes.Esc,\n        RightArrow = KeyCodes.RightArrow,\n        LeftArrow = KeyCodes.LeftArrow;\n      var keyCode = event.keyCode;\n      if ([RightArrow, LeftArrow].includes(keyCode)) {\n        var selection = editor.selection;\n        var focusPoint = selection.focus;\n        if (!selection) return;\n        if (!Range.isCollapsed(selection)) return;\n        if (keyCode === RightArrow) {\n          if (Editor.isEnd(editor, focusPoint, quickInsertPath)) {\n            var insertPoint = transformToText(newEditor, quickInsertNode);\n            focusEditor(newEditor, insertPoint);\n            return;\n          }\n        }\n        if (keyCode === LeftArrow) {\n          if (Editor.isStart(editor, focusPoint, quickInsertPath)) {\n            event.preventDefault();\n            transformToText(newEditor, quickInsertNode);\n            return;\n          }\n        }\n      }\n      if (keyCode === Esc) {\n        // Choose the next point to focus\n        // Here need offset + 1 as text not include the prefix '/'\n        event.preventDefault();\n        var _insertPoint = transformToText(newEditor, quickInsertNode);\n        return focusEditor(newEditor, _insertPoint);\n      }\n    }\n    return onHotKeyDown && onHotKeyDown(event);\n  };\n  newEditor.onCompositionStart = function (event) {\n    var quickInsertEntry = getQuickInsertEntity(editor);\n    if (quickInsertEntry) {\n      event.preventDefault();\n      return true;\n    }\n  };\n  newEditor.isInline = function (element) {\n    if ([QUICK_INSERT].includes(element.type)) {\n      return true;\n    }\n    return isInline(element);\n  };\n  return newEditor;\n};\nexport default withQuickInsert;","map":{"version":3,"names":["Editor","Node","Range","Transforms","QUICK_INSERT","getBeforeText","genQuickInsert","getQuickInsertEntity","transformToText","focusEditor","KeyCodes","withQuickInsert","editor","insertText","onHotKeyDown","isInline","deleteBackward","deleteForward","newEditor","text","isInQuickInsert","_getBeforeText","beforeText","isEndWithNumber","match","quickInsert","insertNodes","unit","quickInsertEntry","selection","isCollapsed","_quickInsertEntry","_slicedToArray","node","path","contentString","string","delete","at","isAtStart","isStart","focus","_Editor$next","next","_Editor$next2","insertPath","insertPoint","start","removeNodes","isAtEnd","isEnd","end","event","_quickInsertEntry2","quickInsertNode","quickInsertPath","Esc","RightArrow","LeftArrow","keyCode","includes","focusPoint","preventDefault","onCompositionStart","element","type"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/plugins/quick-insert/plugin/index.js"],"sourcesContent":["import { Editor, Node, Range, Transforms } from '@seafile/slate';\nimport { QUICK_INSERT } from '../../../constants';\nimport { getBeforeText } from '../../list/helpers';\nimport { genQuickInsert, getQuickInsertEntity, transformToText } from '../helper';\nimport { focusEditor } from '../../../core';\nimport { KeyCodes } from '../../../../../constants';\nconst withQuickInsert = editor => {\n  const {\n    insertText,\n    onHotKeyDown,\n    isInline,\n    deleteBackward,\n    deleteForward\n  } = editor;\n  const newEditor = editor;\n  newEditor.insertText = text => {\n    if (text === '/') {\n      // Avoid triggering quick insert when the cursor is in the quick insert\n      const isInQuickInsert = getQuickInsertEntity(editor);\n      if (isInQuickInsert) return insertText(text);\n      const {\n        beforeText\n      } = getBeforeText(editor);\n      // If the previous text ends with a number, do not trigger the quick insert\n      const isEndWithNumber = beforeText.match(/\\d+$/);\n      if (isEndWithNumber) return insertText(text);\n      const quickInsert = genQuickInsert();\n      return Transforms.insertNodes(editor, quickInsert);\n    }\n    return insertText(text);\n  };\n  newEditor.deleteBackward = unit => {\n    const quickInsertEntry = getQuickInsertEntity(editor);\n    if (quickInsertEntry) {\n      const {\n        selection\n      } = editor;\n      if (selection && Range.isCollapsed(selection)) {\n        const [node, path] = quickInsertEntry;\n        const contentString = Node.string(node);\n        if (!contentString) {\n          return Transforms.delete(editor, {\n            at: path\n          });\n        }\n\n        // Transform to text when delete shortcut prefix\n        const isAtStart = Editor.isStart(editor, selection.focus, quickInsertEntry[1]);\n        if (isAtStart) {\n          const [, insertPath] = Editor.next(editor, {\n            at: path\n          });\n          const insertPoint = Editor.start(editor, insertPath);\n          const insertText = Node.string(quickInsertEntry[0]);\n          Transforms.insertText(editor, insertText, {\n            at: insertPoint\n          });\n          Transforms.removeNodes(editor, {\n            at: path\n          });\n          return;\n        }\n      }\n    }\n    return deleteBackward(unit);\n  };\n  newEditor.deleteForward = unit => {\n    const quickInsertEntry = getQuickInsertEntity(editor);\n    if (quickInsertEntry) {\n      const {\n        selection\n      } = editor;\n      const isAtEnd = Editor.isEnd(editor, selection.focus, quickInsertEntry[1]);\n      if (isAtEnd) {\n        deleteForward(unit);\n        focusEditor(editor, Editor.end(newEditor, quickInsertEntry[1]));\n        return;\n      }\n    }\n    return deleteForward(unit);\n  };\n  newEditor.onHotKeyDown = event => {\n    const quickInsertEntry = getQuickInsertEntity(editor);\n    if (quickInsertEntry) {\n      const [quickInsertNode, quickInsertPath] = quickInsertEntry;\n      const {\n        Esc,\n        RightArrow,\n        LeftArrow\n      } = KeyCodes;\n      const {\n        keyCode\n      } = event;\n      if ([RightArrow, LeftArrow].includes(keyCode)) {\n        const {\n          selection\n        } = editor;\n        const focusPoint = selection.focus;\n        if (!selection) return;\n        if (!Range.isCollapsed(selection)) return;\n        if (keyCode === RightArrow) {\n          if (Editor.isEnd(editor, focusPoint, quickInsertPath)) {\n            const insertPoint = transformToText(newEditor, quickInsertNode);\n            focusEditor(newEditor, insertPoint);\n            return;\n          }\n        }\n        if (keyCode === LeftArrow) {\n          if (Editor.isStart(editor, focusPoint, quickInsertPath)) {\n            event.preventDefault();\n            transformToText(newEditor, quickInsertNode);\n            return;\n          }\n        }\n      }\n      if (keyCode === Esc) {\n        // Choose the next point to focus\n        // Here need offset + 1 as text not include the prefix '/'\n        event.preventDefault();\n        const insertPoint = transformToText(newEditor, quickInsertNode);\n        return focusEditor(newEditor, insertPoint);\n      }\n    }\n    return onHotKeyDown && onHotKeyDown(event);\n  };\n  newEditor.onCompositionStart = event => {\n    const quickInsertEntry = getQuickInsertEntity(editor);\n    if (quickInsertEntry) {\n      event.preventDefault();\n      return true;\n    }\n  };\n  newEditor.isInline = element => {\n    if ([QUICK_INSERT].includes(element.type)) {\n      return true;\n    }\n    return isInline(element);\n  };\n  return newEditor;\n};\nexport default withQuickInsert;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}