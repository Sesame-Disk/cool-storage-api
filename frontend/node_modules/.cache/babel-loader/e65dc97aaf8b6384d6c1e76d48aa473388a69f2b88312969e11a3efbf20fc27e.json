{"ast":null,"code":"import _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { Editor, Path, Range, Transforms } from '@seafile/slate';\nimport { INSERT_POSITION, ORDERED_LIST, PARAGRAPH } from '../../../constants';\nimport { getBeforeText, setListType } from '../helpers';\nimport { focusEditor, getLastChild, getPreviousPath } from '../../../core';\nimport { generateEmptyListItem } from '../model';\nimport { toggleList } from '../transforms';\n\n/**\n * @param {Editor} editor\n * @param {String} text\n * @returns {Boolean} isPreventInsert\n */\nexport var handleShortcut = function handleShortcut(editor, text) {\n  if (text !== ' ') return false;\n  var selection = editor.selection;\n  if (!Range.isCollapsed(selection)) return false;\n  var _Editor$above = Editor.above(editor),\n    _Editor$above2 = _slicedToArray(_Editor$above, 2),\n    aboveNode = _Editor$above2[0],\n    aboveNodePath = _Editor$above2[1];\n  var aboveNodeRef = Editor.pathRef(editor, aboveNodePath);\n  if (aboveNode.type !== PARAGRAPH) return false;\n  // Match ordered list shortcut\n  var regShortcut = /^\\s*[1-9]+\\.\\s*$/;\n  var _getBeforeText = getBeforeText(editor),\n    beforeText = _getBeforeText.beforeText,\n    range = _getBeforeText.range;\n  var matchResult = beforeText.match(regShortcut);\n  var matchedText = matchResult && matchResult[0];\n  // If the match fails or the match is not at the beginning of the line, it is not a shortcut\n  if (!matchResult || matchResult.index !== 0) return false;\n  var previousNodePath = getPreviousPath(aboveNodePath);\n\n  // No previous node means that the current paragraph is the first paragraph in the container\n  if (!previousNodePath) {\n    if (matchedText !== '1.') return false;\n    // Delete shortcut key text\n    Transforms.delete(editor, {\n      at: range\n    });\n    toggleList(editor, ORDERED_LIST);\n    return true;\n  }\n  var _Editor$node = Editor.node(editor, previousNodePath),\n    _Editor$node2 = _slicedToArray(_Editor$node, 2),\n    previousNode = _Editor$node2[0],\n    previousPath = _Editor$node2[1];\n  // If the previous node is not an ordered list and is not start with `1.`,it is not a shortcut\n  if (previousNode.type !== ORDERED_LIST && matchedText !== '1.') return false;\n  // If the previous node is not an ordered list and is start with `1.`,transforms to ordered list\n  if (previousNode.type !== ORDERED_LIST && matchedText === '1.') {\n    // Delete shortcut key text\n    Transforms.delete(editor, {\n      at: range\n    });\n    setListType(editor, ORDERED_LIST);\n    focusEditor(editor);\n    return true;\n  }\n  // Record the order number of the shortcut that will be inserted as a list item\n  var shortcutOrderNum = parseInt(matchResult[0].slice(0, -1));\n\n  // Check If order number is continuous\n  if (previousNode.children.length + 1 !== shortcutOrderNum) return false;\n\n  // Delete shortcut key text\n  Transforms.delete(editor, {\n    at: range\n  });\n  // Update aboveNode after delete shortcut text\n  var _Editor$above3 = Editor.above(editor);\n  var _Editor$above4 = _slicedToArray(_Editor$above3, 1);\n  aboveNode = _Editor$above4[0];\n  var _getLastChild = getLastChild([previousNode, previousPath]),\n    _getLastChild2 = _slicedToArray(_getLastChild, 2),\n    lastListItemPath = _getLastChild2[1];\n  var targetInsertPath = Path.next(lastListItemPath);\n  // Wrap the paragraph in a list item\n  var insertedListItem = generateEmptyListItem();\n  insertedListItem.children.push(aboveNode);\n  Transforms.insertNodes(editor, insertedListItem, {\n    at: targetInsertPath\n  });\n  Transforms.removeNodes(editor, {\n    at: aboveNodeRef.unref()\n  });\n  // Set the selection to the end of the inserted list item\n  Transforms.select(editor, Editor.end(editor, targetInsertPath));\n  return true;\n};","map":{"version":3,"names":["Editor","Path","Range","Transforms","INSERT_POSITION","ORDERED_LIST","PARAGRAPH","getBeforeText","setListType","focusEditor","getLastChild","getPreviousPath","generateEmptyListItem","toggleList","handleShortcut","editor","text","selection","isCollapsed","_Editor$above","above","_Editor$above2","_slicedToArray","aboveNode","aboveNodePath","aboveNodeRef","pathRef","type","regShortcut","_getBeforeText","beforeText","range","matchResult","match","matchedText","index","previousNodePath","delete","at","_Editor$node","node","_Editor$node2","previousNode","previousPath","shortcutOrderNum","parseInt","slice","children","length","_Editor$above3","_Editor$above4","_getLastChild","_getLastChild2","lastListItemPath","targetInsertPath","next","insertedListItem","push","insertNodes","removeNodes","unref","select","end"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/plugins/list/plugin/shortcut.js"],"sourcesContent":["import { Editor, Path, Range, Transforms } from '@seafile/slate';\nimport { INSERT_POSITION, ORDERED_LIST, PARAGRAPH } from '../../../constants';\nimport { getBeforeText, setListType } from '../helpers';\nimport { focusEditor, getLastChild, getPreviousPath } from '../../../core';\nimport { generateEmptyListItem } from '../model';\nimport { toggleList } from '../transforms';\n\n/**\n * @param {Editor} editor\n * @param {String} text\n * @returns {Boolean} isPreventInsert\n */\nexport const handleShortcut = (editor, text) => {\n  if (text !== ' ') return false;\n  const {\n    selection\n  } = editor;\n  if (!Range.isCollapsed(selection)) return false;\n  let [aboveNode, aboveNodePath] = Editor.above(editor);\n  const aboveNodeRef = Editor.pathRef(editor, aboveNodePath);\n  if (aboveNode.type !== PARAGRAPH) return false;\n  // Match ordered list shortcut\n  const regShortcut = /^\\s*[1-9]+\\.\\s*$/;\n  const {\n    beforeText,\n    range\n  } = getBeforeText(editor);\n  const matchResult = beforeText.match(regShortcut);\n  const matchedText = matchResult && matchResult[0];\n  // If the match fails or the match is not at the beginning of the line, it is not a shortcut\n  if (!matchResult || matchResult.index !== 0) return false;\n  const previousNodePath = getPreviousPath(aboveNodePath);\n\n  // No previous node means that the current paragraph is the first paragraph in the container\n  if (!previousNodePath) {\n    if (matchedText !== '1.') return false;\n    // Delete shortcut key text\n    Transforms.delete(editor, {\n      at: range\n    });\n    toggleList(editor, ORDERED_LIST);\n    return true;\n  }\n  const [previousNode, previousPath] = Editor.node(editor, previousNodePath);\n  // If the previous node is not an ordered list and is not start with `1.`,it is not a shortcut\n  if (previousNode.type !== ORDERED_LIST && matchedText !== '1.') return false;\n  // If the previous node is not an ordered list and is start with `1.`,transforms to ordered list\n  if (previousNode.type !== ORDERED_LIST && matchedText === '1.') {\n    // Delete shortcut key text\n    Transforms.delete(editor, {\n      at: range\n    });\n    setListType(editor, ORDERED_LIST);\n    focusEditor(editor);\n    return true;\n  }\n  // Record the order number of the shortcut that will be inserted as a list item\n  const shortcutOrderNum = parseInt(matchResult[0].slice(0, -1));\n\n  // Check If order number is continuous\n  if (previousNode.children.length + 1 !== shortcutOrderNum) return false;\n\n  // Delete shortcut key text\n  Transforms.delete(editor, {\n    at: range\n  });\n  // Update aboveNode after delete shortcut text\n  [aboveNode] = Editor.above(editor);\n  const [, lastListItemPath] = getLastChild([previousNode, previousPath]);\n  const targetInsertPath = Path.next(lastListItemPath);\n  // Wrap the paragraph in a list item\n  const insertedListItem = generateEmptyListItem();\n  insertedListItem.children.push(aboveNode);\n  Transforms.insertNodes(editor, insertedListItem, {\n    at: targetInsertPath\n  });\n  Transforms.removeNodes(editor, {\n    at: aboveNodeRef.unref()\n  });\n  // Set the selection to the end of the inserted list item\n  Transforms.select(editor, Editor.end(editor, targetInsertPath));\n  return true;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}