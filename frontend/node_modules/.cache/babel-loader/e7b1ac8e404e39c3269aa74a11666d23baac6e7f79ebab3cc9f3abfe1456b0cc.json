{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _toArray = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/toArray.js\").default;\nvar _slicedToArray = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertFragmentList = exports.getTextAndListItemNodes = void 0;\nvar _slate = require(\"slate\");\nvar _slugid = _interopRequireDefault(require(\"slugid\"));\nvar _core = require(\"../../../core\");\nvar _constant = require(\"../constant\");\nvar _elementTypes = require(\"../../../constants/element-types\");\nvar isListRoot = function isListRoot(node) {\n  return _slate.Element.isElement(node) && _constant.LIST_TYPES.includes(node.type);\n};\nvar getFirstAncestorOfType = function getFirstAncestorOfType(root, entry, _ref) {\n  var type = _ref.type;\n  var ancestor = _slate.Path.parent(entry[1]);\n  while ((0, _core.getNode)(root, ancestor).type !== type) {\n    ancestor = _slate.Path.parent(ancestor);\n  }\n  return [(0, _core.getNode)(root, ancestor), ancestor];\n};\nvar findListItemsWithContent = function findListItemsWithContent(first) {\n  var prev = null;\n  var node = first;\n  while (isListRoot(node) || node.type === _elementTypes.LIST_ITEM && node.children[0].type !== _elementTypes.PARAGRAPH) {\n    prev = node;\n    var _node$children = _slicedToArray(node.children, 1);\n    node = _node$children[0];\n  }\n  return prev ? prev.children : [node];\n};\nvar trimList = function trimList(listRoot) {\n  if (!isListRoot(listRoot)) {\n    return [listRoot];\n  }\n  var _texts = _slate.Node.texts(listRoot);\n  var textEntries = Array.from(_texts);\n  var commonAncestorEntry = textEntries.reduce(function (commonAncestor, textEntry) {\n    return _slate.Path.isAncestor(commonAncestor[1], textEntry[1]) ? commonAncestor : (0, _core.getCommonNode)(listRoot, textEntry[1], commonAncestor[1]);\n  }, getFirstAncestorOfType(listRoot, textEntries[0], {\n    type: _elementTypes.LIST_ITEM\n  }));\n\n  // is ul/ol: return children\n  // is not ul/ol\n  var _ref3 = isListRoot(commonAncestorEntry[0]) ? commonAncestorEntry[0].children : [commonAncestorEntry[0]],\n    _ref4 = _toArray(_ref3),\n    first = _ref4[0],\n    rest = _ref4.slice(1);\n  return [].concat(_toConsumableArray(findListItemsWithContent(first)), _toConsumableArray(rest));\n};\nvar wrapNodeIntoListItem = function wrapNodeIntoListItem(node) {\n  if (node.type === _elementTypes.LIST_ITEM) return node;\n  var children = (0, _core.getInlineNodes)(node);\n  return {\n    id: _slugid.default.nice(),\n    type: _elementTypes.LIST_ITEM,\n    children: [{\n      id: _slugid.default.nice(),\n      type: _elementTypes.PARAGRAPH,\n      children: children\n    }]\n  };\n};\nvar isSingleLic = function isSingleLic(fragment) {\n  var isFragmentOnlyListRoot = fragment.length === 1 && isListRoot(fragment[0]);\n  return isFragmentOnlyListRoot && _toConsumableArray((0, _core.getNodes)({\n    children: fragment\n  })).filter(function (entry) {\n    return _slate.Element.isElement(entry[0]);\n  }).filter(function (_ref2) {\n    var _ref5 = _slicedToArray(_ref2, 1),\n      node = _ref5[0];\n    return node.type === _elementTypes.PARAGRAPH;\n  }).length === 1;\n};\nvar getTextAndListItemNodes = function getTextAndListItemNodes(editor, fragment, liEntry, licEntry) {\n  var _liEntry = _slicedToArray(liEntry, 2),\n    liPath = _liEntry[1];\n  var _licEntry = _slicedToArray(licEntry, 2),\n    licNode = _licEntry[0],\n    licPath = _licEntry[1];\n  var isEmptyNode = !_slate.Node.string(licNode);\n  // format copied fragment\n  // first: lic, path: [...liPath, 0, 0]\n  // rest: children, path: [...liPath, 1, 0]\n  var _fragment$flatMap$map = fragment.flatMap(trimList).map(wrapNodeIntoListItem),\n    _fragment$flatMap$map2 = _toArray(_fragment$flatMap$map),\n    first = _fragment$flatMap$map2[0],\n    rest = _fragment$flatMap$map2.slice(1);\n  var textNode = null;\n  var listItemNodes = [];\n  if (isListRoot(fragment[0])) {\n    if (isSingleLic(fragment)) {\n      textNode = first;\n      listItemNodes = rest;\n    } else if (isEmptyNode) {\n      var li = (0, _core.getNode)(editor, liPath);\n      var _li$children = _toArray(li.children),\n        currentSubLists = _li$children.slice(1); // old\n\n      var _first$children = _toArray(first.children),\n        newLic = _first$children[0],\n        newSubLists = _first$children.slice(1); // copied\n      // insert copied contents\n      _slate.Transforms.insertNodes(editor, newLic, {\n        at: _slate.Path.next(licPath),\n        select: true\n      });\n      _slate.Transforms.removeNodes(editor, {\n        at: licPath\n      });\n      if (newSubLists.length) {\n        if (currentSubLists.length) {\n          var path = [].concat(_toConsumableArray(liPath), [1, 0]);\n          _slate.Transforms.insertNodes(editor, newSubLists[0].children, {\n            at: path,\n            select: true\n          });\n        } else {\n          _slate.Transforms.insertNodes(editor, newSubLists, {\n            at: _slate.Path.next(licPath),\n            select: true\n          });\n        }\n      }\n      textNode = (0, _core.generateDefaultText)();\n      listItemNodes = rest;\n    } else {\n      textNode = (0, _core.generateDefaultText)();\n      listItemNodes = [first].concat(_toConsumableArray(rest));\n    }\n  } else {\n    textNode = first;\n    listItemNodes = rest;\n    return {\n      textNode: textNode,\n      listItemNodes: listItemNodes\n    };\n  }\n  return {\n    textNode: textNode,\n    listItemNodes: listItemNodes\n  };\n};\nexports.getTextAndListItemNodes = getTextAndListItemNodes;\nvar insertFragmentList = function insertFragmentList(editor) {\n  return function (fragment) {\n    _slate.Editor.withoutNormalizing(editor, function () {\n      var liEntry = (0, _core.findNode)(editor, {\n        match: {\n          type: _elementTypes.LIST_ITEM\n        },\n        mode: 'lowest'\n      });\n      if (!liEntry) {\n        var nodes = isListRoot(fragment) ? [(0, _core.generateDefaultText)()].concat(_toConsumableArray(fragment)) : fragment;\n        return (0, _slate.insertFragment)(editor, nodes);\n      }\n      (0, _slate.insertFragment)(editor, [(0, _core.generateDefaultText)()]); // need ' '\n\n      liEntry = (0, _core.findNode)(editor, {\n        match: {\n          type: _elementTypes.LIST_ITEM\n        },\n        mode: 'lowest'\n      });\n      var licEntry = (0, _core.findNode)(editor, {\n        match: {\n          type: _elementTypes.PARAGRAPH\n        },\n        mode: 'lowest'\n      });\n      if (!licEntry) {\n        var _nodes = isListRoot(fragment) ? [(0, _core.generateDefaultText)()].concat(_toConsumableArray(fragment)) : fragment;\n        return (0, _slate.insertFragment)(editor, _nodes);\n      }\n      var _getTextAndListItemNo = getTextAndListItemNodes(editor, fragment, liEntry, licEntry),\n        textNode = _getTextAndListItemNo.textNode,\n        listItemNodes = _getTextAndListItemNo.listItemNodes;\n      (0, _slate.insertFragment)(editor, [textNode]);\n      var _liEntry2 = liEntry,\n        _liEntry3 = _slicedToArray(_liEntry2, 2),\n        liPath = _liEntry3[1];\n      return _slate.Transforms.insertNodes(editor, listItemNodes, {\n        at: _slate.Path.next(liPath),\n        select: true\n      });\n    });\n  };\n};\nexports.insertFragmentList = insertFragmentList;","map":{"version":3,"names":["_toConsumableArray","require","default","_toArray","_slicedToArray","_interopRequireDefault","Object","defineProperty","exports","value","insertFragmentList","getTextAndListItemNodes","_slate","_slugid","_core","_constant","_elementTypes","isListRoot","node","Element","isElement","LIST_TYPES","includes","type","getFirstAncestorOfType","root","entry","_ref","ancestor","Path","parent","getNode","findListItemsWithContent","first","prev","LIST_ITEM","children","PARAGRAPH","_node$children","trimList","listRoot","_texts","Node","texts","textEntries","Array","from","commonAncestorEntry","reduce","commonAncestor","textEntry","isAncestor","getCommonNode","_ref3","_ref4","rest","slice","concat","wrapNodeIntoListItem","getInlineNodes","id","nice","isSingleLic","fragment","isFragmentOnlyListRoot","length","getNodes","filter","_ref2","_ref5","editor","liEntry","licEntry","_liEntry","liPath","_licEntry","licNode","licPath","isEmptyNode","string","_fragment$flatMap$map","flatMap","map","_fragment$flatMap$map2","textNode","listItemNodes","li","_li$children","currentSubLists","_first$children","newLic","newSubLists","Transforms","insertNodes","at","next","select","removeNodes","path","generateDefaultText","Editor","withoutNormalizing","findNode","match","mode","nodes","insertFragment","_getTextAndListItemNo","_liEntry2","_liEntry3"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/seafile-editor/dist/extension/plugins/list/plugin/insert-fragment-list.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertFragmentList = exports.getTextAndListItemNodes = void 0;\nvar _slate = require(\"slate\");\nvar _slugid = _interopRequireDefault(require(\"slugid\"));\nvar _core = require(\"../../../core\");\nvar _constant = require(\"../constant\");\nvar _elementTypes = require(\"../../../constants/element-types\");\nconst isListRoot = node => {\n  return _slate.Element.isElement(node) && _constant.LIST_TYPES.includes(node.type);\n};\nconst getFirstAncestorOfType = (root, entry, _ref) => {\n  let {\n    type\n  } = _ref;\n  let ancestor = _slate.Path.parent(entry[1]);\n  while ((0, _core.getNode)(root, ancestor).type !== type) {\n    ancestor = _slate.Path.parent(ancestor);\n  }\n  return [(0, _core.getNode)(root, ancestor), ancestor];\n};\nconst findListItemsWithContent = first => {\n  let prev = null;\n  let node = first;\n  while (isListRoot(node) || node.type === _elementTypes.LIST_ITEM && node.children[0].type !== _elementTypes.PARAGRAPH) {\n    prev = node;\n    [node] = node.children;\n  }\n  return prev ? prev.children : [node];\n};\nconst trimList = listRoot => {\n  if (!isListRoot(listRoot)) {\n    return [listRoot];\n  }\n  const _texts = _slate.Node.texts(listRoot);\n  const textEntries = Array.from(_texts);\n  const commonAncestorEntry = textEntries.reduce((commonAncestor, textEntry) => {\n    return _slate.Path.isAncestor(commonAncestor[1], textEntry[1]) ? commonAncestor : (0, _core.getCommonNode)(listRoot, textEntry[1], commonAncestor[1]);\n  }, getFirstAncestorOfType(listRoot, textEntries[0], {\n    type: _elementTypes.LIST_ITEM\n  }));\n\n  // is ul/ol: return children\n  // is not ul/ol\n  const [first, ...rest] = isListRoot(commonAncestorEntry[0]) ? commonAncestorEntry[0].children : [commonAncestorEntry[0]];\n  return [...findListItemsWithContent(first), ...rest];\n};\nconst wrapNodeIntoListItem = node => {\n  if (node.type === _elementTypes.LIST_ITEM) return node;\n  const children = (0, _core.getInlineNodes)(node);\n  return {\n    id: _slugid.default.nice(),\n    type: _elementTypes.LIST_ITEM,\n    children: [{\n      id: _slugid.default.nice(),\n      type: _elementTypes.PARAGRAPH,\n      children\n    }]\n  };\n};\nconst isSingleLic = fragment => {\n  const isFragmentOnlyListRoot = fragment.length === 1 && isListRoot(fragment[0]);\n  return isFragmentOnlyListRoot && [...(0, _core.getNodes)({\n    children: fragment\n  })].filter(entry => _slate.Element.isElement(entry[0])).filter(_ref2 => {\n    let [node] = _ref2;\n    return node.type === _elementTypes.PARAGRAPH;\n  }).length === 1;\n};\nconst getTextAndListItemNodes = (editor, fragment, liEntry, licEntry) => {\n  const [, liPath] = liEntry;\n  const [licNode, licPath] = licEntry;\n  const isEmptyNode = !_slate.Node.string(licNode);\n  // format copied fragment\n  // first: lic, path: [...liPath, 0, 0]\n  // rest: children, path: [...liPath, 1, 0]\n  const [first, ...rest] = fragment.flatMap(trimList).map(wrapNodeIntoListItem);\n  let textNode = null;\n  let listItemNodes = [];\n  if (isListRoot(fragment[0])) {\n    if (isSingleLic(fragment)) {\n      textNode = first;\n      listItemNodes = rest;\n    } else if (isEmptyNode) {\n      const li = (0, _core.getNode)(editor, liPath);\n      const [, ...currentSubLists] = li.children; // old\n\n      const [newLic, ...newSubLists] = first.children; // copied\n      // insert copied contents\n      _slate.Transforms.insertNodes(editor, newLic, {\n        at: _slate.Path.next(licPath),\n        select: true\n      });\n      _slate.Transforms.removeNodes(editor, {\n        at: licPath\n      });\n      if (newSubLists.length) {\n        if (currentSubLists.length) {\n          const path = [...liPath, 1, 0];\n          _slate.Transforms.insertNodes(editor, newSubLists[0].children, {\n            at: path,\n            select: true\n          });\n        } else {\n          _slate.Transforms.insertNodes(editor, newSubLists, {\n            at: _slate.Path.next(licPath),\n            select: true\n          });\n        }\n      }\n      textNode = (0, _core.generateDefaultText)();\n      listItemNodes = rest;\n    } else {\n      textNode = (0, _core.generateDefaultText)();\n      listItemNodes = [first, ...rest];\n    }\n  } else {\n    textNode = first;\n    listItemNodes = rest;\n    return {\n      textNode,\n      listItemNodes\n    };\n  }\n  return {\n    textNode,\n    listItemNodes\n  };\n};\nexports.getTextAndListItemNodes = getTextAndListItemNodes;\nconst insertFragmentList = editor => {\n  return fragment => {\n    _slate.Editor.withoutNormalizing(editor, () => {\n      let liEntry = (0, _core.findNode)(editor, {\n        match: {\n          type: _elementTypes.LIST_ITEM\n        },\n        mode: 'lowest'\n      });\n      if (!liEntry) {\n        const nodes = isListRoot(fragment) ? [(0, _core.generateDefaultText)(), ...fragment] : fragment;\n        return (0, _slate.insertFragment)(editor, nodes);\n      }\n      (0, _slate.insertFragment)(editor, [(0, _core.generateDefaultText)()]); // need ' '\n\n      liEntry = (0, _core.findNode)(editor, {\n        match: {\n          type: _elementTypes.LIST_ITEM\n        },\n        mode: 'lowest'\n      });\n      const licEntry = (0, _core.findNode)(editor, {\n        match: {\n          type: _elementTypes.PARAGRAPH\n        },\n        mode: 'lowest'\n      });\n      if (!licEntry) {\n        const nodes = isListRoot(fragment) ? [(0, _core.generateDefaultText)(), ...fragment] : fragment;\n        return (0, _slate.insertFragment)(editor, nodes);\n      }\n      const {\n        textNode,\n        listItemNodes\n      } = getTextAndListItemNodes(editor, fragment, liEntry, licEntry);\n      (0, _slate.insertFragment)(editor, [textNode]);\n      const [, liPath] = liEntry;\n      return _slate.Transforms.insertNodes(editor, listItemNodes, {\n        at: _slate.Path.next(liPath),\n        select: true\n      });\n    });\n  };\n};\nexports.insertFragmentList = insertFragmentList;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}