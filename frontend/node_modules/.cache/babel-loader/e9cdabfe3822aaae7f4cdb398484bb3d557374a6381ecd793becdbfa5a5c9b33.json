{"ast":null,"code":"/////////////////////////////////////////////////////////////////////////////\n// constants\n\nvar typeWords = [\"-type\", \"-spec\", \"-export_type\", \"-opaque\"];\nvar keywordWords = [\"after\", \"begin\", \"catch\", \"case\", \"cond\", \"end\", \"fun\", \"if\", \"let\", \"of\", \"query\", \"receive\", \"try\", \"when\"];\nvar separatorRE = /[\\->,;]/;\nvar separatorWords = [\"->\", \";\", \",\"];\nvar operatorAtomWords = [\"and\", \"andalso\", \"band\", \"bnot\", \"bor\", \"bsl\", \"bsr\", \"bxor\", \"div\", \"not\", \"or\", \"orelse\", \"rem\", \"xor\"];\nvar operatorSymbolRE = /[\\+\\-\\*\\/<>=\\|:!]/;\nvar operatorSymbolWords = [\"=\", \"+\", \"-\", \"*\", \"/\", \">\", \">=\", \"<\", \"=<\", \"=:=\", \"==\", \"=/=\", \"/=\", \"||\", \"<-\", \"!\"];\nvar openParenRE = /[<\\(\\[\\{]/;\nvar openParenWords = [\"<<\", \"(\", \"[\", \"{\"];\nvar closeParenRE = /[>\\)\\]\\}]/;\nvar closeParenWords = [\"}\", \"]\", \")\", \">>\"];\nvar guardWords = [\"is_atom\", \"is_binary\", \"is_bitstring\", \"is_boolean\", \"is_float\", \"is_function\", \"is_integer\", \"is_list\", \"is_number\", \"is_pid\", \"is_port\", \"is_record\", \"is_reference\", \"is_tuple\", \"atom\", \"binary\", \"bitstring\", \"boolean\", \"function\", \"integer\", \"list\", \"number\", \"pid\", \"port\", \"record\", \"reference\", \"tuple\"];\nvar bifWords = [\"abs\", \"adler32\", \"adler32_combine\", \"alive\", \"apply\", \"atom_to_binary\", \"atom_to_list\", \"binary_to_atom\", \"binary_to_existing_atom\", \"binary_to_list\", \"binary_to_term\", \"bit_size\", \"bitstring_to_list\", \"byte_size\", \"check_process_code\", \"contact_binary\", \"crc32\", \"crc32_combine\", \"date\", \"decode_packet\", \"delete_module\", \"disconnect_node\", \"element\", \"erase\", \"exit\", \"float\", \"float_to_list\", \"garbage_collect\", \"get\", \"get_keys\", \"group_leader\", \"halt\", \"hd\", \"integer_to_list\", \"internal_bif\", \"iolist_size\", \"iolist_to_binary\", \"is_alive\", \"is_atom\", \"is_binary\", \"is_bitstring\", \"is_boolean\", \"is_float\", \"is_function\", \"is_integer\", \"is_list\", \"is_number\", \"is_pid\", \"is_port\", \"is_process_alive\", \"is_record\", \"is_reference\", \"is_tuple\", \"length\", \"link\", \"list_to_atom\", \"list_to_binary\", \"list_to_bitstring\", \"list_to_existing_atom\", \"list_to_float\", \"list_to_integer\", \"list_to_pid\", \"list_to_tuple\", \"load_module\", \"make_ref\", \"module_loaded\", \"monitor_node\", \"node\", \"node_link\", \"node_unlink\", \"nodes\", \"notalive\", \"now\", \"open_port\", \"pid_to_list\", \"port_close\", \"port_command\", \"port_connect\", \"port_control\", \"pre_loaded\", \"process_flag\", \"process_info\", \"processes\", \"purge_module\", \"put\", \"register\", \"registered\", \"round\", \"self\", \"setelement\", \"size\", \"spawn\", \"spawn_link\", \"spawn_monitor\", \"spawn_opt\", \"split_binary\", \"statistics\", \"term_to_binary\", \"time\", \"throw\", \"tl\", \"trunc\", \"tuple_size\", \"tuple_to_list\", \"unlink\", \"unregister\", \"whereis\"];\n\n// upper case: [A-Z] [Ø-Þ] [À-Ö]\n// lower case: [a-z] [ß-ö] [ø-ÿ]\nvar anumRE = /[\\w@Ø-ÞÀ-Öß-öø-ÿ]/;\nvar escapesRE = /[0-7]{1,3}|[bdefnrstv\\\\\"']|\\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/;\n\n/////////////////////////////////////////////////////////////////////////////\n// tokenizer\n\nfunction tokenizer(stream, state) {\n  // in multi-line string\n  if (state.in_string) {\n    state.in_string = !doubleQuote(stream);\n    return rval(state, stream, \"string\");\n  }\n\n  // in multi-line atom\n  if (state.in_atom) {\n    state.in_atom = !singleQuote(stream);\n    return rval(state, stream, \"atom\");\n  }\n\n  // whitespace\n  if (stream.eatSpace()) {\n    return rval(state, stream, \"whitespace\");\n  }\n\n  // attributes and type specs\n  if (!peekToken(state) && stream.match(/-\\s*[a-zß-öø-ÿ][\\wØ-ÞÀ-Öß-öø-ÿ]*/)) {\n    if (is_member(stream.current(), typeWords)) {\n      return rval(state, stream, \"type\");\n    } else {\n      return rval(state, stream, \"attribute\");\n    }\n  }\n  var ch = stream.next();\n\n  // comment\n  if (ch == '%') {\n    stream.skipToEnd();\n    return rval(state, stream, \"comment\");\n  }\n\n  // colon\n  if (ch == \":\") {\n    return rval(state, stream, \"colon\");\n  }\n\n  // macro\n  if (ch == '?') {\n    stream.eatSpace();\n    stream.eatWhile(anumRE);\n    return rval(state, stream, \"macro\");\n  }\n\n  // record\n  if (ch == \"#\") {\n    stream.eatSpace();\n    stream.eatWhile(anumRE);\n    return rval(state, stream, \"record\");\n  }\n\n  // dollar escape\n  if (ch == \"$\") {\n    if (stream.next() == \"\\\\\" && !stream.match(escapesRE)) {\n      return rval(state, stream, \"error\");\n    }\n    return rval(state, stream, \"number\");\n  }\n\n  // dot\n  if (ch == \".\") {\n    return rval(state, stream, \"dot\");\n  }\n\n  // quoted atom\n  if (ch == '\\'') {\n    if (!(state.in_atom = !singleQuote(stream))) {\n      if (stream.match(/\\s*\\/\\s*[0-9]/, false)) {\n        stream.match(/\\s*\\/\\s*[0-9]/, true);\n        return rval(state, stream, \"fun\"); // 'f'/0 style fun\n      }\n\n      if (stream.match(/\\s*\\(/, false) || stream.match(/\\s*:/, false)) {\n        return rval(state, stream, \"function\");\n      }\n    }\n    return rval(state, stream, \"atom\");\n  }\n\n  // string\n  if (ch == '\"') {\n    state.in_string = !doubleQuote(stream);\n    return rval(state, stream, \"string\");\n  }\n\n  // variable\n  if (/[A-Z_Ø-ÞÀ-Ö]/.test(ch)) {\n    stream.eatWhile(anumRE);\n    return rval(state, stream, \"variable\");\n  }\n\n  // atom/keyword/BIF/function\n  if (/[a-z_ß-öø-ÿ]/.test(ch)) {\n    stream.eatWhile(anumRE);\n    if (stream.match(/\\s*\\/\\s*[0-9]/, false)) {\n      stream.match(/\\s*\\/\\s*[0-9]/, true);\n      return rval(state, stream, \"fun\"); // f/0 style fun\n    }\n\n    var w = stream.current();\n    if (is_member(w, keywordWords)) {\n      return rval(state, stream, \"keyword\");\n    } else if (is_member(w, operatorAtomWords)) {\n      return rval(state, stream, \"operator\");\n    } else if (stream.match(/\\s*\\(/, false)) {\n      // 'put' and 'erlang:put' are bifs, 'foo:put' is not\n      if (is_member(w, bifWords) && (peekToken(state).token != \":\" || peekToken(state, 2).token == \"erlang\")) {\n        return rval(state, stream, \"builtin\");\n      } else if (is_member(w, guardWords)) {\n        return rval(state, stream, \"guard\");\n      } else {\n        return rval(state, stream, \"function\");\n      }\n    } else if (lookahead(stream) == \":\") {\n      if (w == \"erlang\") {\n        return rval(state, stream, \"builtin\");\n      } else {\n        return rval(state, stream, \"function\");\n      }\n    } else if (is_member(w, [\"true\", \"false\"])) {\n      return rval(state, stream, \"boolean\");\n    } else {\n      return rval(state, stream, \"atom\");\n    }\n  }\n\n  // number\n  var digitRE = /[0-9]/;\n  var radixRE = /[0-9a-zA-Z]/; // 36#zZ style int\n  if (digitRE.test(ch)) {\n    stream.eatWhile(digitRE);\n    if (stream.eat('#')) {\n      // 36#aZ  style integer\n      if (!stream.eatWhile(radixRE)) {\n        stream.backUp(1); //\"36#\" - syntax error\n      }\n    } else if (stream.eat('.')) {\n      // float\n      if (!stream.eatWhile(digitRE)) {\n        stream.backUp(1); // \"3.\" - probably end of function\n      } else {\n        if (stream.eat(/[eE]/)) {\n          // float with exponent\n          if (stream.eat(/[-+]/)) {\n            if (!stream.eatWhile(digitRE)) {\n              stream.backUp(2); // \"2e-\" - syntax error\n            }\n          } else {\n            if (!stream.eatWhile(digitRE)) {\n              stream.backUp(1); // \"2e\" - syntax error\n            }\n          }\n        }\n      }\n    }\n\n    return rval(state, stream, \"number\"); // normal integer\n  }\n\n  // open parens\n  if (nongreedy(stream, openParenRE, openParenWords)) {\n    return rval(state, stream, \"open_paren\");\n  }\n\n  // close parens\n  if (nongreedy(stream, closeParenRE, closeParenWords)) {\n    return rval(state, stream, \"close_paren\");\n  }\n\n  // separators\n  if (greedy(stream, separatorRE, separatorWords)) {\n    return rval(state, stream, \"separator\");\n  }\n\n  // operators\n  if (greedy(stream, operatorSymbolRE, operatorSymbolWords)) {\n    return rval(state, stream, \"operator\");\n  }\n  return rval(state, stream, null);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// utilities\nfunction nongreedy(stream, re, words) {\n  if (stream.current().length == 1 && re.test(stream.current())) {\n    stream.backUp(1);\n    while (re.test(stream.peek())) {\n      stream.next();\n      if (is_member(stream.current(), words)) {\n        return true;\n      }\n    }\n    stream.backUp(stream.current().length - 1);\n  }\n  return false;\n}\nfunction greedy(stream, re, words) {\n  if (stream.current().length == 1 && re.test(stream.current())) {\n    while (re.test(stream.peek())) {\n      stream.next();\n    }\n    while (0 < stream.current().length) {\n      if (is_member(stream.current(), words)) {\n        return true;\n      } else {\n        stream.backUp(1);\n      }\n    }\n    stream.next();\n  }\n  return false;\n}\nfunction doubleQuote(stream) {\n  return quote(stream, '\"', '\\\\');\n}\nfunction singleQuote(stream) {\n  return quote(stream, '\\'', '\\\\');\n}\nfunction quote(stream, quoteChar, escapeChar) {\n  while (!stream.eol()) {\n    var ch = stream.next();\n    if (ch == quoteChar) {\n      return true;\n    } else if (ch == escapeChar) {\n      stream.next();\n    }\n  }\n  return false;\n}\nfunction lookahead(stream) {\n  var m = stream.match(/^\\s*([^\\s%])/, false);\n  return m ? m[1] : \"\";\n}\nfunction is_member(element, list) {\n  return -1 < list.indexOf(element);\n}\nfunction rval(state, stream, type) {\n  // parse stack\n  pushToken(state, realToken(type, stream));\n\n  // map erlang token type to CodeMirror style class\n  //     erlang             -> CodeMirror tag\n  switch (type) {\n    case \"atom\":\n      return \"atom\";\n    case \"attribute\":\n      return \"attribute\";\n    case \"boolean\":\n      return \"atom\";\n    case \"builtin\":\n      return \"builtin\";\n    case \"close_paren\":\n      return null;\n    case \"colon\":\n      return null;\n    case \"comment\":\n      return \"comment\";\n    case \"dot\":\n      return null;\n    case \"error\":\n      return \"error\";\n    case \"fun\":\n      return \"meta\";\n    case \"function\":\n      return \"tag\";\n    case \"guard\":\n      return \"property\";\n    case \"keyword\":\n      return \"keyword\";\n    case \"macro\":\n      return \"macroName\";\n    case \"number\":\n      return \"number\";\n    case \"open_paren\":\n      return null;\n    case \"operator\":\n      return \"operator\";\n    case \"record\":\n      return \"bracket\";\n    case \"separator\":\n      return null;\n    case \"string\":\n      return \"string\";\n    case \"type\":\n      return \"def\";\n    case \"variable\":\n      return \"variable\";\n    default:\n      return null;\n  }\n}\nfunction aToken(tok, col, ind, typ) {\n  return {\n    token: tok,\n    column: col,\n    indent: ind,\n    type: typ\n  };\n}\nfunction realToken(type, stream) {\n  return aToken(stream.current(), stream.column(), stream.indentation(), type);\n}\nfunction fakeToken(type) {\n  return aToken(type, 0, 0, type);\n}\nfunction peekToken(state, depth) {\n  var len = state.tokenStack.length;\n  var dep = depth ? depth : 1;\n  if (len < dep) {\n    return false;\n  } else {\n    return state.tokenStack[len - dep];\n  }\n}\nfunction pushToken(state, token) {\n  if (!(token.type == \"comment\" || token.type == \"whitespace\")) {\n    state.tokenStack = maybe_drop_pre(state.tokenStack, token);\n    state.tokenStack = maybe_drop_post(state.tokenStack);\n  }\n}\nfunction maybe_drop_pre(s, token) {\n  var last = s.length - 1;\n  if (0 < last && s[last].type === \"record\" && token.type === \"dot\") {\n    s.pop();\n  } else if (0 < last && s[last].type === \"group\") {\n    s.pop();\n    s.push(token);\n  } else {\n    s.push(token);\n  }\n  return s;\n}\nfunction maybe_drop_post(s) {\n  if (!s.length) return s;\n  var last = s.length - 1;\n  if (s[last].type === \"dot\") {\n    return [];\n  }\n  if (last > 1 && s[last].type === \"fun\" && s[last - 1].token === \"fun\") {\n    return s.slice(0, last - 1);\n  }\n  switch (s[last].token) {\n    case \"}\":\n      return d(s, {\n        g: [\"{\"]\n      });\n    case \"]\":\n      return d(s, {\n        i: [\"[\"]\n      });\n    case \")\":\n      return d(s, {\n        i: [\"(\"]\n      });\n    case \">>\":\n      return d(s, {\n        i: [\"<<\"]\n      });\n    case \"end\":\n      return d(s, {\n        i: [\"begin\", \"case\", \"fun\", \"if\", \"receive\", \"try\"]\n      });\n    case \",\":\n      return d(s, {\n        e: [\"begin\", \"try\", \"when\", \"->\", \",\", \"(\", \"[\", \"{\", \"<<\"]\n      });\n    case \"->\":\n      return d(s, {\n        r: [\"when\"],\n        m: [\"try\", \"if\", \"case\", \"receive\"]\n      });\n    case \";\":\n      return d(s, {\n        E: [\"case\", \"fun\", \"if\", \"receive\", \"try\", \"when\"]\n      });\n    case \"catch\":\n      return d(s, {\n        e: [\"try\"]\n      });\n    case \"of\":\n      return d(s, {\n        e: [\"case\"]\n      });\n    case \"after\":\n      return d(s, {\n        e: [\"receive\", \"try\"]\n      });\n    default:\n      return s;\n  }\n}\nfunction d(stack, tt) {\n  // stack is a stack of Token objects.\n  // tt is an object; {type:tokens}\n  // type is a char, tokens is a list of token strings.\n  // The function returns (possibly truncated) stack.\n  // It will descend the stack, looking for a Token such that Token.token\n  //  is a member of tokens. If it does not find that, it will normally (but\n  //  see \"E\" below) return stack. If it does find a match, it will remove\n  //  all the Tokens between the top and the matched Token.\n  // If type is \"m\", that is all it does.\n  // If type is \"i\", it will also remove the matched Token and the top Token.\n  // If type is \"g\", like \"i\", but add a fake \"group\" token at the top.\n  // If type is \"r\", it will remove the matched Token, but not the top Token.\n  // If type is \"e\", it will keep the matched Token but not the top Token.\n  // If type is \"E\", it behaves as for type \"e\", except if there is no match,\n  //  in which case it will return an empty stack.\n\n  for (var type in tt) {\n    var len = stack.length - 1;\n    var tokens = tt[type];\n    for (var i = len - 1; -1 < i; i--) {\n      if (is_member(stack[i].token, tokens)) {\n        var ss = stack.slice(0, i);\n        switch (type) {\n          case \"m\":\n            return ss.concat(stack[i]).concat(stack[len]);\n          case \"r\":\n            return ss.concat(stack[len]);\n          case \"i\":\n            return ss;\n          case \"g\":\n            return ss.concat(fakeToken(\"group\"));\n          case \"E\":\n            return ss.concat(stack[i]);\n          case \"e\":\n            return ss.concat(stack[i]);\n        }\n      }\n    }\n  }\n  return type == \"E\" ? [] : stack;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// indenter\n\nfunction indenter(state, textAfter, cx) {\n  var t;\n  var wordAfter = wordafter(textAfter);\n  var currT = peekToken(state, 1);\n  var prevT = peekToken(state, 2);\n  if (state.in_string || state.in_atom) {\n    return null;\n  } else if (!prevT) {\n    return 0;\n  } else if (currT.token == \"when\") {\n    return currT.column + cx.unit;\n  } else if (wordAfter === \"when\" && prevT.type === \"function\") {\n    return prevT.indent + cx.unit;\n  } else if (wordAfter === \"(\" && currT.token === \"fun\") {\n    return currT.column + 3;\n  } else if (wordAfter === \"catch\" && (t = getToken(state, [\"try\"]))) {\n    return t.column;\n  } else if (is_member(wordAfter, [\"end\", \"after\", \"of\"])) {\n    t = getToken(state, [\"begin\", \"case\", \"fun\", \"if\", \"receive\", \"try\"]);\n    return t ? t.column : null;\n  } else if (is_member(wordAfter, closeParenWords)) {\n    t = getToken(state, openParenWords);\n    return t ? t.column : null;\n  } else if (is_member(currT.token, [\",\", \"|\", \"||\"]) || is_member(wordAfter, [\",\", \"|\", \"||\"])) {\n    t = postcommaToken(state);\n    return t ? t.column + t.token.length : cx.unit;\n  } else if (currT.token == \"->\") {\n    if (is_member(prevT.token, [\"receive\", \"case\", \"if\", \"try\"])) {\n      return prevT.column + cx.unit + cx.unit;\n    } else {\n      return prevT.column + cx.unit;\n    }\n  } else if (is_member(currT.token, openParenWords)) {\n    return currT.column + currT.token.length;\n  } else {\n    t = defaultToken(state);\n    return truthy(t) ? t.column + cx.unit : 0;\n  }\n}\nfunction wordafter(str) {\n  var m = str.match(/,|[a-z]+|\\}|\\]|\\)|>>|\\|+|\\(/);\n  return truthy(m) && m.index === 0 ? m[0] : \"\";\n}\nfunction postcommaToken(state) {\n  var objs = state.tokenStack.slice(0, -1);\n  var i = getTokenIndex(objs, \"type\", [\"open_paren\"]);\n  return truthy(objs[i]) ? objs[i] : false;\n}\nfunction defaultToken(state) {\n  var objs = state.tokenStack;\n  var stop = getTokenIndex(objs, \"type\", [\"open_paren\", \"separator\", \"keyword\"]);\n  var oper = getTokenIndex(objs, \"type\", [\"operator\"]);\n  if (truthy(stop) && truthy(oper) && stop < oper) {\n    return objs[stop + 1];\n  } else if (truthy(stop)) {\n    return objs[stop];\n  } else {\n    return false;\n  }\n}\nfunction getToken(state, tokens) {\n  var objs = state.tokenStack;\n  var i = getTokenIndex(objs, \"token\", tokens);\n  return truthy(objs[i]) ? objs[i] : false;\n}\nfunction getTokenIndex(objs, propname, propvals) {\n  for (var i = objs.length - 1; -1 < i; i--) {\n    if (is_member(objs[i][propname], propvals)) {\n      return i;\n    }\n  }\n  return false;\n}\nfunction truthy(x) {\n  return x !== false && x != null;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// this object defines the mode\n\nexport var erlang = {\n  name: \"erlang\",\n  startState: function startState() {\n    return {\n      tokenStack: [],\n      in_string: false,\n      in_atom: false\n    };\n  },\n  token: tokenizer,\n  indent: indenter,\n  languageData: {\n    commentTokens: {\n      line: \"%\"\n    }\n  }\n};","map":{"version":3,"names":["typeWords","keywordWords","separatorRE","separatorWords","operatorAtomWords","operatorSymbolRE","operatorSymbolWords","openParenRE","openParenWords","closeParenRE","closeParenWords","guardWords","bifWords","anumRE","escapesRE","tokenizer","stream","state","in_string","doubleQuote","rval","in_atom","singleQuote","eatSpace","peekToken","match","is_member","current","ch","next","skipToEnd","eatWhile","test","w","token","lookahead","digitRE","radixRE","eat","backUp","nongreedy","greedy","re","words","length","peek","quote","quoteChar","escapeChar","eol","m","element","list","indexOf","type","pushToken","realToken","aToken","tok","col","ind","typ","column","indent","indentation","fakeToken","depth","len","tokenStack","dep","maybe_drop_pre","maybe_drop_post","s","last","pop","push","slice","d","g","i","e","r","E","stack","tt","tokens","ss","concat","indenter","textAfter","cx","t","wordAfter","wordafter","currT","prevT","unit","getToken","postcommaToken","defaultToken","truthy","str","index","objs","getTokenIndex","stop","oper","propname","propvals","x","erlang","name","startState","languageData","commentTokens","line"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@codemirror/legacy-modes/mode/erlang.js"],"sourcesContent":["/////////////////////////////////////////////////////////////////////////////\n// constants\n\nvar typeWords = [\n  \"-type\", \"-spec\", \"-export_type\", \"-opaque\"];\n\nvar keywordWords = [\n  \"after\",\"begin\",\"catch\",\"case\",\"cond\",\"end\",\"fun\",\"if\",\n  \"let\",\"of\",\"query\",\"receive\",\"try\",\"when\"];\n\nvar separatorRE    = /[\\->,;]/;\nvar separatorWords = [\n  \"->\",\";\",\",\"];\n\nvar operatorAtomWords = [\n  \"and\",\"andalso\",\"band\",\"bnot\",\"bor\",\"bsl\",\"bsr\",\"bxor\",\n  \"div\",\"not\",\"or\",\"orelse\",\"rem\",\"xor\"];\n\nvar operatorSymbolRE    = /[\\+\\-\\*\\/<>=\\|:!]/;\nvar operatorSymbolWords = [\n  \"=\",\"+\",\"-\",\"*\",\"/\",\">\",\">=\",\"<\",\"=<\",\"=:=\",\"==\",\"=/=\",\"/=\",\"||\",\"<-\",\"!\"];\n\nvar openParenRE    = /[<\\(\\[\\{]/;\nvar openParenWords = [\n  \"<<\",\"(\",\"[\",\"{\"];\n\nvar closeParenRE    = /[>\\)\\]\\}]/;\nvar closeParenWords = [\n  \"}\",\"]\",\")\",\">>\"];\n\nvar guardWords = [\n  \"is_atom\",\"is_binary\",\"is_bitstring\",\"is_boolean\",\"is_float\",\n  \"is_function\",\"is_integer\",\"is_list\",\"is_number\",\"is_pid\",\n  \"is_port\",\"is_record\",\"is_reference\",\"is_tuple\",\n  \"atom\",\"binary\",\"bitstring\",\"boolean\",\"function\",\"integer\",\"list\",\n  \"number\",\"pid\",\"port\",\"record\",\"reference\",\"tuple\"];\n\nvar bifWords = [\n  \"abs\",\"adler32\",\"adler32_combine\",\"alive\",\"apply\",\"atom_to_binary\",\n  \"atom_to_list\",\"binary_to_atom\",\"binary_to_existing_atom\",\n  \"binary_to_list\",\"binary_to_term\",\"bit_size\",\"bitstring_to_list\",\n  \"byte_size\",\"check_process_code\",\"contact_binary\",\"crc32\",\n  \"crc32_combine\",\"date\",\"decode_packet\",\"delete_module\",\n  \"disconnect_node\",\"element\",\"erase\",\"exit\",\"float\",\"float_to_list\",\n  \"garbage_collect\",\"get\",\"get_keys\",\"group_leader\",\"halt\",\"hd\",\n  \"integer_to_list\",\"internal_bif\",\"iolist_size\",\"iolist_to_binary\",\n  \"is_alive\",\"is_atom\",\"is_binary\",\"is_bitstring\",\"is_boolean\",\n  \"is_float\",\"is_function\",\"is_integer\",\"is_list\",\"is_number\",\"is_pid\",\n  \"is_port\",\"is_process_alive\",\"is_record\",\"is_reference\",\"is_tuple\",\n  \"length\",\"link\",\"list_to_atom\",\"list_to_binary\",\"list_to_bitstring\",\n  \"list_to_existing_atom\",\"list_to_float\",\"list_to_integer\",\n  \"list_to_pid\",\"list_to_tuple\",\"load_module\",\"make_ref\",\"module_loaded\",\n  \"monitor_node\",\"node\",\"node_link\",\"node_unlink\",\"nodes\",\"notalive\",\n  \"now\",\"open_port\",\"pid_to_list\",\"port_close\",\"port_command\",\n  \"port_connect\",\"port_control\",\"pre_loaded\",\"process_flag\",\n  \"process_info\",\"processes\",\"purge_module\",\"put\",\"register\",\n  \"registered\",\"round\",\"self\",\"setelement\",\"size\",\"spawn\",\"spawn_link\",\n  \"spawn_monitor\",\"spawn_opt\",\"split_binary\",\"statistics\",\n  \"term_to_binary\",\"time\",\"throw\",\"tl\",\"trunc\",\"tuple_size\",\n  \"tuple_to_list\",\"unlink\",\"unregister\",\"whereis\"];\n\n// upper case: [A-Z] [Ø-Þ] [À-Ö]\n// lower case: [a-z] [ß-ö] [ø-ÿ]\nvar anumRE       = /[\\w@Ø-ÞÀ-Öß-öø-ÿ]/;\nvar escapesRE    =\n    /[0-7]{1,3}|[bdefnrstv\\\\\"']|\\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/;\n\n/////////////////////////////////////////////////////////////////////////////\n// tokenizer\n\nfunction tokenizer(stream,state) {\n  // in multi-line string\n  if (state.in_string) {\n    state.in_string = (!doubleQuote(stream));\n    return rval(state,stream,\"string\");\n  }\n\n  // in multi-line atom\n  if (state.in_atom) {\n    state.in_atom = (!singleQuote(stream));\n    return rval(state,stream,\"atom\");\n  }\n\n  // whitespace\n  if (stream.eatSpace()) {\n    return rval(state,stream,\"whitespace\");\n  }\n\n  // attributes and type specs\n  if (!peekToken(state) &&\n      stream.match(/-\\s*[a-zß-öø-ÿ][\\wØ-ÞÀ-Öß-öø-ÿ]*/)) {\n    if (is_member(stream.current(),typeWords)) {\n      return rval(state,stream,\"type\");\n    }else{\n      return rval(state,stream,\"attribute\");\n    }\n  }\n\n  var ch = stream.next();\n\n  // comment\n  if (ch == '%') {\n    stream.skipToEnd();\n    return rval(state,stream,\"comment\");\n  }\n\n  // colon\n  if (ch == \":\") {\n    return rval(state,stream,\"colon\");\n  }\n\n  // macro\n  if (ch == '?') {\n    stream.eatSpace();\n    stream.eatWhile(anumRE);\n    return rval(state,stream,\"macro\");\n  }\n\n  // record\n  if (ch == \"#\") {\n    stream.eatSpace();\n    stream.eatWhile(anumRE);\n    return rval(state,stream,\"record\");\n  }\n\n  // dollar escape\n  if (ch == \"$\") {\n    if (stream.next() == \"\\\\\" && !stream.match(escapesRE)) {\n      return rval(state,stream,\"error\");\n    }\n    return rval(state,stream,\"number\");\n  }\n\n  // dot\n  if (ch == \".\") {\n    return rval(state,stream,\"dot\");\n  }\n\n  // quoted atom\n  if (ch == '\\'') {\n    if (!(state.in_atom = (!singleQuote(stream)))) {\n      if (stream.match(/\\s*\\/\\s*[0-9]/,false)) {\n        stream.match(/\\s*\\/\\s*[0-9]/,true);\n        return rval(state,stream,\"fun\");      // 'f'/0 style fun\n      }\n      if (stream.match(/\\s*\\(/,false) || stream.match(/\\s*:/,false)) {\n        return rval(state,stream,\"function\");\n      }\n    }\n    return rval(state,stream,\"atom\");\n  }\n\n  // string\n  if (ch == '\"') {\n    state.in_string = (!doubleQuote(stream));\n    return rval(state,stream,\"string\");\n  }\n\n  // variable\n  if (/[A-Z_Ø-ÞÀ-Ö]/.test(ch)) {\n    stream.eatWhile(anumRE);\n    return rval(state,stream,\"variable\");\n  }\n\n  // atom/keyword/BIF/function\n  if (/[a-z_ß-öø-ÿ]/.test(ch)) {\n    stream.eatWhile(anumRE);\n\n    if (stream.match(/\\s*\\/\\s*[0-9]/,false)) {\n      stream.match(/\\s*\\/\\s*[0-9]/,true);\n      return rval(state,stream,\"fun\");      // f/0 style fun\n    }\n\n    var w = stream.current();\n\n    if (is_member(w,keywordWords)) {\n      return rval(state,stream,\"keyword\");\n    }else if (is_member(w,operatorAtomWords)) {\n      return rval(state,stream,\"operator\");\n    }else if (stream.match(/\\s*\\(/,false)) {\n      // 'put' and 'erlang:put' are bifs, 'foo:put' is not\n      if (is_member(w,bifWords) &&\n          ((peekToken(state).token != \":\") ||\n           (peekToken(state,2).token == \"erlang\"))) {\n        return rval(state,stream,\"builtin\");\n      }else if (is_member(w,guardWords)) {\n        return rval(state,stream,\"guard\");\n      }else{\n        return rval(state,stream,\"function\");\n      }\n    }else if (lookahead(stream) == \":\") {\n      if (w == \"erlang\") {\n        return rval(state,stream,\"builtin\");\n      } else {\n        return rval(state,stream,\"function\");\n      }\n    }else if (is_member(w,[\"true\",\"false\"])) {\n      return rval(state,stream,\"boolean\");\n    }else{\n      return rval(state,stream,\"atom\");\n    }\n  }\n\n  // number\n  var digitRE      = /[0-9]/;\n  var radixRE      = /[0-9a-zA-Z]/;         // 36#zZ style int\n  if (digitRE.test(ch)) {\n    stream.eatWhile(digitRE);\n    if (stream.eat('#')) {                // 36#aZ  style integer\n      if (!stream.eatWhile(radixRE)) {\n        stream.backUp(1);                 //\"36#\" - syntax error\n      }\n    } else if (stream.eat('.')) {       // float\n      if (!stream.eatWhile(digitRE)) {\n        stream.backUp(1);        // \"3.\" - probably end of function\n      } else {\n        if (stream.eat(/[eE]/)) {        // float with exponent\n          if (stream.eat(/[-+]/)) {\n            if (!stream.eatWhile(digitRE)) {\n              stream.backUp(2);            // \"2e-\" - syntax error\n            }\n          } else {\n            if (!stream.eatWhile(digitRE)) {\n              stream.backUp(1);            // \"2e\" - syntax error\n            }\n          }\n        }\n      }\n    }\n    return rval(state,stream,\"number\");   // normal integer\n  }\n\n  // open parens\n  if (nongreedy(stream,openParenRE,openParenWords)) {\n    return rval(state,stream,\"open_paren\");\n  }\n\n  // close parens\n  if (nongreedy(stream,closeParenRE,closeParenWords)) {\n    return rval(state,stream,\"close_paren\");\n  }\n\n  // separators\n  if (greedy(stream,separatorRE,separatorWords)) {\n    return rval(state,stream,\"separator\");\n  }\n\n  // operators\n  if (greedy(stream,operatorSymbolRE,operatorSymbolWords)) {\n    return rval(state,stream,\"operator\");\n  }\n\n  return rval(state,stream,null);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// utilities\nfunction nongreedy(stream,re,words) {\n  if (stream.current().length == 1 && re.test(stream.current())) {\n    stream.backUp(1);\n    while (re.test(stream.peek())) {\n      stream.next();\n      if (is_member(stream.current(),words)) {\n        return true;\n      }\n    }\n    stream.backUp(stream.current().length-1);\n  }\n  return false;\n}\n\nfunction greedy(stream,re,words) {\n  if (stream.current().length == 1 && re.test(stream.current())) {\n    while (re.test(stream.peek())) {\n      stream.next();\n    }\n    while (0 < stream.current().length) {\n      if (is_member(stream.current(),words)) {\n        return true;\n      }else{\n        stream.backUp(1);\n      }\n    }\n    stream.next();\n  }\n  return false;\n}\n\nfunction doubleQuote(stream) {\n  return quote(stream, '\"', '\\\\');\n}\n\nfunction singleQuote(stream) {\n  return quote(stream,'\\'','\\\\');\n}\n\nfunction quote(stream,quoteChar,escapeChar) {\n  while (!stream.eol()) {\n    var ch = stream.next();\n    if (ch == quoteChar) {\n      return true;\n    }else if (ch == escapeChar) {\n      stream.next();\n    }\n  }\n  return false;\n}\n\nfunction lookahead(stream) {\n  var m = stream.match(/^\\s*([^\\s%])/, false)\n  return m ? m[1] : \"\";\n}\n\nfunction is_member(element,list) {\n  return (-1 < list.indexOf(element));\n}\n\nfunction rval(state,stream,type) {\n\n  // parse stack\n  pushToken(state,realToken(type,stream));\n\n  // map erlang token type to CodeMirror style class\n  //     erlang             -> CodeMirror tag\n  switch (type) {\n  case \"atom\":        return \"atom\";\n  case \"attribute\":   return \"attribute\";\n  case \"boolean\":     return \"atom\";\n  case \"builtin\":     return \"builtin\";\n  case \"close_paren\": return null;\n  case \"colon\":       return null;\n  case \"comment\":     return \"comment\";\n  case \"dot\":         return null;\n  case \"error\":       return \"error\";\n  case \"fun\":         return \"meta\";\n  case \"function\":    return \"tag\";\n  case \"guard\":       return \"property\";\n  case \"keyword\":     return \"keyword\";\n  case \"macro\":       return \"macroName\";\n  case \"number\":      return \"number\";\n  case \"open_paren\":  return null;\n  case \"operator\":    return \"operator\";\n  case \"record\":      return \"bracket\";\n  case \"separator\":   return null;\n  case \"string\":      return \"string\";\n  case \"type\":        return \"def\";\n  case \"variable\":    return \"variable\";\n  default:            return null;\n  }\n}\n\nfunction aToken(tok,col,ind,typ) {\n  return {token:  tok,\n          column: col,\n          indent: ind,\n          type:   typ};\n}\n\nfunction realToken(type,stream) {\n  return aToken(stream.current(),\n                stream.column(),\n                stream.indentation(),\n                type);\n}\n\nfunction fakeToken(type) {\n  return aToken(type,0,0,type);\n}\n\nfunction peekToken(state,depth) {\n  var len = state.tokenStack.length;\n  var dep = (depth ? depth : 1);\n\n  if (len < dep) {\n    return false;\n  }else{\n    return state.tokenStack[len-dep];\n  }\n}\n\nfunction pushToken(state,token) {\n\n  if (!(token.type == \"comment\" || token.type == \"whitespace\")) {\n    state.tokenStack = maybe_drop_pre(state.tokenStack,token);\n    state.tokenStack = maybe_drop_post(state.tokenStack);\n  }\n}\n\nfunction maybe_drop_pre(s,token) {\n  var last = s.length-1;\n\n  if (0 < last && s[last].type === \"record\" && token.type === \"dot\") {\n    s.pop();\n  }else if (0 < last && s[last].type === \"group\") {\n    s.pop();\n    s.push(token);\n  }else{\n    s.push(token);\n  }\n  return s;\n}\n\nfunction maybe_drop_post(s) {\n  if (!s.length) return s\n  var last = s.length-1;\n\n  if (s[last].type === \"dot\") {\n    return [];\n  }\n  if (last > 1 && s[last].type === \"fun\" && s[last-1].token === \"fun\") {\n    return s.slice(0,last-1);\n  }\n  switch (s[last].token) {\n  case \"}\":    return d(s,{g:[\"{\"]});\n  case \"]\":    return d(s,{i:[\"[\"]});\n  case \")\":    return d(s,{i:[\"(\"]});\n  case \">>\":   return d(s,{i:[\"<<\"]});\n  case \"end\":  return d(s,{i:[\"begin\",\"case\",\"fun\",\"if\",\"receive\",\"try\"]});\n  case \",\":    return d(s,{e:[\"begin\",\"try\",\"when\",\"->\",\n                              \",\",\"(\",\"[\",\"{\",\"<<\"]});\n  case \"->\":   return d(s,{r:[\"when\"],\n                           m:[\"try\",\"if\",\"case\",\"receive\"]});\n  case \";\":    return d(s,{E:[\"case\",\"fun\",\"if\",\"receive\",\"try\",\"when\"]});\n  case \"catch\":return d(s,{e:[\"try\"]});\n  case \"of\":   return d(s,{e:[\"case\"]});\n  case \"after\":return d(s,{e:[\"receive\",\"try\"]});\n  default:     return s;\n  }\n}\n\nfunction d(stack,tt) {\n  // stack is a stack of Token objects.\n  // tt is an object; {type:tokens}\n  // type is a char, tokens is a list of token strings.\n  // The function returns (possibly truncated) stack.\n  // It will descend the stack, looking for a Token such that Token.token\n  //  is a member of tokens. If it does not find that, it will normally (but\n  //  see \"E\" below) return stack. If it does find a match, it will remove\n  //  all the Tokens between the top and the matched Token.\n  // If type is \"m\", that is all it does.\n  // If type is \"i\", it will also remove the matched Token and the top Token.\n  // If type is \"g\", like \"i\", but add a fake \"group\" token at the top.\n  // If type is \"r\", it will remove the matched Token, but not the top Token.\n  // If type is \"e\", it will keep the matched Token but not the top Token.\n  // If type is \"E\", it behaves as for type \"e\", except if there is no match,\n  //  in which case it will return an empty stack.\n\n  for (var type in tt) {\n    var len = stack.length-1;\n    var tokens = tt[type];\n    for (var i = len-1; -1 < i ; i--) {\n      if (is_member(stack[i].token,tokens)) {\n        var ss = stack.slice(0,i);\n        switch (type) {\n        case \"m\": return ss.concat(stack[i]).concat(stack[len]);\n        case \"r\": return ss.concat(stack[len]);\n        case \"i\": return ss;\n        case \"g\": return ss.concat(fakeToken(\"group\"));\n        case \"E\": return ss.concat(stack[i]);\n        case \"e\": return ss.concat(stack[i]);\n        }\n      }\n    }\n  }\n  return (type == \"E\" ? [] : stack);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// indenter\n\nfunction indenter(state, textAfter, cx) {\n  var t;\n  var wordAfter = wordafter(textAfter);\n  var currT = peekToken(state,1);\n  var prevT = peekToken(state,2);\n\n  if (state.in_string || state.in_atom) {\n    return null;\n  }else if (!prevT) {\n    return 0;\n  }else if (currT.token == \"when\") {\n    return currT.column + cx.unit;\n  }else if (wordAfter === \"when\" && prevT.type === \"function\") {\n    return prevT.indent+cx.unit;\n  }else if (wordAfter === \"(\" && currT.token === \"fun\") {\n    return  currT.column+3;\n  }else if (wordAfter === \"catch\" && (t = getToken(state,[\"try\"]))) {\n    return t.column;\n  }else if (is_member(wordAfter,[\"end\",\"after\",\"of\"])) {\n    t = getToken(state,[\"begin\",\"case\",\"fun\",\"if\",\"receive\",\"try\"]);\n    return t ? t.column : null;\n  }else if (is_member(wordAfter,closeParenWords)) {\n    t = getToken(state,openParenWords);\n    return t ? t.column : null;\n  }else if (is_member(currT.token,[\",\",\"|\",\"||\"]) ||\n            is_member(wordAfter,[\",\",\"|\",\"||\"])) {\n    t = postcommaToken(state);\n    return t ? t.column+t.token.length : cx.unit;\n  }else if (currT.token == \"->\") {\n    if (is_member(prevT.token, [\"receive\",\"case\",\"if\",\"try\"])) {\n      return prevT.column+cx.unit+cx.unit;\n    }else{\n      return prevT.column+cx.unit;\n    }\n  }else if (is_member(currT.token,openParenWords)) {\n    return currT.column+currT.token.length;\n  }else{\n    t = defaultToken(state);\n    return truthy(t) ? t.column+cx.unit : 0;\n  }\n}\n\nfunction wordafter(str) {\n  var m = str.match(/,|[a-z]+|\\}|\\]|\\)|>>|\\|+|\\(/);\n\n  return truthy(m) && (m.index === 0) ? m[0] : \"\";\n}\n\nfunction postcommaToken(state) {\n  var objs = state.tokenStack.slice(0,-1);\n  var i = getTokenIndex(objs,\"type\",[\"open_paren\"]);\n\n  return truthy(objs[i]) ? objs[i] : false;\n}\n\nfunction defaultToken(state) {\n  var objs = state.tokenStack;\n  var stop = getTokenIndex(objs,\"type\",[\"open_paren\",\"separator\",\"keyword\"]);\n  var oper = getTokenIndex(objs,\"type\",[\"operator\"]);\n\n  if (truthy(stop) && truthy(oper) && stop < oper) {\n    return objs[stop+1];\n  } else if (truthy(stop)) {\n    return objs[stop];\n  } else {\n    return false;\n  }\n}\n\nfunction getToken(state,tokens) {\n  var objs = state.tokenStack;\n  var i = getTokenIndex(objs,\"token\",tokens);\n\n  return truthy(objs[i]) ? objs[i] : false;\n}\n\nfunction getTokenIndex(objs,propname,propvals) {\n\n  for (var i = objs.length-1; -1 < i ; i--) {\n    if (is_member(objs[i][propname],propvals)) {\n      return i;\n    }\n  }\n  return false;\n}\n\nfunction truthy(x) {\n  return (x !== false) && (x != null);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// this object defines the mode\n\nexport const erlang = {\n  name: \"erlang\",\n  startState() {\n    return {tokenStack: [],\n            in_string:  false,\n            in_atom:    false};\n  },\n\n  token: tokenizer,\n\n  indent: indenter,\n\n  languageData: {\n    commentTokens: {line: \"%\"}\n  }\n};\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}