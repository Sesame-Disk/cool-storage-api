{"ast":null,"code":"function wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\n;\nvar builtinArray = [\"Clamp\", \"Constructor\", \"EnforceRange\", \"Exposed\", \"ImplicitThis\", \"Global\", \"PrimaryGlobal\", \"LegacyArrayClass\", \"LegacyUnenumerableNamedProperties\", \"LenientThis\", \"NamedConstructor\", \"NewObject\", \"NoInterfaceObject\", \"OverrideBuiltins\", \"PutForwards\", \"Replaceable\", \"SameObject\", \"TreatNonObjectAsNull\", \"TreatNullAs\", \"EmptyString\", \"Unforgeable\", \"Unscopeable\"];\nvar builtins = wordRegexp(builtinArray);\nvar typeArray = [\"unsigned\", \"short\", \"long\",\n// UnsignedIntegerType\n\"unrestricted\", \"float\", \"double\",\n// UnrestrictedFloatType\n\"boolean\", \"byte\", \"octet\",\n// Rest of PrimitiveType\n\"Promise\",\n// PromiseType\n\"ArrayBuffer\", \"DataView\", \"Int8Array\", \"Int16Array\", \"Int32Array\", \"Uint8Array\", \"Uint16Array\", \"Uint32Array\", \"Uint8ClampedArray\", \"Float32Array\", \"Float64Array\",\n// BufferRelatedType\n\"ByteString\", \"DOMString\", \"USVString\", \"sequence\", \"object\", \"RegExp\", \"Error\", \"DOMException\", \"FrozenArray\",\n// Rest of NonAnyType\n\"any\",\n// Rest of SingleType\n\"void\" // Rest of ReturnType\n];\n\nvar types = wordRegexp(typeArray);\nvar keywordArray = [\"attribute\", \"callback\", \"const\", \"deleter\", \"dictionary\", \"enum\", \"getter\", \"implements\", \"inherit\", \"interface\", \"iterable\", \"legacycaller\", \"maplike\", \"partial\", \"required\", \"serializer\", \"setlike\", \"setter\", \"static\", \"stringifier\", \"typedef\",\n// ArgumentNameKeyword except\n// \"unrestricted\"\n\"optional\", \"readonly\", \"or\"];\nvar keywords = wordRegexp(keywordArray);\nvar atomArray = [\"true\", \"false\",\n// BooleanLiteral\n\"Infinity\", \"NaN\",\n// FloatLiteral\n\"null\" // Rest of ConstValue\n];\n\nvar atoms = wordRegexp(atomArray);\nvar startDefArray = [\"callback\", \"dictionary\", \"enum\", \"interface\"];\nvar startDefs = wordRegexp(startDefArray);\nvar endDefArray = [\"typedef\"];\nvar endDefs = wordRegexp(endDefArray);\nvar singleOperators = /^[:<=>?]/;\nvar integers = /^-?([1-9][0-9]*|0[Xx][0-9A-Fa-f]+|0[0-7]*)/;\nvar floats = /^-?(([0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)/;\nvar identifiers = /^_?[A-Za-z][0-9A-Z_a-z-]*/;\nvar identifiersEnd = /^_?[A-Za-z][0-9A-Z_a-z-]*(?=\\s*;)/;\nvar strings = /^\"[^\"]*\"/;\nvar multilineComments = /^\\/\\*.*?\\*\\//;\nvar multilineCommentsStart = /^\\/\\*.*/;\nvar multilineCommentsEnd = /^.*?\\*\\//;\nfunction readToken(stream, state) {\n  // whitespace\n  if (stream.eatSpace()) return null;\n\n  // comment\n  if (state.inComment) {\n    if (stream.match(multilineCommentsEnd)) {\n      state.inComment = false;\n      return \"comment\";\n    }\n    stream.skipToEnd();\n    return \"comment\";\n  }\n  if (stream.match(\"//\")) {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n  if (stream.match(multilineComments)) return \"comment\";\n  if (stream.match(multilineCommentsStart)) {\n    state.inComment = true;\n    return \"comment\";\n  }\n\n  // integer and float\n  if (stream.match(/^-?[0-9\\.]/, false)) {\n    if (stream.match(integers) || stream.match(floats)) return \"number\";\n  }\n\n  // string\n  if (stream.match(strings)) return \"string\";\n\n  // identifier\n  if (state.startDef && stream.match(identifiers)) return \"def\";\n  if (state.endDef && stream.match(identifiersEnd)) {\n    state.endDef = false;\n    return \"def\";\n  }\n  if (stream.match(keywords)) return \"keyword\";\n  if (stream.match(types)) {\n    var lastToken = state.lastToken;\n    var nextToken = (stream.match(/^\\s*(.+?)\\b/, false) || [])[1];\n    if (lastToken === \":\" || lastToken === \"implements\" || nextToken === \"implements\" || nextToken === \"=\") {\n      // Used as identifier\n      return \"builtin\";\n    } else {\n      // Used as type\n      return \"type\";\n    }\n  }\n  if (stream.match(builtins)) return \"builtin\";\n  if (stream.match(atoms)) return \"atom\";\n  if (stream.match(identifiers)) return \"variable\";\n\n  // other\n  if (stream.match(singleOperators)) return \"operator\";\n\n  // unrecognized\n  stream.next();\n  return null;\n}\n;\nexport var webIDL = {\n  name: \"webidl\",\n  startState: function startState() {\n    return {\n      // Is in multiline comment\n      inComment: false,\n      // Last non-whitespace, matched token\n      lastToken: \"\",\n      // Next token is a definition\n      startDef: false,\n      // Last token of the statement is a definition\n      endDef: false\n    };\n  },\n  token: function token(stream, state) {\n    var style = readToken(stream, state);\n    if (style) {\n      var cur = stream.current();\n      state.lastToken = cur;\n      if (style === \"keyword\") {\n        state.startDef = startDefs.test(cur);\n        state.endDef = state.endDef || endDefs.test(cur);\n      } else {\n        state.startDef = false;\n      }\n    }\n    return style;\n  },\n  languageData: {\n    autocomplete: builtinArray.concat(typeArray).concat(keywordArray).concat(atomArray)\n  }\n};","map":{"version":3,"names":["wordRegexp","words","RegExp","join","builtinArray","builtins","typeArray","types","keywordArray","keywords","atomArray","atoms","startDefArray","startDefs","endDefArray","endDefs","singleOperators","integers","floats","identifiers","identifiersEnd","strings","multilineComments","multilineCommentsStart","multilineCommentsEnd","readToken","stream","state","eatSpace","inComment","match","skipToEnd","startDef","endDef","lastToken","nextToken","next","webIDL","name","startState","token","style","cur","current","test","languageData","autocomplete","concat"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@codemirror/legacy-modes/mode/webidl.js"],"sourcesContent":["function wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n};\n\nvar builtinArray = [\n  \"Clamp\",\n  \"Constructor\",\n  \"EnforceRange\",\n  \"Exposed\",\n  \"ImplicitThis\",\n  \"Global\", \"PrimaryGlobal\",\n  \"LegacyArrayClass\",\n  \"LegacyUnenumerableNamedProperties\",\n  \"LenientThis\",\n  \"NamedConstructor\",\n  \"NewObject\",\n  \"NoInterfaceObject\",\n  \"OverrideBuiltins\",\n  \"PutForwards\",\n  \"Replaceable\",\n  \"SameObject\",\n  \"TreatNonObjectAsNull\",\n  \"TreatNullAs\",\n    \"EmptyString\",\n  \"Unforgeable\",\n  \"Unscopeable\"\n];\nvar builtins = wordRegexp(builtinArray);\n\nvar typeArray = [\n  \"unsigned\", \"short\", \"long\",                  // UnsignedIntegerType\n  \"unrestricted\", \"float\", \"double\",            // UnrestrictedFloatType\n  \"boolean\", \"byte\", \"octet\",                   // Rest of PrimitiveType\n  \"Promise\",                                    // PromiseType\n  \"ArrayBuffer\", \"DataView\", \"Int8Array\", \"Int16Array\", \"Int32Array\",\n  \"Uint8Array\", \"Uint16Array\", \"Uint32Array\", \"Uint8ClampedArray\",\n  \"Float32Array\", \"Float64Array\",               // BufferRelatedType\n  \"ByteString\", \"DOMString\", \"USVString\", \"sequence\", \"object\", \"RegExp\",\n  \"Error\", \"DOMException\", \"FrozenArray\",       // Rest of NonAnyType\n  \"any\",                                        // Rest of SingleType\n  \"void\"                                        // Rest of ReturnType\n];\nvar types = wordRegexp(typeArray);\n\nvar keywordArray = [\n  \"attribute\", \"callback\", \"const\", \"deleter\", \"dictionary\", \"enum\", \"getter\",\n  \"implements\", \"inherit\", \"interface\", \"iterable\", \"legacycaller\", \"maplike\",\n  \"partial\", \"required\", \"serializer\", \"setlike\", \"setter\", \"static\",\n  \"stringifier\", \"typedef\",                     // ArgumentNameKeyword except\n                                                // \"unrestricted\"\n  \"optional\", \"readonly\", \"or\"\n];\nvar keywords = wordRegexp(keywordArray);\n\nvar atomArray = [\n  \"true\", \"false\",                              // BooleanLiteral\n  \"Infinity\", \"NaN\",                            // FloatLiteral\n  \"null\"                                        // Rest of ConstValue\n];\nvar atoms = wordRegexp(atomArray);\n\nvar startDefArray = [\"callback\", \"dictionary\", \"enum\", \"interface\"];\nvar startDefs = wordRegexp(startDefArray);\n\nvar endDefArray = [\"typedef\"];\nvar endDefs = wordRegexp(endDefArray);\n\nvar singleOperators = /^[:<=>?]/;\nvar integers = /^-?([1-9][0-9]*|0[Xx][0-9A-Fa-f]+|0[0-7]*)/;\nvar floats = /^-?(([0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)/;\nvar identifiers = /^_?[A-Za-z][0-9A-Z_a-z-]*/;\nvar identifiersEnd = /^_?[A-Za-z][0-9A-Z_a-z-]*(?=\\s*;)/;\nvar strings = /^\"[^\"]*\"/;\nvar multilineComments = /^\\/\\*.*?\\*\\//;\nvar multilineCommentsStart = /^\\/\\*.*/;\nvar multilineCommentsEnd = /^.*?\\*\\//;\n\nfunction readToken(stream, state) {\n  // whitespace\n  if (stream.eatSpace()) return null;\n\n  // comment\n  if (state.inComment) {\n    if (stream.match(multilineCommentsEnd)) {\n      state.inComment = false;\n      return \"comment\";\n    }\n    stream.skipToEnd();\n    return \"comment\";\n  }\n  if (stream.match(\"//\")) {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n  if (stream.match(multilineComments)) return \"comment\";\n  if (stream.match(multilineCommentsStart)) {\n    state.inComment = true;\n    return \"comment\";\n  }\n\n  // integer and float\n  if (stream.match(/^-?[0-9\\.]/, false)) {\n    if (stream.match(integers) || stream.match(floats)) return \"number\";\n  }\n\n  // string\n  if (stream.match(strings)) return \"string\";\n\n  // identifier\n  if (state.startDef && stream.match(identifiers)) return \"def\";\n\n  if (state.endDef && stream.match(identifiersEnd)) {\n    state.endDef = false;\n    return \"def\";\n  }\n\n  if (stream.match(keywords)) return \"keyword\";\n\n  if (stream.match(types)) {\n    var lastToken = state.lastToken;\n    var nextToken = (stream.match(/^\\s*(.+?)\\b/, false) || [])[1];\n\n    if (lastToken === \":\" || lastToken === \"implements\" ||\n        nextToken === \"implements\" || nextToken === \"=\") {\n      // Used as identifier\n      return \"builtin\";\n    } else {\n      // Used as type\n      return \"type\";\n    }\n  }\n\n  if (stream.match(builtins)) return \"builtin\";\n  if (stream.match(atoms)) return \"atom\";\n  if (stream.match(identifiers)) return \"variable\";\n\n  // other\n  if (stream.match(singleOperators)) return \"operator\";\n\n  // unrecognized\n  stream.next();\n  return null;\n};\n\nexport const webIDL = {\n  name: \"webidl\",\n  startState: function() {\n    return {\n      // Is in multiline comment\n      inComment: false,\n      // Last non-whitespace, matched token\n      lastToken: \"\",\n      // Next token is a definition\n      startDef: false,\n      // Last token of the statement is a definition\n      endDef: false\n    };\n  },\n  token: function(stream, state) {\n    var style = readToken(stream, state);\n\n    if (style) {\n      var cur = stream.current();\n      state.lastToken = cur;\n      if (style === \"keyword\") {\n        state.startDef = startDefs.test(cur);\n        state.endDef = state.endDef || endDefs.test(cur);\n      } else {\n        state.startDef = false;\n      }\n    }\n\n    return style;\n  },\n\n  languageData: {\n    autocomplete: builtinArray.concat(typeArray).concat(keywordArray).concat(atomArray)\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}