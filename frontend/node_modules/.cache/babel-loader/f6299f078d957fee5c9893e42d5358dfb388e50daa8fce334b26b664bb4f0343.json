{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _slate = require(\"slate\");\nvar _isHotkey = _interopRequireDefault(require(\"is-hotkey\"));\nvar _core = require(\"../../core\");\nvar _helper = require(\"./helper\");\nvar _keyboard = require(\"../../constants/keyboard\");\nvar _common = require(\"../../../utils/common\");\nvar _constants = require(\"../../constants\");\nvar _elementTypes = require(\"../../constants/element-types\");\nvar isSelectionAtLineEnd = function isSelectionAtLineEnd(editor, path) {\n  var selection = editor.selection;\n  if (!selection) return false;\n  var isAtLineEnd = _slate.Editor.isEnd(editor, selection.anchor, path) || _slate.Editor.isEnd(editor, selection.focus, path);\n  return isAtLineEnd;\n};\nvar isSelectionAtLineStart = function isSelectionAtLineStart(editor, path) {\n  var selection = editor.selection;\n  if (!selection) return false;\n  var isAtLineEnd = _slate.Editor.isStart(editor, selection.anchor, path) || _slate.Editor.isStart(editor, selection.focus, path);\n  return isAtLineEnd;\n};\nvar withHeader = function withHeader(editor) {\n  var insertBreak = editor.insertBreak,\n    insertFragment = editor.insertFragment,\n    insertText = editor.insertText,\n    deleteBackward = editor.deleteBackward,\n    onHotKeyDown = editor.onHotKeyDown;\n  var newEditor = editor;\n\n  // Rewrite insertBreak - insert paragraph when carriage return at the end of header\n  newEditor.insertBreak = function () {\n    var _slate$Editor$nodes = _slate.Editor.nodes(newEditor, {\n        match: function match(n) {\n          if (!_slate.Element.isElement(n)) return false;\n          if (n.type.startsWith(_constants.ELementTypes.HEADER)) return true;\n          return false;\n        },\n        // Matches nodes whose node.type starts with header\n        universal: true\n      }),\n      _slate$Editor$nodes2 = _slicedToArray(_slate$Editor$nodes, 1),\n      match = _slate$Editor$nodes2[0];\n    if (!match) {\n      insertBreak();\n      return;\n    }\n    var isAtLineEnd = isSelectionAtLineEnd(editor, match[1]);\n    // If an empty p is inserted at the end of the line, otherwise wrap normally\n    if (isAtLineEnd) {\n      var p = (0, _core.generateEmptyElement)(_constants.ELementTypes.PARAGRAPH);\n      _slate.Transforms.insertNodes(newEditor, p, {\n        mode: 'highest'\n      });\n    } else {\n      insertBreak();\n    }\n  };\n  newEditor.deleteBackward = function (unit) {\n    var selection = editor.selection;\n    if (!selection) return deleteBackward(unit);\n    var _slate$Editor$nodes3 = _slate.Editor.nodes(newEditor, {\n        match: function match(n) {\n          if (!_slate.Element.isElement(n)) return false;\n          if (n.type && n.type.startsWith(_constants.ELementTypes.HEADER)) return true;\n          return false;\n        },\n        // Matches nodes whose node.type starts with header\n        universal: true\n      }),\n      _slate$Editor$nodes4 = _slicedToArray(_slate$Editor$nodes3, 1),\n      headerEntry = _slate$Editor$nodes4[0];\n    if (!headerEntry) {\n      deleteBackward(unit);\n      return false;\n    }\n    var isAtLineStart = isSelectionAtLineStart(editor, headerEntry[1]);\n    if (isAtLineStart) {\n      (0, _helper.setHeaderType)(editor, _constants.ELementTypes.PARAGRAPH);\n      return true;\n    }\n    return deleteBackward(unit);\n  };\n  newEditor.insertFragment = function (fragment) {\n    var headerEntry = (0, _core.getSelectedNodeEntryByTypes)(editor, _constants.HEADERS);\n    if (!headerEntry) return insertFragment(fragment);\n    var firstChild = fragment[0];\n    if (fragment.length === 1) {\n      // is single list item\n      if (_constants.LIST_TYPE_ARRAY.includes(firstChild.type)) {\n        if (firstChild.children.length === 1) {\n          var text = _slate.Node.string(fragment[0]);\n          insertText(text);\n          return;\n        }\n\n        // insert list at current path\n        if ((0, _core.isSelectionAtBlockStart)(editor)) {\n          _slate.Transforms.insertNodes(newEditor, fragment);\n          return;\n        }\n        var nextPath = _slate.Path.next(headerEntry[1]);\n        _slate.Transforms.insertNodes(newEditor, fragment, {\n          at: nextPath\n        });\n        return;\n      }\n      if (firstChild.type === _elementTypes.TABLE) {\n        var _nextPath = _slate.Path.next(headerEntry[1]);\n        _slate.Transforms.insertNodes(newEditor, fragment, {\n          at: _nextPath\n        });\n        return;\n      }\n    }\n    return insertFragment(fragment);\n  };\n  newEditor.onHotKeyDown = function (event) {\n    var HOT_KEYS = (0, _common.isMac)() ? _keyboard.MAC_HOTKEYS_EVENT_HEADER : _keyboard.WIN_HOTKEYS_EVENT_HEADER;\n    var hotEntries = Object.entries(HOT_KEYS);\n    var isHeaderEvent = false;\n    var headerType = '';\n    for (var _i = 0, _hotEntries = hotEntries; _i < _hotEntries.length; _i++) {\n      var element = _hotEntries[_i];\n      var _element = _slicedToArray(element, 2),\n        key = _element[0],\n        value = _element[1];\n      isHeaderEvent = (0, _isHotkey.default)(value, event);\n      if (isHeaderEvent) {\n        headerType = key;\n        break;\n      }\n    }\n    if (!isHeaderEvent) {\n      return onHotKeyDown && onHotKeyDown(event);\n    }\n    event.preventDefault();\n    if ((0, _helper.isMenuDisabled)(newEditor)) return true;\n    var currentHeaderType = (0, _helper.getHeaderType)(editor);\n    if (currentHeaderType === headerType) {\n      (0, _helper.setHeaderType)(newEditor, _constants.ELementTypes.PARAGRAPH);\n    } else {\n      (0, _helper.setHeaderType)(newEditor, headerType);\n    }\n    return true;\n  };\n  return newEditor;\n};\nvar _default = exports.default = withHeader;","map":{"version":3,"names":["_slicedToArray","require","default","_interopRequireDefault","Object","defineProperty","exports","value","_slate","_isHotkey","_core","_helper","_keyboard","_common","_constants","_elementTypes","isSelectionAtLineEnd","editor","path","selection","isAtLineEnd","Editor","isEnd","anchor","focus","isSelectionAtLineStart","isStart","withHeader","insertBreak","insertFragment","insertText","deleteBackward","onHotKeyDown","newEditor","_slate$Editor$nodes","nodes","match","n","Element","isElement","type","startsWith","ELementTypes","HEADER","universal","_slate$Editor$nodes2","p","generateEmptyElement","PARAGRAPH","Transforms","insertNodes","mode","unit","_slate$Editor$nodes3","_slate$Editor$nodes4","headerEntry","isAtLineStart","setHeaderType","fragment","getSelectedNodeEntryByTypes","HEADERS","firstChild","length","LIST_TYPE_ARRAY","includes","children","text","Node","string","isSelectionAtBlockStart","nextPath","Path","next","at","TABLE","event","HOT_KEYS","isMac","MAC_HOTKEYS_EVENT_HEADER","WIN_HOTKEYS_EVENT_HEADER","hotEntries","entries","isHeaderEvent","headerType","_i","_hotEntries","element","_element","key","preventDefault","isMenuDisabled","currentHeaderType","getHeaderType","_default"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/seafile-editor/dist/extension/plugins/header/plugin.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _slate = require(\"slate\");\nvar _isHotkey = _interopRequireDefault(require(\"is-hotkey\"));\nvar _core = require(\"../../core\");\nvar _helper = require(\"./helper\");\nvar _keyboard = require(\"../../constants/keyboard\");\nvar _common = require(\"../../../utils/common\");\nvar _constants = require(\"../../constants\");\nvar _elementTypes = require(\"../../constants/element-types\");\nconst isSelectionAtLineEnd = (editor, path) => {\n  const {\n    selection\n  } = editor;\n  if (!selection) return false;\n  const isAtLineEnd = _slate.Editor.isEnd(editor, selection.anchor, path) || _slate.Editor.isEnd(editor, selection.focus, path);\n  return isAtLineEnd;\n};\nconst isSelectionAtLineStart = (editor, path) => {\n  const {\n    selection\n  } = editor;\n  if (!selection) return false;\n  const isAtLineEnd = _slate.Editor.isStart(editor, selection.anchor, path) || _slate.Editor.isStart(editor, selection.focus, path);\n  return isAtLineEnd;\n};\nconst withHeader = editor => {\n  const {\n    insertBreak,\n    insertFragment,\n    insertText,\n    deleteBackward,\n    onHotKeyDown\n  } = editor;\n  const newEditor = editor;\n\n  // Rewrite insertBreak - insert paragraph when carriage return at the end of header\n  newEditor.insertBreak = () => {\n    const [match] = _slate.Editor.nodes(newEditor, {\n      match: n => {\n        if (!_slate.Element.isElement(n)) return false;\n        if (n.type.startsWith(_constants.ELementTypes.HEADER)) return true;\n        return false;\n      },\n      // Matches nodes whose node.type starts with header\n      universal: true\n    });\n    if (!match) {\n      insertBreak();\n      return;\n    }\n    const isAtLineEnd = isSelectionAtLineEnd(editor, match[1]);\n    // If an empty p is inserted at the end of the line, otherwise wrap normally\n    if (isAtLineEnd) {\n      const p = (0, _core.generateEmptyElement)(_constants.ELementTypes.PARAGRAPH);\n      _slate.Transforms.insertNodes(newEditor, p, {\n        mode: 'highest'\n      });\n    } else {\n      insertBreak();\n    }\n  };\n  newEditor.deleteBackward = unit => {\n    const {\n      selection\n    } = editor;\n    if (!selection) return deleteBackward(unit);\n    const [headerEntry] = _slate.Editor.nodes(newEditor, {\n      match: n => {\n        if (!_slate.Element.isElement(n)) return false;\n        if (n.type && n.type.startsWith(_constants.ELementTypes.HEADER)) return true;\n        return false;\n      },\n      // Matches nodes whose node.type starts with header\n      universal: true\n    });\n    if (!headerEntry) {\n      deleteBackward(unit);\n      return false;\n    }\n    const isAtLineStart = isSelectionAtLineStart(editor, headerEntry[1]);\n    if (isAtLineStart) {\n      (0, _helper.setHeaderType)(editor, _constants.ELementTypes.PARAGRAPH);\n      return true;\n    }\n    return deleteBackward(unit);\n  };\n  newEditor.insertFragment = fragment => {\n    const headerEntry = (0, _core.getSelectedNodeEntryByTypes)(editor, _constants.HEADERS);\n    if (!headerEntry) return insertFragment(fragment);\n    const firstChild = fragment[0];\n    if (fragment.length === 1) {\n      // is single list item\n      if (_constants.LIST_TYPE_ARRAY.includes(firstChild.type)) {\n        if (firstChild.children.length === 1) {\n          const text = _slate.Node.string(fragment[0]);\n          insertText(text);\n          return;\n        }\n\n        // insert list at current path\n        if ((0, _core.isSelectionAtBlockStart)(editor)) {\n          _slate.Transforms.insertNodes(newEditor, fragment);\n          return;\n        }\n        const nextPath = _slate.Path.next(headerEntry[1]);\n        _slate.Transforms.insertNodes(newEditor, fragment, {\n          at: nextPath\n        });\n        return;\n      }\n      if (firstChild.type === _elementTypes.TABLE) {\n        const nextPath = _slate.Path.next(headerEntry[1]);\n        _slate.Transforms.insertNodes(newEditor, fragment, {\n          at: nextPath\n        });\n        return;\n      }\n    }\n    return insertFragment(fragment);\n  };\n  newEditor.onHotKeyDown = event => {\n    const HOT_KEYS = (0, _common.isMac)() ? _keyboard.MAC_HOTKEYS_EVENT_HEADER : _keyboard.WIN_HOTKEYS_EVENT_HEADER;\n    const hotEntries = Object.entries(HOT_KEYS);\n    let isHeaderEvent = false;\n    let headerType = '';\n    for (const element of hotEntries) {\n      const [key, value] = element;\n      isHeaderEvent = (0, _isHotkey.default)(value, event);\n      if (isHeaderEvent) {\n        headerType = key;\n        break;\n      }\n    }\n    if (!isHeaderEvent) {\n      return onHotKeyDown && onHotKeyDown(event);\n    }\n    event.preventDefault();\n    if ((0, _helper.isMenuDisabled)(newEditor)) return true;\n    const currentHeaderType = (0, _helper.getHeaderType)(editor);\n    if (currentHeaderType === headerType) {\n      (0, _helper.setHeaderType)(newEditor, _constants.ELementTypes.PARAGRAPH);\n    } else {\n      (0, _helper.setHeaderType)(newEditor, headerType);\n    }\n    return true;\n  };\n  return newEditor;\n};\nvar _default = exports.default = withHeader;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}