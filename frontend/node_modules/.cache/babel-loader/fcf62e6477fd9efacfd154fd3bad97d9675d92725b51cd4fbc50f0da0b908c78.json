{"ast":null,"code":"import _toConsumableArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport isHotkey from 'is-hotkey';\nimport { Editor, Transforms, Path, Element } from '@seafile/slate';\nimport { ReactEditor } from '@seafile/slate-react';\nimport { getNodeType, getParentNode, getSelectedNodeByType, isLastNode, generateEmptyElement, focusEditor } from '../../core';\nimport { ELEMENT_TYPE, KEYBOARD, PARAGRAPH, CLIPBOARD_FORMAT_KEY, CHECK_LIST_ITEM, ORDERED_LIST, UNORDERED_LIST, TABLE_ROW, TABLE, TABLE_CELL } from '../../constants';\nimport { TABLE_MAX_ROWS, EMPTY_SELECTED_RANGE, TABLE_ELEMENT, TABLE_ELEMENT_POSITION, TABLE_CELL_MIN_WIDTH, TABLE_ROW_MIN_HEIGHT } from './constants';\nimport ObjectUtils from '../../../utils/object-utils';\nimport { getSelectedInfo, insertTableElement, removeTable, insertMultipleRowsAndColumns, setTableFragmentData, deleteTableRangeData, focusCell, deleteHandler, isTableLocation, isLastTableCell } from './helpers';\nimport EventBus from '../../../utils/event-bus';\nimport { INTERNAL_EVENT } from '../../../constants';\nvar withTable = function withTable(editor) {\n  var insertBreak = editor.insertBreak,\n    deleteBackward = editor.deleteBackward,\n    deleteForward = editor.deleteForward,\n    insertData = editor.insertData,\n    selectAll = editor.selectAll,\n    normalizeNode = editor.normalizeNode,\n    handleTab = editor.handleTab,\n    getFragment = editor.getFragment,\n    setFragmentData = editor.setFragmentData,\n    insertFragment = editor.insertFragment,\n    cut = editor.cut;\n  var newEditor = editor;\n  newEditor.tableSelectedRange = EMPTY_SELECTED_RANGE;\n  var eventBus = EventBus.getInstance();\n  newEditor.tableOnKeyDown = function (event) {\n    // Handle special keyboard events\n    if (isHotkey('mod+a', event)) {\n      event.preventDefault();\n      var _getSelectedInfo = getSelectedInfo(newEditor),\n        table = _getSelectedInfo.table,\n        tableSize = _getSelectedInfo.tableSize;\n      var allTableRange = {\n        minRowIndex: 0,\n        maxRowIndex: tableSize[0] - 1,\n        minColIndex: 0,\n        maxColIndex: tableSize[1] - 1\n      };\n      newEditor.tableSelectedRange = allTableRange;\n      eventBus.dispatch(INTERNAL_EVENT.SET_TABLE_SELECT_RANGE, table, allTableRange);\n    }\n    if (isHotkey(KEYBOARD.UP, event)) {\n      focusCell(newEditor, event, KEYBOARD.UP);\n    }\n    if (isHotkey(KEYBOARD.RIGHT, event)) {\n      focusCell(newEditor, event, KEYBOARD.RIGHT);\n    }\n    if (isHotkey(KEYBOARD.DOWN, event)) {\n      focusCell(newEditor, event, KEYBOARD.DOWN);\n    }\n    if (isHotkey(KEYBOARD.LEFT, event)) {\n      focusCell(newEditor, event, KEYBOARD.LEFT);\n    }\n    if (isHotkey('tab', event)) {\n      event.preventDefault();\n    }\n  };\n  newEditor.insertBreak = function () {\n    var selectedNode = getSelectedNodeByType(newEditor, ELEMENT_TYPE.TABLE);\n    if (selectedNode != null) {\n      newEditor.insertText('\\n'); // If table is selected, wrap in cell\n      return;\n    }\n    insertBreak();\n  };\n  newEditor.deleteBackward = function (unit) {\n    var deleteType = deleteHandler(newEditor);\n    if (deleteType === 'table') {\n      var _getSelectedInfo2 = getSelectedInfo(editor),\n        tablePath = _getSelectedInfo2.tablePath;\n      removeTable(editor, tablePath);\n      return;\n    }\n\n    // range selection delete\n    if (deleteType === 'range') {\n      deleteTableRangeData(newEditor);\n      return;\n    }\n    if (deleteType === 'default') return;\n    var selection = newEditor.selection;\n    if (selection) {\n      var before = Editor.before(newEditor, selection);\n      if (before) {\n        var isTableOnBeforeLocation = isTableLocation(newEditor, before);\n        var isTableOnCurSelection = isTableLocation(newEditor, selection);\n        // If the current is not a table and the previous one is a table.\n        if (isTableOnBeforeLocation && !isTableOnCurSelection) {\n          var _Editor$nodes = Editor.nodes(editor, {\n              match: function match(n) {\n                return Element.isElement(n) && !Editor.parent(n, ReactEditor.findPath(editor, n))[1].length;\n              }\n            }),\n            _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n            currentNodeEntry = _Editor$nodes2[0];\n          if (!currentNodeEntry) return;\n          var _Array$from = Array.from(currentNodeEntry),\n            _Array$from2 = _slicedToArray(_Array$from, 2),\n            currentNode = _Array$from2[0],\n            currentPath = _Array$from2[1];\n\n          // If the current is paragraph.\n          if (currentNode.type === PARAGRAPH) {\n            var path = before.path;\n            Transforms.select(editor, {\n              anchor: {\n                offset: 0,\n                path: [path[0], 0, 0, 0]\n              },\n              focus: {\n                offset: 0,\n                path: [path[0], 0, 0, 0]\n              }\n            });\n            var beforeTable = Editor.node(editor, [path[0]]);\n            var beforeRow = Editor.node(editor, [path[0], path[1]]);\n            var tableSize = [beforeTable[0].children.length, beforeRow[0].children.length];\n            var allTableRange = {\n              minRowIndex: 0,\n              maxRowIndex: tableSize[0] - 1,\n              minColIndex: 0,\n              maxColIndex: tableSize[1] - 1\n            };\n            newEditor.tableSelectedRange = allTableRange;\n            eventBus.dispatch(INTERNAL_EVENT.SET_TABLE_SELECT_RANGE, beforeTable[0], allTableRange);\n            return;\n          }\n\n          // If deleting node is empty check-list, order-list, unordered-list, change to paragraph\n          var transformTypes = [CHECK_LIST_ITEM, ORDERED_LIST, UNORDERED_LIST];\n          if (transformTypes.includes(currentNode.type)) {\n            Transforms.delete(newEditor, {\n              at: currentPath\n            });\n            Transforms.insertNodes(newEditor, generateEmptyElement(PARAGRAPH), {\n              at: currentPath\n            });\n            focusEditor(editor, Editor.start(editor, currentPath));\n          }\n          return;\n        }\n      }\n    }\n    deleteBackward(unit);\n  };\n  newEditor.deleteForward = function (unit) {\n    var nextNode = Editor.next(newEditor);\n    var newNodeParent = getParentNode(newEditor.children, nextNode[0].id);\n    if (newNodeParent.type === ELEMENT_TYPE.TABLE_CELL) return;\n    deleteForward(unit);\n  };\n  newEditor.getFragment = function () {\n    var selectedNode = getSelectedNodeByType(newEditor, ELEMENT_TYPE.TABLE);\n    if (!selectedNode) {\n      return getFragment();\n    }\n    var tableSelectedRange = newEditor.tableSelectedRange;\n    if (ObjectUtils.isSameObject(tableSelectedRange, EMPTY_SELECTED_RANGE)) {\n      var fragment = getFragment();\n\n      // When a cell is selected, it should be converted to text\n      return [Object.freeze({\n        children: fragment[0].children[0].children[0]['children'],\n        id: fragment[0]['id'],\n        type: ELEMENT_TYPE.PARAGRAPH\n      })];\n    }\n    var minColIndex = tableSelectedRange.minColIndex,\n      maxColIndex = tableSelectedRange.maxColIndex,\n      minRowIndex = tableSelectedRange.minRowIndex,\n      maxRowIndex = tableSelectedRange.maxRowIndex;\n    var rows = selectedNode.children;\n    var columns = selectedNode.columns;\n    var selectedRows = [];\n    var selectedColumns = [];\n    for (var i = minRowIndex; i <= maxRowIndex; i++) {\n      var row = rows[i];\n      var rowChildren = row.children;\n      var newRowChildren = [];\n      for (var j = minColIndex; j <= maxColIndex; j++) {\n        var column = rowChildren[j];\n        newRowChildren.push(column);\n      }\n      selectedRows.push(_objectSpread(_objectSpread({}, row), {}, {\n        children: newRowChildren\n      }));\n    }\n    for (var _j = minColIndex; _j <= maxColIndex; _j++) {\n      var _column = columns[_j];\n      selectedColumns.push(_column);\n    }\n    return [Object.freeze(_objectSpread(_objectSpread({}, selectedNode), {}, {\n      children: selectedRows,\n      columns: selectedColumns\n    }))];\n  };\n\n  // copy: mod + c\n  newEditor.setFragmentData = function (dataTransfer) {\n    var selectedNode = getSelectedNodeByType(newEditor, ELEMENT_TYPE.TABLE);\n    if (!selectedNode) {\n      return setFragmentData(dataTransfer);\n    }\n    var tableSelectedRange = newEditor.tableSelectedRange;\n    if (ObjectUtils.isSameObject(tableSelectedRange, EMPTY_SELECTED_RANGE)) {\n      return setFragmentData(dataTransfer);\n    }\n    return setTableFragmentData(newEditor, dataTransfer);\n  };\n  newEditor.cut = function (event) {\n    var selectedNode = getSelectedNodeByType(newEditor, ELEMENT_TYPE.TABLE);\n    var tableSelectedRange = newEditor.tableSelectedRange;\n    if (selectedNode && !ObjectUtils.isSameObject(tableSelectedRange, EMPTY_SELECTED_RANGE)) {\n      setTableFragmentData(newEditor, event.clipboardData);\n      var deleteType = deleteHandler(newEditor);\n      if (deleteType === 'table') {\n        var _getSelectedInfo3 = getSelectedInfo(editor),\n          tablePath = _getSelectedInfo3.tablePath;\n        removeTable(editor, tablePath);\n        return;\n      }\n\n      // range selection delete\n      if (deleteType === 'range') {\n        deleteTableRangeData(newEditor);\n        return;\n      }\n      return;\n    }\n    return cut(event);\n  };\n\n  // copy insert text\n  newEditor.insertData = function (data) {\n    var selectedNode = getSelectedNodeByType(newEditor, ELEMENT_TYPE.TABLE_CELL);\n    if (!selectedNode) {\n      insertData(data);\n      return;\n    }\n    var fragment = data.getData(\"application/\".concat(CLIPBOARD_FORMAT_KEY));\n    if (fragment) {\n      var decoded = decodeURIComponent(window.atob(fragment));\n      var parsedData = JSON.parse(decoded);\n      if (Array.isArray(parsedData) && parsedData.some(function (item) {\n        return item.type === ELEMENT_TYPE.TABLE;\n      })) {\n        var tableElement = parsedData.find(function (item) {\n          return item.type === ELEMENT_TYPE.TABLE;\n        });\n        insertMultipleRowsAndColumns(newEditor, tableElement.children, tableElement.columns);\n        return;\n      }\n    }\n    var text = data.getData('text/plain');\n    if (!text) return;\n    Editor.insertText(newEditor, text);\n  };\n  newEditor.insertFragment = function (data) {\n    if (data.type === ELEMENT_TYPE.TABLE) {\n      Transforms.insertNodes(editor, data);\n      return;\n    }\n    return insertFragment(data);\n  };\n  newEditor.selectAll = function () {\n    var selection = newEditor.selection;\n    if (!selection) {\n      selectAll();\n      return;\n    }\n    var selectedCell = getSelectedNodeByType(newEditor, ELEMENT_TYPE.TABLE_CELL);\n    if (!selectedCell) {\n      selectAll();\n      return;\n    }\n    var anchor = selection.anchor,\n      focus = selection.focus;\n    if (!Path.equals(anchor.path.slice(0, 3), focus.path.slice(0, 3))) {\n      selectAll();\n      return;\n    }\n    var _getSelectedInfo4 = getSelectedInfo(newEditor),\n      table = _getSelectedInfo4.table,\n      tableSize = _getSelectedInfo4.tableSize;\n    eventBus.dispatch(INTERNAL_EVENT.SET_TABLE_SELECT_RANGE, table, {\n      minRowIndex: 0,\n      maxRowIndex: tableSize[0] - 1,\n      minColIndex: 0,\n      maxColIndex: tableSize[1] - 1\n    });\n  };\n\n  // Rewrite normalizeNode\n  newEditor.normalizeNode = function (_ref) {\n    var _node$children$, _node$children$$child, _node$children$2, _node$children$2$chil;\n    var _ref2 = _slicedToArray(_ref, 2),\n      node = _ref2[0],\n      path = _ref2[1];\n    var type = getNodeType(node);\n    if (node.type === TABLE_ROW) {\n      var parentEntry = Editor.parent(editor, path);\n      if ((parentEntry === null || parentEntry === void 0 ? void 0 : parentEntry[0].type) !== TABLE) {\n        Transforms.unwrapNodes(editor, {\n          at: path\n        });\n        return;\n      }\n    }\n    if (node.type === TABLE_CELL) {\n      var _parentEntry = Editor.parent(editor, path);\n      if ((_parentEntry === null || _parentEntry === void 0 ? void 0 : _parentEntry[0].type) !== TABLE_ROW) {\n        Transforms.unwrapNodes(editor, {\n          at: path\n        });\n        return;\n      }\n    }\n    if (type !== ELEMENT_TYPE.TABLE) {\n      return normalizeNode([node, path]);\n    }\n\n    // Check field integrity\n    // Check table - columns\n    var isMissColumn = !node.columns;\n    if (isMissColumn) {\n      if (!node.columns) {\n        var columnCount = node.children[0].children.length;\n        var width = Math.max(TABLE_CELL_MIN_WIDTH, parseInt(editor.width / columnCount));\n        var columns = Array(node.children[0].children.length).fill({\n          width: width\n        });\n        Transforms.setNodes(newEditor, {\n          columns: columns\n        }, {\n          at: path\n        });\n      }\n    }\n\n    // Check table - style\n    if (!node.style) {\n      var _columnCount = node.children[0].children.length;\n      var columnWidth = Math.max(TABLE_CELL_MIN_WIDTH, parseInt(editor.width / _columnCount));\n      Transforms.setNodes(newEditor, {\n        style: {\n          gridTemplateColumns: \"repeat(\".concat(_columnCount, \", \").concat(columnWidth, \"px)\"),\n          gridAutoRows: \"minmax(\".concat(TABLE_ROW_MIN_HEIGHT, \"}px, auto)\")\n        }\n      }, {\n        at: path\n      });\n    }\n\n    // Check table - ui\n    if (!node.ui) {\n      Transforms.setNodes(newEditor, {\n        ui: {\n          alternate_highlight: false\n        }\n      }, {\n        at: path\n      });\n    }\n\n    // Check row - style\n    if (!node.children[0].style) {\n      var style = {\n        min_height: TABLE_ROW_MIN_HEIGHT\n      };\n      node.children.forEach(function (row, index) {\n        if (!row.style) {\n          Transforms.setNodes(newEditor, {\n            style: style\n          }, {\n            at: path.concat(index)\n          });\n        }\n      });\n    }\n\n    // Check cell - style & inherit_style\n    if ((node === null || node === void 0 ? void 0 : (_node$children$ = node.children[0]) === null || _node$children$ === void 0 ? void 0 : (_node$children$$child = _node$children$.children[0]) === null || _node$children$$child === void 0 ? void 0 : _node$children$$child.style) || (node === null || node === void 0 ? void 0 : (_node$children$2 = node.children[0]) === null || _node$children$2 === void 0 ? void 0 : (_node$children$2$chil = _node$children$2.children[0]) === null || _node$children$2$chil === void 0 ? void 0 : _node$children$2$chil.inherit_style)) {\n      node.children.forEach(function (row, rowIndex) {\n        row.children.forEach(function (cell, cellIndex) {\n          if (!cell.style || !cell.inherit_style) {\n            var _style = cell.style || {};\n            var inherit_style = cell.inherit_style || {};\n            Transforms.setNodes(newEditor, {\n              style: _style,\n              inherit_style: inherit_style\n            }, {\n              at: path.concat(rowIndex, cellIndex)\n            });\n          }\n        });\n      });\n    }\n\n    // insert empty node，continue editor\n    var isLast = isLastNode(newEditor, node);\n    if (isLast) {\n      var p = generateEmptyElement(PARAGRAPH);\n      Transforms.insertNodes(newEditor, p, {\n        at: [path[0] + 1]\n      });\n    }\n  };\n\n  // Jump to the next cell when pressing tab in the table\n  newEditor.handleTab = function (event) {\n    var selectedNode = getSelectedNodeByType(newEditor, ELEMENT_TYPE.TABLE);\n    if (!selectedNode) {\n      handleTab(event);\n      return;\n    }\n    var above = Editor.above(newEditor);\n\n    // Select multiple cells, jump to the first selected cell\n    if (above[0].type === ELEMENT_TYPE.TABLE) {\n      var _selection = newEditor.selection;\n      var anchor = _selection.anchor;\n      Transforms.select(newEditor, _toConsumableArray(anchor.path.slice(0, -1)));\n      return;\n    }\n\n    // Add row to the last cell\n    if (isLastTableCell(newEditor, above)) {\n      var _getSelectedInfo5 = getSelectedInfo(newEditor),\n        tablePath = _getSelectedInfo5.tablePath,\n        tableSize = _getSelectedInfo5.tableSize;\n      if (tableSize[0] === TABLE_MAX_ROWS) return;\n      insertTableElement(newEditor, TABLE_ELEMENT.ROW, TABLE_ELEMENT_POSITION.AFTER);\n      Transforms.select(newEditor, [].concat(_toConsumableArray(tablePath), [tableSize[0], 0]));\n      return;\n    }\n    var selection = newEditor.selection;\n\n    // The default behavior, the cursor is in the middle of the text, and the current text content is selected\n    // Change to jump to next cell\n    if (selection.anchor.offset === selection.focus.offset) {\n      var _getSelectedInfo6 = getSelectedInfo(newEditor),\n        _tableSize = _getSelectedInfo6.tableSize,\n        _tablePath = _getSelectedInfo6.tablePath,\n        rowIndex = _getSelectedInfo6.rowIndex,\n        cellIndex = _getSelectedInfo6.cellIndex;\n      var lastColumnIndex = _tableSize[1] - 1;\n      var nextCell = [rowIndex, cellIndex + 1];\n      if (lastColumnIndex < nextCell[1]) {\n        nextCell = [rowIndex + 1, 0];\n      }\n      Transforms.select(newEditor, [].concat(_toConsumableArray(_tablePath), _toConsumableArray(nextCell)));\n      return;\n    }\n    var next = Editor.next(newEditor);\n    Transforms.select(newEditor, next[1]);\n  };\n  newEditor.reSetTableSelectedRange = function () {\n    newEditor.tableSelectedRange = EMPTY_SELECTED_RANGE;\n  };\n  return newEditor;\n};\nexport default withTable;","map":{"version":3,"names":["_objectSpread","isHotkey","Editor","Transforms","Path","Element","ReactEditor","getNodeType","getParentNode","getSelectedNodeByType","isLastNode","generateEmptyElement","focusEditor","ELEMENT_TYPE","KEYBOARD","PARAGRAPH","CLIPBOARD_FORMAT_KEY","CHECK_LIST_ITEM","ORDERED_LIST","UNORDERED_LIST","TABLE_ROW","TABLE","TABLE_CELL","TABLE_MAX_ROWS","EMPTY_SELECTED_RANGE","TABLE_ELEMENT","TABLE_ELEMENT_POSITION","TABLE_CELL_MIN_WIDTH","TABLE_ROW_MIN_HEIGHT","ObjectUtils","getSelectedInfo","insertTableElement","removeTable","insertMultipleRowsAndColumns","setTableFragmentData","deleteTableRangeData","focusCell","deleteHandler","isTableLocation","isLastTableCell","EventBus","INTERNAL_EVENT","withTable","editor","insertBreak","deleteBackward","deleteForward","insertData","selectAll","normalizeNode","handleTab","getFragment","setFragmentData","insertFragment","cut","newEditor","tableSelectedRange","eventBus","getInstance","tableOnKeyDown","event","preventDefault","_getSelectedInfo","table","tableSize","allTableRange","minRowIndex","maxRowIndex","minColIndex","maxColIndex","dispatch","SET_TABLE_SELECT_RANGE","UP","RIGHT","DOWN","LEFT","selectedNode","insertText","unit","deleteType","_getSelectedInfo2","tablePath","selection","before","isTableOnBeforeLocation","isTableOnCurSelection","_Editor$nodes","nodes","match","n","isElement","parent","findPath","length","_Editor$nodes2","_slicedToArray","currentNodeEntry","_Array$from","Array","from","_Array$from2","currentNode","currentPath","type","path","select","anchor","offset","focus","beforeTable","node","beforeRow","children","transformTypes","includes","delete","at","insertNodes","start","nextNode","next","newNodeParent","id","isSameObject","fragment","Object","freeze","rows","columns","selectedRows","selectedColumns","i","row","rowChildren","newRowChildren","j","column","push","dataTransfer","clipboardData","_getSelectedInfo3","data","getData","concat","decoded","decodeURIComponent","window","atob","parsedData","JSON","parse","isArray","some","item","tableElement","find","text","selectedCell","equals","slice","_getSelectedInfo4","_ref","_node$children$","_node$children$$child","_node$children$2","_node$children$2$chil","_ref2","parentEntry","unwrapNodes","isMissColumn","columnCount","width","Math","max","parseInt","fill","setNodes","style","columnWidth","gridTemplateColumns","gridAutoRows","ui","alternate_highlight","min_height","forEach","index","inherit_style","rowIndex","cell","cellIndex","isLast","p","above","_toConsumableArray","_getSelectedInfo5","ROW","AFTER","_getSelectedInfo6","lastColumnIndex","nextCell","reSetTableSelectedRange"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/extension/plugins/table/plugin.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport isHotkey from 'is-hotkey';\nimport { Editor, Transforms, Path, Element } from '@seafile/slate';\nimport { ReactEditor } from '@seafile/slate-react';\nimport { getNodeType, getParentNode, getSelectedNodeByType, isLastNode, generateEmptyElement, focusEditor } from '../../core';\nimport { ELEMENT_TYPE, KEYBOARD, PARAGRAPH, CLIPBOARD_FORMAT_KEY, CHECK_LIST_ITEM, ORDERED_LIST, UNORDERED_LIST, TABLE_ROW, TABLE, TABLE_CELL } from '../../constants';\nimport { TABLE_MAX_ROWS, EMPTY_SELECTED_RANGE, TABLE_ELEMENT, TABLE_ELEMENT_POSITION, TABLE_CELL_MIN_WIDTH, TABLE_ROW_MIN_HEIGHT } from './constants';\nimport ObjectUtils from '../../../utils/object-utils';\nimport { getSelectedInfo, insertTableElement, removeTable, insertMultipleRowsAndColumns, setTableFragmentData, deleteTableRangeData, focusCell, deleteHandler, isTableLocation, isLastTableCell } from './helpers';\nimport EventBus from '../../../utils/event-bus';\nimport { INTERNAL_EVENT } from '../../../constants';\nconst withTable = editor => {\n  const {\n    insertBreak,\n    deleteBackward,\n    deleteForward,\n    insertData,\n    selectAll,\n    normalizeNode,\n    handleTab,\n    getFragment,\n    setFragmentData,\n    insertFragment,\n    cut\n  } = editor;\n  const newEditor = editor;\n  newEditor.tableSelectedRange = EMPTY_SELECTED_RANGE;\n  const eventBus = EventBus.getInstance();\n  newEditor.tableOnKeyDown = event => {\n    // Handle special keyboard events\n    if (isHotkey('mod+a', event)) {\n      event.preventDefault();\n      const {\n        table,\n        tableSize\n      } = getSelectedInfo(newEditor);\n      const allTableRange = {\n        minRowIndex: 0,\n        maxRowIndex: tableSize[0] - 1,\n        minColIndex: 0,\n        maxColIndex: tableSize[1] - 1\n      };\n      newEditor.tableSelectedRange = allTableRange;\n      eventBus.dispatch(INTERNAL_EVENT.SET_TABLE_SELECT_RANGE, table, allTableRange);\n    }\n    if (isHotkey(KEYBOARD.UP, event)) {\n      focusCell(newEditor, event, KEYBOARD.UP);\n    }\n    if (isHotkey(KEYBOARD.RIGHT, event)) {\n      focusCell(newEditor, event, KEYBOARD.RIGHT);\n    }\n    if (isHotkey(KEYBOARD.DOWN, event)) {\n      focusCell(newEditor, event, KEYBOARD.DOWN);\n    }\n    if (isHotkey(KEYBOARD.LEFT, event)) {\n      focusCell(newEditor, event, KEYBOARD.LEFT);\n    }\n    if (isHotkey('tab', event)) {\n      event.preventDefault();\n    }\n  };\n  newEditor.insertBreak = () => {\n    const selectedNode = getSelectedNodeByType(newEditor, ELEMENT_TYPE.TABLE);\n    if (selectedNode != null) {\n      newEditor.insertText('\\n'); // If table is selected, wrap in cell\n      return;\n    }\n    insertBreak();\n  };\n  newEditor.deleteBackward = unit => {\n    const deleteType = deleteHandler(newEditor);\n    if (deleteType === 'table') {\n      const {\n        tablePath\n      } = getSelectedInfo(editor);\n      removeTable(editor, tablePath);\n      return;\n    }\n\n    // range selection delete\n    if (deleteType === 'range') {\n      deleteTableRangeData(newEditor);\n      return;\n    }\n    if (deleteType === 'default') return;\n    const {\n      selection\n    } = newEditor;\n    if (selection) {\n      const before = Editor.before(newEditor, selection);\n      if (before) {\n        const isTableOnBeforeLocation = isTableLocation(newEditor, before);\n        const isTableOnCurSelection = isTableLocation(newEditor, selection);\n        // If the current is not a table and the previous one is a table.\n        if (isTableOnBeforeLocation && !isTableOnCurSelection) {\n          const [currentNodeEntry] = Editor.nodes(editor, {\n            match: n => Element.isElement(n) && !Editor.parent(n, ReactEditor.findPath(editor, n))[1].length\n          });\n          if (!currentNodeEntry) return;\n          const [currentNode, currentPath] = Array.from(currentNodeEntry);\n\n          // If the current is paragraph.\n          if (currentNode.type === PARAGRAPH) {\n            const {\n              path\n            } = before;\n            Transforms.select(editor, {\n              anchor: {\n                offset: 0,\n                path: [path[0], 0, 0, 0]\n              },\n              focus: {\n                offset: 0,\n                path: [path[0], 0, 0, 0]\n              }\n            });\n            const beforeTable = Editor.node(editor, [path[0]]);\n            const beforeRow = Editor.node(editor, [path[0], path[1]]);\n            const tableSize = [beforeTable[0].children.length, beforeRow[0].children.length];\n            const allTableRange = {\n              minRowIndex: 0,\n              maxRowIndex: tableSize[0] - 1,\n              minColIndex: 0,\n              maxColIndex: tableSize[1] - 1\n            };\n            newEditor.tableSelectedRange = allTableRange;\n            eventBus.dispatch(INTERNAL_EVENT.SET_TABLE_SELECT_RANGE, beforeTable[0], allTableRange);\n            return;\n          }\n\n          // If deleting node is empty check-list, order-list, unordered-list, change to paragraph\n          const transformTypes = [CHECK_LIST_ITEM, ORDERED_LIST, UNORDERED_LIST];\n          if (transformTypes.includes(currentNode.type)) {\n            Transforms.delete(newEditor, {\n              at: currentPath\n            });\n            Transforms.insertNodes(newEditor, generateEmptyElement(PARAGRAPH), {\n              at: currentPath\n            });\n            focusEditor(editor, Editor.start(editor, currentPath));\n          }\n          return;\n        }\n      }\n    }\n    deleteBackward(unit);\n  };\n  newEditor.deleteForward = unit => {\n    const nextNode = Editor.next(newEditor);\n    const newNodeParent = getParentNode(newEditor.children, nextNode[0].id);\n    if (newNodeParent.type === ELEMENT_TYPE.TABLE_CELL) return;\n    deleteForward(unit);\n  };\n  newEditor.getFragment = () => {\n    const selectedNode = getSelectedNodeByType(newEditor, ELEMENT_TYPE.TABLE);\n    if (!selectedNode) {\n      return getFragment();\n    }\n    const {\n      tableSelectedRange\n    } = newEditor;\n    if (ObjectUtils.isSameObject(tableSelectedRange, EMPTY_SELECTED_RANGE)) {\n      const fragment = getFragment();\n\n      // When a cell is selected, it should be converted to text\n      return [Object.freeze({\n        children: fragment[0].children[0].children[0]['children'],\n        id: fragment[0]['id'],\n        type: ELEMENT_TYPE.PARAGRAPH\n      })];\n    }\n    const {\n      minColIndex,\n      maxColIndex,\n      minRowIndex,\n      maxRowIndex\n    } = tableSelectedRange;\n    const rows = selectedNode.children;\n    const columns = selectedNode.columns;\n    let selectedRows = [];\n    let selectedColumns = [];\n    for (let i = minRowIndex; i <= maxRowIndex; i++) {\n      const row = rows[i];\n      const rowChildren = row.children;\n      let newRowChildren = [];\n      for (let j = minColIndex; j <= maxColIndex; j++) {\n        const column = rowChildren[j];\n        newRowChildren.push(column);\n      }\n      selectedRows.push(_objectSpread(_objectSpread({}, row), {}, {\n        children: newRowChildren\n      }));\n    }\n    for (let j = minColIndex; j <= maxColIndex; j++) {\n      const column = columns[j];\n      selectedColumns.push(column);\n    }\n    return [Object.freeze(_objectSpread(_objectSpread({}, selectedNode), {}, {\n      children: selectedRows,\n      columns: selectedColumns\n    }))];\n  };\n\n  // copy: mod + c\n  newEditor.setFragmentData = dataTransfer => {\n    const selectedNode = getSelectedNodeByType(newEditor, ELEMENT_TYPE.TABLE);\n    if (!selectedNode) {\n      return setFragmentData(dataTransfer);\n    }\n    const {\n      tableSelectedRange\n    } = newEditor;\n    if (ObjectUtils.isSameObject(tableSelectedRange, EMPTY_SELECTED_RANGE)) {\n      return setFragmentData(dataTransfer);\n    }\n    return setTableFragmentData(newEditor, dataTransfer);\n  };\n  newEditor.cut = event => {\n    const selectedNode = getSelectedNodeByType(newEditor, ELEMENT_TYPE.TABLE);\n    const {\n      tableSelectedRange\n    } = newEditor;\n    if (selectedNode && !ObjectUtils.isSameObject(tableSelectedRange, EMPTY_SELECTED_RANGE)) {\n      setTableFragmentData(newEditor, event.clipboardData);\n      const deleteType = deleteHandler(newEditor);\n      if (deleteType === 'table') {\n        const {\n          tablePath\n        } = getSelectedInfo(editor);\n        removeTable(editor, tablePath);\n        return;\n      }\n\n      // range selection delete\n      if (deleteType === 'range') {\n        deleteTableRangeData(newEditor);\n        return;\n      }\n      return;\n    }\n    return cut(event);\n  };\n\n  // copy insert text\n  newEditor.insertData = data => {\n    const selectedNode = getSelectedNodeByType(newEditor, ELEMENT_TYPE.TABLE_CELL);\n    if (!selectedNode) {\n      insertData(data);\n      return;\n    }\n    const fragment = data.getData(\"application/\".concat(CLIPBOARD_FORMAT_KEY));\n    if (fragment) {\n      const decoded = decodeURIComponent(window.atob(fragment));\n      const parsedData = JSON.parse(decoded);\n      if (Array.isArray(parsedData) && parsedData.some(item => item.type === ELEMENT_TYPE.TABLE)) {\n        const tableElement = parsedData.find(item => item.type === ELEMENT_TYPE.TABLE);\n        insertMultipleRowsAndColumns(newEditor, tableElement.children, tableElement.columns);\n        return;\n      }\n    }\n    const text = data.getData('text/plain');\n    if (!text) return;\n    Editor.insertText(newEditor, text);\n  };\n  newEditor.insertFragment = data => {\n    if (data.type === ELEMENT_TYPE.TABLE) {\n      Transforms.insertNodes(editor, data);\n      return;\n    }\n    return insertFragment(data);\n  };\n  newEditor.selectAll = () => {\n    const selection = newEditor.selection;\n    if (!selection) {\n      selectAll();\n      return;\n    }\n    const selectedCell = getSelectedNodeByType(newEditor, ELEMENT_TYPE.TABLE_CELL);\n    if (!selectedCell) {\n      selectAll();\n      return;\n    }\n    const {\n      anchor,\n      focus\n    } = selection;\n    if (!Path.equals(anchor.path.slice(0, 3), focus.path.slice(0, 3))) {\n      selectAll();\n      return;\n    }\n    const {\n      table,\n      tableSize\n    } = getSelectedInfo(newEditor);\n    eventBus.dispatch(INTERNAL_EVENT.SET_TABLE_SELECT_RANGE, table, {\n      minRowIndex: 0,\n      maxRowIndex: tableSize[0] - 1,\n      minColIndex: 0,\n      maxColIndex: tableSize[1] - 1\n    });\n  };\n\n  // Rewrite normalizeNode\n  newEditor.normalizeNode = _ref => {\n    var _node$children$, _node$children$$child, _node$children$2, _node$children$2$chil;\n    let [node, path] = _ref;\n    const type = getNodeType(node);\n    if (node.type === TABLE_ROW) {\n      const parentEntry = Editor.parent(editor, path);\n      if ((parentEntry === null || parentEntry === void 0 ? void 0 : parentEntry[0].type) !== TABLE) {\n        Transforms.unwrapNodes(editor, {\n          at: path\n        });\n        return;\n      }\n    }\n    if (node.type === TABLE_CELL) {\n      const parentEntry = Editor.parent(editor, path);\n      if ((parentEntry === null || parentEntry === void 0 ? void 0 : parentEntry[0].type) !== TABLE_ROW) {\n        Transforms.unwrapNodes(editor, {\n          at: path\n        });\n        return;\n      }\n    }\n    if (type !== ELEMENT_TYPE.TABLE) {\n      return normalizeNode([node, path]);\n    }\n\n    // Check field integrity\n    // Check table - columns\n    const isMissColumn = !node.columns;\n    if (isMissColumn) {\n      if (!node.columns) {\n        const columnCount = node.children[0].children.length;\n        const width = Math.max(TABLE_CELL_MIN_WIDTH, parseInt(editor.width / columnCount));\n        const columns = Array(node.children[0].children.length).fill({\n          width\n        });\n        Transforms.setNodes(newEditor, {\n          columns\n        }, {\n          at: path\n        });\n      }\n    }\n\n    // Check table - style\n    if (!node.style) {\n      const columnCount = node.children[0].children.length;\n      const columnWidth = Math.max(TABLE_CELL_MIN_WIDTH, parseInt(editor.width / columnCount));\n      Transforms.setNodes(newEditor, {\n        style: {\n          gridTemplateColumns: \"repeat(\".concat(columnCount, \", \").concat(columnWidth, \"px)\"),\n          gridAutoRows: \"minmax(\".concat(TABLE_ROW_MIN_HEIGHT, \"}px, auto)\")\n        }\n      }, {\n        at: path\n      });\n    }\n\n    // Check table - ui\n    if (!node.ui) {\n      Transforms.setNodes(newEditor, {\n        ui: {\n          alternate_highlight: false\n        }\n      }, {\n        at: path\n      });\n    }\n\n    // Check row - style\n    if (!node.children[0].style) {\n      const style = {\n        min_height: TABLE_ROW_MIN_HEIGHT\n      };\n      node.children.forEach((row, index) => {\n        if (!row.style) {\n          Transforms.setNodes(newEditor, {\n            style\n          }, {\n            at: path.concat(index)\n          });\n        }\n      });\n    }\n\n    // Check cell - style & inherit_style\n    if ((node === null || node === void 0 ? void 0 : (_node$children$ = node.children[0]) === null || _node$children$ === void 0 ? void 0 : (_node$children$$child = _node$children$.children[0]) === null || _node$children$$child === void 0 ? void 0 : _node$children$$child.style) || (node === null || node === void 0 ? void 0 : (_node$children$2 = node.children[0]) === null || _node$children$2 === void 0 ? void 0 : (_node$children$2$chil = _node$children$2.children[0]) === null || _node$children$2$chil === void 0 ? void 0 : _node$children$2$chil.inherit_style)) {\n      node.children.forEach((row, rowIndex) => {\n        row.children.forEach((cell, cellIndex) => {\n          if (!cell.style || !cell.inherit_style) {\n            const style = cell.style || {};\n            const inherit_style = cell.inherit_style || {};\n            Transforms.setNodes(newEditor, {\n              style,\n              inherit_style\n            }, {\n              at: path.concat(rowIndex, cellIndex)\n            });\n          }\n        });\n      });\n    }\n\n    // insert empty node，continue editor\n    const isLast = isLastNode(newEditor, node);\n    if (isLast) {\n      const p = generateEmptyElement(PARAGRAPH);\n      Transforms.insertNodes(newEditor, p, {\n        at: [path[0] + 1]\n      });\n    }\n  };\n\n  // Jump to the next cell when pressing tab in the table\n  newEditor.handleTab = event => {\n    const selectedNode = getSelectedNodeByType(newEditor, ELEMENT_TYPE.TABLE);\n    if (!selectedNode) {\n      handleTab(event);\n      return;\n    }\n    const above = Editor.above(newEditor);\n\n    // Select multiple cells, jump to the first selected cell\n    if (above[0].type === ELEMENT_TYPE.TABLE) {\n      const {\n        selection\n      } = newEditor;\n      const {\n        anchor\n      } = selection;\n      Transforms.select(newEditor, [...anchor.path.slice(0, -1)]);\n      return;\n    }\n\n    // Add row to the last cell\n    if (isLastTableCell(newEditor, above)) {\n      const {\n        tablePath,\n        tableSize\n      } = getSelectedInfo(newEditor);\n      if (tableSize[0] === TABLE_MAX_ROWS) return;\n      insertTableElement(newEditor, TABLE_ELEMENT.ROW, TABLE_ELEMENT_POSITION.AFTER);\n      Transforms.select(newEditor, [...tablePath, tableSize[0], 0]);\n      return;\n    }\n    const {\n      selection\n    } = newEditor;\n\n    // The default behavior, the cursor is in the middle of the text, and the current text content is selected\n    // Change to jump to next cell\n    if (selection.anchor.offset === selection.focus.offset) {\n      const {\n        tableSize,\n        tablePath,\n        rowIndex,\n        cellIndex\n      } = getSelectedInfo(newEditor);\n      const lastColumnIndex = tableSize[1] - 1;\n      let nextCell = [rowIndex, cellIndex + 1];\n      if (lastColumnIndex < nextCell[1]) {\n        nextCell = [rowIndex + 1, 0];\n      }\n      Transforms.select(newEditor, [...tablePath, ...nextCell]);\n      return;\n    }\n    const next = Editor.next(newEditor);\n    Transforms.select(newEditor, next[1]);\n  };\n  newEditor.reSetTableSelectedRange = () => {\n    newEditor.tableSelectedRange = EMPTY_SELECTED_RANGE;\n  };\n  return newEditor;\n};\nexport default withTable;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}