{"ast":null,"code":"import _toConsumableArray from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _defineProperty from \"/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport { generateIdMapAndIds, getIdDiffs } from './diff';\nimport ObjectUtils from './object-utils';\nimport { MODIFY_TYPE, REBASE_TYPE, REBASE_MARK_KEY, REBASE_ORIGIN, REBASE_TYPES } from '../constants';\nimport { ELEMENT_TYPE } from '../extension/constants';\nimport { replaceNodeId } from '../node-id/helpers';\nexport var hasConflict = function hasConflict(content) {\n  if (!Array.isArray(content) || content.length === 0) return false;\n  var flag = false;\n  for (var i = 0; i < content.length; i++) {\n    var element = content[i];\n    var rebase_type = element.rebase_type,\n      children = element.children;\n    if (REBASE_TYPES.includes(rebase_type)) {\n      flag = true;\n      break;\n    } else {\n      var childrenFlag = hasConflict(children);\n      if (!childrenFlag) continue;\n      flag = childrenFlag;\n      break;\n    }\n  }\n  return flag;\n};\nvar getChanges = function getChanges(masterContent, revisionContent) {\n  var _generateIdMapAndIds = generateIdMapAndIds(masterContent.children),\n    masterContentMap = _generateIdMapAndIds.map,\n    masterIds = _generateIdMapAndIds.ids;\n  var _generateIdMapAndIds2 = generateIdMapAndIds(revisionContent.children),\n    currentContentMap = _generateIdMapAndIds2.map,\n    currentIds = _generateIdMapAndIds2.ids;\n  var idDiffs = getIdDiffs(masterIds, currentIds);\n  var content = [];\n  idDiffs.forEach(function (idDiff) {\n    var value = idDiff.value,\n      added = idDiff.added,\n      removed = idDiff.removed;\n    if (added) {\n      var addedList = value.map(function (item) {\n        return _objectSpread(_objectSpread({}, currentContentMap[item]), {}, _defineProperty({}, REBASE_MARK_KEY.MODIFY_TYPE, MODIFY_TYPE.ADD));\n      });\n      content.push.apply(content, _toConsumableArray(addedList));\n    } else if (removed) {\n      var deletedList = value.map(function (item) {\n        return _objectSpread(_objectSpread({}, masterContentMap[item]), {}, _defineProperty({}, REBASE_MARK_KEY.MODIFY_TYPE, MODIFY_TYPE.DELETE));\n      });\n      content.push.apply(content, _toConsumableArray(deletedList));\n    } else {\n      value.forEach(function (elementId) {\n        if (ObjectUtils.isSameObject(masterContentMap[elementId], currentContentMap[elementId])) {\n          content.push(currentContentMap[elementId]);\n        } else {\n          var _objectSpread4;\n          var oldElement = masterContentMap[elementId];\n          var currentElement = currentContentMap[elementId];\n          var newElement = _objectSpread(_objectSpread({}, currentElement), {}, (_objectSpread4 = {}, _defineProperty(_objectSpread4, REBASE_MARK_KEY.MODIFY_TYPE, MODIFY_TYPE.MODIFY), _defineProperty(_objectSpread4, REBASE_MARK_KEY.OLD_ELEMENT, oldElement), _objectSpread4));\n          if (currentElement.type === oldElement.type) {\n            var elementType = currentElement.type;\n            if ([ELEMENT_TYPE.UNORDERED_LIST, ELEMENT_TYPE.ORDERED_LIST].includes(elementType)) {\n              var listContent = getChanges(oldElement, currentElement);\n              newElement[REBASE_MARK_KEY.MODIFY_TYPE] = MODIFY_TYPE.CHILDREN_MODIFY;\n              newElement['children'] = listContent;\n            }\n          }\n          content.push(newElement);\n        }\n      });\n    }\n  });\n  return content;\n};\nvar getMergeElement = function getMergeElement(diffElement, baseElement) {\n  var modifyType = diffElement[REBASE_MARK_KEY.MODIFY_TYPE];\n  var newElement = _objectSpread({}, diffElement);\n  newElement[REBASE_MARK_KEY.MODIFY_TYPE] && delete newElement[REBASE_MARK_KEY.MODIFY_TYPE];\n\n  // revision does not have this element, master has this element\n  if (modifyType === MODIFY_TYPE.DELETE) {\n    // base content does not have this element, indicating that it is newly added by master and needs to be retained, and will not be counted as a conflict.\n    if (!baseElement) return [newElement];\n\n    // base content has this element, master modified it, indicating that revision deleted it, and the user manually selected the conflict\n    if (!ObjectUtils.isSameObject(baseElement, diffElement, [REBASE_MARK_KEY.MODIFY_TYPE])) {\n      newElement[REBASE_MARK_KEY.REBASE_TYPE] = REBASE_TYPE.MODIFY_DELETE;\n      return [newElement];\n    }\n\n    // base content has this element, but master has not modified it. It means that revision has deleted it and the program has deleted it. The conflict will not be counted.\n    return [];\n  }\n\n  // revision has this element, master does not have this element\n  if (modifyType === MODIFY_TYPE.ADD) {\n    // base content does not have this element, indicating that it is newly added by revision and needs to be retained, and will not be counted as a conflict.\n    if (!baseElement) return [newElement];\n\n    // master deleted it, revision modified it, and the user manually selected the conflict\n    if (!ObjectUtils.isSameObject(baseElement, diffElement, [REBASE_MARK_KEY.MODIFY_TYPE])) {\n      newElement[REBASE_MARK_KEY.REBASE_TYPE] = REBASE_TYPE.DELETE_MODIFY;\n      return [newElement];\n    }\n\n    // master deleted it, revision did not modify it, the program deleted it, and the conflict is not counted.\n    return [];\n  }\n\n  // Elements that differ between revision and master\n  if (modifyType === MODIFY_TYPE.MODIFY) {\n    var _objectSpread7, _objectSpread8;\n    var masterElement = _objectSpread({}, diffElement[REBASE_MARK_KEY.OLD_ELEMENT]);\n    delete newElement[REBASE_MARK_KEY.OLD_ELEMENT];\n\n    // revision and master both add a new element, but the content is different. ===》 At present, this situation does not exist, it only exists in the theoretical stage.\n    if (!baseElement) {\n      var _objectSpread5, _objectSpread6;\n      return [_objectSpread(_objectSpread({}, replaceNodeId(masterElement)), {}, (_objectSpread5 = {}, _defineProperty(_objectSpread5, REBASE_MARK_KEY.REBASE_TYPE, REBASE_TYPE.MODIFY_MODIFY), _defineProperty(_objectSpread5, REBASE_MARK_KEY.OLD_ELEMENT, masterElement), _defineProperty(_objectSpread5, REBASE_MARK_KEY.ORIGIN, REBASE_ORIGIN.OTHER), _objectSpread5)), _objectSpread(_objectSpread({}, newElement), {}, (_objectSpread6 = {}, _defineProperty(_objectSpread6, REBASE_MARK_KEY.REBASE_TYPE, REBASE_TYPE.MODIFY_MODIFY), _defineProperty(_objectSpread6, REBASE_MARK_KEY.ORIGIN, REBASE_ORIGIN.MY), _objectSpread6))];\n    }\n\n    // master is the same as base, indicating that revision has modified the content\n    if (ObjectUtils.isSameObject(masterElement, baseElement)) return [newElement];\n\n    // revision is the same as base, indicating that master has modified the content\n    if (ObjectUtils.isSameObject(newElement, baseElement)) return [masterElement];\n\n    // They are all different. Revision and master were modified at the same time. If there is a conflict, the conflict needs to be resolved manually.\n    return [_objectSpread(_objectSpread({}, replaceNodeId(masterElement)), {}, (_objectSpread7 = {}, _defineProperty(_objectSpread7, REBASE_MARK_KEY.REBASE_TYPE, REBASE_TYPE.MODIFY_MODIFY), _defineProperty(_objectSpread7, REBASE_MARK_KEY.OLD_ELEMENT, masterElement), _defineProperty(_objectSpread7, REBASE_MARK_KEY.ORIGIN, REBASE_ORIGIN.OTHER), _objectSpread7)), _objectSpread(_objectSpread({}, newElement), {}, (_objectSpread8 = {}, _defineProperty(_objectSpread8, REBASE_MARK_KEY.REBASE_TYPE, REBASE_TYPE.MODIFY_MODIFY), _defineProperty(_objectSpread8, REBASE_MARK_KEY.ORIGIN, REBASE_ORIGIN.MY), _objectSpread8))];\n  }\n  if (modifyType === MODIFY_TYPE.CHILDREN_MODIFY) {\n    var _masterElement = _objectSpread({}, diffElement[REBASE_MARK_KEY.OLD_ELEMENT]);\n    delete newElement[REBASE_MARK_KEY.OLD_ELEMENT];\n\n    // revision and master both add a new element, but the content is different. ===》 At present, this situation does not exist, it only exists in the theoretical stage.\n    if (!baseElement) {\n      var _objectSpread9, _objectSpread10;\n      return [_objectSpread(_objectSpread({}, replaceNodeId(_masterElement)), {}, (_objectSpread9 = {}, _defineProperty(_objectSpread9, REBASE_MARK_KEY.REBASE_TYPE, REBASE_TYPE.MODIFY_MODIFY), _defineProperty(_objectSpread9, REBASE_MARK_KEY.OLD_ELEMENT, _masterElement), _defineProperty(_objectSpread9, REBASE_MARK_KEY.ORIGIN, REBASE_ORIGIN.OTHER), _objectSpread9)), _objectSpread(_objectSpread({}, newElement), {}, (_objectSpread10 = {}, _defineProperty(_objectSpread10, REBASE_MARK_KEY.REBASE_TYPE, REBASE_TYPE.MODIFY_MODIFY), _defineProperty(_objectSpread10, REBASE_MARK_KEY.ORIGIN, REBASE_ORIGIN.MY), _objectSpread10))];\n    }\n    if (ObjectUtils.isSameObject(_masterElement, baseElement)) return [newElement];\n    if (ObjectUtils.isSameObject(newElement, baseElement)) return [_masterElement];\n    if (ObjectUtils.isSameObject(_masterElement, newElement, ['type'])) {\n      if (ObjectUtils.isSameObject(_masterElement, baseElement, ['type'])) return [newElement];\n      if (ObjectUtils.isSameObject(newElement, baseElement, ['type'])) return [_masterElement];\n    }\n\n    // The content of the subnode has changed and needs to be solved manually.\n    var childrenContent = getMergeContent(baseElement, diffElement.children);\n    return [_objectSpread(_objectSpread({}, newElement), {}, {\n      children: childrenContent\n    })];\n  }\n  newElement[REBASE_MARK_KEY.OLD_ELEMENT] && delete newElement[REBASE_MARK_KEY.OLD_ELEMENT];\n  return [newElement];\n};\nvar getMergeContent = function getMergeContent(baseContent, diffChanges) {\n  var _generateIdMapAndIds3 = generateIdMapAndIds(diffChanges),\n    diffChangesContentMap = _generateIdMapAndIds3.map,\n    diffChangesContentIds = _generateIdMapAndIds3.ids;\n  var _generateIdMapAndIds4 = generateIdMapAndIds(baseContent.children),\n    baseContentMap = _generateIdMapAndIds4.map;\n  var content = [];\n  diffChangesContentIds.forEach(function (elementId) {\n    var diffElement = diffChangesContentMap[elementId];\n    var baseElement = baseContentMap[elementId];\n    var mergeElements = getMergeElement(diffElement, baseElement);\n    content.push.apply(content, _toConsumableArray(mergeElements));\n  });\n  return content;\n};\nexport var canMerge = function canMerge(content, reference) {\n  if (hasConflict(content)) return false;\n  if (!Array.isArray(reference) || reference.length === 0) return true;\n  var _generateIdMapAndIds5 = generateIdMapAndIds(reference),\n    referenceMap = _generateIdMapAndIds5.map;\n  var flag = true;\n  for (var i = 0; i < content.length; i++) {\n    var element = content[i];\n    var referenceElement = referenceMap[element.id];\n    if (!referenceElement) {\n      flag = false;\n      break;\n    }\n    flag = canMerge(element.children, referenceElement.children);\n    if (flag === false) {\n      break;\n    }\n  }\n  return flag;\n};\nexport var getRebase = function getRebase(masterContent, baseContent, revisionContent) {\n  // master no changes, merged directly\n  if (masterContent.version === baseContent.version) {\n    return {\n      canMerge: true,\n      isNeedReplaceMaster: true,\n      value: revisionContent\n    };\n  }\n\n  // The revision content has not changed\n  if (baseContent.version === revisionContent.version) {\n    return {\n      canMerge: true,\n      isNeedReplaceMaster: false,\n      value: masterContent\n    };\n  }\n  var diffChanges = getChanges(masterContent, revisionContent);\n  var content = getMergeContent(baseContent, diffChanges);\n  return {\n    canMerge: canMerge(content, revisionContent.children),\n    isNeedReplaceMaster: true,\n    value: _objectSpread(_objectSpread({}, revisionContent), {}, {\n      children: content,\n      version: Math.max(masterContent.version, revisionContent.version) + 1\n    })\n  };\n};","map":{"version":3,"names":["_objectSpread","generateIdMapAndIds","getIdDiffs","ObjectUtils","MODIFY_TYPE","REBASE_TYPE","REBASE_MARK_KEY","REBASE_ORIGIN","REBASE_TYPES","ELEMENT_TYPE","replaceNodeId","hasConflict","content","Array","isArray","length","flag","i","element","rebase_type","children","includes","childrenFlag","getChanges","masterContent","revisionContent","_generateIdMapAndIds","masterContentMap","map","masterIds","ids","_generateIdMapAndIds2","currentContentMap","currentIds","idDiffs","forEach","idDiff","value","added","removed","addedList","item","_defineProperty","ADD","push","apply","_toConsumableArray","deletedList","DELETE","elementId","isSameObject","_objectSpread4","oldElement","currentElement","newElement","MODIFY","OLD_ELEMENT","type","elementType","UNORDERED_LIST","ORDERED_LIST","listContent","CHILDREN_MODIFY","getMergeElement","diffElement","baseElement","modifyType","MODIFY_DELETE","DELETE_MODIFY","_objectSpread7","_objectSpread8","masterElement","_objectSpread5","_objectSpread6","MODIFY_MODIFY","ORIGIN","OTHER","MY","_objectSpread9","_objectSpread10","childrenContent","getMergeContent","baseContent","diffChanges","_generateIdMapAndIds3","diffChangesContentMap","diffChangesContentIds","_generateIdMapAndIds4","baseContentMap","mergeElements","canMerge","reference","_generateIdMapAndIds5","referenceMap","referenceElement","id","getRebase","version","isNeedReplaceMaster","Math","max"],"sources":["/Users/abel/Documents/Code-Experiments/cool-storage-api/frontend/node_modules/@seafile/sdoc-editor/dist/basic-sdk/utils/rebase.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport { generateIdMapAndIds, getIdDiffs } from './diff';\nimport ObjectUtils from './object-utils';\nimport { MODIFY_TYPE, REBASE_TYPE, REBASE_MARK_KEY, REBASE_ORIGIN, REBASE_TYPES } from '../constants';\nimport { ELEMENT_TYPE } from '../extension/constants';\nimport { replaceNodeId } from '../node-id/helpers';\nexport const hasConflict = content => {\n  if (!Array.isArray(content) || content.length === 0) return false;\n  let flag = false;\n  for (let i = 0; i < content.length; i++) {\n    const element = content[i];\n    const {\n      rebase_type,\n      children\n    } = element;\n    if (REBASE_TYPES.includes(rebase_type)) {\n      flag = true;\n      break;\n    } else {\n      const childrenFlag = hasConflict(children);\n      if (!childrenFlag) continue;\n      flag = childrenFlag;\n      break;\n    }\n  }\n  return flag;\n};\nconst getChanges = (masterContent, revisionContent) => {\n  const {\n    map: masterContentMap,\n    ids: masterIds\n  } = generateIdMapAndIds(masterContent.children);\n  const {\n    map: currentContentMap,\n    ids: currentIds\n  } = generateIdMapAndIds(revisionContent.children);\n  const idDiffs = getIdDiffs(masterIds, currentIds);\n  let content = [];\n  idDiffs.forEach(idDiff => {\n    const {\n      value,\n      added,\n      removed\n    } = idDiff;\n    if (added) {\n      const addedList = value.map(item => _objectSpread(_objectSpread({}, currentContentMap[item]), {}, {\n        [REBASE_MARK_KEY.MODIFY_TYPE]: MODIFY_TYPE.ADD\n      }));\n      content.push(...addedList);\n    } else if (removed) {\n      const deletedList = value.map(item => _objectSpread(_objectSpread({}, masterContentMap[item]), {}, {\n        [REBASE_MARK_KEY.MODIFY_TYPE]: MODIFY_TYPE.DELETE\n      }));\n      content.push(...deletedList);\n    } else {\n      value.forEach(elementId => {\n        if (ObjectUtils.isSameObject(masterContentMap[elementId], currentContentMap[elementId])) {\n          content.push(currentContentMap[elementId]);\n        } else {\n          const oldElement = masterContentMap[elementId];\n          const currentElement = currentContentMap[elementId];\n          let newElement = _objectSpread(_objectSpread({}, currentElement), {}, {\n            [REBASE_MARK_KEY.MODIFY_TYPE]: MODIFY_TYPE.MODIFY,\n            [REBASE_MARK_KEY.OLD_ELEMENT]: oldElement\n          });\n          if (currentElement.type === oldElement.type) {\n            const elementType = currentElement.type;\n            if ([ELEMENT_TYPE.UNORDERED_LIST, ELEMENT_TYPE.ORDERED_LIST].includes(elementType)) {\n              const listContent = getChanges(oldElement, currentElement);\n              newElement[REBASE_MARK_KEY.MODIFY_TYPE] = MODIFY_TYPE.CHILDREN_MODIFY;\n              newElement['children'] = listContent;\n            }\n          }\n          content.push(newElement);\n        }\n      });\n    }\n  });\n  return content;\n};\nconst getMergeElement = (diffElement, baseElement) => {\n  const modifyType = diffElement[REBASE_MARK_KEY.MODIFY_TYPE];\n  const newElement = _objectSpread({}, diffElement);\n  newElement[REBASE_MARK_KEY.MODIFY_TYPE] && delete newElement[REBASE_MARK_KEY.MODIFY_TYPE];\n\n  // revision does not have this element, master has this element\n  if (modifyType === MODIFY_TYPE.DELETE) {\n    // base content does not have this element, indicating that it is newly added by master and needs to be retained, and will not be counted as a conflict.\n    if (!baseElement) return [newElement];\n\n    // base content has this element, master modified it, indicating that revision deleted it, and the user manually selected the conflict\n    if (!ObjectUtils.isSameObject(baseElement, diffElement, [REBASE_MARK_KEY.MODIFY_TYPE])) {\n      newElement[REBASE_MARK_KEY.REBASE_TYPE] = REBASE_TYPE.MODIFY_DELETE;\n      return [newElement];\n    }\n\n    // base content has this element, but master has not modified it. It means that revision has deleted it and the program has deleted it. The conflict will not be counted.\n    return [];\n  }\n\n  // revision has this element, master does not have this element\n  if (modifyType === MODIFY_TYPE.ADD) {\n    // base content does not have this element, indicating that it is newly added by revision and needs to be retained, and will not be counted as a conflict.\n    if (!baseElement) return [newElement];\n\n    // master deleted it, revision modified it, and the user manually selected the conflict\n    if (!ObjectUtils.isSameObject(baseElement, diffElement, [REBASE_MARK_KEY.MODIFY_TYPE])) {\n      newElement[REBASE_MARK_KEY.REBASE_TYPE] = REBASE_TYPE.DELETE_MODIFY;\n      return [newElement];\n    }\n\n    // master deleted it, revision did not modify it, the program deleted it, and the conflict is not counted.\n    return [];\n  }\n\n  // Elements that differ between revision and master\n  if (modifyType === MODIFY_TYPE.MODIFY) {\n    const masterElement = _objectSpread({}, diffElement[REBASE_MARK_KEY.OLD_ELEMENT]);\n    delete newElement[REBASE_MARK_KEY.OLD_ELEMENT];\n\n    // revision and master both add a new element, but the content is different. ===》 At present, this situation does not exist, it only exists in the theoretical stage.\n    if (!baseElement) {\n      return [_objectSpread(_objectSpread({}, replaceNodeId(masterElement)), {}, {\n        [REBASE_MARK_KEY.REBASE_TYPE]: REBASE_TYPE.MODIFY_MODIFY,\n        [REBASE_MARK_KEY.OLD_ELEMENT]: masterElement,\n        [REBASE_MARK_KEY.ORIGIN]: REBASE_ORIGIN.OTHER\n      }), _objectSpread(_objectSpread({}, newElement), {}, {\n        [REBASE_MARK_KEY.REBASE_TYPE]: REBASE_TYPE.MODIFY_MODIFY,\n        [REBASE_MARK_KEY.ORIGIN]: REBASE_ORIGIN.MY\n      })];\n    }\n\n    // master is the same as base, indicating that revision has modified the content\n    if (ObjectUtils.isSameObject(masterElement, baseElement)) return [newElement];\n\n    // revision is the same as base, indicating that master has modified the content\n    if (ObjectUtils.isSameObject(newElement, baseElement)) return [masterElement];\n\n    // They are all different. Revision and master were modified at the same time. If there is a conflict, the conflict needs to be resolved manually.\n    return [_objectSpread(_objectSpread({}, replaceNodeId(masterElement)), {}, {\n      [REBASE_MARK_KEY.REBASE_TYPE]: REBASE_TYPE.MODIFY_MODIFY,\n      [REBASE_MARK_KEY.OLD_ELEMENT]: masterElement,\n      [REBASE_MARK_KEY.ORIGIN]: REBASE_ORIGIN.OTHER\n    }), _objectSpread(_objectSpread({}, newElement), {}, {\n      [REBASE_MARK_KEY.REBASE_TYPE]: REBASE_TYPE.MODIFY_MODIFY,\n      [REBASE_MARK_KEY.ORIGIN]: REBASE_ORIGIN.MY\n    })];\n  }\n  if (modifyType === MODIFY_TYPE.CHILDREN_MODIFY) {\n    const masterElement = _objectSpread({}, diffElement[REBASE_MARK_KEY.OLD_ELEMENT]);\n    delete newElement[REBASE_MARK_KEY.OLD_ELEMENT];\n\n    // revision and master both add a new element, but the content is different. ===》 At present, this situation does not exist, it only exists in the theoretical stage.\n    if (!baseElement) {\n      return [_objectSpread(_objectSpread({}, replaceNodeId(masterElement)), {}, {\n        [REBASE_MARK_KEY.REBASE_TYPE]: REBASE_TYPE.MODIFY_MODIFY,\n        [REBASE_MARK_KEY.OLD_ELEMENT]: masterElement,\n        [REBASE_MARK_KEY.ORIGIN]: REBASE_ORIGIN.OTHER\n      }), _objectSpread(_objectSpread({}, newElement), {}, {\n        [REBASE_MARK_KEY.REBASE_TYPE]: REBASE_TYPE.MODIFY_MODIFY,\n        [REBASE_MARK_KEY.ORIGIN]: REBASE_ORIGIN.MY\n      })];\n    }\n    if (ObjectUtils.isSameObject(masterElement, baseElement)) return [newElement];\n    if (ObjectUtils.isSameObject(newElement, baseElement)) return [masterElement];\n    if (ObjectUtils.isSameObject(masterElement, newElement, ['type'])) {\n      if (ObjectUtils.isSameObject(masterElement, baseElement, ['type'])) return [newElement];\n      if (ObjectUtils.isSameObject(newElement, baseElement, ['type'])) return [masterElement];\n    }\n\n    // The content of the subnode has changed and needs to be solved manually.\n    const childrenContent = getMergeContent(baseElement, diffElement.children);\n    return [_objectSpread(_objectSpread({}, newElement), {}, {\n      children: childrenContent\n    })];\n  }\n  newElement[REBASE_MARK_KEY.OLD_ELEMENT] && delete newElement[REBASE_MARK_KEY.OLD_ELEMENT];\n  return [newElement];\n};\nconst getMergeContent = (baseContent, diffChanges) => {\n  const {\n    map: diffChangesContentMap,\n    ids: diffChangesContentIds\n  } = generateIdMapAndIds(diffChanges);\n  const {\n    map: baseContentMap\n  } = generateIdMapAndIds(baseContent.children);\n  let content = [];\n  diffChangesContentIds.forEach(elementId => {\n    const diffElement = diffChangesContentMap[elementId];\n    const baseElement = baseContentMap[elementId];\n    const mergeElements = getMergeElement(diffElement, baseElement);\n    content.push(...mergeElements);\n  });\n  return content;\n};\nexport const canMerge = (content, reference) => {\n  if (hasConflict(content)) return false;\n  if (!Array.isArray(reference) || reference.length === 0) return true;\n  const {\n    map: referenceMap\n  } = generateIdMapAndIds(reference);\n  let flag = true;\n  for (let i = 0; i < content.length; i++) {\n    const element = content[i];\n    let referenceElement = referenceMap[element.id];\n    if (!referenceElement) {\n      flag = false;\n      break;\n    }\n    flag = canMerge(element.children, referenceElement.children);\n    if (flag === false) {\n      break;\n    }\n  }\n  return flag;\n};\nexport const getRebase = (masterContent, baseContent, revisionContent) => {\n  // master no changes, merged directly\n  if (masterContent.version === baseContent.version) {\n    return {\n      canMerge: true,\n      isNeedReplaceMaster: true,\n      value: revisionContent\n    };\n  }\n\n  // The revision content has not changed\n  if (baseContent.version === revisionContent.version) {\n    return {\n      canMerge: true,\n      isNeedReplaceMaster: false,\n      value: masterContent\n    };\n  }\n  const diffChanges = getChanges(masterContent, revisionContent);\n  const content = getMergeContent(baseContent, diffChanges);\n  return {\n    canMerge: canMerge(content, revisionContent.children),\n    isNeedReplaceMaster: true,\n    value: _objectSpread(_objectSpread({}, revisionContent), {}, {\n      children: content,\n      version: Math.max(masterContent.version, revisionContent.version) + 1\n    })\n  };\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}